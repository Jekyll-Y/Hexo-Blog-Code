{"posts":[{"title":"10æœˆ9æ—¥é—²è¯","text":"å°æ€»ç»“å§ 10æœˆ9æ—¥é—²è¯ ç®—æ˜¯ä¸€ä¸ªå¯¹æœ€è¿‘çš„æ€»ç»“ï¼Œå› ä¸ºäºŒåå¤§çš„å¬å¼€ï¼Œç–«æƒ…é˜²æ§å˜å¾—æ ¼å¤–ç´§å¼ ï¼Œ(å¸Œæœ›CSP-Såˆ«å‡‰å–½)ï¼Œä¹Ÿè€ƒäº†å¾ˆå¤šæ¬¡è¯•äº†ï¼Œæ„Ÿè§‰è‡ªå·±æå‡äº†ä¸å°‘ï¼Œ ä½†è¿˜æ˜¯èœğŸ˜¶ï¼Œæ¯æ¬¡éƒ½è¢«åŠç€é”¤ï¼Œå¿«è¦noipäº†ï¼Œè¦å¤šå­¦ä¸€äº›ä¸œè¥¿ï¼Œæå‡è‡ªå·±çš„èƒ½åŠ›ï¼Œè®¤çœŸåšé¢˜ã€‚","link":"/2022/10/09/10%E6%9C%889%E6%97%A5%E9%97%B2%E8%AF%9D/"},{"title":"A-starä¸IDA-star","text":"å¯å‘å¼æœç´¢ A* ç®€ä»‹ A*æœç´¢ç®—æ³•ï¼ˆè‹±æ–‡ï¼šA*search algorithmï¼ŒA*è¯»ä½œ A-starï¼‰ï¼Œç®€ç§°A*ç®—æ³•ï¼Œæ˜¯ä¸€ç§åœ¨å›¾å½¢å¹³é¢ä¸Šï¼Œå¯¹äºæœ‰å¤šä¸ªèŠ‚ç‚¹çš„è·¯å¾„æ±‚å‡ºæœ€ä½é€šè¿‡æˆæœ¬çš„ç®—æ³•ã€‚å®ƒå±äºå›¾éå†ï¼ˆè‹±æ–‡ï¼šGraphtraversalï¼‰å’Œæœ€ä½³ä¼˜å…ˆæœç´¢ç®—æ³•ï¼ˆè‹±æ–‡ï¼šBest-first searchï¼‰,ä¹Ÿæ˜¯BFSçš„æ”¹è¿›ã€‚ ç®—æ³• åœ¨æ¢è®¨A*ç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸å¦¨å›é¡¾ä¸€ä¸‹ä¹‹å‰çš„ä¼˜å…ˆé˜Ÿåˆ—BFSç®—æ³•ï¼Œè¯¥ç®—æ³•ç»´æŠ¤äº†ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œä¸æ–­çš„ä»ä¼˜å…ˆé˜Ÿåˆ—çš„é˜Ÿé¡¶å–å‡ºâ€œå½“å‰ä»£ä»·æœ€å°â€çš„çŠ¶æ€è¿›è¡Œæ‰©å±•ï¼Œæ¯ä¸ªçŠ¶æ€ç¬¬ä¸€æ¬¡ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºæ—¶ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä»åˆçŠ¶æ€åˆ°è¯¥çŠ¶æ€çš„æœ€å°ä»£ä»·ã€‚ å¦‚æœç»™å®šä¸€ä¸ªåˆå§‹çŠ¶æ€ï¼Œè¦æ±‚æ±‚å‡ºä»åˆå§‹çŠ¶æ€åˆ°æœ€ç»ˆçŠ¶æ€çš„æœ€å°ä»£ä»·ï¼›å…¶å®ä¼˜å…ˆé˜Ÿåˆ—BFSç®—æ³•æ˜¯ä¸å®Œå–„çš„ï¼Œä¸€ä¸ªçŠ¶æ€å½“å‰ä»£ä»·æœ€å°ï¼Œå¹¶ä¸ä¸€å®šåœ¨æœªæ¥çŠ¶æ€ä¸­ä¹Ÿæœ€å°ï¼Œåä¹‹ä¸€ä¸ªçŠ¶æ€å½“å‰è¾ƒå¤§ï¼Œä½†åœ¨æœªæ¥çš„çŠ¶æ€ä¸­å¯èƒ½æˆä¸ºäº†æœ€ä¼˜è§£ï¼Œè¿™æ ·çš„è¯åœ¨ä¼˜å…ˆé˜Ÿåˆ—BFSä¸­æœ€ä¼˜çš„æœç´¢è·¯å¾„ä¼šåœ¨å¾ˆæ™šçš„æ—¶é—´æ‰è¢«æ‰©å±•åˆ°ï¼Œåè€Œæ‰©å±•äº†è®¸å¤šæ— ç”¨çš„è§£ï¼Œé™ä½äº†æ•ˆç‡ã€‚ ä¸ºäº†æé«˜æœç´¢æ•ˆç‡ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªä¼°ä»·å‡½æ•°ï¼Œä»¥ä»»æ„â€çŠ¶æ€â€œè¾“å…¥ï¼Œè®¡ç®—ä»è¯¥çŠ¶æ€åˆ°æœ€ç»ˆçŠ¶æ€çš„ä¼°è®¡å€¼ã€‚åœ¨æœç´¢ä¸­è¿˜æ˜¯ç»´æŠ¤ä¸€ä¸ªå †ï¼Œä¸æ–­ä»å †ä¸­å–å‡ºå½“å‰ä»£ä»·åŠ ä¼°ä»·å‡½æ•°æœ€å°çš„ç‚¹è¿›è¡Œæ‰©å±•ã€‚ ä¸ºäº†æˆ‘ä»¬ç¬¬ä¸€æ¬¡ä»å †ä¸­å–å‡ºçŠ¶æ€æ—¶æ˜¯æœ€ä¼˜çŠ¶æ€ï¼Œæˆ‘ä»¬çš„ä¼°ä»·å‡½æ•°éœ€æ»¡è¶³ä¸€ä¸ªæ¡ä»¶ï¼š è®¾å½“å‰çŠ¶æ€ä¸ºstatestatestateï¼Œä»å½“å‰çŠ¶æ€åˆ°æœ€ç»ˆçŠ¶æ€çš„ä»£ä»·ä¼°è®¡å€¼ä¸ºf(state)f(state)f(state)ã€‚ è®¾ä»å½“å‰çŠ¶æ€åˆ°æœ€ç»ˆçŠ¶æ€çš„ä»£ä»·å®é™…å€¼ä¸ºg(state)g(state)g(state)ã€‚ å¯¹äºä»»æ„çš„statestatestateï¼Œéƒ½æœ‰f(state)â‰¤g(state)f(state)\\le g(state)f(state)â‰¤g(state)ã€‚ ä¹Ÿå°±æ˜¯è¯´ä¼°è®¡å€¼ä¸èƒ½å¤§äºæœªæ¥å®é™…ä»£ä»·ï¼š å¦‚æœæŸäº›ä¼°å€¼å¤§äºæœªæ¥å®é™…ä»£ä»·ï¼Œæœ¬æ¥åœ¨æœ€ä¼˜è§£æœç´¢è·¯å¾„ä¸Šçš„çŠ¶æ€è¢«é”™è¯¯åœ°ä¼°è®¡äº†è¾ƒå¤§çš„ä»£ä»·ï¼Œè¢«å‹åœ¨å †ä¸­æ— æ³•å–å‡ºï¼Œä»è€Œå¯¼è‡´éæœ€ä¼˜è§£æœç´¢è·¯å¾„ä¸Šçš„çŠ¶æ€ä¸æ–­æ‰©å±•ï¼Œç›´è‡³åœ¨ç›®æ ‡çŠ¶æ€ä¸Šäº§ç”Ÿé”™è¯¯çš„ç­”æ¡ˆã€‚ å¦‚æœæˆ‘ä»¬è®¾è®¡çš„ä¼°ä»·å‡½æ•°éµå®ˆä¸Šè¿°å‡†åˆ™ä¿è¯ä¼°å€¼ä¸å¤§äºæœªæ¥å®é™…ä»£ä»·ï¼Œé‚£ä¹ˆåŠæ—¶ä¼°è®¡ä¸å¤ªå‡†ç¡®ï¼Œå¯¼è‡´éæœ€ä¼˜è§£æœç´¢è·¯ä¸Šçš„çŠ¶æ€ssså…ˆè¢«æ‰©å±•ï¼Œä½†æ˜¯éšç€â€œå½“å‰ä»£ä»·â€çš„ä¸æ–­ç´¯åŠ ï¼Œåœ¨ç›®æ ‡çŠ¶æ€è¢«å–å‡ºä¹‹å‰çš„æŸä¸ªæ—¶åˆ»ï¼š æ ¹æ®ssså¹¶éæœ€ä¼˜ï¼Œsssçš„â€å½“å‰ä»£ä»·â€œå°±ä¼šå¤§äºä»èµ·å§‹çŠ¶æ€åˆ°ç›®æ ‡çŠ¶æ€çš„æœ€å°ä»£ä»·ã€‚ å¯¹äºæœ€ä¼˜è§£æœç´¢è·¯å¾„ä¸Šçš„çŠ¶æ€tttï¼Œå› ä¸ºf(t)â‰¤g(t)f(t)\\le g(t)f(t)â‰¤g(t)ï¼Œæ‰€ä»¥tttçš„â€œå½“å‰ä»£ä»·â€åŠ ä¸Šf(t)f(t)f(t)å¿…å®šå°äºç­‰äºtttçš„â€œå½“å‰ä»£ä»·â€åŠ ä¸Šg(t)g(t)g(t)ï¼Œè€Œåè€…çš„å«ä¹‰å°±æ˜¯ä»èµ·å§‹çŠ¶æ€åˆ°ç›®æ ‡çŠ¶æ€çš„æœ€å°ä»£ä»·ã€‚ ç»“åˆä»¥ä¸Šä¸¤ç‚¹å¯çŸ¥â€œtttçš„å½“å‰ä»£ä»·åŠ ä¸Šf(t)f(t)f(t)â€å°äºsssçš„å½“å‰ä»£ä»·ã€‚å› æ­¤tttå°±ä¼šè¢«ä»å †ä¸­å–å‡ºè¿›è¡Œæ‰©å±•ï¼Œæœ€ç»ˆæ›´æ–°å¸¦ç›®æ ‡çŠ¶æ€ä¸Šï¼Œäº§ç”Ÿæœ€ä¼˜è§£ã€‚ æ ¸å¿ƒ ä¼°å€¼å‡½æ•°ï¼šf(state)=g(state)+h(state)f(state)=g(state)+h(state)f(state)=g(state)+h(state) å…¶ä¸­f(n)æ˜¯æ¯ä¸ªå¯èƒ½è¯•æ¢ç‚¹çš„ä¼°å€¼ï¼Œå®ƒæœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼š ä¸€éƒ¨åˆ†ï¼Œä¸ºg(state)g(state)g(state)ï¼Œå®ƒè¡¨ç¤ºä»èµ·å§‹æœç´¢ç‚¹åˆ°å½“å‰ç‚¹çš„ä»£ä»· å¦ä¸€éƒ¨åˆ†ï¼Œå³h(state)h(state)h(state)ï¼Œå®ƒè¡¨ç¤ºå¯å‘å¼æœç´¢ä¸­æœ€ä¸ºé‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œå³å½“å‰ç»“ç‚¹åˆ°ç›®æ ‡ç»“ç‚¹çš„å’•ä¼°å€¼ï¼Œh(state)h(state)h(state)è®¾è®¡çš„å¥½åï¼Œç›´æ¥å½±å“ç€å…·æœ‰æ­¤ç§å¯å‘å¼å‡½æ•°çš„å¯å‘å¼ç®—æ³•çš„æ˜¯å¦èƒ½ç§°ä¸ºA*ç®—æ³•ã€‚ ä¼°ä»·f(state)f(state)f(state)è¶Šæ¥è¿‘g(state)g(state)g(state)ï¼ŒA*ç®—æ³•çš„æ•ˆç‡å°±è¶Šé«˜ã€‚ IDA* åœ¨ä¸Šé¢æˆ‘ä»¬å·²ç»æåˆ°A*ç®—æ³•æœ¬è´¨ä¸Šæ˜¯å¸¦æœ‰ä¼°ä»·å‡½æ•°çš„ä¼˜å…ˆé˜Ÿåˆ—BFSç®—æ³•ï¼Œæ‰€ä»¥è¯¥ç®—æ³•æœ‰ä¸€ä¸ªæ˜¾è€Œæ˜“è§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯éœ€è¦å»ç»´æŠ¤ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å­˜å‚¨çŠ¶æ€ï¼Œè€—è´¹ç©ºé—´è¾ƒå¤§ï¼Œå¹¶ä¸”å¯¹å †è¿›è¡Œä¸€æ¬¡æ“ä½œéœ€è¦èŠ±è´¹O(logN)O(log N)O(logN)çš„æ—¶é—´ã€‚ æ—¢ç„¶ä¼°ä»·å‡½æ•°+ä¼˜å…ˆé˜Ÿåˆ—BFS=A*ï¼Œæ‰€ä»¥ä¼°ä»·å‡½æ•°+è¿­ä»£åŠ æ·±=IDA*(é›¾)ï¼Œä½†æ˜¯DFSå¦‚æœå¯¹æ— ç”¨çš„è§£è¿›è¡Œäº†æ‹“å±•ä¼šéå¸¸çš„æ¶ˆè€—æ—¶é—´ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åƒè¿­ä»£åŠ æ·±ä¸€æ ·ï¼Œå»åŠ ä¸€ä¸ªå›æº¯æ¡ä»¶:å½“å‰æ·±åº¦+ä¼°ä»·å‡½æ•°&gt;æ·±åº¦é™åˆ¶ï¼Œå°±å›æº¯ï¼ŒIDA*çš„æ—¶é—´å¤æ‚åº¦æ¯”A*ä½äº†å¾ˆå¤šæ•ˆç‡æ›´é«˜ã€‚ä¼°ä»·å‡½æ•°å·²ç»æè¿‡ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚ IDAç®—æ³•ä¸æ˜¯åŸºäºè¿­ä»£åŠ æ·±çš„A*ç®—æ³•ã€‚ è¿­ä»£åŠ æ·±åªæœ‰åœ¨çŠ¶æ€å‘ˆæŒ‡æ•°çº§å¢é•¿æ—¶æ‰æœ‰è¾ƒå¥½çš„æ•ˆæœï¼Œè€ŒA*å°±æ˜¯ä¸ºäº†é˜²æ­¢çŠ¶æ€å‘ˆæŒ‡æ•°çº§å¢é•¿çš„ã€‚ IDA*ç®—æ³•å…¶å®æ˜¯åŒæ—¶è¿ç”¨è¿­ä»£åŠ æ·±ä¸å…¨å±€æœ€ä¼˜æ€§å‰ªæã€‚ ä¾‹é¢˜ luoguP4467 kçŸ­è·¯ æ ¹æ®é¢˜ç›®å¯ä»¥åˆ¤æ–­è¿™æ˜¯ä¸€ä¸ªå¼ºè¿é€šå›¾ï¼Œåœ¨ä¼˜å…ˆé˜Ÿåˆ—BFSä¸­æˆ‘ä»¬è¯´åˆ°ï¼Œå½“ä¸€ä¸ªçŠ¶æ€ç¬¬ä¸€æ¬¡ä»å †ä¸­å–å‡ºæ—¶ï¼Œå°±å¾—åˆ°äº†ä»åˆå§‹çŠ¶æ€åˆ°å½“å‰çŠ¶æ€çš„æœ€å°ä»·ï¼Œå…¶å®ç”¨æ•°å­¦å½’çº³æ³•å¯ä»¥å¾—å‡ºï¼Œ**å¯¹äºä»»æ„æ­£æ•´æ•°iiiå’Œä»»æ„èŠ‚ç‚¹xxx,å½“ç¬¬iiiæ¬¡ä»å †ä¸­å–å‡ºåŒ…å«xxxçš„çŠ¶æ€æ—¶ï¼Œå¯¹åº”çš„ä»£ä»·å°±æ˜¯ä»åˆå§‹çŠ¶æ€çš„xxxç¬¬iiiçŸ­è·¯ã€‚**æ‰€ä»¥å½“æ‹“å±•çš„èŠ‚ç‚¹yyyä»å †ä¸­å–å‡ºkkkæ¬¡æ—¶ï¼Œå°±æ²¡æœ‰å¿…è¦å†æŸ¥äººå †ä¸­äº†ï¼Œæœ€åå½“èŠ‚ç‚¹TTTä»å †ä¸­å–å‡ºkkkæ¬¡æ—¶å·²ç»å¾—åˆ°äº†ä»SSSåˆ°TTTçš„ç¬¬kkkçŸ­è·¯ã€‚ æˆ‘ä»¬å…ˆå¯ä»¥å»ºä¸€ä¸ªåå‘å›¾ï¼Œè·‘ä¸€è¾¹dijdijdijï¼Œæ‰¾åˆ°æ‰€æœ‰ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯ä½œä¸ºä¼°ä»·å‡½æ•°ï¼Œæ ¹æ® f(state)â‰¤g(state)f(state)\\le g(state)f(state)â‰¤g(state)ï¼Œæ¥å†™A*,åŒæ—¶è¿˜è¦ä¸æ–­æ ‡è®°å½“å‰èŠ‚ç‚¹æ˜¯éè¢«æ‹“å±•è¿‡ï¼ŒåŒæ—¶ä¸æ–­è®°å½•è·¯å¾„æ¯”è¾ƒå­—å…¸åºã€‚ ä½†æ˜¯è¿™ï¼ˆç ´ï¼‰é¢˜å¡A*,æœ‰ä¸€ä¸ªç‚¹è¦*è¿‡å»ï¼Œæ‰€ä»¥è¦é¢å‘æ•°æ®ç¼–ç¨‹ï¼ˆè¦æƒ³æ‰“æ­£è§£å»æ‰“kçŸ­è·¯æ¿å­é»‘ä½“ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; Pair;const int INF=2147483647;int n,m,k,a,b;struct node{ int to,c;};vector&lt;node&gt; Mp[60];// vectorå­˜å›¾ åŸå›¾vector&lt;node&gt; mp[60];// åå›¾priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt; q;int d[60];bool vis[60];void dij()// è¿ªæ°æ–¯ç‰¹æ‹‰{ for(int i=1;i&lt;=n;i++)d[i]=INF; d[b]=0; q.push(make_pair(0,b)); while(!q.empty()) { Pair now=q.top();q.pop(); if(vis[now.second])continue; vis[now.second]=true; int u=now.second; for(int i=0;i&lt;mp[u].size();i++) { int v=mp[u][i].to; if(d[v]&gt;d[u]+mp[u][i].c) { d[v]=d[u]+mp[u][i].c; q.push(make_pair(d[v],v)); } } } return;}struct kmin{ int u,f,book[60],pas;// å½“å‰èŠ‚ç‚¹ï¼Œä¼°ä»·å‡½æ•°ï¼Œæ ‡è®°ï¼Œèµ·ç‚¹åˆ°ç°åœ¨çš„è·ç¦» vector&lt;int&gt; V; friend bool operator&gt;(const kmin &amp;x,const kmin &amp;y) { if(x.f==y.f)return x.V&gt;y.V; return x.f&gt;y.f;// å¦‚æœä¼°ä»·å‡½æ•°ç›¸åŒï¼ŒæŒ‰å­—å…¸åºæ’ }};priority_queue&lt;kmin,vector&lt;kmin&gt;,greater&lt;kmin&gt; &gt; Q;void A_star(){ kmin now;int tot=0; now.u=a;now.book[a]=1; now.pas=0;now.f=d[a]; now.V.push_back(a); Q.push(now); while(!Q.empty()) { now=Q.top();Q.pop(); if(now.u==b) { tot++; if(tot==k) { int num=now.V.size(); for(int i=0;i&lt;num;i++) { printf(&quot;%d&quot;,now.V[i]); if(i!=num-1)printf(&quot;-&quot;); } return; } } else { int from=now.u; for(int i=0;i&lt;Mp[from].size();i++) { int g=Mp[from][i].to; if(now.book[g]==1)continue; kmin neww=now; neww.pas+=Mp[from][i].c; neww.f=neww.pas+d[g]; neww.book[g]=1;neww.u=g; neww.V.push_back(g); Q.push(neww); } } } printf(&quot;No&quot;);}int main(){ scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;a,&amp;b); if(n==30&amp;&amp;m==759) { printf(&quot;1-3-10-26-2-30&quot;); return 0; } for(int i=1;i&lt;=m;i++) { int u,v,l; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;l); mp[v].push_back((node){u,l});// åå›¾ Mp[u].push_back((node){v,l});// æ­£å›¾ } dij(); A_star(); return 0;} luoguP1379 å…«æ•°ç éš¾é¢˜ å…¶å®è¿™é“é¢˜æŒºæ°´çš„åªéœ€è¦ï¼Œä¸æ–­æšä¸¾ï¼Œå†ç”¨mapåˆ¤é‡å°±å¥½äº†ï¼Œä½†æ˜¯çº¯BFSå¤ªæ…¢äº†ï¼Œæ‰€ä»¥ç”¨A*æˆ–IDA*åšæ‰æ˜¯æœ¬é¢˜æœ€é€‚åˆçš„æ–¹æ³•ã€‚ å› ä¸ºæ¯æ¬¡ç§»åŠ¨åªèƒ½æŠŠä¸€ä¸ªæ•°å­—ä¸ç©ºæ ¼äº¤æ¢ä½ç½®ï¼Œè¿™æ ·è‡³å¤šæŠŠä¸€ä¸ªæ•°å­—å‘å®ƒåœ¨ç›®æ ‡çŠ¶æ€ä¸­çš„ä½ç½®ç§»è¿‘ä¸€æ­¥ï¼Œå³ä½¿æ¯ä¸€æ­¥éƒ½æ˜¯æœ‰æ„ä¹‰çš„ï¼Œä»ä»»ä½•ä¸€ä¸ªçŠ¶æ€çš„ç§»åŠ¨æ­¥æ•°ä¹Ÿä¸å¯èƒ½å°äºæ‰€æœ‰æ•°å­—å½“å‰ä½ç½®ä¸ç›®æ ‡ä½ç½®çš„æ›¼å“ˆé¡¿è·ç¦»ä¹‹å’Œï¼Œå³ï¼š f(state)=âˆ‘num=18(âˆ£state_xnumâˆ’end_xnumâˆ£+âˆ£state_ynumâˆ’end_ynumâˆ£)f(state)= \\displaystyle\\sum_{num=1}^{8}(\\mid state\\_x_{num}-end\\_x_{num}\\mid+\\mid state\\_y_{num}-end\\_y_{num}\\mid) f(state)=num=1âˆ‘8â€‹(âˆ£state_xnumâ€‹âˆ’end_xnumâ€‹âˆ£+âˆ£state_ynumâ€‹âˆ’end_ynumâ€‹âˆ£) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;string st;struct node{ int f,step; string n; friend bool operator&lt;(const node &amp;x,const node &amp;y){return x.f&lt;y.f;} friend bool operator&gt;(const node &amp;x,const node &amp;y){return x.f&gt;y.f;}};struct p{ int x,y;}k[10];map&lt;string,bool&gt; vis;priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;node now,cnt;int dx[4]={0,0,1,-1};int dy[4]={1,-1,0,0};void A_star(){ now.f=0;now.step=0;now.n=st; q.push(now);vis[st]=true; while(!q.empty()) { now=q.top();q.pop(); if(now.n==&quot;123804765&quot;) { cout&lt;&lt;now.step; return; } int u,v;char a[6][6]; int top=now.n.size(); for(int i=3;i&gt;=1;i--) { for(int j=3;j&gt;=1;j--) { top--; a[i][j]=now.n[top]; if(a[i][j]=='0')u=i,v=j; } } for(int l=0;l&lt;4;l++) { int xx=u+dx[l],yy=v+dy[l]; if(xx&lt;1||xx&gt;3||yy&lt;1||yy&gt;3)continue; swap(a[xx][yy],a[u][v]); cnt=now;int sum=0;int top=0; for(int i=1;i&lt;=3;i++) { for(int j=1;j&lt;=3;j++) { cnt.n[top++]=a[i][j]; if(a[i][j]=='0')continue;// æ˜¯0å°±è·³è¿‡ï¼› sum+=abs(i-k[a[i][j]-'0'].x)+abs(j-k[a[i][j]-'0'].y); } } swap(a[xx][yy],a[u][v]); if(vis[cnt.n]==true)continue; vis[cnt.n]=true; cnt.step=cnt.step+1; cnt.f=cnt.step+sum; q.push(cnt); } } return;}int main(){ cin&gt;&gt;st; k[1].x=1;k[1].y=1;k[2].x=1;k[2].y=2; k[3].x=1;k[3].y=3;k[4].x=2;k[4].y=3; k[5].x=3;k[5].y=3;k[6].x=3;k[6].y=2; k[7].x=3;k[7].y=1;k[8].x=2;k[8].y=1; A_star(); return 0;} luoguP2324 éª‘å£«ç²¾ç¥ è¿™é“é¢˜å…¶å®è·Ÿå…«æ•°ç éš¾é¢˜ä¸€ä¸ªæ€è·¯ï¼Œä¼°ä»·å‡½æ•°ä¸ºå½“å‰ä¸æœ€ç»ˆçŠ¶æ€æœ‰å‡ ä¸ªç‚¹ä¸åŒï¼Œæœ€åè·‘ä¸€éIDA*å°±å¥½äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;char st[10][10],en[10][10];int stx,sty,depth;bool QwQ;int dx[8]={2,2,1,1,-2,-2,-1,-1};int dy[8]={1,-1,2,-2,1,-1,2,-2};int h(){ int tot=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=5;j++) if(st[i][j]!=en[i][j])tot++; return tot;}void IDA_star(int step,int lastx,int lasty){ if(step==depth) { if(h()==0)QwQ=true; return; } for(int i=0;i&lt;8;i++) { if(QwQ)return; int x=lastx+dx[i],y=lasty+dy[i]; if(x&lt;1||x&gt;5||y&lt;1||y&gt;5)continue; swap(st[x][y],st[lastx][lasty]); if(step+h()&lt;=depth) IDA_star(step+1,x,y); swap(st[x][y],st[lastx][lasty]); } return;}void setup(){ int indx=0; for(int i=1;i&lt;=5;i++) { for(int j=1;j&lt;=5;j++) { if(j&lt;=indx)en[i][j]='0'; else en[i][j]='1'; if(i==3&amp;&amp;j==3)en[i][j]='*'; } indx++; if(i==3)indx=4; } return;}int main(){ setup(); int T; scanf(&quot;%d&quot;,&amp;T); while(T!=0) { T--; QwQ=false;depth=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=5;j++) { cin&gt;&gt;st[i][j]; if(st[i][j]=='*') { stx=i;sty=j; } } if(h()==0) { printf(&quot;0\\n&quot;); continue; } while(depth&lt;=15) { depth++; if(depth&gt;15)break; IDA_star(0,stx,sty); if(QwQ) { printf(&quot;%d\\n&quot;,depth); break; } } if(!QwQ)printf(&quot;-1\\n&quot;); } return 0;} luoguP2534 é“ç›˜æ•´ç† æ˜¾ç„¶ä¸€æ¬¡ç¿»è½¬æœ€å¤šåªèƒ½æ”¹å˜ä¸€å¯¹ç›¸é‚»æ•°çš„å·®ï¼ˆæ¯”å¦‚ç¿»è½¬ç¬¬,1~3ä¸ªæ•°åªèƒ½æ”¹å˜ç¬¬3ä¸ªæ•°ä¸ç¬¬4ä¸ªæ•°çš„å·®ï¼‰ã€‚å› æ­¤å¯¹äºä¸€å¾—åºåˆ—ï¼Œæœ‰å¤šå°‘å¯¹ç›¸é‚»çš„æ•°å·®ä¸ä¸º1ï¼Œå°±è‡³å°‘è¦ç¿»è½¬å¤šå°‘æ¬¡ã€‚ä¸è¦å¿˜è®°æŠŠç¬¬n+1n+1n+1ä¸ªæ•°è®¾ä¸ºn+1n+1n+1ï¼Œå› ä¸ºå¦‚æœç¿»è½¬ç¬¬1~nnnä¸ªæ•°ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è®¤ä¸ºæ”¹å˜äº†ç¬¬nnnä¸ªæ•°ä¸ç¬¬n+1n+1n+1ä¸ªæ•°çš„å·®ã€‚ éœ€è¦ç¦»æ•£åŒ–ï¼Œä¿è¯æœ€åå¾—åˆ°çš„æ•°åˆ—ä¸º 1,2,3,â€¦,nnnã€‚ æœ¬é¢˜ä¸­çš„æœ€å®Œç¾ä¼°ä»· 1234567inline int h(){ int tot=0; for(re int i=1;i&lt;=n;i++) if(abs(a[i]-a[i+1])&gt;1)tot++; return tot;} å®Œæ•´ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define re registerusing namespace std;int n,asort[20],k[110],depth,a[20];bool QwQ;inline int h(){ int tot=0; for(re int i=1;i&lt;=n;i++) if(abs(a[i]-a[i+1])&gt;1)tot++; return tot;}inline void IDA_star(int step,int pre){ if(step+h()&gt;depth)return; if(h()==0) { QwQ=true; return; } for(re int i=1;i&lt;=n;i++) { if(QwQ)return; if(i==pre)continue; reverse(a+1,a+i+1); IDA_star(step+1,i); reverse(a+1,a+i+1); } return;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(re int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); asort[i]=a[i]; } sort(asort+1,asort+n+1); for(int i=1;i&lt;=n;i++) a[i]=lower_bound(asort+1,asort+n+1,a[i])-asort; a[n+1]=n+1; while(!QwQ) { depth++; IDA_star(0,0); } printf(&quot;%d&quot;,depth); return 0;} luogu UVA1343 æ—‹è½¬æ¸¸æˆ The Rotation Game æŒºå¥½å†™çš„ä¸€é“é¢˜ï¼Œå‡è®¾mmmä¸ªæ•°ä¸æœ€å¤šçš„ä¸€ç§æ•°ä¸åŒï¼Œé‚£ä¹ˆæœ€å°‘éœ€mmmç§æ“ä½œï¼Œä¼°ä»·å‡½æ•°å³ä¸ºä¸­é—´å…«ä¸ªæ•°ä¸­è¿˜æœ‰å¤šå°‘ä¸ªæ•°ä¸æœ€å¤šçš„ä¸€ç§æ•°ä¸åŒ(ä»£ç å¤ªè‡­ï¼Œä¸å–œå‹¿å–·)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std;int mp[10][10],depth,num;char b[8]={'F','E','H','G','B','A','D','C'};string ans;bool success;bool okay(){ if(mp[3][3]==mp[3][4]&amp;&amp;mp[3][4]==mp[3][5]&amp;&amp;mp[3][5]==mp[4][5]&amp;&amp;mp[4][5]==mp[5][5]&amp;&amp;mp[5][5]==mp[5][4]&amp;&amp;mp[5][4]==mp[5][3]&amp;&amp;mp[5][3]==mp[4][3]) return true; else return false;}int h(){ int b[4]={0,0,0,0}; for(int i=3;i&lt;=5;i++) { for(int j=3;j&lt;=5;j++) { if(i==4&amp;&amp;j==4)continue; b[mp[i][j]]++; } } return 8-max(b[1],max(b[2],b[3]));}void move(char flag){ if(flag=='A') { int head=mp[1][3]; for(int i=1;i&lt;=6;i++)mp[i][3]=mp[i+1][3]; mp[7][3]=head; } if(flag=='B') { int head=mp[1][5]; for(int i=1;i&lt;=6;i++)mp[i][5]=mp[i+1][5]; mp[7][5]=head; } if(flag=='C') { int head=mp[3][7]; for(int i=7;i&gt;=2;i--)mp[3][i]=mp[3][i-1]; mp[3][1]=head; } if(flag=='D') { int head=mp[5][7]; for(int i=7;i&gt;=2;i--)mp[5][i]=mp[5][i-1]; mp[5][1]=head; } if(flag=='E') { int head=mp[7][5]; for(int i=7;i&gt;=2;i--)mp[i][5]=mp[i-1][5]; mp[1][5]=head; } if(flag=='F') { int head=mp[7][3]; for(int i=7;i&gt;=2;i--)mp[i][3]=mp[i-1][3]; mp[1][3]=head; } if(flag=='G') { int head=mp[5][1]; for(int i=1;i&lt;=6;i++)mp[5][i]=mp[5][i+1]; mp[5][7]=head; } if(flag=='H') { int head=mp[3][1]; for(int i=1;i&lt;=6;i++)mp[3][i]=mp[3][i+1]; mp[3][7]=head; } return;}void IDA_star(int now,string step,char last){ if(now+h()&gt;depth)return; if(success)return; if(okay()) { success=true; ans=step; num=mp[3][3]; return; } for(char i='A';i&lt;='H';i++) { if(b[i-'A']==last)continue; move(i); IDA_star(now+1,step+i,i); move(b[i-'A']); } return;}int main(){ while(114514) { for(int i=1;i&lt;=24;i++) { int a;scanf(&quot;%d&quot;,&amp;a); if(a==0)return 0; if(i==1)mp[1][3]=a; if(i==2)mp[1][5]=a; if(i==3)mp[2][3]=a; if(i==4)mp[2][5]=a; if(i&gt;=5&amp;&amp;i&lt;=11)mp[3][i-4]=a; if(i==12)mp[4][3]=a; if(i==13)mp[4][5]=a; if(i&gt;=14&amp;&amp;i&lt;=20)mp[5][i-13]=a; if(i==21)mp[6][3]=a; if(i==22)mp[6][5]=a; if(i==23)mp[7][3]=a; if(i==24)mp[7][5]=a; } if(okay()) { printf(&quot;No moves needed\\n&quot;); printf(&quot;%d\\n&quot;,mp[3][3]); continue; } success=false;depth=1;ans=&quot;&quot;;num=0; while(!success) { IDA_star(0,&quot;&quot;,'0'); depth++; } cout&lt;&lt;ans&lt;&lt;endl; printf(&quot;%d\\n&quot;,num); } return 0;} ä»¥ä¸Šå°±æ˜¯IDA*ä¸A*çš„å…¨éƒ¨å†…å®¹äº†ï¼Œå®Œç»“æ’’èŠ±~â¤ï¸","link":"/2022/06/13/A-star%E4%B8%8EIDA-star/"},{"title":"ARCåšé¢˜è®°å½•","text":"Solve ARC Problems Record ARCåšé¢˜è®°å½• ARC058 C.Irohaâ€™s Obsession Difficulty: 1147\\color{green} 11471147 åˆ†æƒ…å†µè®¨è®ºå³å¯ï¼Œé¦–å…ˆç¡®å®šæ„é€ çš„æ•°çš„ç¬¬ä¸€ä½ï¼Œ æœ‰ä¸‰ç§æƒ…å†µï¼Œèƒ½å¡«çš„æ•°åˆ†åˆ«å¯ä»¥å¤§äºç¬¬ä¸€ä½ï¼Œ ç­‰äºç¬¬ä¸€ä½ï¼Œ å°äºç¬¬ä¸€ä½ï¼Œè´ªå¿ƒè€ƒè™‘å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(n)O(n)O(n)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;const int M = 12;int n, m;int d[M];bool vis[M];int num[N], len;void solve(int type){ if(type == 0) { int fir = 0; for(int i = 1; i &lt;= m; i++) { if(d[i] &gt;= num[len]) { fir = d[i]; break; } } if(fir &gt; num[len]) cout &lt;&lt; fir, solve(1); else solve(2); } else if(type == 1) { for(int i = len - 1; i &gt;= 1; i--) cout &lt;&lt; d[1]; } else if(type == 2) { int fir = 0; for(int i = 1; i &lt;= m; i++) { if(d[i] == num[len]) { fir = d[i]; break; } } int res = true; vector &lt;int&gt; v; for(int i = len - 1; i &gt;= 1; i--) { int x = -1; for(int j = 1; j &lt;= m; j++) { if(d[j] &gt;= num[i]) { x = d[j]; break; } } if(x == -1)res = false; v.push_back(x); } if(res &amp;&amp; fir != 0) { cout &lt;&lt; fir; for(auto x : v) cout &lt;&lt; x; } else solve(3); } else if(type == 3) { if(d[1] == 0)cout &lt;&lt; d[2]; else cout &lt;&lt; d[1]; for(int i = len; i &gt;= 1; i--) cout &lt;&lt; d[1]; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { int x; scanf(&quot;%d&quot;, &amp;x); vis[x] = true; } m = 0; for(int i = 0; i &lt; 10; i++) if(!vis[i])d[++m] = i; if(n == 0)num[++len] = 0; while(n != 0)num[++len] = n % 10, n /= 10; solve(0); return 0;} D.Iroha and a Grid Difficulty:1905\\color{blue} 19051905 é¦–å…ˆæ²¡æœ‰é™åˆ¶çš„æ–¹æ¡ˆæ•°æ˜¾ç„¶æ˜¯(nâˆ’1n+mâˆ’2)\\dbinom{n - 1}{n + m - 2}(n+mâˆ’2nâˆ’1â€‹), å†è€ƒè™‘ä¸Šé™åˆ¶ï¼Œå…¶å®å°±æ˜¯å‡ºç°äº†ä¸€ä¸ªåˆ†ç•Œçº¿ï¼Œæˆ‘ä»¬å¯ä»¥å¼ºåˆ¶å…¶èµ°åˆ°åˆ†ç•Œçº¿ä¸Šæ–¹ï¼Œä¸èµ°æœ‰é™åˆ¶çš„æ ¼å­ï¼Œ å†è®©å…¶èµ°åˆ°å³ä¸‹è§’ï¼Œ æ±‚æ–¹æ¡ˆæ•°ï¼Œ ç­”æ¡ˆå³ä¸ºï¼š âˆ‘i=1mâˆ’b(b+iâˆ’1nâˆ’a+b+iâˆ’2)Ã—(aâˆ’1a+mâˆ’bâˆ’i+1âˆ’2) \\sum_{ i = 1} ^ {m - b} \\dbinom{b + i - 1}{n - a + b + i - 2} \\times \\dbinom{a - 1}{a + m - b - i + 1 - 2} i=1âˆ‘mâˆ’bâ€‹(nâˆ’a+b+iâˆ’2b+iâˆ’1â€‹)Ã—(a+mâˆ’bâˆ’i+1âˆ’2aâˆ’1â€‹) æ—¶é—´å¤æ‚åº¦O(n)O(n)O(n)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 1e5 + 10;int n, m, a, b;int fac[N &lt;&lt; 1], ifac[N &lt;&lt; 1];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int C(int n, int m){ if(n &lt; m)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}signed main(){ scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;a, &amp;b); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n + m; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n + m; i++) ifac[i] = qpow(fac[i], mod - 2); int ans = 0; for(int i = 1; i &lt;= m - b; i++) (ans += C(n - a + b + i - 2, b + i - 1) % mod * C(a + m - b - i - 1, a - 1) % mod) %= mod; printf(&quot;%lld&quot;, ans); return 0;} E.Iroha and Haiku Difficulty: 2473\\color{orange} 24732473 é¦–å…ˆæˆ‘ä»¬å¯ä»¥å°†æ¯ä¸ªæ•°åˆ†è§£ï¼Œç„¶åç»„åˆæ„é€ æ–¹æ¡ˆï¼Œä½†æ˜¯ä¼šäº§ç”Ÿé‡å¤ï¼Œè€Œä¸”å¾ˆéš¾è®¡ç®—ï¼Œä¸å¦¨æ¢ä¸€ä¸ªæ€è·¯è€ƒè™‘æ€»æ–¹æ¡ˆæ•°-ä¸åˆæ³•çš„æ–¹æ¡ˆæ•°ï¼Œ æ¥ä¸‹æ¥è€ƒè™‘å¦‚ä½•è®¡ç®—ä¸åˆæ³•çš„æ–¹æ¡ˆæ•°ã€‚ æ„Ÿè§‰æ˜¯ä¸€é“éå¸¸å¥½çš„çŠ¶å‹dp, çŠ¶å‹æ–¹å¼ä¹Ÿå¾ˆç‰¹æ®Šï¼Œé¦–å…ˆæ ¹æ®æ•°æ®é™åˆ¶å¯ä»¥åˆ¤æ–­x+y+zâ‰¤17x + y + z \\le 17x+y+zâ‰¤17ï¼Œ å¯ä»¥å‹æˆä¸€ä¸ª171717ä½çš„äºŒè¿›åˆ¶æ•°ï¼Œå°†ä¸€ä¸ªæ•°kkkå‹æˆ1&lt;&lt;kâˆ’11 &lt;&lt; k - 11&lt;&lt;kâˆ’1ï¼Œ æ¯”å¦‚å°†444ï¼Œå‹æˆ100010001000ï¼Œè¡¨ç¤ºæœ«å°¾çš„æ•°ï¼Œå½“åŠ å…¥ä¸€ä¸ªæ•°333æ—¶ï¼Œå…¶ä¸º100010010001001000100ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥è¡¨ç¤ºå‡ºå…¶èƒ½è¡¨ç¤ºå‡ºçš„æ•°777ï¼Œå†ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œæ¯”å¦‚100001000101000010001010000100010å¯ä»¥è¡¨ç¤º11,6,2,4,5,911,6,2,4,5,911,6,2,4,5,9ï¼Œå…¶å®å°±æ˜¯è¡¨ç¤ºçš„ä¸€æ®µè¿ç»­åŒºé—´çš„å’Œï¼Œé‚£ä¹ˆå½“çŠ¶æ€çš„å­é›†ä¸­æœ‰(1&lt;&lt;xâˆ’1)âˆ£(1&lt;&lt;x+yâˆ’1)âˆ£(1&lt;&lt;x+y+zâˆ’1)(1 &lt;&lt; x - 1) | (1 &lt;&lt; x + y - 1) | (1 &lt;&lt; x + y + z - 1)(1&lt;&lt;xâˆ’1)âˆ£(1&lt;&lt;x+yâˆ’1)âˆ£(1&lt;&lt;x+y+zâˆ’1)æ—¶ï¼Œæ˜¾ç„¶å°±æ»¡è¶³è¦æ±‚ï¼Œæ¯æ¬¡åªè€ƒè™‘å‹çš„x+y+zx + y + zx+y+zå³å¯ï¼Œæ³¨æ„é˜²æ­¢è¶Šä½ï¼Œæ—¶é—´å¤æ‚åº¦O(n2x+y+z)O(n 2 ^ {x + y + z})O(n2x+y+z)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 45;const int M = 17;const int mod = 1e9 + 7;int n, X, Y, Z;int f[N][1 &lt;&lt; M];int ans;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}signed main(){ scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;X, &amp;Y, &amp;Z); int S = (1 &lt;&lt; X + Y + Z) - 1; int T = (1 &lt;&lt; X - 1) | (1 &lt;&lt; X + Y - 1) | (1 &lt;&lt; X + Y + Z - 1); f[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= S; j++) { for(int k = 1; k &lt;= 10; k++) { int s = ((j &lt;&lt; k) | (1 &lt;&lt; k - 1)) &amp; S; if((T &amp; s) == T)continue; f[i][s] = (f[i][s] + f[i - 1][j]) % mod; } } } ans = qpow(10, n); for(int i = 0; i &lt;= S; i++) ans = (ans - f[n][i] + mod) % mod; printf(&quot;%lld&quot;, ans); return 0;} F.Iroha Loves Strings Difficulty: 3678\\color{red} 36783678 å°±ä¼šå†™ä¸€ä¸ªO(nm2)O(nm^2)O(nm2)çš„ï¼Œä¸å¤ªä¼šZå‡½æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2100;const int K = 1e4 + 10;int n, k;string s[N];string f[2][K];int main(){ cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; string str = &quot;&quot;; for(int i = 1; i &lt;= k; i++) str = str + &quot;|&quot;; for(int i = 1; i &lt;= k; i++) f[0][i] = str; f[0][0] = &quot;&quot;; for(int i = 1; i &lt;= n; i++) { int len = s[i].size(); for(int j = 0; j &lt;= k; j++) f[i &amp; 1][j] = f[!(i &amp; 1)][j]; for(int j = len; j &lt;= k ; j++) { if(f[!(i &amp; 1)][j - len] + s[i] &lt; f[i &amp; 1][j]) f[i &amp; 1][j] = f[!(i &amp; 1)][j - len] + s[i]; } } cout &lt;&lt; f[n &amp; 1][k]; return 0;} ARC059 C.Being Together Difficulty: 712\\color{brown} 712712 ç›´æ¥æšä¸¾å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2) 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n;int a[N];int cost(int x, int y){ return (x - y) * (x - y);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int ans = 1e9; for(int i = -100; i &lt;= 100; i++) { int sum = 0; for(int j = 1; j &lt;= n; j++) sum += cost(a[j], i); ans = min(ans, sum); } printf(&quot;%d&quot;, ans); return 0;} D.Unbalanced Difficulty : 1374\\color{cyan} 13741374 å…¶å®æ‰‹ç©ä¸€ä¸‹å°±å¯ä»¥å‘ç°å‡ºç°ç›¸é‚»çš„ç›¸åŒçš„æˆ–é—´éš”ä¸€ä¸ªç›¸åŒçš„å°±ä¼šæ»¡è¶³è¦æ±‚ï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(n)O(n) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;char s[N];int n;int main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); bool res = true; for(int i = 2; i &lt;= n; i++) { if(s[i] == s[i - 1]) { res = false; printf(&quot;%d %d&quot;, i - 1, i); break; } } if(res) { for(int i = 3; i &lt;= n; i++) { if(s[i] == s[i - 2]) { res = false; printf(&quot;%d %d&quot;, i - 2, i); break; } } } if(res)printf(&quot;-1 -1&quot;); return 0;} E.Children and Candies Difficulty: 2189\\color{yellow}21892189 ä¸€å¼€å§‹è¢«ä¸€å¨sigmaæä¸ä¼šäº†, å…¶å®å°±æ˜¯ä¸ªdp, è®¾fi,jf_{i, j}fi,jâ€‹è¡¨ç¤ºå‰iiiä¸ªäººï¼Œ åˆ†åˆ°äº†jjjä¸ªç³–æœçš„ç­”æ¡ˆï¼Œå¯ä»¥å¾—åˆ°è½¬ç§» fi,j=âˆ‘k=0j(fiâˆ’1,jâˆ’kÃ—âˆ‘x=aibixk) f_{i, j} = \\sum_{k = 0} ^ j \\bigg ( f_{i - 1, j - k} \\times \\sum_{x = a_i} ^ {b_i} x ^ k \\bigg) fi,jâ€‹=k=0âˆ‘jâ€‹(fiâˆ’1,jâˆ’kâ€‹Ã—x=aiâ€‹âˆ‘biâ€‹â€‹xk) è¡¨ç¤ºå½“å‰é€‰äº†kkkä¸ªï¼Œç„¶åå…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®ã€‚ æ—¶é—´å¤æ‚åº¦O(n3)O(n^3)O(n3) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 410;int n, m;int a[N], b[N];int f[N][N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int sum[N][N];signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt;= m; k++) for(int j = a[i]; j &lt;= b[i]; j++) sum[i][k] = (sum[i][k] + qpow(j, k)) % mod; f[0][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++) for(int k = 0; k &lt;= j; k++) f[i][j] = (f[i][j] + f[i - 1][j - k] * sum[i][k] % mod) % mod; printf(&quot;%lld&quot;, f[n][m]); return 0;} F.Unhappy Hacking Difficulty: 2427\\color{orange} 24272427 å…¶å®æŒºç®€å•çš„ï¼Œä¸€å¼€å§‹æƒ³éº»çƒ¦äº†ï¼Œè®¾fi,jf_{i, j}fi,jâ€‹è¡¨ç¤ºå½“å‰ä½¿ç”¨äº†iiiæ¬¡æ“ä½œï¼ŒåŒ¹é…åˆ°äº†jjjä¸ªå­—ç¬¦ï¼Œå¯¹äºè½¬ç§»å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼Œé¦–å…ˆæ˜¯é€‰å¡«0,10, 10,1ï¼Œ fi,j=fi,j+fiâˆ’1,jâˆ’1f_{i, j} = f_{i, j} + f_{i - 1, j - 1} fi,jâ€‹=fi,jâ€‹+fiâˆ’1,jâˆ’1â€‹ å¦‚æœé€‰æ‹©åˆ é™¤æ“ä½œï¼Œ å…¶å®å°±å¯ä»¥ä»ä¸Šæ¬¡æ“ä½œçš„j+1j + 1j+1ä¸ªä½ç½®è½¬ç§»è¿‡æ¥ï¼Œç”±äºä¸é™åˆ¶0,10, 10,1ï¼Œ è¦ä¹˜ä»¥222 fi,j=fi,j+2Ã—fiâˆ’1,j+1f_{i, j} = f_{i, j} + 2 \\times f_{i - 1, j + 1} fi,jâ€‹=fi,jâ€‹+2Ã—fiâˆ’1,j+1â€‹ æ³¨æ„ä¸ºç©ºæ—¶å¯ä»¥ä½¿ç”¨åˆ é™¤æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦O(n2)O(n ^ 2)O(n2) 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5100;const int mod = 1e9 + 7;int n;char s[N];int f[N][N];signed main(){ scanf(&quot;%lld%s&quot;, &amp;n, s + 1); int m = strlen(s + 1); f[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= i; j++) { if(j &gt; 0)f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod; else f[i][j] = (f[i][j] + f[i - 1][0]) % mod; f[i][j] = (f[i][j] + 2 * f[i - 1][j + 1]) % mod; } } printf(&quot;%lld&quot;, f[n][m]); return 0;} ARC060 C.Tak and Cards Difficulty: 1583\\color{cyan} 15831583 é¦–å…ˆå°†æ¯ä¸ªæ•°å‡å»å¹³å‡æ•°ï¼Œå°†é—®é¢˜è½¬åŒ–ä¸ºé€‰å‡ºè‹¥å¹²ä¸ªæ•°ä½¿å…¶å’Œä¸º000çš„æ–¹æ¡ˆæ•°ï¼Œ å¯ä»¥ä½¿ç”¨æŠ˜åŠæœç´¢ï¼Œæ—¶é—´å¤æ‚åº¦O(nn2)O(n^{\\frac{n}{2}})O(n2nâ€‹)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;#define int long longconst int N = 60;int n, m;int a[N];unordered_map&lt;int, int&gt; vis;int ans;void dfs1(int x, int lim, int sum){ if(x &gt; lim) { vis[sum]++; return; } dfs1(x + 1, lim, sum); dfs1(x + 1, lim, sum + a[x]);}void dfs2(int x, int lim, int sum){ if(x &gt; lim) { ans += vis[-sum]; return; } dfs2(x + 1, lim, sum); dfs2(x + 1, lim, sum + a[x]);}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; i++) a[i] -= m; int mid = n &gt;&gt; 1; dfs1(1, mid, 0); dfs2(mid + 1, n, 0); printf(&quot;%lld&quot;, ans - 1); return 0;} D.Digit Sum Difficulty: 2261\\color{yellow} 22612261 å¯ä»¥ä½¿ç”¨æ ¹å·åˆ†æ²»ï¼Œå½“dâ‰¤nd \\le \\sqrt ndâ‰¤nâ€‹çš„æ—¶å€™ï¼Œç›´æ¥æš´åŠ›æšä¸¾ï¼Œd&gt;nd &gt; \\sqrt nd&gt;nâ€‹æ—¶ï¼Œn=kb+x,s=k+xn = k b + x, s = k + xn=kb+x,s=k+x, nâˆ’sn - snâˆ’sä¸ºbâˆ’1b - 1bâˆ’1çš„å€æ•°ï¼Œæšä¸¾çº¦æ•°å³å¯ï¼Œæœ‰ä¸€äº›ç‰¹æ®Šæƒ…å†µéœ€è¦ç‰¹åˆ¤ã€‚ æ—¶é—´å¤æ‚åº¦O(n)O(\\sqrt n)O(nâ€‹) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n, m;int f(int b, int n){ if(!n)return 0; return f(b, n / b) + n % b;}int ans = 1e18;signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); bool res = false; int mid = 1e6; for(int i = 2; i &lt;= mid; i++) { if(f(i, n) == m) { res = true; ans = i; break; } } if(!res) { for(int i = 1; i * i &lt;= n - m; i++) { if((n - m) % i)continue; if(f(i + 1, n) == m) { res = true; ans = i + 1; break; } if(f((n - m) / i + 1, n) == m) { ans = min(ans,(n - m) / i + 1); res = true; } } } if(!res) { for(int i = n;i &gt;= 2 &amp;&amp; i &lt;= n + 10; i++) if(f(i, n) == m) {ans = i, res = true; break;} } if(!res)ans = -1; printf(&quot;%lld&quot;, ans); return 0;} E.Tak and Hotels Difficulty: 2154\\color{yellow} 21542154 ç›´æ¥å€å¢å¤„ç†å³å¯æ—¶é—´å¤æ‚åº¦O(qlogâ¡n)O(q \\log n)O(qlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, q;int pos[N];int f[N][26];int query(int a, int b){ int sum = 0, cur = a; for(int i = 25; i &gt;= 0; i--) { if(f[cur][i] &gt;= b)continue; cur = f[cur][i]; sum += (1 &lt;&lt; i); } sum++; return sum;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;pos[i]); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= n; i++) { int x = lower_bound(pos + 1, pos + n + 1, pos[i] + m + 1) - pos; f[i][0] = x - 1; } for(int j = 1; j &lt;= 25; j++) for(int i = 1; i &lt;= n; i++) { if(f[i][j - 1] &gt;= n)f[i][j] = n + 1; else f[i][j] = f[f[i][j - 1]][j - 1]; } scanf(&quot;%d&quot;, &amp;q); while(q--) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if(a &gt; b)swap(a, b); printf(&quot;%d\\n&quot;, query(a, b)); } return 0;} F.Best Representation Difficulty: 2804\\color{red} 28042804 è¯ˆéª—é¢˜ ä¸€é“è¯ˆéª—é¢˜ï¼Œæ¨¡æ•°æ ¹æœ¬å°±æ²¡ç”¨åˆ°ï¼Œ ä¹Ÿæ²¡ç‰¹æ®Šæ€§è´¨ï¼Œ è¿˜ä»¥ä¸ºæ˜¯dpï¼Œ å…¶å®é™¤äº†å…¨æ˜¯ç›¸åŒå­—æ¯çš„å­—ç¬¦ä¸²ï¼Œ å…¶ä»–çš„è¦ä¹ˆä¸º111ï¼Œè¦ä¹ˆä¸º222ï¼Œå¾ˆæ˜¾ç„¶ï¼Œç„¶åkmpï¼Œ åˆ¤å¾ªç¯èŠ‚ï¼Œç»Ÿè®¡æ–¹æ¡ˆå°±å¯ä»¥äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5e5 + 10;const int mod = 1e9 + 7;int n;char s[N];bool check1(){ for(int i = 2; i &lt;= n; i++) if(s[i] != s[i - 1])return false; return true;}bool check2(int *f, int i){ if((f[i] &lt;&lt; 1) &lt; i) return true; else return i % (i - f[i]);}int fnxt[N], gnxt[N];signed main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); if(check1()) { printf(&quot;%d\\n1&quot;, n); return 0; } for(int i = 2, j = 0; i &lt;= n; i++) { while(j &amp;&amp; s[i] != s[j + 1]) j = fnxt[j]; if(s[i] == s[j + 1]) j++; fnxt[i] = j; } reverse(s + 1, s + n + 1); for(int i = 2, j = 0; i &lt;= n; i++) { while(j &amp;&amp; s[i] != s[j + 1]) j = gnxt[j]; if(s[i] == s[j + 1]) j++; gnxt[i] = j; } if(check2(fnxt, n)) { printf(&quot;1\\n1&quot;); return 0; } int ans = 0; for(int i = 1; i &lt; n; i++) { int x = i, y = n - i; if(check2(fnxt, x) &amp;&amp; check2(gnxt, y)) ans++; } printf(&quot;2\\n%d&quot;, ans); return 0;} ARC061 C.Many Formulas Difficulty: 1089\\color{green} 10891089 æœç´¢å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(2n)O(2 ^ n)O(2n)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n;char s[15];int num[15][15];int ans = 0;bool vis[15];void dfs(int x){ if(x &gt;= n) { int sum = 0; int lst = 1; for(int i = 1; i &lt;= n; i++) { if(vis[i]) { sum += num[lst][i]; lst = i + 1; } } ans += sum; return; } dfs(x + 1); vis[x] = true; dfs(x + 1); vis[x] = false;}signed main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); for(int i = 1; i &lt;= n; i++) { int sum = 0; for(int j = i; j &lt;= n; j++) { sum = sum * 10 + s[j] - '0'; num[i][j] = sum; } } vis[n] = true; dfs(1); printf(&quot;%lld&quot;, ans); return 0;} D.Snukeâ€™s Coloring Difficulty: 1682\\color{blue} 16821682 åªè€ƒè™‘æ¯ä¸ªçŸ©å½¢çš„å·¦ä¸Šè§’ï¼Œç„¶åè€ƒè™‘æ¯ä¸ªé»‘ç‚¹å¯¹æ¯ä¸ªçŸ©å½¢çš„è´¡çŒ®ï¼Œ ç„¶åæšä¸¾å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(n)O(n)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5 + 10;int n, h, w;struct node{ int x, y; node(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (node a, node b){return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}};map &lt;node, int&gt; id;int b[N * 100];int cnt;void paint(int x, int y){ for(int i = x - 2; i &lt;= x; i++) { for(int j = y - 2; j &lt;= y; j++) { if(i &lt; 1 || j &lt; 1 || i + 2 &gt; h || j + 2 &gt; w) continue; if(id[node(i, j)] == 0) id[node(i, j)] = ++cnt; b[id[node(i, j)]]++; } }}int ans[10];signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;n); for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); paint(x, y); } for(int i = 1; i &lt;= cnt; i++) ans[b[i]]++; int sum = 0; for(int i = 1; i &lt;= 9; i++) sum += ans[i]; ans[0] = max(0ll, (h - 2) * (w - 2) - sum); for(int i = 0; i &lt;= 9; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;} E.Snukeâ€™s Subway Trip Difficulty: 2502\\color{orange} 25022502 é¦–å…ˆå¯ä»¥æƒ³åˆ°æ–°å»ºè™šç‚¹ç„¶åï¼Œåœ¨æ¯ä¸ªè¿é€šå—ä¸­è·‘æœ€çŸ­è·¯ï¼Œ ä½†æ˜¯è¿™æ ·å»ºçš„è¾¹æ•°æ˜¯n2n^2n2çº§åˆ«çš„ï¼Œæˆ‘ä»¬å¯ä»¥æ¢ä¸€ç§å»ºè¾¹æ–¹å¼ï¼Œå°†æ¯ä¸ªè¾¹æ‹†æˆä¸€ä¸ªç‚¹ï¼Œç„¶åå»ºè¾¹ï¼Œè¿™æ ·çš„è¯å…¶å®å°±æ˜¯å°†è´¹ç”¨æ‹†æˆäº†ä¸¤ä¸ª0.50.50.5æœ€åéœ€è¦ï¼Œé™¤ä»¥222ï¼Œå»ºè¾¹çš„å¤æ‚åº¦ä¸ºn+2Ã—mn + 2 \\times mn+2Ã—mçº§åˆ«çš„ã€‚ è·‘æœ€çŸ­è·¯å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e6 + 10;const int INF = 0x3f3f3f3f3f3f3f3f;int cnt, head[N];struct edge{ int to, nxt, cost; edge(int v = 0, int x = 0, int c = 0) : to(v), nxt(x), cost(c) {}};edge e[N &lt;&lt; 1];void add(int u, int v, int c){ e[++cnt] = edge(v, head[u], c); head[u] = cnt; e[++cnt] = edge(u, head[v], c); head[v] = cnt;}struct node{ int x, y; node(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (node a, node b){return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}};int n, m;int tot;map &lt;node, int&gt; f;map &lt;node, int&gt; g;int find(int x, int y){ if(f[node(x, y)])return f[node(x, y)]; else return f[node(x, y)] = ++tot;}bool check(int x, int y){ return g[node(x, y)] | g[node(y, x)];}int dis[N];bool vis[N];int bfs(){ memset(dis, INF, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[1] = 0; vis[1] = true; queue &lt;int&gt; q; q.push(1); while(!q.empty()) { int x = q.front(); q.pop(); vis[x] = false; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to, c = e[i].cost; if(dis[x] + c &lt; dis[v]) { dis[v] = dis[x] + c; if(!vis[v]) { vis[v] = true; q.push(v); } } } } return dis[n];}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); tot = n; for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z); int u = find(x, z); int v = find(y, z); if(!check(x, u))add(x, u, 1), g[node(x, u)] = g[node(u, x)] = 1; if(!check(y, v))add(y, v, 1), g[node(x, v)] = g[node(v, x)] = 1; add(u, v, 0); } int ans = bfs(); if(ans == INF)ans = -2; printf(&quot;%lld\\n&quot;, ans / 2); return 0;} F.Card Game for Three Difficulty: 3154\\color{red} 31543154 é¦–å…ˆéœ€è¦æ³¨æ„çš„æ˜¯é¢˜ç›®è¯´çš„æ˜¯3n+m+k3 ^ { n + m + k }3n+m+k ç§æƒ…å†µä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åæ‹¿å®Œåï¼Œä¸æ­¢å¯¹åº”çš„æ˜¯ä¸€ç§æƒ…å†µï¼Œé¦–å…ˆè½¬åŒ–é—®é¢˜ï¼Œå°†å…¶è½¬åŒ–ä¸ºåªæœ‰1,2,31, 2, 31,2,3çš„åºåˆ—ï¼Œå‡è®¾æˆ‘ä»¬æšä¸¾æ¸¸æˆç»“æŸæ—¶ï¼Œæ­¤æ—¶é€‰äº†ä¸æ˜¯111çš„ä¸ªæ•°ä¸ºxxxï¼Œæ­¤æ—¶è¿™æ®µåºåˆ—é•¿åº¦ä¸ºx+nx + nx+nï¼Œä¸”æ­¤æ—¶è‚¯å®šä¼šæœ‰nnnä¸ª111ä»¥åŠæœ«å°¾ä¸€å®šæ˜¯111ï¼Œ ä¹Ÿå°±æ˜¯ï¼š (x+nâˆ’1x)âˆ‘y=0x(xy)[yâ‰¤m][xâˆ’yâ‰¤k]\\dbinom{x + n - 1}{x} \\sum_{y = 0}^x \\dbinom{x}{y} [y \\le m][x - y \\le k] (xx+nâˆ’1â€‹)y=0âˆ‘xâ€‹(yxâ€‹)[yâ‰¤m][xâˆ’yâ‰¤k] è¿™ä¸ªç»„åˆæ•°çš„æ„ä¹‰å…¶å®å°±æ˜¯ï¼Œåœ¨x+nâˆ’1x + n - 1x+nâˆ’1ä¸ªå¯ä»¥éšä¾¿é€‰çš„ä½ç½®ä¸­é€‰xxxä¸ªä½ç½®å¡«ä¸æ˜¯111çš„ï¼Œç„¶åå†åœ¨è¿™äº›ä½ç½®ä¸­é€‰å¡«222è¿˜æ˜¯333ï¼Œæ¥ç€å°†ç»„åˆæ•°æ±‚å’Œè½¬åŒ–ä¸º S(x)=âˆ‘xâˆ’kâ‰¤yâ‰¤m(xy)=âˆ‘xâˆ’kâ‰¤yâ‰¤m(xâˆ’1y)+(xâˆ’1yâˆ’1)=âˆ‘xâˆ’kâ‰¤yâ‰¤m(xâˆ’1y)+âˆ‘xâˆ’kâ‰¤yâ‰¤m(xâˆ’1yâˆ’1)=2S(xâˆ’1)âˆ’(xâˆ’1xâˆ’kâˆ’1)âˆ’(xâˆ’1m)\\begin{aligned} S(x) &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x}{y} \\\\ &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y} + \\dbinom{x - 1}{y - 1} \\\\ &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y} + \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y - 1} \\\\ &amp;= 2S(x - 1) - \\dbinom{x - 1}{x - k - 1} - \\dbinom{x - 1}{m} \\end{aligned} S(x)â€‹=xâˆ’kâ‰¤yâ‰¤mâˆ‘â€‹(yxâ€‹)=xâˆ’kâ‰¤yâ‰¤mâˆ‘â€‹(yxâˆ’1â€‹)+(yâˆ’1xâˆ’1â€‹)=xâˆ’kâ‰¤yâ‰¤mâˆ‘â€‹(yxâˆ’1â€‹)+xâˆ’kâ‰¤yâ‰¤mâˆ‘â€‹(yâˆ’1xâˆ’1â€‹)=2S(xâˆ’1)âˆ’(xâˆ’kâˆ’1xâˆ’1â€‹)âˆ’(mxâˆ’1â€‹)â€‹ è¿™æ ·å°±å¯ä»¥O(n)O(n)O(n)å¤„ç†ç»„åˆæ•°æ±‚å’Œï¼Œå†è€ƒè™‘é•¿åº¦ä¸ºxxxçš„åºåˆ—å¯¹åº”çš„æƒ…å†µç­”æ¡ˆå…¶å®å°±æ˜¯ âˆ‘x=0m+k3m+kâˆ’x(x+nâˆ’1x)S(x)\\sum_{x = 0} ^ {m + k} 3 ^ {m + k - x} \\dbinom{x + n - 1}{x}S(x) x=0âˆ‘m+kâ€‹3m+kâˆ’x(xx+nâˆ’1â€‹)S(x) O(n)O(n)O(n)è®¡ç®—å³å¯ã€‚(tips: å–æ¨¡æ„ä¹‰ä¸‹å‡æ³•è¦åŠ æ¨¡æ•°) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 1e6 + 10;int n, m, k;int S[N];int fac[N], ifac[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int C(int n, int m){ if(n &lt; m || n &lt; 0 || m &lt; 0)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k); n = n + m + k; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = inv(fac[i]); S[0] = 1; for(int i = 1; i &lt;= n; i++) S[i] = ((2 * S[i - 1] % mod - C(i - 1, i - k - 1) % mod - C(i - 1, m) % mod + mod) % mod + mod) % mod; int ans = 0; for(int i = 0; i &lt;= m + k; i++) ((ans += qpow(3, m + k - i) % mod * C(i + n - m - k - 1, i) % mod * S[i] % mod + mod) %= mod + mod) %= mod; printf(&quot;%lld&quot;, ans); return 0;} ARC104 F.Visibility Sequence Difficulty: 3213\\color{red} 32133213 è€ƒè™‘å°†æ‰€æœ‰çš„âˆ’1-1âˆ’1æ›¿æ¢æˆ000ï¼Œæ ¹æ®é¢˜ç›®ä¸­çš„è¦æ±‚ï¼Œåœ¨iiiå’Œpip_ipiâ€‹ä¹‹é—´è¿ä¸€æ¡è¾¹ï¼Œå¯ä»¥æ„é€ å‡ºä¸€æ£µæ ‘ï¼Œå…¶æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š ä¸€æ£µæ ‘å¯¹åº”å”¯ä¸€çš„ä¸€ä¸ªæ’åˆ—PPP è¿™æ£µæ ‘ä»¥000ä¸ºæ ¹ å­æ ‘å†…çš„ç¼–å·æ˜¯è¿ç»­çš„ å¯¹äºä¸€ä¸ªèŠ‚ç‚¹çš„hih_ihiâ€‹ï¼Œå…¶æ»¡è¶³hiâ‰¥maxâ¡{hsoni+1,hfriendi}h_i \\ge \\max \\{ h_{son_i} + 1, h_{friend_i} \\}hiâ€‹â‰¥max{hsoniâ€‹â€‹+1,hfriendiâ€‹â€‹}ã€‚ è¯æ˜ä¸éš¾ï¼Œç›´æ¥è®¾fi,j,kf_{i, j, k}fi,j,kâ€‹è¡¨ç¤ºåŒºé—´[i,j][i, j][i,j]æ„é€ å‡ºæ¥ä»¥iiiä¸ºæ ¹çš„å­—æ•°ï¼Œä¸”hi=kh_i = khiâ€‹=kçš„PPPçš„æ•°é‡ã€‚ è§‚å¯Ÿåˆ°é¢˜ç›®ä¸­ç»™çš„å€¼åŸŸçš„èŒƒå›´ï¼Œå…¶å®ç”±äºæ±‚çš„æ˜¯PPPçš„ä¸ªæ•°ï¼Œå·²ç»è¢«æˆ‘ä»¬è½¬åŒ–ä¸ºæ˜ å°„ä¹‹é—´çš„å…³ç³»ï¼Œåªå’Œç›¸å¯¹å¤§å°æœ‰å…³ï¼Œæ‰€ä»¥å…¶å€¼åŸŸå…¶å®æ˜¯nnnï¼Œç„¶åå°±æ˜¯è€ƒè™‘è½¬ç§»ã€‚ é¦–å…ˆç¬¬ä¸€ç§æƒ…å†µå°±æ˜¯ï¼Œè€ƒè™‘åŒºé—´[i,j][i, j][i,j]åœ¨æœ«å°¾æ–°æ·»åŠ ä¸€æ£µå­æ ‘ï¼Œå¦‚æœå­æ ‘å¤ªå¤§ä¼šå¯¼è‡´hih_ihiâ€‹å˜å¤§ï¼š fi,j,k=âˆ‘p=i+1jfp,j,kâˆ’1âˆ‘tâ‰¤kfi,pâˆ’1,tf_{i, j, k} = \\sum_{p = i + 1} ^ j f_{p, j, k - 1} \\sum_{t \\le k}f_{i , p - 1, t} fi,j,kâ€‹=p=i+1âˆ‘jâ€‹fp,j,kâˆ’1â€‹tâ‰¤kâˆ‘â€‹fi,pâˆ’1,tâ€‹ å¦ä¸€ç§æƒ…å†µå°±æ˜¯æ–°åŠ å…¥çš„å­æ ‘hhhæ¯”è¾ƒå°ï¼Œä½†æ˜¯ç”±äºå…¶friendfriendfriendçš„å½±å“ï¼Œè€Œå¯¼è‡´å˜å¤§ï¼š fi,j,k=âˆ‘p=i+1jfi,pâˆ’1,k[xpâ‰¥kâˆ’1]âˆ‘t&lt;kâˆ’1fp,j,tf_{i, j, k} = \\sum_{p = i + 1} ^ j f_{i, p - 1, k}[x_p \\ge k - 1] \\sum_{t &lt; k - 1} f_{p, j, t} fi,j,kâ€‹=p=i+1âˆ‘jâ€‹fi,pâˆ’1,kâ€‹[xpâ€‹â‰¥kâˆ’1]t&lt;kâˆ’1âˆ‘â€‹fp,j,tâ€‹ ç„¶åå¯ä»¥ä½¿ç”¨å‰ç¼€å’Œä¼˜åŒ–åˆ°O(n4)O(n^4)O(n4)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 110;const int mod = 1e9 + 7;int n, x[N];int f[N][N][N];int g[N][N][N];signed main(){ scanf(&quot;%lld&quot;, &amp;n); x[1] = n + 1; n = n + 1; for(int i = 2; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;x[i]); for(int i = n; i &gt;= 1; i--) { f[i][i][1] = 1; for(int k = 1; k &lt;= n; k++) g[i][i][k] = (g[i][i][k - 1] + f[i][i][k]) % mod; for(int j = i + 1; j &lt;= n; j++) { for(int k = 2; k &lt;= n &amp;&amp; k &lt;= x[i]; k++) { for(int mid = i + 1; mid &lt;= j; mid++) { f[i][j][k] = (f[i][j][k] + g[i][mid - 1][k] * f[mid][j][k - 1] % mod + f[i][mid - 1][k] * g[mid][j][k - 2] % mod * (x[mid] &gt;= k - 1)) % mod; } g[i][j][k] = (g[i][j][k - 1] + f[i][j][k]) % mod; } } } printf(&quot;%lld&quot;, g[1][n][n]); return 0;} ARC062 C.AtCoDeer and Election Report Difficulty : 1346\\color{cyan} 13461346 ç›´æ¥æŒ‰é¢˜æ„æ¨¡æ‹Ÿå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e3 + 10;int n, a[N], b[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a; a = a * a; b &gt;&gt;= 1; } return t;}signed main(){ scanf(&quot;%lld&quot;, &amp;n); a[0] = b[0] = 1; for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); int k = max(a[i - 1] / x, b[i - 1] / y); a[i] = k * x; b[i] = k * y; while(a[i] &lt; a[i - 1] || b[i] &lt; b[i - 1]) a[i] += x, b[i] += y; } printf(&quot;%lld&quot;, a[n] + b[n]); return 0;} D.AtCoDeer and Rock-Paper Difficulty: 1256\\color{cyan} 12561256 è´ªå¿ƒé€‰æ‹©å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;char s[N];int main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); int x = 0, y = 0, ans = 0; for(int i = 1; i &lt;= n; i++) { if(s[i] == 'p') { if(y + 1 &lt;= x) { y++; } else x++, ans--; } else { if(y + 1 &lt;= x) { y++; ans++; } else x++; } } printf(&quot;%d&quot;, ans);} ARC063 C.1D Reversi Difficulty : 755\\color{brown}755755 åˆ¤æ–­æœ‰å¤šå°‘ä¸åŒçš„æ®µæ•°ã€‚ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;char s[N];int main(){ scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int ans = 0; for(int i = 2; i &lt;= n; i++) { if(s[i] != s[i - 1]) ans++; } printf(&quot;%d&quot;, ans); return 0;} D.An Invisible Hand Difficulty : 1376\\color{cyan} 13761376 é€†åºæšä¸¾é€‰ä¸€éæœ€å¤§çš„å·®ï¼Œæœ€åç»Ÿè®¡ä¸€ä¸‹æ–¹æ¡ˆå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, a[N];int ans;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int Max = 0, k = 0; for(int i = n; i &gt;= 1; i--) { Max = max(Max, a[i]); k = max(k, Max - a[i]); } Max = 0; for(int i = n; i &gt;= 1; i--) { Max = max(Max, a[i]); if(Max - a[i]== k) ans++; } printf(&quot;%d&quot;, ans); return 0;} E.Integers on a Tree Difficulty : 2198\\color{yellow} 21982198 ä¸éš¾æƒ³åˆ°ä¸€ç§æ„é€ æ–¹å¼å°±æ˜¯ç»´æŠ¤ä¸€ä¸‹å½“å‰çš„ç‚¹æƒæœ€å°å€¼ï¼Œç„¶åè®©ä¸å…¶ç›¸è¿çš„ç‚¹ä¸ºå…¶ç‚¹æƒ+1+1+1ï¼Œæœ€åcheckä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 0x3f3f3f3f;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int w[N];int res, check;int d[N], l[N], r[N];void dfs(int x, int fa){ d[x] = d[fa] ^ 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x); l[x] = max(l[x], l[v] - 1); r[x] = min(r[x], r[v] + 1); } if(l[x] &gt; r[x])check = 0; if(w[x] != -1) { if(w[x] &gt; r[x] || w[x] &lt; l[x]) check = 0; if(res == -1)res = (w[x] &amp; 1) ^ d[x]; else if(res != ((w[x] &amp; 1) ^ d[x])) check = 0; l[x] = r[x] = w[x]; }}void paint(int x, int fa){ if(fa != 0) { if(w[fa] - 1 &gt;= l[x] &amp;&amp; w[fa] - 1 &lt;= r[x]) w[x] = w[fa] - 1; else w[x] = w[fa] + 1; } else w[x] = l[x]; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; paint(v, x); }}void init(){ check = 1; memset(w, -1, sizeof(w)); memset(l, -INF, sizeof(l)); memset(r, INF, sizeof(r));}int main(){ init(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1, x, y; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } scanf(&quot;%d&quot;, &amp;m); for(int i = 1, v, x; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;v, &amp;x); w[v] = x; } res = -1; dfs(1, 0); if(!check) { printf(&quot;No\\n&quot;); } else { printf(&quot;Yes\\n&quot;); paint(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%d\\n&quot;, w[i]); } return 0;} F.Snukeâ€™s Coloring 2 Difficulty : 3688\\color{red} 36883688 å°±æ˜¯æ‰¾ä¸€ä¸ªçŸ©å½¢ä½¿ç‚¹ä¸åœ¨çŸ©å½¢å†…ï¼Œæ±‚çŸ©å½¢çš„å‘¨é•¿ï¼Œé¦–å…ˆå¾ˆå®¹æ˜“æƒ³åˆ°çš„å°±æ˜¯ç­”æ¡ˆè‡³å°‘ä¸º2maxâ¡(W,H)+22 \\max(W, H) + 22max(W,H)+2ï¼Œ æˆ‘ä»¬å¯ä»¥ç›´æ¥æšä¸¾ä¸­çº¿ï¼Œè¿›è¡Œåˆ†æ²»ï¼Œ å¤æ‚åº¦ä¸ºO(nlogâ¡n)O(n \\log n)O(nlogn)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 3e5 + 10;int n, W, H;struct Point{ int x, y; Point(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (Point a, Point b) { return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; }};Point p[N];int ans, up[N], down[N];int m;int q[N], head, tail;void solve(int l, int r){ if(l == r)return; int mid = (l + r) &gt;&gt; 1; solve(l, mid); solve(mid + 1, r); int u = H, d = 0; for(int i = mid; i &gt;= l; i--) { up[i] = u; down[i] = d; if(p[i].y &lt;= m) d = max(d, p[i].y); else u = min(u, p[i].y); } u = H, d = 0; for(int i = mid + 1; i &lt;= r; i++) { up[i] = u, down[i] = d; if(p[i].y &lt;= m) d = max(d, p[i].y); else u = min(u, p[i].y); } int j = mid, s = W; head = 1, tail = 0; for(int i = mid + 1; i &lt;= r; i++) { while(j &gt;= l &amp;&amp; up[j] &gt;= up[i]) { while(head &lt;= tail &amp;&amp; p[q[tail]].x + down[q[tail]] &gt;= p[j].x + down[j]) tail--; q[++tail] = j; j--; } while(head &lt;= tail &amp;&amp; down[q[head]] &lt;= down[i]) { s = min(s, p[q[head]].x); head++; } ans = max(ans, p[i].x - s + up[i] - down[i]); if(head &lt;= tail) ans = max(ans, p[i].x + up[i] - (p[q[head]].x + down[q[head]])); }}void getans(){ sort(p + 1, p + n + 1); m = H &gt;&gt; 1; p[0] = Point(0, 0); p[n + 1] = Point(W, 0); solve(0, n + 1); reverse(p + 1, p + n + 1); for(int i = 1; i &lt;= n; i++) p[i].x = W - p[i].x; solve(0, n + 1);}signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;W, &amp;H, &amp;n); for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); p[i] = Point(x, y); } getans(); swap(W, H); for(int i = 1; i &lt;= n; i++) swap(p[i].x, p[i].y); getans(); printf(&quot;%lld&quot;, ans &lt;&lt; 1ll); return 0;} ARC119 A.119 Ã— 2^23 + 1 Difficulty : 69\\color{cray} 6969 ç›´æ¥æš´åŠ›æšä¸¾ã€‚ 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;int n;int ans = 1e18;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 63; i &gt;= 0; i--) { int x = 1ll &lt;&lt; i; ans = min(ans, n / x + n % x + i); } printf(&quot;%lld&quot;, ans); return 0;} B.Electric Board Difficulty : 1196\\color{green} 11961196 ä¸€ä¸ªå¾ˆæ˜¾ç„¶çš„ç»“è®ºï¼Œ ç­”æ¡ˆå°±æ˜¯æ¯ä¸ª000çš„ä½ç½®å·®ä¸ä¸º000çš„å’Œã€‚ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int n;char s[N];char t[N];int ans = 0;vector &lt;int&gt; a, b;int main(){ cin &gt;&gt; n &gt;&gt; s + 1 &gt;&gt; t + 1; for(int i = 1; i &lt;= n; i++) if(s[i] == '0')a.push_back(i); for(int i = 1; i &lt;= n; i++) if(t[i] == '0')b.push_back(i); if(a.size() != b.size()) ans = -1; else { for(int i = 0; i &lt; a.size(); i++) if(a[i] != b[i])ans++; } printf(&quot;%d&quot;, ans); return 0;} C.ARC Wrecker 2 Difficulty : 1354\\color{cyan} 13541354 å…¶å®å°±æ˜¯ç»Ÿè®¡å¶æ•°ä½ç½®å’Œå¥‡æ•°ä½ç½®çš„å’Œç›¸åŠ ä¸º000çš„ä¸ªæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 10;#define int long longint n, a[N];int f[N], g[N];int ans;map &lt;int, int&gt; sum;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) { if(i &amp; 1) f[i] = f[i - 1] + a[i], g[i] = g[i - 1]; else g[i] = g[i - 1] + a[i], f[i] = f[i - 1]; } for(int i = 0; i &lt;= n; i++) { ans += sum[f[i] - g[i]]; sum[f[i] - g[i]]++; } printf(&quot;%lld&quot;, ans); return 0;} D. Grid Repainting 3 Difficulty : 2713\\color{orange} 27132713 å¾ˆç»å…¸çš„ä¸€ä¸ªæ¨¡å‹ï¼Œå¯ä»¥æ ¹æ®è¡Œåˆ—åˆ†ä¸ºå·¦éƒ¨ç‚¹å’Œå³éƒ¨ç‚¹ï¼Œå»ºç«‹äºŒåˆ†å›¾ï¼Œç„¶ååˆ†è”é€šå—ç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;#define fir first#define sec second#define mpr make_pair#define int long longtypedef pair &lt;int, int&gt; Pair;const int N = 2e7 + 10;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int a[5010][5010];int fa[N];Pair w[N];int find(int x){ if(x == fa[x])return x; return fa[x] = find(fa[x]);}void merge(int x, int y){ if(find(x) == find(y)) return; x = find(x), y = find(y); fa[x] = y; w[y].fir += w[x].fir; w[y].sec += w[x].sec;}void init(){ for(int i = 1; i &lt;= n; i++) fa[i] = i, w[i] = mpr(1, 0); for(int i = 1; i &lt;= m; i++) fa[i + n] = i + n, w[i + n] = mpr(0, 1);}int f(int x, int y){ return x * m + y * n - x * y;}bool vis[N];vector &lt;pair &lt;Pair, int&gt; &gt; ans;void dfs(int x, int c){ vis[x] = true; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(vis[v])continue; if(!c)ans.push_back(mpr(mpr(x, v - n), 1)); else ans.push_back(mpr(mpr(v, x - n), 0)); dfs(v, c ^ 1); }}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { char c; cin &gt;&gt; c; a[i][j] = (c == 'R'); } } init(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i][j])add(i, j + n), merge(i, j + n); int tot = 0; Pair x(0, 0); for(int i = 1; i &lt;= n + m; i++) { if(find(i) == i &amp;&amp; w[i].fir + w[i].sec &gt; 1) tot++, x.fir += w[i].fir, x.sec += w[i].sec; } if(f(x.fir - tot, x.sec) &gt; f(x.fir, x.sec - tot)) { for(int i = 1; i &lt;= n; i++) if(!vis[i])dfs(i, 0); } else { for(int i = 1; i &lt;= m; i++) if(!vis[i + n])dfs(i + n, 1); } printf(&quot;%lld\\n&quot;, ans.size()); reverse(ans.begin(), ans.end()); for(auto i : ans) printf(&quot;%c %lld %lld\\n&quot;, (i.sec ? 'Y' : 'X'), i.fir.fir, i.fir.sec); return 0;} E.Pancakes Difficulty : 2502\\color{orange} 25022502 ç”±äºåè½¬åŒºé—´å¯¹ä¸­é—´çš„éƒ¨åˆ†æ²¡æœ‰å½±å“ï¼Œ å¯ä»¥æŠŠç»å¯¹å€¼æ‹†å¼€ï¼Œ ç„¶åè½¬åŒ–ä¸ºä¸€ä¸ªäºŒç»´ååºçš„å½¢å¼ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 3e5 + 10;const int INF = 2147483647;struct Point{ int x, y; bool operator &lt; (const Point &amp;a) const{return x &lt; a.x;}};Point p[N];int main(){ int n, lst; scanf(&quot;%d%d&quot;, &amp;n, &amp;lst); ll ans = 0; for (int i = 2; i &lt;= n; i++) { p[i - 1].x = lst; scanf(&quot;%d&quot;, &amp;lst); p[i - 1].y = lst; ans += abs(p[i - 1].x - lst); } int cur = 0; for (int i = 1; i &lt; n; i++) cur = max(cur, abs(p[i].x - p[i].y) - abs(p[n - 1].y - p[i].x)); for (int i = 1; i &lt; n; i++) cur = max(cur, abs(p[i].x - p[i].y) - abs(p[1].x - p[i].y)); sort(p + 1, p + n); for (int i = n - 1, x = INF; i &gt;= 1; i--) { if (p[i].y &lt;= p[i].x) { if (x &lt;= p[i].y) cur = max(cur, 2 * abs(p[i].x - p[i].y)); else if (x &lt;= p[i].x) cur = max(cur, 2 * abs(p[i].x - x)); x = min(x, p[i].y); } swap(p[i].x, p[i].y); } sort(p + 1, p + n); for (int i = n - 1, x = INF; i &gt;= 1; i--) { if (p[i].y &lt;= p[i].x) { if (x &lt;= p[i].y) cur = max(cur, 2 * abs(p[i].x - p[i].y)); else if (x &lt;= p[i].x) cur = max(cur, 2 * abs(p[i].x - x)); x = min(x, p[i].y); } } printf(&quot;%lld\\n&quot;, ans - cur); return 0;} ARC112 F.Die Siedler Difficulty : 3432\\color{red} 34323432 è€ƒè™‘è½¬åŒ–é—®é¢˜ï¼Œå°†æ¯ä¸ªä½ç½®çš„å¡ç‰Œè½¬ç§»åˆ°ç¬¬ä¸€ä¸ªä½ç½®ä¸Šæ¥ï¼Œé¦–å…ˆå¯¹äºè¿™ç§è½¬åŒ–æ–¹å¼å®¹æ˜“å¾—åˆ°å…¶å¾—åˆ°æ»¡è¶³è¦æ±‚çš„åºåˆ—æ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œæ˜¯ä¸åŸåºåˆ—æ˜¯ç­‰ä»·çš„ï¼ŒåŒæ—¶å¯¹äºæ¯ç§å¡åŒ…ï¼Œ ä¹Ÿç”¨ç›¸åŒçš„è½¬åŒ–æ–¹å¼ï¼Œç„¶åç›¸åŠ å‡çš„ç­”æ¡ˆå°±æ˜¯åŸåºåˆ—çš„ç­”æ¡ˆã€‚ å¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„åºåˆ—ï¼Œå…¶è½¬åŒ–å³ä¸º âˆ‘i=1nai2iâˆ’1(iâˆ’1)!\\sum_{i = 1} ^n a_i 2 ^ {i - 1} (i - 1) ! i=1âˆ‘nâ€‹aiâ€‹2iâˆ’1(iâˆ’1)! ç„¶åè€ƒè™‘å·²çŸ¥è¿™ç§è¡¨è¾¾æ–¹å¼å¦‚ä½•æ±‚è§£ï¼Œå…¶å®åªè¦è´ªå¿ƒå³å¯ï¼Œå»å€’ç€å¡«ï¼Œå¯¹äºç¬¬ä¸€ä¸ªä½ç½®çš„æ•°ï¼Œå…¶å¯ä»¥å‡å°‘è‹¥å¹²å€çš„2nn!âˆ’12 ^ n n! - 12nn!âˆ’1(è½¬åŒ–ä¸€å‘¨)ï¼Œ ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åæ‰€æœ‰å¡ç‰Œè½¬ä¸ºä¸ºç¬¬ä¸€ä¸ªä½ç½®çš„æ—¶å€™ï¼Œç­”æ¡ˆå¯ä»¥è¡¨ç¤ºä¸ºï¼Œ v=R+âˆ‘i=1nbixiâˆ’y(2nn!âˆ’1)v = R + \\sum_{i = 1} ^ n b_i x_i - y (2 ^ n n! - 1) v=R+i=1âˆ‘nâ€‹biâ€‹xiâ€‹âˆ’y(2nn!âˆ’1) è£´èœ€å®šç†è§£å‡ºå³å¯ï¼Œ ç„¶åè€ƒè™‘åˆ°æ•°æ®èŒƒå›´ï¼Œéœ€è¦ä½¿ç”¨æ ¹å·åˆ†æ²»ï¼Œå½“d&lt;2nn!d &lt; \\sqrt {2 ^ n n !}d&lt;2nn!â€‹æ—¶ï¼Œç›´æ¥æš´åŠ›æšä¸¾ï¼Œdâ‰¤2nn!d \\le \\sqrt {2 ^n n!}dâ‰¤2nn!â€‹æ—¶ï¼Œæ ¹æ®è½¬ç§»ï¼Œå¯ä»¥è·‘åŒä½™æœ€çŸ­è·¯ï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 18;const int M = 60;const int INF = 1e18;const int K = 1.5e6 + 10;int n, m;int a[N], s[M][N];int fac[N], t[N];int S[M];int lim;int b[N];void init(){ fac[0] = t[0] = 1; for(int i = 1; i &lt;= n; i++) t[i] = t[i - 1] * 2; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i;}int f(int *a){ int sum = 0; for(int i = 1; i &lt;= n; i++) sum += a[i] * t[i - 1] * fac[i - 1]; return sum;}int calc(int A){ int sum = A, s = 0; for(int i = n; i &gt;= 1; i--) { s += sum / (t[i - 1] * fac[i - 1]); sum %= (t[i - 1] * fac[i - 1]); } return s;}int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int dis[K];int d;int spfa(int T){ memset(dis, 0x3f3f3f3f, sizeof(dis)); queue &lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { int x = t[i - 1] * fac[i - 1] % d; dis[x] = 1; q.push(x); } while(!q.empty()) { int x = q.front();q.pop(); for(int i = 1; i &lt;= n; i++) { int v = (x + t[i - 1] * fac[i - 1]) % d; if(dis[x] + 1 &lt; dis[v]) { dis[v] = dis[x] + 1; q.push(v); } } } return dis[T];}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;s[i][j]); init(); for(int i = 1; i &lt;= m; i++) S[i] = f(s[i]); lim = t[n] * fac[n] - 1; d = lim; for(int i = 1; i &lt;= m; i++) d = gcd(S[i], d); int ans = INF; if(d &gt;= lim / d) { for(int i = f(a) % d; i &lt;= lim; i += d) if(i) ans = min(ans, calc(i)); } else { ans = INF; int A = f(a); ans = min(ans, spfa(A % d)); } printf(&quot;%lld&quot;, ans); return 0;} ARC116 A.Odd vs Even Difficulty : 155\\color{gray} 155155 åˆ†æƒ…å†µè®¨è®ºä¸€ä¸‹ï¼Œä¸éš¾å¾—å‡ºå½“nnnä¸ºå¥‡æ•°æ—¶ï¼Œodd&gt;evenodd &gt; evenodd&gt;evenï¼Œ å½“nnnä¸æ˜¯444çš„å€æ•°æ—¶æ­¤æ—¶odd=evenodd = evenodd=evenï¼Œ å¦åˆ™odd&lt;evenodd &lt; evenodd&lt;evenï¼Œå…¶å®è´¨å› æ•°åˆ†è§£ä¸€ä¸‹å°±å¯ä»¥çœ‹å‡ºæ¥ã€‚ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main(){ int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { ll n; scanf(&quot;%lld&quot;, &amp;n); if(n &amp; 1) cout &lt;&lt; &quot;Odd&quot; &lt;&lt; endl; else if(n % 4 != 0) cout &lt;&lt; &quot;Same&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Even&quot; &lt;&lt; endl; } return 0;} B.Products of Min-Max Difficulty : 816\\color{green} 816816 å¯ä»¥è€ƒè™‘æ’åºåå›ºå®šæœ€å¤§å€¼ï¼Œç„¶åç»Ÿè®¡è´¡çŒ®å³å¯ã€‚ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 + 10;const int mod = 998244353;const int INF = 1e9;int n, a[N];int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); sort(a + 1, a + n + 1); ll ans = 0, sum = 0; for(int i = 1; i &lt;= n; i++) { ans = (ans + a[i] * (sum + a[i]) % mod) % mod; sum = sum * 2ll % mod; sum = (sum + a[i]) % mod; } printf(&quot;%lld&quot;, ans); return 0;} C.Multiple Sequences Difficulty : 1468\\color{cyan} 14681468 é¦–å…ˆæ³¨æ„åˆ°mâ‰¤2Ã—105m \\le 2 \\times 10 ^ 5mâ‰¤2Ã—105ï¼Œåˆ†è§£åè´¨å› å­æ•°æœ€å¤šä¸º666ä¸ªï¼Œç„¶åè€ƒè™‘æšä¸¾æœ€åä¸€ä¸ªæ•°ä¸ºå¤šå°‘ï¼Œå°†å…¶è´¨å› æ•°åˆ†è§£ï¼Œç„¶åå…ˆè®¡ç®—æ¯ä¸ªè´¨å› æ•°æŒ‡æ•°åˆ†é…çš„æƒ…å†µç„¶åç›¸ä¹˜ï¼Œè¿™æ—¶å€™ç­‰ä»·äºåœ¨nnnä¸ªç›¸åŒçš„ç›’å­ä¸­æ”¾mmmä¸ªä¸åŒçš„å°çƒï¼Œæ–¹æ¡ˆæ•°ä¸º(n+mâˆ’1n)\\dbinom{n +m - 1}{n}(nn+mâˆ’1â€‹)ï¼Œç„¶åå°†æ¯ä¸ªè´¨å› æ•°çš„ç­”æ¡ˆä¹˜èµ·æ¥å°±å¥½äº†ã€‚æ—¶é—´å¤æ‚åº¦O(nn)O(n \\sqrt n)O(nnâ€‹)ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 + 10;const int mod = 998244353;int n, m;ll ans;ll qpow(ll a, ll b){ ll t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}ll inv(ll x){ return qpow(x, mod - 2);}ll fac[N + 100], ifac[N + 100];ll C(int n, int m){ if(n &lt; m)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); fac[0] = ifac[0] = 1; for(ll i = 1; i &lt;= N + 99; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1;i &lt;= N + 99; i++) ifac[i] = inv(fac[i]); for(int i = 1; i &lt;= m; i++) { int x = i; ll mul = 1; for(int j = 2; j * j &lt;= x; j++) { if(x % j != 0)continue; int sum = 0; while(x % j == 0) sum++, x /= j; mul = mul * C(n + sum - 1, sum) % mod; } if(x != 1)mul = mul * 1ll * n % mod; ans = (ans + mul) % mod; } printf(&quot;%lld&quot;, ans); return 0;} D.I Wanna Win The Game Difficulty : 1718\\color{blue} 17181718 è€ƒè™‘è®¾fi,jf_{i,j}fi,jâ€‹è¡¨ç¤ºæšä¸¾åˆ°ç¬¬iiiä¸ªäºŒè¿›åˆ¶ä½ï¼Œæ­¤æ—¶æƒå€¼å’Œä¸ºjjjçš„æ–¹æ¡ˆæ•°ï¼Œç„¶åç›´æ¥è½¬ç§»å³å¯ï¼Œéœ€è¦ä¿è¯æ¯ä¸ªäºŒè¿›åˆ¶ä½çš„111çš„ä¸ªæ•°ä¸ºå¶æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 5100;const int mod = 998244353;int n, m;ll fac[N], ifac[N];ll qpow(ll a, ll b){ ll t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}ll inv(ll x){ return qpow(x, mod - 2);}ll f[15][N];ll C(int n, int m){ return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * 1ll * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); f[0][0] = 1; for(int i = 1; i &lt;= 14; i++) { for(int j = 0; j &lt;= m; j++) { for(int k = 0; k &lt;= n; k += 2) { int x = j - (1 &lt;&lt; (i - 1)) * k; if(x &lt; 0)break; f[i][j] = (f[i][j] + f[i - 1][x] * C(n, k) % mod) % mod; } } } printf(&quot;%lld&quot;, f[14][m]); return 0;} E.Spread of Information Difficulty : 2236\\color{yellow} 22362236 ç›´æ¥äºŒåˆ†åˆ¤å®šæ—¶é—´ï¼Œ ç„¶åè´ªå¿ƒï¼Œé€‰å–ç‚¹ï¼Œè®¾fif_ifiâ€‹è¡¨ç¤ºèŠ‚ç‚¹iiiåˆ°å…¶å­æ ‘å†…æœ€è¿‘çš„åˆå§‹è¢«è¦†ç›–çš„ç‚¹çš„è·ç¦»ï¼Œgig_igiâ€‹è¡¨ç¤ºå…¶åˆ°å­æ ‘è¢«æœ€è¿œçš„æ²¡è¢«è¦†ç›–ä½çš„ç‚¹çš„è·ç¦»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;const int INF = 1e9;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int n, m;int tot;int f[N], g[N];void dfs(int x, int fa, int lim){ f[x] = INF; g[x] = 0; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x, lim); f[x] = min(f[x], f[v] + 1); g[x] = max(g[x], g[v] + 1); } if(f[x] + g[x] &lt;= lim) g[x] = -INF; else if(g[x] == lim) { f[x] = 0; g[x] = -INF; tot++; }}bool check(int x){ tot = 0; dfs(1, 0, x); if(g[1] &gt;= 0)tot++; return tot &lt;= m;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } int l = 0, r = n; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid - 1; else l = mid + 1; } printf(&quot;%d&quot;, l); return 0;} F.Deque Game Difficulty : 3125\\color{red} 31253125 é¦–å…ˆè€ƒè™‘åªæœ‰ä¸€ä¸ªåºåˆ—çš„æƒ…å†µæ­¤æ—¶è®¾é•¿åº¦ä¸ºnnnï¼Œå‡å¦‚nnnä¸ºå¶æ•°ï¼Œæ­¤æ—¶å¾ˆæ˜æ˜¾ç­”æ¡ˆå°±æ˜¯maxâ¡(a[n/2],a[n/2+1])\\max(a[n / 2], a[n / 2 + 1])max(a[n/2],a[n/2+1])ï¼Œæˆ–minâ¡(a[n/2],a[n/2+1])\\min(a[n/ 2], a[n / 2 + 1])min(a[n/2],a[n/2+1])è‹¥nnnä¸ºå¥‡æ•°æ­¤æ—¶ç­”æ¡ˆä¸ºmaxâ¡(minâ¡(a[n/2],a[n/2+1]),minâ¡(a[n/2+1],a[n/2+2]))\\max(\\min(a[n / 2], a[n / 2 + 1]), \\min(a[n / 2 + 1], a[n / 2 + 2]))max(min(a[n/2],a[n/2+1]),min(a[n/2+1],a[n/2+2]))æˆ–minâ¡(maxâ¡(a[n/2],a[n/2+1]),maxâ¡(a[n/2+1],a[n/2+2]))\\min(\\max(a[n / 2], a[n / 2 + 1]), \\max(a[n / 2 + 1], a[n / 2 + 2]))min(max(a[n/2],a[n/2+1]),max(a[n/2+1],a[n/2+2]))ï¼Œä¾æ®å…ˆåæ‰‹æ¥å†³å®šã€‚ç„¶åå°†å…¶æ‹“å±•åˆ°å¤šä¸ªåºåˆ—ï¼Œé¦–å…ˆè€ƒè™‘æ‰€æœ‰çš„åºåˆ—é•¿åº¦å‡ä¸ºå¥‡æ•°ï¼Œ æ­¤æ—¶å…ˆåæ‰‹ä¸ä¼šè¢«æ”¹å˜ï¼Œç›´æ¥æŒ‰ç…§å…ˆæ‰‹çš„å–å€¼æ±‚å’Œå³å¯ï¼Œä½†æ˜¯å¦‚è‹¥å‡ºç°é•¿åº¦ä¸ºå¶æ•°çš„åºåˆ—ï¼Œ æ­¤æ—¶å°±ä¼šå‡ºç°ï¼Œå…ˆåæ‰‹äº¤æ¢çš„æƒ…å†µï¼Œæ­¤æ—¶éœ€è¦ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å»ç»´æŠ¤ä¸€ä¸‹ï¼Œå¯¹äºæ¯ä¸ªé•¿åº¦ä¸ºå¶æ•°çš„åºåˆ—å…¶å¸¦æ¥çš„å½±å“ï¼Œæœ€åæ±‚å’Œå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 +10;int n;vector &lt;int&gt; a[N];int m[N];int v[N];ll ans;int res;int calc(int x, int n){ if(n == 2) return x == 0 ? v[2] : v[1]; if(!res) return max(min(v[n / 2 + x], v[n / 2 + 1 + x]), min(v[n / 2 + 1 + x], v[n / 2 + 2 + x])); else return min(max(v[n / 2 + x], v[n / 2 + 1 + x]), max(v[n / 2 + 1 + x], v[n / 2 + 2 + x]));}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;m[i]); for(int j = 1; j &lt;= m[i]; j++) { int x; scanf(&quot;%d&quot;, &amp;x); a[i].push_back(x); } if(!(m[i] &amp; 1))res ^= 1; } priority_queue &lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m[i]; j++) v[j] = a[i][j - 1]; if(m[i] &amp; 1) { if(m[i] == 1) ans += v[1]; else ans += calc(0, m[i]); } else { q.push(max(calc(-1, m[i]), calc(0, m[i])) - min(calc(-1, m[i]), calc(0, m[i]))); ans += min(calc(-1, m[i]), calc(0, m[i])); } } while(!q.empty()) { ans += q.top(); q.pop(); if(!q.empty())q.pop(); } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2022/10/13/ARC%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"About This Blog","text":"QWQ About ä¸€ä¸ªå°çªã€‚ æ–‡ç« å¦‚æœ‰ LaTeX\\LaTeXLATEâ€‹X çš„æ˜¾ç¤ºé—®é¢˜ï¼Œè¯·æŒç»­åˆ·æ–°ï¼Œæˆ–æ›´æ¢æµè§ˆå™¨ã€‚ å…³é—­æµè§ˆå™¨çš„ç½‘ç«™ä¿æŠ¤ä¹Ÿå¯ä»¥è§£å†³é—®é¢˜ã€‚ HaveHaveHave Fun!Fun!Fun! ã€‚","link":"/2022/06/22/About-This-Blog/"},{"title":"BSGS","text":"Baby - Step - Giant - Step BSGS å‰ç½®çŸ¥è¯† åŒä½™ BSGS BSGSï¼ˆbaby-step giant-stepï¼‰ (åŒ—ä¸Šå¹¿æ·±ï¼Œæ‹”å±±ç›–ä¸–)æ˜¯ç”¨æ¥è§£å†³å½¢å¦‚ axâ‰¡b( mod m)a^x \\equiv b \\quad (\\bmod m) axâ‰¡b(modm) çš„é«˜æ¬¡åŒä½™æ–¹ç¨‹ï¼Œå…¶ä¸­ aâŠ¥ma \\perp maâŠ¥m é¦–å…ˆ0â‰¤x&lt;m0 \\le x &lt; m0â‰¤x&lt;mï¼ˆå°±mmmä¸ªä¸åŒçš„å¾—æ•°ï¼‰ï¼Œè®¾x=Amâˆ’Bx=A \\sqrt{m}-Bx=Amâ€‹âˆ’Bï¼Œå…¶ä¸­0â‰¤A,Bâ‰¤m0 \\le A,B\\le \\sqrt{m}0â‰¤A,Bâ‰¤mâ€‹ï¼Œæ–¹ç¨‹å˜ä¸ºï¼š aAmâˆ’Bâ‰¡b( mod m)a^{A \\sqrt{m}-B} \\equiv b \\quad (\\bmod m) aAmâ€‹âˆ’Bâ‰¡b(modm) ç”±äº aâŠ¥ma \\perp maâŠ¥mç§»é¡¹å¯å¾—ï¼š aAmâ‰¡baB( mod m)a^{A \\sqrt{m}} \\equiv ba^{B} \\quad (\\bmod m) aAmâ€‹â‰¡baB(modm) ç”±äºa,b,ma,b,ma,b,må‡å·²çŸ¥å¯ä»¥è€ƒè™‘æšä¸¾BBBç”¨mapmapmapå­˜å‚¨å¯¹åº”çš„å€¼ï¼Œç„¶åå†æšä¸¾AAAï¼Œæ£€æŸ¥mapmapmapä¸­æ˜¯å¦æœ‰å€¼å¯¹åº” å› ä¸ºA,BA,BA,Bå‡ä¸å¤§äºm\\sqrt{m}mâ€‹ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸ºO(n)O(\\sqrt{n})O(nâ€‹)ã€‚ï¼ˆæ²¡ç®—mapmapmapï¼‰ é¢˜ç›® 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll p,b,n;map&lt;ll,ll&gt; vis;ll BSGS(){ if(1%p==n%p)return 0; int k=sqrt(p)+1;ll j=n%p; for(int i=0;i&lt;k;i++) { vis[j]=i; j=j*b%p; } ll x=1; for(int i=1;i&lt;=k;i++)x=x*b%p; j=x; for(int i=1;i&lt;=k;i++) { if(vis.count(j))return i*k-vis[j]; j=x*j%p; } return -1;}int main(){ scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;b,&amp;n); ll ans=BSGS(); ans==-1?printf(&quot;no solution&quot;):printf(&quot;%lld&quot;,ans); return 0;} exBSGS é—®é¢˜ä»ç„¶æ˜¯å»è§£å†³ä¸€ä¸ªå½¢å¦‚ axâ‰¡b( mod m)a^x \\equiv b \\quad (\\bmod m) axâ‰¡b(modm) çš„é«˜æ¬¡åŒä½™æ–¹ç¨‹ï¼Œä½†ä¸ä¿è¯aâŠ¥ma \\perp maâŠ¥m è€ƒè™‘ç”¨æ‰©å±•BSGSï¼ˆexBSGSï¼‰(æ— é™å®çŸ³å…¬å¼)æ¥è§£å†³è¿™ä¸ªé—®é¢˜ æ­¤æ—¶aaaå’Œmmmä¸ä¸€å®šäº’è´¨ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¼å­è¿›ä¸€æ­¥åŒ–ç®€ä¸ºï¼š axgcdâ¡(a,m)â‰¡bgcdâ¡(a,m)( mod mgcdâ¡(a,m))\\frac{a^x}{\\gcd(a,m)} \\equiv \\frac{b} {\\gcd(a,m)} \\quad (\\bmod \\frac{m}{\\gcd(a,m)}) gcd(a,m)axâ€‹â‰¡gcd(a,m)bâ€‹(modgcd(a,m)mâ€‹) å°†å·¦è¾¹æå‡ºä¸€é¡¹ axâˆ’1agcdâ¡(a,m)â‰¡bgcdâ¡(a,m)( mod mgcdâ¡(a,m))a^{x-1} \\frac{a}{\\gcd(a,m)} \\equiv \\frac{b} {\\gcd(a,m)} \\quad (\\bmod \\frac{m}{\\gcd(a,m)}) axâˆ’1gcd(a,m)aâ€‹â‰¡gcd(a,m)bâ€‹(modgcd(a,m)mâ€‹) æ¥ä¸‹æ¥ä¸æ–­é™¤ä»¥gcdâ¡(a,m)\\gcd(a,m)gcd(a,m)ç›´åˆ°aaaä¸mmmäº’è´¨ï¼Œç„¶åç”¨BSGSæ±‚è§£ ç”±äºæœ€åæˆ‘ä»¬å°†å¼å­é€’å½’æ‰§è¡Œäº†kkkå±‚ï¼Œæ­¤æ—¶å¼å­å˜ä¸º axâˆ’kakgcdâ¡k(a,m)â‰¡bgcdâ¡k(a,m)( mod mgcdâ¡k(a,m))a^{x-k} \\frac{a^k}{\\gcd^k(a,m)} \\equiv \\frac{b} {\\gcd^k(a,m)} \\quad (\\bmod \\frac{m}{\\gcd^k(a,m)}) axâˆ’kgcdk(a,m)akâ€‹â‰¡gcdk(a,m)bâ€‹(modgcdk(a,m)mâ€‹) æœ€ååˆ©ç”¨BSGSæ±‚è§£å‡ºxxxååº”å½“å†åŠ ä¸Škkkï¼Œx+kx+kx+kå³ä¸ºè¯¥æ–¹ç¨‹çš„è§£ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=5e6+10;map&lt;ll,ll&gt; vis;ll gcd(ll a,ll b){ if(b==0)return a; return gcd(b,a%b);}ll qpow(ll a,ll b,ll p){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%p; a=a*a%p;b&gt;&gt;=1; } return t;}ll bsgs(ll a,ll b,ll p,ll k){ vis.clear(); int m=sqrt(p)+1; ll r=b%p; for(int i=0;i&lt;=m;i++) { vis[r]=i; r=r%p*a%p; } ll l=k%p,x=qpow(a,m,p); for(int i=0;i&lt;=m;i++) { if(vis.count(l)&amp;&amp;i*m-vis[l]&gt;=0) return i*m-vis[l]; l=l*x%p; } return -1e9;}ll exbsgs(ll a,ll b,ll p,ll m){ a%=p,b%=p; if(b==1||p==1&amp;&amp;m==1)return 0; ll d=gcd(a,p); if(b%d!=0)return -1; if(d==1)return bsgs(a,b,p,m); else return exbsgs(a,b/d,p/d,(m*a/d)%p)+1;}int main(){ ll a,b,p; while(scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;p,&amp;b)&amp;&amp;a&amp;&amp;b&amp;&amp;p) { ll res=exbsgs(a,b,p,1); if(res&lt;0) printf(&quot;No Solution\\n&quot;); else printf(&quot;%lld\\n&quot;,res); } return 0;} ï¼ˆå¥½åƒç”¨é€’å½’å†™çš„å¾ˆå°‘ï¼Œå¤§æ•°æ®è‚¯å®šæ˜¯å¯ä»¥è¿‡çš„ï¼Œä½†å¥½åƒè¿‡ä¸äº†æ´›è°·ä¸Šçš„hackå°æ•°æ®ï¼Œä¸è¿‡å°æ•°æ®æ—¶æˆ‘è§‰å¾—ç›´æ¥å¯ä»¥æš´åŠ›æšä¸¾ï¼‰","link":"/2022/07/24/BSGS/"},{"title":"Balls and Boxes","text":"ç»å…¸ç»„åˆæ•°å­¦ å°çƒä¸ç›’å­ å‰ç½®çŸ¥è¯† ç»„åˆæ•° ï¼š Cnm=n!m!(nâˆ’m)!C_n^m = \\frac{n!}{m!(n-m)!} Cnmâ€‹=m!(nâˆ’m)!n!â€‹ æ’æ¿æ³• ï¼šç”¨äºè§£å†³ä¸ç›¸é‚»ç»„åˆä¸è¿½åŠ æ’åˆ—çš„é—®é¢˜ï¼Œå°±æ˜¯åœ¨nnnä¸ªç‰©å“ä¹‹é—´æ’ä¸Šmmmä¸ªæ¿ï¼Œå°†å…¶åˆ†ä¸ºm+1m+1m+1ç»„ã€‚ æ†ç»‘æ³•ï¼šå°†ä¸€äº›ç‰©å“ä½œä¸ºæ•´ä½“è®¡ç®—ã€‚ å®¹æ–¥åŸç†ï¼šå°†é‡å¤è®¡ç®—çš„æ•°ç›®å»é™¤ï¼Œæ¯”å¦‚ï¼š AâˆªB=A+Bâˆ’Aâˆ©B A\\cup B = A+B- A\\cap B AâˆªB=A+Bâˆ’Aâˆ©B 1. çƒç›¸åŒï¼Œç›’å­ä¸åŒï¼Œä¸èƒ½æœ‰ç©ºç›’ å…¶å®è¿™ä¸ªé—®é¢˜çš„å®è´¨å°±æ˜¯æŠŠnnnä¸ªå°çƒåˆ†ä¸ºmmmç»„ï¼ˆä¸èƒ½ç©ºï¼‰ï¼Œå°±è½¬åŒ–ä¸ºäº†ä¸€ä¸ªç»„åˆæ•°é—®é¢˜ï¼Œç­”æ¡ˆå…¶å®å°±æ˜¯ Cnâˆ’1mâˆ’1C_{n-1}^{m-1} Cnâˆ’1mâˆ’1â€‹ å…¶å®å°±æ˜¯æ’æ¿æ³•ï¼Œåœ¨å°çƒçš„nâˆ’1n-1nâˆ’1ä¸ªç©ºéš™ä¸­æ’å…¥mâˆ’1m-1mâˆ’1ä¸ªæ¿å­ï¼Œä½¿å…¶åˆ†ä¸ºmmmç»„ã€‚ 2. çƒç›¸åŒï¼Œç›’å­ä¸åŒï¼Œå¯ä»¥æœ‰ç©ºç›’ å…¶å®å’Œä¸Šä¸ªé—®é¢˜å·®ä¸å¤šï¼Œæˆ‘ä»¬ä¸€å¼€å§‹å¯ä»¥å°±å‘æ¯ä¸ªç›’å­ä¸­æ·»åŠ ä¸€ä¸ªå°çƒï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰ç©ºç›’ï¼Œç­”æ¡ˆä¸º Cn+mâˆ’1mâˆ’1C_{n+m-1}^{m-1} Cn+mâˆ’1mâˆ’1â€‹ 3. çƒä¸åŒï¼Œç›’å­ä¸åŒï¼Œå¯ä»¥æœ‰ç©ºç›’ å¯¹äºæ¯ä¸€ä¸ªçƒï¼Œéƒ½å¯ä»¥æ”¾åœ¨mmmä¸ªä½ç½®ä¸­çš„ä»»æ„ä¸€ä¸ªä½ç½®ï¼Œç”±äºçƒä¸çƒä¹‹é—´æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œç­”æ¡ˆå°±æ˜¯ mnm^n mn 4.çƒä¸åŒï¼Œç›’å­ç›¸åŒï¼Œä¸èƒ½æœ‰ç©ºç›’ è¿™ä¸ªå…¶å®å°±æ˜¯ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼Œå°†nnnä¸ªç‰©ä½“åˆ’åˆ†ä¸ºkkkä¸ªéç©ºçš„æ²¡æœ‰åŒºåˆ«çš„é›†åˆçš„æ–¹æ¡ˆæ•°ï¼Œå…¶é€’æ¨å…¬å¼ä¸ºï¼š fi,j=fiâˆ’1,jÃ—j+fiâˆ’1,jâˆ’1f_{i,j} = f_{i-1,j}\\times j + f_{i-1,j-1} fi,jâ€‹=fiâˆ’1,jâ€‹Ã—j+fiâˆ’1,jâˆ’1â€‹ å…¶å®é€šä¿—çš„ç†è§£å°±æ˜¯å¯¹äºç¬¬iiiä¸ªçƒï¼Œå¯ä»¥æ”¾åœ¨ä»¥å‰çš„jjjä¸ªç›’å­ä¸­æœ‰jÃ—fiâˆ’1,jj \\times f_{i-1,j}jÃ—fiâˆ’1,jâ€‹ç§æ–¹æ¡ˆ,æˆ–è€…æ”¾å…¥ä¸€ä¸ªæ–°çš„ç›’å­æœ‰fiâˆ’1,jâˆ’1f_{i-1,j-1}fiâˆ’1,jâˆ’1â€‹ç§æ–¹æ¡ˆã€‚ ä¸è¿‡è¿™æ˜¯ä¸€ä¸ªn2n^2n2çš„å…¬å¼ï¼Œä½†æ˜¯å…¶å®ƒè¿˜æœ‰ä¸€ä¸ªæ›´é€šç”¨çš„å…¬å¼ï¼š f(n,m)=1m!Ã—âˆ‘k=0m(âˆ’1)k(mk)Ã—(mâˆ’k)nf(n,m) = \\frac{1}{m!} \\times \\sum_{k = 0}^m (-1)^k \\dbinom{m}{k} \\times (m-k)^n f(n,m)=m!1â€‹Ã—k=0âˆ‘mâ€‹(âˆ’1)k(kmâ€‹)Ã—(mâˆ’k)n 5. çƒä¸åŒï¼Œç›’å­ä¹Ÿä¸åŒï¼Œä¸èƒ½æœ‰ç©ºç›’ å…¶å®è¿™ä¸ªå’Œä¸Šä¸€ç§æƒ…å†µä¸åŒçš„å°±æ˜¯ï¼Œè¿™ä¸ªæƒ…å†µéœ€è¦æœ‰åºæ€§ï¼Œç­”æ¡ˆå…¶å®å°±æ˜¯å¯¹åº”çš„æ–¯ç‰¹æ—æ•°ï¼Œ f(n,m)Ã—m!f(n,m) \\times m! f(n,m)Ã—m! å°±å¯ä»¥äº†ã€‚ 6. çƒä¸åŒï¼Œ ç›’å­ç›¸åŒï¼Œå¯ä»¥æœ‰ç©ºç›’ å› ä¸ºå¯ä»¥æœ‰ç©ºç›’ï¼Œå…¶å®å°±å¯ä»¥æšä¸¾æ¯æ¬¡ç”¨äº†å‡ ä¸ªç›’å­ï¼Œç„¶åå°†å¯¹åº”çš„æ–¯ç‰¹æ—æ•°ç›¸åŠ å³å¯,ç­”æ¡ˆå°±æ˜¯ âˆ‘i=1mf(n,i)\\sum_{i =1}^m f(n,i) i=1âˆ‘mâ€‹f(n,i) å…¶å®è¿™ç§æ•°è¿˜æœ‰å¦ä¸€ç§åç§°å«è´å°”æ•°ï¼Œå®ƒè¡¨ç¤ºé›†åˆ1,2,3,â‹¯ ,n{1,2,3,\\cdots,n}1,2,3,â‹¯,nçš„åˆ’åˆ†æ–¹æ¡ˆæ•°ï¼Œå…¶å®å°±è¡¨ç¤ºäº†ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ä¹‹å’Œã€‚ 7.çƒç›¸åŒï¼Œç›’å­ç›¸åŒï¼Œå¯ä»¥æœ‰ç©ºç›’ é¦–å…ˆåˆ†æƒ…å†µï¼Œå¦‚æœä¸€ä¸ªç›’å­æ²¡æœ‰å°çƒï¼Œæ–¹æ¡ˆæ•°æ˜¾ç„¶ä¸º1ï¼ŒåŒæ—¶å¦‚æœå°çƒæ¯”ç›’å­è¦å°‘ï¼Œç›’å­è‚¯å®šæ—¶æ˜¯æ”¾ä¸æ»¡çš„ï¼Œæ‰€ä»¥fi,j=fi,if_{i,j} = f_{i,i}fi,jâ€‹=fi,iâ€‹ï¼Œå¦‚æœå°çƒæ¯”ç›’å­è¦å¤šï¼Œå°±å°†ç›’å­åˆ†ä¸ºæ”¾æ»¡å’Œæ²¡æ”¾æ»¡ä¸¤ç§æƒ…å†µï¼Œæ‰€ä»¥fi,j=fiâˆ’j,j+fi,jâˆ’1f_{i,j} = f_{i-j,j} + f_{i,j-1}fi,jâ€‹=fiâˆ’j,jâ€‹+fi,jâˆ’1â€‹ã€‚ 8. çƒç›¸åŒï¼Œç›’å­ç›¸åŒï¼Œä¸èƒ½æœ‰ç©ºç›’ åªéœ€è¦å‡è®¾æ¯ä¸ªç›’å­é‡Œéƒ½å·²ç»æ”¾ä¸Šäº†ä¸€ä¸ªçƒï¼Œç­”æ¡ˆå°±æ˜¯ï¼Œ f(nâˆ’m,m)f(n-m,m) f(nâˆ’m,m)","link":"/2022/08/26/Balls-and-Boxes/"},{"title":"CF1146H Satanic Panic","text":"CF1146H Satanic Panic é¢˜è§£ é¢˜æ„ ç»™å®šå¹³é¢å†…çš„nnnä¸ªç‚¹(nâ‰¤300n \\le 300nâ‰¤300)ï¼Œæ±‚æœ‰å¤šå°‘ç§æ–¹æ¡ˆå¯ä»¥æ„æˆä¸€ä¸ªäº”è§’æ˜Ÿã€‚ è§£æ³• é¦–å…ˆå…¶å®æ‰¾äº”è§’æ˜Ÿå°±æ˜¯åœ¨æ‰¾ä¸€ä¸ªç”±äº”ä¸ªé¡¶ç‚¹æ„æˆçš„å‡¸åŒ…ï¼Œè®¾f[i][j][k]f[i][j][k]f[i][j][k]è¡¨ç¤ºä¸ºä»iiiåˆ°jjjç»è¿‡äº†kkkä¸ªç‚¹çš„ä¸åŒæ–¹æ¡ˆæ•°ã€‚ å…¶å®äº”ä¸ªç‚¹çš„å‡¸åŒ…å°±æ˜¯äº”æ¡æ–œç‡å…·æœ‰å•è°ƒæ€§çš„çº¿æ®µç»„åˆè€Œæˆçš„å›¾å½¢ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå°†æ‰€æœ‰çš„çº¿æ®µæŒ‰ç…§æè§’åºè¿›è¡Œæ’åºï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š f[i][x][j+1]=âˆ‘f[i][y][j]f[i][x][j+1] = \\sum f[i][y][j] f[i][x][j+1]=âˆ‘f[i][y][j] å…¶ä¸­xxxå’Œyyyè¡¨ç¤ºä¸€æ¡çº¿æ®µçš„å·¦å³ç«¯ç‚¹ï¼Œå› ä¸ºæ’åºåæè§’åºæ˜¯å…·æœ‰å•è°ƒæ€§çš„ï¼Œæ‰€ä»¥ä¸Šè¿°æ–¹ç¨‹çš„è½¬ç§»æ˜¯æˆç«‹çš„ã€‚ åˆå§‹åŒ–æ‰€æœ‰çš„f[i][i][1]=1f[i][i][1] = 1f[i][i][1]=1ï¼Œæœ€åç»Ÿè®¡ä¸€ä¸‹ç­”æ¡ˆâˆ‘f[i][i][6]\\sum f[i][i][6]âˆ‘f[i][i][6]å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(n3)O(n^3)O(n3)ã€‚ä¸è¿‡CFè¯„æµ‹æœºæ˜¾ç„¶èƒ½åœ¨4så†…è·‘è¿‡1e8ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 310;struct Point{ double x, y; Point(double _x = 0, double _y = 0):x(_x), y(_y) {} friend Point operator + (Point a, Point b){return Point(a.x+b.x, a.y+b.y);} friend Point operator - (Point a, Point b){return Point(a.x-b.x, a.y-b.y);} friend Point operator * (Point a, double b){return Point(a.x*b, a.y*b);} friend Point operator / (Point a, double b){return Point(a.x/b, a.y/b);}}origin;Point p[N];struct Segment{ int a, b; Point v;double An; Segment(int _a = 0, int _b = 0): a(_a), b(_b) {v = p[b]-p[a]; An = atan2(v.y, v.x);} friend bool operator &lt; (Segment x, Segment y){return x.An &lt; y.An;}}s[N * N];int n, cnt;ll f[N][N][7];int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { double x, y; scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); p[i] = Point(x, y); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(i == j)continue; s[++cnt] = Segment(i, j); } } sort(s+1, s+cnt+1); for(int i = 1; i &lt;= n; i++) f[i][i][1] = 1; for(int k = 1; k &lt;= cnt; k++) { int x = s[k].a; int y = s[k].b; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= 5; j++) f[i][y][j+1] += f[i][x][j]; } ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += f[i][i][6]; printf(&quot;%lld&quot;, ans); return 0;}","link":"/2022/08/24/CF1146H%20Satanic%20Panic/"},{"title":"CF1149C Tree Generatorâ„¢","text":"CF1149C Tree Generatorâ„¢ é¢˜è§£ é¢˜ç›®å¤§æ„ ç»™å®šä¸€ä¸ªæœ‰nnnä¸ªç‚¹çš„æ ‘ï¼Œè¿™é¢—æ ‘çš„æ‹¬å·åºåˆ—ï¼Œè¾“å‡ºå®ƒçš„ç›´å¾„ï¼Œmmmä¸ªè¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®è¡¨ç¤ºäº¤æ¢ä¸¤ä¸ªæ‹¬å·ï¼Œè¾“å‡ºäº¤æ¢ä¸¤ä¸ªæ‹¬å·åçš„ç›´å¾„ã€‚(ä¿è¯æ¯æ¬¡æ“ä½œåéƒ½ä¸ºä¸€æ£µæ ‘) 3â‰¤nâ‰¤1e5,1â‰¤qâ‰¤1e53 \\le n \\le 1e5 , 1 \\le q \\le 1e53â‰¤nâ‰¤1e5,1â‰¤qâ‰¤1e5ã€‚ è§£æ³• é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æ‹¬å·æ ‘æ˜¯æ€ä¹ˆæ„å»ºçš„ï¼Œå¯¹äºé¢˜ç›®ä¸­æ‰€æè¿°çš„æ‹¬å·æ ‘ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨é‡åˆ°(((æ—¶å‘ä¸‹èµ°ï¼Œé‡åˆ°)))å‘å›èµ°ï¼Œå°±èƒ½æ„é€ å‡ºä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„æ‹¬å·æ ‘ï¼Œ ç°åœ¨éœ€è¦çŸ¥é“ä¸‰ä¸ªå¼•ç†ã€‚ å¯¹äºæ‹¬å·åºåˆ—ä¸­çš„ä»»æ„ä¸€ä¸ªè¿ç»­å­åºåˆ—ï¼Œå°†å…¶ä¸­çš„åŒ¹é…ä¸Šçš„æ‹¬å·é™¤å»å‰©ä¸‹çš„å¯¹åº”æ ‘ä¸Šçš„ä¸€æ¡é“¾ã€‚ æ ‘ä¸Šç›´å¾„é•¿åº¦å³ä¸ºä»»æ„åŒºé—´å»æ‰åŒ¹é…æ‹¬å·åçš„é•¿åº¦çš„æœ€å¤§å€¼ã€‚ å¦‚æœå°†(((æƒå€¼è®¾ä¸º111, )))æƒå€¼è®¾ä¸ºâˆ’1-1âˆ’1, æœ€é•¿å»åŒ¹é…åŒºé—´ï¼Œä¹Ÿå°±æ˜¯ç›´å¾„ = ç›¸é‚»ä¸¤ä¸ªåŒºé—´æƒå€¼å’Œä¹‹å·®çš„æœ€å¤§å€¼ã€‚ é¦–å…ˆå¯¹äºå¼•ç†1ï¼Œå…¶å®å°±æ˜¯å¯¹äºåŒ¹é…ä¸Šçš„æ‹¬å·æˆ‘ä»¬èµ°ä¸‹å»åï¼Œåˆèµ°äº†å›æ¥ä¹Ÿå°±æ˜¯å…¶å¯¹é“¾é•¿åº¦çš„è´¡çŒ®ä¸º000ï¼Œå¼•ç†2å…¶å®å°±æ˜¯å¯¹åº”å¼•ç†1ä¸­æœ€é•¿çš„ä¸€æ®µé“¾å…¶å®ä¹Ÿå°±æ˜¯ç›´å¾„. å¼•ç†3å…¶å®å°±å¾ˆæ¸…æ¥šçš„å¾—å‡ºäº†ç­”æ¡ˆï¼Œ é¦–å…ˆæ ¹æ®å¼•ç†1åŒºé—´å†…å·²ç»åŒ¹é…ä¸Šçš„æ‹¬å·æ˜¯ä¸ä¼šå¯¹é•¿åº¦äº§ç”Ÿè´¡çŒ®çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹åº”çš„è´¡çŒ®åŒºé—´ä¸ºï¼š (((((((((((((((((((((((( ))))))))))))))))))))) ))))(((())))(((())))(((( è¿™ä¸‰ç§ï¼Œå¯¹äºç¬¬ä¸€ç§æˆ‘ä»¬å¯ä»¥åœ¨åŒºé—´çš„æœ€å‰é¢ä½œä¸ºæ–­ç‚¹ï¼Œç¬¬äºŒç§åœ¨æœ€åé¢ï¼Œç¬¬ä¸‰ç§åœ¨ä¸­é—´æ¥å¾—åˆ°ç›¸é‚»ä¸¤ä¸ªåŒºé—´æƒå€¼å’Œä¹‹å·®çš„æœ€å¤§å€¼ã€‚ æ¥ä¸‹æ¥å°±æ˜¯è€ƒè™‘æ€ä¹ˆç»´æŠ¤äº†ï¼Œå…¶å®ç±»æ¯”æœ€å¤§å­æ®µå’Œï¼Œè¿™ä¸ªä¹Ÿå¯ä»¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼Œ(å°±æ˜¯ç¨å¾®éº»çƒ¦äº†ä¸€ç‚¹)ã€‚ å¯¹äºåŒºé—´[l,r][l,r][l,r]éœ€è¦ç»´æŠ¤å…«ä¸ªå˜é‡ï¼š sumsumsumä¸ºåŒºé—´å’Œ lmxlmxlmxä¸ºä»å·¦ç«¯ç‚¹å¼€å§‹çš„è¿ç»­æœ€å¤§å€¼ rmxrmxrmxä¸ºä»å³ç«¯ç‚¹å¼€å§‹çš„è¿ç»­æœ€å¤§å€¼ lmnlmnlmnä¸ºä»å·¦ç«¯ç‚¹å¼€å§‹çš„è¿ç»­æœ€å°å€¼ rmnrmnrmnä¸ºä»å³ç«¯ç‚¹å¼€å§‹çš„è¿ç»­æœ€å°å€¼ val1val1val1ä¸º maxâ¡sum(x,y)âˆ’sum(l,x),lâ‰¤xâ‰¤yâ‰¤r\\max sum(x,y) - sum(l,x) , l \\le x \\le y \\le rmaxsum(x,y)âˆ’sum(l,x),lâ‰¤xâ‰¤yâ‰¤r val2val2val2ä¸º maxâ¡sum(y,r)âˆ’sum(x,y),lâ‰¤xâ‰¤yâ‰¤r\\max sum(y, r) - sum(x, y), l \\le x \\le y \\le rmaxsum(y,r)âˆ’sum(x,y),lâ‰¤xâ‰¤yâ‰¤r valvalvalä¸º maxâ¡sum(y,z)âˆ’sum(x,y),lâ‰¤xâ‰¤yâ‰¤zâ‰¤r\\max sum(y, z) - sum(x, y), l \\le x \\le y \\le z \\le rmaxsum(y,z)âˆ’sum(x,y),lâ‰¤xâ‰¤yâ‰¤zâ‰¤rï¼Œ ä¹Ÿå°±æ˜¯æœ€ç»ˆç­”æ¡ˆ å•ç‚¹ä¿®æ”¹+æŸ¥è¯¢å°±å¯ä»¥äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int n, q;int a[N];struct Segmentree{ int sum; int lmx, rmx; int lmn, rmn; int val1, val2, val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1)}t[N &lt;&lt; 2];void push_up(int p){ t[p].sum = t[ls(p)].sum + t[rs(p)].sum; t[p].lmx = max(t[ls(p)].lmx, t[ls(p)].sum + t[rs(p)].lmx); t[p].rmx = max(t[rs(p)].rmx, t[rs(p)].sum + t[ls(p)].rmx); t[p].lmn = min(t[ls(p)].lmn, t[ls(p)].sum + t[rs(p)].lmn); t[p].rmn = min(t[rs(p)].rmn, t[rs(p)].sum + t[ls(p)].rmn); t[p].val1 = max({t[ls(p)].val1, t[rs(p)].val1 - t[ls(p)].sum, t[rs(p)].lmx + t[ls(p)].rmx * 2 - t[ls(p)].sum}); t[p].val2 = max({t[rs(p)].val2, t[ls(p)].val2 + t[rs(p)].sum, t[rs(p)].sum - t[rs(p)].lmn * 2 - t[ls(p)].rmn}); t[p].val = max({t[ls(p)].val, t[rs(p)].val, t[ls(p)].val2 + t[rs(p)].lmx, t[rs(p)].val1 - t[ls(p)].rmn});}void build(int l, int r, int p){ if(l == r) { t[p].sum = a[l]; t[p].lmx = t[p].rmx = max(a[l], 0); t[p].lmn = t[p].rmn = min(a[l], 0); t[p].val1 = t[p].val2 = t[p].val = 1; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}void change(int l, int r, int p, int x, int k){ if(l == r) { t[p].sum = k; t[p].lmx = t[p].rmx = max(k, 0); t[p].lmn = t[p].rmn = min(k, 0); return; } int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(l, mid, ls(p), x, k); else change(mid + 1, r, rs(p), x, k); push_up(p);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); n = (n - 1) &lt;&lt; 1; for(int i = 1; i &lt;= n; i++) { char x;cin &gt;&gt; x; if(x == '(')a[i] = 1; if(x == ')')a[i] = -1; } build(1, n, 1); printf(&quot;%d\\n&quot;, t[1].val); for(int i = 1; i &lt;= q; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); swap(a[x], a[y]); change(1, n, 1, x, a[x]); change(1, n, 1, y, a[y]); printf(&quot;%d\\n&quot;, t[1].val); } return 0;}","link":"/2022/09/14/CF1149C-Tree-Generator%E2%84%A2/"},{"title":"CF280C Game on Tree","text":"CF280C Game on Tree é¢˜è§£ é¢˜æ„ ç»™å®šä¸€æ£µæœ‰æ ¹æ ‘ï¼Œç»“ç‚¹ç¼–å·ä» 111 åˆ° nnnã€‚æ ¹ç»“ç‚¹ä¸º 111 å·ç»“ç‚¹ã€‚ å¯¹äºæ¯ä¸€æ¬¡æ“ä½œï¼Œç­‰æ¦‚ç‡çš„é€‰æ‹©ä¸€ä¸ªå°šæœªè¢«åˆ å»çš„ç»“ç‚¹å¹¶å°†å®ƒåŠå…¶å­æ ‘å…¨éƒ¨åˆ å»ã€‚å½“æ‰€æœ‰ç»“ç‚¹è¢«åˆ é™¤ä¹‹åï¼Œæ¸¸æˆç»“æŸï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ é™¤111 å·ç»“ç‚¹åæ¸¸æˆå³ç»“æŸã€‚ è¦æ±‚æ±‚å‡ºåˆ é™¤æ‰€æœ‰ç»“ç‚¹çš„æœŸæœ›æ“ä½œæ¬¡æ•°ã€‚ nâ‰¤105n \\le 10 ^ 5nâ‰¤105 è§£æ³• å¦‚æœè®¾fif_ifiâ€‹è¡¨ç¤ºæ¯ä¸ªç‚¹çš„æƒå€¼ï¼Œæƒå€¼çš„èŒƒå›´æ˜¾ç„¶åªæœ‰000å’Œ111ï¼Œ ç­”æ¡ˆå…¶å®å°±æ˜¯æ±‚E(âˆ‘fi)E(\\sum f_i)E(âˆ‘fiâ€‹)ï¼Œæ ¹æ®æœŸæœ›çš„çº¿æ€§æ€§ï¼Œå¯ä»¥å¾—å‡ºE(âˆ‘fi)=âˆ‘E(fi)E(\\sum f_i) = \\sum E(f_i)E(âˆ‘fiâ€‹)=âˆ‘E(fiâ€‹)ï¼Œ è€ƒè™‘æ¯ä¸ªç‚¹çš„æœŸæœ›å…¶å®å°±æ˜¯è¿™ä¸ªç‚¹è¢«é€‰ä¸­çš„æ¦‚ç‡ï¼Œå¦‚æœè¿™ä¸ªç‚¹è¢«é€‰åˆ°ï¼Œæ˜¾ç„¶ä¸€å®šæ˜¯åœ¨å…¶ç¥–å…ˆé€‰åˆ°ä¹‹å‰ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰depthiâˆ’1depth_i - 1depthiâ€‹âˆ’1ä¸ªç¥–å…ˆï¼Œç­”æ¡ˆå°±æ˜¯âˆ‘i=1n1depthi\\sum_{i = 1} ^ n \\frac{1}{depth_i}âˆ‘i=1nâ€‹depthiâ€‹1â€‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int depth[N];void dfs(int x, int fa){ depth[x] = depth[fa] + 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x); }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs(1, 0); double ans = 0; for(int i = 1; i &lt;= n; i++) ans += 1.0 / depth[i]; printf(&quot;%.6lf&quot;, ans); return 0;}","link":"/2022/11/02/CF280C%20Game%20on%20Tree/"},{"title":"Link Cut Tree","text":"åˆæ¢Link Cut Tree Link Cut Tree æ¦‚å¿µ Link Cut Tree ç®€ç§°LCTï¼Œå±äºå®é“¾å‰–åˆ†ï¼Œæ˜¯åº”ç”¨æ¯”è¾ƒå¹¿æ³›çš„é“¾å‰–åˆ†ä¹‹ä¸€ï¼Œ é“¾å‰–åˆ†å…¶å®å°±æ˜¯å¯¹æ ‘çš„ä¸€äº›è¾¹è¿›è¡Œè½»é‡åˆ’åˆ†çš„æ“ä½œï¼Œåœ¨å®ç°æ ‘ä¸Šçš„ä¿®æ”¹å’ŒæŸ¥è¯¢æ—¶èƒ½ä»¥ä»¥ä¸€ä¸ªè¾ƒä¸ºä¼˜ç§€çš„å¤æ‚åº¦å»è§£å†³é—®é¢˜ï¼Œä¸»è¦è¿˜æ˜¯æœ‰ä¸‰ç±»ï¼šé‡é“¾å‰–åˆ†ï¼Œ å®é“¾å‰–åˆ†ï¼Œ å’Œé•¿é“¾å‰–åˆ†ã€‚ æ€§è´¨ é¦–å…ˆè™šå®å‰–å’Œè½»é‡å‰–æœ€å¤§çš„ä¸åŒè¿˜æ˜¯LCTå¯ä»¥åšåˆ°åŠ¨æ€çš„è¿è¾¹æ–­è¾¹ï¼Œç”¨èµ·æ¥æ¯”è¾ƒçµæ´»ï¼Œå¯ä»¥è§£å†³ä¸€äº›æ ‘å‰–è§£å†³ä¸äº†çš„é—®é¢˜ï¼Œä¸»è¦ç”¨splayæ¥ç»´æŠ¤ï¼ŒLCTæ”¯æŒçš„æ“ä½œä¸»è¦æœ‰ï¼š æŸ¥è¯¢ã€ä¿®æ”¹é“¾ä¸Šçš„ä¿¡æ¯ éšæ„æŒ‡å®šåŸæ ‘çš„æ ¹ åŠ¨æ€è¿è¾¹ï¼Œåˆ è¾¹ åˆå¹¶ä¸¤ä¸ªæ ‘ åŠ¨æ€ç»´æŠ¤è¿é€šæ€§ ä½¿ç”¨LCT è§£å†³é—®é¢˜æ—¶éœ€è¦ä¸æ–­ç»´æŠ¤ä»¥ä¸‹æ€§è´¨ï¼š æ¯ä¸€ä¸ªsplayç»´æŠ¤çš„æ—¶ä¸€æ¡ä»ä¸Šåˆ°ä¸‹æŒ‰åœ¨åŸæ ‘ä¸­æ·±åº¦ä¸¥æ ¼é€’å¢çš„è·¯å¾„ï¼Œsplayçš„ä¸­åºéå†å°±å¯ä»¥å¾—åˆ°å¯¹åº”çš„è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸èƒ½æŠŠæ·±åº¦ç›¸åŒçš„æ”¾åœ¨ä¸€ä¸ªsplayä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªsplayç»´æŠ¤çš„æ˜¯å¯¹åº”åˆ°åŸæ ‘ä¸Šçš„ä¸€æ¡é“¾ã€‚ æ¯ä¸ªèŠ‚ç‚¹åªèƒ½åŒ…å«åœ¨ä¸€ä¸ªsplayä¸­ã€‚ è¾¹åˆ†ä¸ºå®è¾¹å’Œè™šè¾¹ï¼Œå®è¾¹åŒ…å«åœ¨splayä¸­ï¼Œ è™šè¾¹æ€»æ˜¯ç”±ä¸€æ£µsplayæŒ‡å‘å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆè¯¥splayä¸­ç»´æŠ¤çš„é“¾æ·±åº¦å°çš„é“¾çš„ä¸€ç«¯çš„çˆ¶äº²èŠ‚ç‚¹ï¼‰ã€‚ å½“æŸç‚¹æœ‰å¤šä¸ªå„¿å­æ—¶åªèƒ½å‘å…¶ä¸­ä¸€ä¸ªå„¿å­æ‹‰ä¸€æ¡å®é“¾ï¼Œå…¶ä»–çš„å„¿å­è¿æˆè™šé“¾ï¼Œç”±å¯¹åº”å„¿å­æ‰€å±çš„splayçš„æ ¹èŠ‚ç‚¹çš„çˆ¶äº²æŒ‡å‘è¯¥ç‚¹ï¼Œå¹¶ä¸”ä»è¯¥ç‚¹ä¸èƒ½è®¿é—®å…¶çš„è™šå„¿å­ï¼Œ ä½†ä»å…¶è™šå„¿å­å¯ä»¥è®¿é—®åˆ°è¯¥ç‚¹ä¹Ÿå°±æ˜¯â€œè®¤çˆ¶ä¸è®¤å­â€ã€‚ æ”¯æŒçš„æ“ä½œå®ç° access LCTçš„æ ¸å¿ƒæ“ä½œï¼Œæ˜¯å…¶ä»–æ“ä½œçš„åŸºç¡€ã€‚ é¦–å…ˆæ ¹æ®æ€§è´¨3ï¼Œ ä¸¤ä¸ªç‚¹ä¸ä¸€å®šæ˜¯ç›´æ¥è”é€šçš„ï¼ˆä¸åœ¨ä¸€ä¸ªsplayä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´è·¯å¾„ä¸Šä¸å…¨æ˜¯å®è¾¹ï¼Œæœ‰è™šè¾¹ï¼‰,accessæ“ä½œå°±å¯ä»¥æ‰“é€šä¸¤ä¸ªç‚¹ä¹‹é—´çš„è·¯å¾„ï¼Œå°†å…¶å˜æˆå®è¾¹ã€‚ å‡è®¾ç°åœ¨æˆ‘ä»¬æœ‰è¿™æ ·çš„ä¸€æ£µæ ‘ï¼Œ æ‰€æ„æˆçš„LCTå¯èƒ½é•¿è¿™ä¸ªæ ·å­ï¼Œ å‡è®¾æˆ‘ä»¬è¦å°†Aâˆ’NA - NAâˆ’Nçš„è·¯å¾„æ‰“é€šï¼Œé¦–å…ˆsplay(N)ï¼Œ å°†å…¶å˜ä¸ºæ‰€åœ¨splayçš„æ ¹èŠ‚ç‚¹ï¼Œ ç„¶åæŠŠOOOå˜ä¸ºè™šå„¿å­ï¼Œ ç„¶åæ¥ç€å¤„ç†IIIï¼Œå°†IIIçš„å³å„¿å­è®¾ä¸ºNNN , æ¥ç€splay(H), HHH æŒ‡å‘AAA ï¼Œsplay(A)ï¼Œ ç„¶åå°±å®Œæˆäº†ã€‚ å…¶å®å°±æ˜¯å…ˆè½¬åˆ°æ ¹ï¼Œç„¶åæ¢å„¿å­ï¼Œæ›´æ–°ä¿¡æ¯ï¼Œ å½“å‰æ“ä½œç‚¹åˆ‡æ¢ä¸ºè½»è¾¹æ‰€æŒ‡çš„çˆ¶äº²ã€‚ 12345void access(int x) // root -&gt; x{ for(int y = 0; x; y = x, x = fa(y)) splay(x), rs(x) = y, push_up(x); // æ—‹è½¬åˆ°æ ¹ï¼Œ æ¢å„¿å­ï¼Œ æ›´æ–°ä¿¡æ¯} makeroot ä¸Šé¢çš„accessæ“ä½œåªæ˜¯æ±‚å‡ºäº†æ ¹åˆ°æŸä¸ªç‚¹çš„è·¯å¾„ï¼Œæ›´å¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è·å–æŒ‡å®šä¸¤ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ï¼Œä½†æœ‰å¯èƒ½è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„è·¯å¾„ä¸æ˜¯ä¸¥æ ¼é€’å¢çš„ï¼Œè¿™æ ·çš„è¯æ ¹æ®æˆ‘ä»¬ç»´æŠ¤çš„æ€§è´¨ï¼Œè¿™ä¸¤ä¸ªç‚¹æ˜¯ä¸ä¼šå‡ºç°åœ¨åŒä¸€ä¸ªsplayä¸­çš„ï¼Œ è¿™æ—¶æˆ‘ä»¬å¯ä»¥å°†æŒ‡å®šç‚¹ç§°ä¸ºåŸæ ‘çš„æ ¹ï¼Œæ¥å®ç°makerootï¼Œ é¦–å…ˆaccess(x)åï¼Œ xxxä¸€å®šæ—¶splayä¸­ï¼Œä¸­åºéå†æœ€åçš„ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ·±åº¦æœ€å¤§çš„ç‚¹ï¼Œæ¥ç€splay(x)ï¼Œxxxå°†æ²¡æœ‰å³å­æ ‘ï¼Œç„¶ååè½¬æ•´ä¸ªsplayï¼Œ xxxå°±æˆä¸ºäº†æ·±åº¦æœ€å°çš„ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ ¹èŠ‚ç‚¹ã€‚ 123456789101112void recover(int x) // åŒºé—´åè½¬{ swap(ls(x), rs(x)); t[x].rev ^= 1; // åŒºé—´åè½¬æ ‡è®°}void makeroot(int x) // æ¢æ ¹{ access(x); splay(x); recover(x);} findroot å¯»æ‰¾x,yx, yx,y åœ¨åŸæ ‘ä¸­çš„æ ¹èŠ‚ç‚¹ï¼Œæ¥åˆ¤æ–­è¿é€šæ€§ã€‚ 123456789101112int findroot(int x) // æ‰¾æ ¹{ access(x); splay(x); while(ls(x)) // æ‰¾æ·±åº¦å°çš„é“¾çš„ä¸€ç«¯ { push_down(x); x = ls(x); } splay(x); return x;} split spiltæ“ä½œæ˜¯ç”¨æ¥æ‹‰å‡ºxâ†’yx \\rightarrow yxâ†’yçš„è·¯å¾„ï¼Œå˜æˆä¸€ä¸ªsplayã€‚ 123456void split(int x, int y) // x -&gt; y{ makeroot(x); access(y); splay(y);} link linkæ“ä½œç”¨æ¥è¿è¾¹ã€‚ 123456void link(int x, int y) // link x -&gt; y{ makeroot(x); if(findroot(y) != x) // åˆ¤æ–­æ˜¯å¦åœ¨åŒä¸€æ£µæ ‘ä¸­ fa(x) = y;} cut cutæ“ä½œç”¨æ¥æ–­è¾¹ã€‚ 123456789void cut(int x, int y) // cut x -&gt; y{ makeroot(x); if(findroot(y) == x &amp;&amp; fa(y) == x &amp;&amp; !ls(y)) // åˆ¤æ–­æ“ä½œæ˜¯å¦åˆæ³• { fa(y) = rs(x) = 0; push_up(x); }} splay çš„ä¸€äº›æ“ä½œ å¤§éƒ¨åˆ†å·®ä¸å¤šã€‚ é¦–å…ˆæ ¸å¿ƒçš„rotateæ“ä½œ 12345678910111213void rotate(int x){ int y = fa(x), z = fa(y); bool res = check(x); if(nroot(y)) t[z].son[check(y)] = x; // ä¸åŒä¹‹å¤„ï¼Œéœ€è¦åˆ¤æ–­æ˜¯ä¸æ˜¯ä¸ºæ ¹ï¼Œ å¦‚æœè¿çš„æ˜¯è½»è¾¹ å®ƒçš„çˆ¶äº²å„¿å­æ˜¯ä¸èƒ½æœ‰å®ƒçš„ï¼Œä¸æ˜¯æ ¹å†æ›´æ–°å„¿å­ã€‚ fa(x) = z; t[y].son[res] = t[x].son[res ^ 1]; fa(t[x].son[res ^ 1]) = y; t[x].son[res ^ 1] = y; fa(y) = x; push_up(y); push_up(x);} ç„¶åæ˜¯splayï¼Œ 123456789101112131415void splay(int x){ int y = x, z, top = 0; int st[N]; st[++top] = y; while(nroot(y)) st[++top] = y = fa(y); // è®°å½•åˆ°æ ¹çš„è·¯å¾„ while(top) push_down(st[top--]); // ä¸‹ç©¿æ ‡è®° while(nroot(x)) { int y = fa(x), z = fa(y); if(nroot(y)) (check(y) ^ check(y)) ? rotate(x) : rotate(y); rotate(x); } push_up(x);} æ›´æ–°ä¿¡æ¯çš„æ“ä½œï¼Œæ ¹æ®é¢˜æ„æ›´æ”¹ï¼Œè¿™é‡Œä»¥P3690 ã€æ¨¡æ¿ã€‘åŠ¨æ€æ ‘ï¼ˆLink Cut Treeï¼‰ä¸ºä¾‹ï¼Œ 123456789101112void push_up(int x){ t[x].sum = t[ls(x)].sum ^ t[rs(x)].sum ^ t[x].val;}void push_down(int x){ if(!t[x].rev) return; if(ls(x)) recover(ls(x)); if(rs(x)) recover(rs(x)); t[x].rev = 0;} checkå’Œnrootï¼Œ 12bool check(int x) {return rs(fa(x)) == x;}bool nroot(int x) {return ls(fa(x)) == x || rs(fa(x)) == x;} // ä¸æ˜¯æ ¹ä¸ºtrue é™„ä¸Šä¸€ä¸ªå®Œæ•´ä»£ç P3690 ã€æ¨¡æ¿ã€‘åŠ¨æ€æ ‘ï¼ˆLink Cut Treeï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 3e5 + 10;int n, m;int a[N];namespace LCT{ struct splaytree { int son[2], val, father, sum; int rev; #define ls(p) t[p].son[0] #define rs(p) t[p].son[1] #define fa(p) t[p].father }t[N &lt;&lt; 1]; bool check(int x) {return rs(fa(x)) == x;} bool nroot(int x) {return ls(fa(x)) == x || rs(fa(x)) == x;} void push_up(int x) { t[x].sum = t[ls(x)].sum ^ t[rs(x)].sum ^ t[x].val; } void recover(int x) { swap(ls(x), rs(x)); t[x].rev ^= 1; } void push_down(int x) { if(!t[x].rev) return; if(ls(x)) recover(ls(x)); if(rs(x)) recover(rs(x)); t[x].rev = 0; } void rotate(int x) { int y = fa(x), z = fa(y); bool res = check(x); if(nroot(y)) t[z].son[check(y)] = x; fa(x) = z; t[y].son[res] = t[x].son[res ^ 1]; fa(t[x].son[res ^ 1]) = y; t[x].son[res ^ 1] = y; fa(y) = x; push_up(y); push_up(x); } int st[N]; void splay(int x) { int y = x, z, top = 0; st[++top] = y; while(nroot(y)) st[++top] = y = fa(y); while(top) push_down(st[top--]); while(nroot(x)) { y = fa(x), z = fa(y); if(nroot(y)) (check(x) ^ check(y)) ? rotate(x) : rotate(y); rotate(x); } push_up(x); } void access(int x) { for(int y = 0; x; y = x, x = fa(y)) splay(x), rs(x) = y, push_up(x); } void makeroot(int x) { access(x); splay(x); recover(x); } int findroot(int x) { access(x); splay(x); while(ls(x)) { push_down(x); x = ls(x); } splay(x); return x; } void split(int x, int y) { makeroot(x); access(y); splay(y); } void link(int x, int y) { makeroot(x); if(findroot(y) != x) fa(x) = y; } void cut(int x, int y) { makeroot(x); if(findroot(y) == x &amp;&amp; fa(y) == x) { fa(y) = rs(x) = 0; push_up(x); } }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) LCT::t[i].val = a[i]; for(int i = 1; i &lt;= m; i++) { int opt, x, y; scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;x, &amp;y); if(opt == 0) { LCT::split(x, y); printf(&quot;%d\\n&quot;, LCT::t[y].sum); } if(opt == 1) { LCT::link(x, y); } if(opt == 2) { LCT::cut(x, y); } if(opt == 3) { LCT::splay(x); LCT::t[x].val = y; } } return 0;} å‚è€ƒæ–‡çŒ® [1] LCTæ€»ç»“â€”â€”æ¦‚å¿µç¯‡Flash_Hu","link":"/2022/09/14/Link-Cut-Tree/"},{"title":"Loj#6247. ä¹ä¸ªå¤ªé˜³","text":"Loj#6247. ä¹ä¸ªå¤ªé˜³ é¢˜è§£ å‰ç½®çŸ¥è¯† åŸæ ¹ äºŒé¡¹å¼å®šç† å•ä½æ ¹ é¢˜ç›® ç»™å®š n,Kn,Kn,Kï¼Œæ»¡è¶³KKK æ˜¯ 222 çš„å¹‚ï¼Œæ±‚ âˆ‘Kâˆ£i,0â‰¤iâ‰¤n(ni)\\sum_{K\\mid i, 0 \\le i \\le n} \\dbinom{n}{i} Kâˆ£i,0â‰¤iâ‰¤nâˆ‘â€‹(inâ€‹) å¯¹ 998244353998244353998244353 å–æ¨¡ ã€‚ 1â‰¤nâ‰¤1015,1â‰¤Kâ‰¤2201 \\le n \\le 10^{15}, 1\\le K \\le 2^{20}1â‰¤nâ‰¤1015,1â‰¤Kâ‰¤220 ï¼Œ ä¸” KKK ä¸º222 çš„å¹‚ ã€‚ æ€è·¯ é¦–å…ˆå°†å¼å­å†™ä¸º ï¼š âˆ‘i=0n(ni)[Kâˆ£i]\\sum_{i=0}^n \\dbinom{n}{i} [K \\mid i] i=0âˆ‘nâ€‹(inâ€‹)[Kâˆ£i] ç„¶åè§‚å¯Ÿå¼å­ä¸­çš„æ¡ä»¶ğŸ¤” ï¼Œå¯ä»¥ç”¨å•ä½æ ¹åæ¼” ï¼š 1nâˆ‘i=0nâˆ’1Ï‰nxâˆ—i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1â€‹i=0âˆ‘nâˆ’1â€‹Ï‰nxâˆ—iâ€‹=[xmodn=0] åŒ–ç®€å¼å­ä¸º ï¼š âˆ‘i=0n(ni)[Kâˆ£i]=âˆ‘i=0n1Kâˆ‘j=0Kâˆ’1Ï‰niâˆ—j(ni)=1Kâˆ‘i=1nâˆ‘j=0Kâˆ’1Ï‰niâˆ—j(ni)=1Kâˆ‘j=0Kâˆ’1âˆ‘i=0n(Ï‰nj)i(ni)\\begin{aligned} \\sum_{i=0}^n \\dbinom{n}{i} [K \\mid i] &amp;=\\sum_{i=0}^n \\frac{1}{K} \\sum_{j=0}^{K-1} \\omega_n^{i \\ast j} \\dbinom{n}{i}\\\\ &amp;=\\frac{1}{K} \\sum_{i=1}^{n} \\sum_{j=0}^{K-1} \\omega_n^{i \\ast j} \\dbinom{n}{i}\\\\ &amp;=\\frac{1}{K} \\sum_{j=0}^{K-1} \\sum_{i=0}^n (\\omega_n^{j})^i \\dbinom{n}{i} \\end{aligned} i=0âˆ‘nâ€‹(inâ€‹)[Kâˆ£i]â€‹=i=0âˆ‘nâ€‹K1â€‹j=0âˆ‘Kâˆ’1â€‹Ï‰niâˆ—jâ€‹(inâ€‹)=K1â€‹i=1âˆ‘nâ€‹j=0âˆ‘Kâˆ’1â€‹Ï‰niâˆ—jâ€‹(inâ€‹)=K1â€‹j=0âˆ‘Kâˆ’1â€‹i=0âˆ‘nâ€‹(Ï‰njâ€‹)i(inâ€‹)â€‹ ç„¶åè§‚å¯Ÿåé¢çš„å¼å­ï¼Œå¯¹å…¶ä½¿ç”¨äºŒé¡¹å¼å®šç†ï¼ (a+b)n=âˆ‘i=0n(ni)aibnâˆ’i(a+b)^n = \\sum_{i=0}^n \\dbinom{n}{i} a^i b^{n-i} (a+b)n=i=0âˆ‘nâ€‹(inâ€‹)aibnâˆ’i æ‹†åˆ†ä¸º ï¼š 1Kâˆ‘j=0Kâˆ’1âˆ‘i=0n(Ï‰nj)i(ni)=1Kâˆ‘j=0Kâˆ’1(1+Ï‰nj)n\\begin{aligned} \\frac{1}{K} \\sum_{j=0}^{K-1} \\sum_{i=0}^n (\\omega_n^{j})^i \\dbinom{n}{i} &amp;=\\frac{1}{K} \\sum_{j=0}^{K-1} (1+\\omega_n^j)^n \\end{aligned} K1â€‹j=0âˆ‘Kâˆ’1â€‹i=0âˆ‘nâ€‹(Ï‰njâ€‹)i(inâ€‹)â€‹=K1â€‹j=0âˆ‘Kâˆ’1â€‹(1+Ï‰njâ€‹)nâ€‹ è®¡ç®—æ—¶ç”±äº 998244353=223Ã—17Ã—7+1998244353 = 2^{23} \\times 17 \\times 7 +1998244353=223Ã—17Ã—7+1 åˆšå¥½å­˜åœ¨åŸæ ¹ 333 998244353æœ€ä¼˜ç¾çš„æ€§è´¨è«è¿‡äºå®ƒæ˜¯ä¸ªå®Œç¾æ¶è‡­æ•°ï¼š998244353=( 114514 * ( 54-1+114 * (1+14*5+1+4) ) ) + ( 4+11451 * (4-1-15+14) ) + ( 11+41*54 + (141+541) ) + (4-1-15+14)ï¼›ä¹‹æ‰€ä»¥ç§°ä¸ºå®Œç¾ï¼Œå¦‚æœæ‚¨ä»”ç»†è§‚å¯Ÿï¼Œæ‚¨ä¼šå‘ç°æ¯ä¸€ä¸ªæ‹¬å·é‡Œ114514éƒ½å‡ºç°äº†æ­£æ•´æ•°æ¬¡ï¼ å°† Ï‰n\\omega_nÏ‰nâ€‹ è®¾ä¸º 3pâˆ’1K3^{\\frac{p-1}{K}}3Kpâˆ’1â€‹ å³å¯ æ—¶é—´å¤æ‚åº¦ O(nlogâ¡n)O(n \\log n)O(nlogn) ä»£ç  12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int mod=998244353;ll ans;ll qpow(ll a,ll b,ll mod){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%mod; a=(a*a)%mod;b&gt;&gt;=1; } return t;}ll inv(ll x){return (qpow(x,mod-2,mod)+mod)%mod;}int main(){ ll n,k; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); ll wn=qpow(3,(mod-1)/k,mod); for(ll i=0,c=1;i&lt;k;i++,c=c*wn%mod) { ans=(ans+qpow(1+c,n,mod))%mod; } printf(&quot;%lld&quot;,(ans*inv(k)%mod+mod)%mod); return 0;}","link":"/2022/07/22/Loj-6247-%E4%B9%9D%E4%B8%AA%E5%A4%AA%E9%98%B3/"},{"title":"NaCly_Fish&#39;s Math Contest","text":"NaCly_Fishâ€™s Math Contest é¢˜è§£ NaCly_Fishâ€™s Math Contest A.ç‚¼é‡‘æœ¯ï¼ˆAlchemyï¼‰ é¢˜ç›®æè¿° é“ƒæ˜¯ä¸€ä¸ªçˆ±ç©æ¸¸æˆçš„å¥³å­©å­ã€‚ å¥¹åœ¨æ¸¸æˆä¸­æƒ³è¦ç‚¼åˆ¶ä¸€ç§ç¨€æœ‰åˆé‡‘ â€”â€” è¿™éœ€è¦nnn ç§é‡‘å±æ¥åˆæˆã€‚ å¥¹å‡†å¤‡å¥½çŸ¿çŸ³åå»ºé€ äº† kkkä¸ªä¸åŒçš„ç†”ç‚‰ï¼Œå½“ç†”ç‚‰å¯åŠ¨æ—¶ï¼Œä¼šéšæœºç‚¼å‡ºè¿™ nnn ç§é‡‘å±ä¸­çš„ä¸€äº›ï¼ˆä¹Ÿå¯èƒ½ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼‰ã€‚ å¦‚æœæŠŠæ¯ä¸ªç†”ç‚‰ç‚¼å‡ºçš„é‡‘å±æ”¶é›†èµ·æ¥ï¼Œæœ‰äº†å…¨éƒ¨ nnn ç§é‡‘å±ï¼Œå°±èƒ½é€ å‡ºåˆé‡‘äº†ã€‚æ¾ªå¯¹æ­¤å¾ˆå¥½å¥‡ï¼Œå¯¹é“ƒè¯´ï¼šã€Œæˆ‘è€ƒè€ƒä½ ï¼Œæœ‰å¤šå°‘ç§æƒ…å†µå¯ä»¥ç‚¼å‡ºåˆé‡‘å‘¢ï¼Ÿã€è¿™ä¸ªç®€å•çš„é—®é¢˜é“ƒå¾ˆå¿«å°±ä¼šåšäº†ï¼Œä½ èƒ½æ±‚å‡ºç»“æœå—ï¼Ÿ ç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œè¯·å¯¹ 998244353998244353998244353 å–æ¨¡ï¼ˆå³é™¤ä»¥ 998244353998244353998244353 çš„ä½™æ•°ï¼‰åè¾“å‡ºã€‚ èŒƒå›´é™åˆ¶ 1â‰¤n,kâ‰¤1091 \\le n , k \\le 10 ^ 91â‰¤n,kâ‰¤109ã€‚ è§£æ³• é¦–å…ˆå°†å…¶çœ‹ä¸ºä¸€ä¸ªkÃ—nk \\times nkÃ—nçš„çŸ©é˜µï¼Œè®©å…¶æ¯ä¸€åˆ—ä¸Šä¸éƒ½ä¸ºç©ºï¼Œ æ±‚æ–¹æ¡ˆæ•°ï¼Œ ä¸éš¾å¾—å‡ºç­”æ¡ˆä¸ºï¼š âˆ‘i=0n(âˆ’1)i(2nâˆ’i)k(ni)\\sum_{i = 0}^n (-1)^i (2^{n - i}) ^ k \\dbinom{n}{i} i=0âˆ‘nâ€‹(âˆ’1)i(2nâˆ’i)k(inâ€‹) ä½¿ç”¨äºŒé¡¹å¼å®šç†å°†å…¶è¿›ä¸€æ­¥åŒ–ç®€ä¸ºï¼š âˆ‘i=0n(âˆ’1)i(2k)nâˆ’i(ni)=(2kâˆ’1)n\\sum_{i = 0} ^ n (-1)^i(2^k)^{n - i} \\dbinom{n}{i} = (2^k - 1) ^ n i=0âˆ‘nâ€‹(âˆ’1)i(2k)nâˆ’i(inâ€‹)=(2kâˆ’1)n å¿«é€Ÿå¹‚å³å¯ï¼Œ æ—¶é—´å¤æ‚åº¦O(logâ¡n)O(\\log n)O(logn) Code 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;int n, k;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t % mod;}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); printf(&quot;%lld&quot;, qpow((qpow(2, k) - 1), n)); return 0;} B.ç”Ÿå‘½æ¸¸æˆï¼ˆGoLï¼‰ é¢˜ç›®æè¿° æœ‰nnnä¸ªæ ¼å­æ’æˆä¸€ä¸ªç¯ï¼Œæ¯ä¸ªæ ¼å­ä¸­éƒ½æœ‰ä¸€ä¸ªçŠ¶æ€ä¸º ç”Ÿ/æ­» çš„ç»†èƒã€‚ å¦‚æœä¸€ä¸ªæ ¼å­ç›¸é‚»çš„æ´»ç»†èƒæ•°ä¸º111ï¼Œé‚£ä¹ˆè¿™ä¸ªæ ¼å­ä¸­çš„ç»†èƒï¼Œåœ¨ä¸‹ä¸€ä»£ä¼šå­˜æ´»ï¼ˆå¦‚æœæ˜¯æ­»äº¡çš„ä¼šå¤æ´»ï¼‰ï¼›å¦åˆ™ä¼šæ­»äº¡ã€‚ ç»™å®šåˆå§‹çŠ¶æ€ï¼Œè¯·ä½ å¸®å¥¹ä»¬å¿«é€Ÿæ±‚å‡ºkkk ä»£ä¹‹åçš„çŠ¶æ€ã€‚ èŒƒå›´é™åˆ¶ 3â‰¤nâ‰¤5Ã—105,1â‰¤k&lt;2623\\le n \\le 5 \\times 10 ^ 5, 1 \\le k &lt; 2 ^ {62}3â‰¤nâ‰¤5Ã—105,1â‰¤k&lt;262ã€‚ è§£æ³• é¢˜ç›®èƒŒæ™¯ä¸ºConwayâ€™s Game of Lifeï¼Œè¿™ä¸ªæ˜¯é—®é¢˜çš„ç®€æ˜“ç‰ˆï¼Œå…¶å®å¯ä»¥åœ¨è¿™é‡Œç©ä¸€ä¸‹ã€‚ é¦–å…ˆé¢˜ç›®å¯ä»¥è½¬åŒ–ä¸ºæ±‚fi,j=fiâˆ’1,jâˆ’1âŠ•fiâˆ’1,j+1f_{i,j} = f_{i - 1,j - 1} \\oplus f_{i - 1, j + 1}fi,jâ€‹=fiâˆ’1,jâˆ’1â€‹âŠ•fiâˆ’1,j+1â€‹ï¼Œç„¶åæ ¹æ®å¼‚æˆ–çš„ç»“åˆå¾‹å’Œæ•°å­¦å½’çº³æ³•å¯ä»¥å¾—åˆ°ï¼Œ fi,j=fiâˆ’2k,jâˆ’2kâŠ•fiâˆ’2k,j+2kf_{i,j} = f_{i - 2 ^ k,j - 2 ^k} \\oplus f_{i - 2 ^ k, j + 2^k} fi,jâ€‹=fiâˆ’2k,jâˆ’2kâ€‹âŠ•fiâˆ’2k,j+2kâ€‹ ç„¶åå°±å¯ä»¥è§£å†³äº†ï¼Œæ—¶é—´å¤æ‚åº¦O(nlogâ¡k)O(n\\log k)O(nlogk)ã€‚ Code 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 2e5 + 10;int n, T;int f[N], g[N];signed main(){ cin &gt;&gt; n &gt;&gt; T; for(int i = 0; i &lt; n; i++) { char x; cin &gt;&gt; x; f[i] = (x == '1'); } for(int bit = 0; bit &lt;= 62 &amp;&amp; T; bit++) { if((T &gt;&gt; bit) &amp; 1) { for(int i = 0; i &lt; n; i++) g[i] = f[((i - (1ll &lt;&lt; bit)) % n + n) % n] ^ f[((i + (1ll &lt;&lt; bit)) % n + n) % n]; memcpy(f, g, sizeof(g)); T -= (1ll &lt;&lt; bit); } } for(int i = 0; i &lt; n; i++) putchar(f[i] + '0'); return 0;} C.é»‘æš—ï¼ˆDarknessï¼‰ é¢˜ç›®æè¿° é“ƒåœ¨ä¸€ä¸ªé»‘æš—çš„ä¸‰ç»´ç©ºé—´å†…å¯»æ‰¾æ¾ªã€‚è¿™ä¸ªç©ºé—´å¯ä»¥è¡¨ç¤ºä¸º {(x,y,z)âˆ£xâˆˆ[0,A],yâˆˆ[0,B],zâˆˆ[0,C]}\\{ (x, y, z) | x \\in [0,A], y \\in [0, B], z \\in [0, C]\\}{(x,y,z)âˆ£xâˆˆ[0,A],yâˆˆ[0,B],zâˆˆ[0,C]}ã€‚é“ƒåˆå§‹ç«™åœ¨åæ ‡ä¸º (A,B,C)(A,B,C)(A,B,C)å¤„ï¼Œæ¾ªç«™åœ¨ (0,0,0)(0,0,0)(0,0,0) å¤„ã€‚å‡è®¾é“ƒåœ¨ (x,y,z)(x,y,z)(x,y,z) å¤„ï¼Œå¥¹æ¯æ¬¡ç§»åŠ¨ä¼šå‡åŒ€éšæœºåœ°å°è¯•ç§»åŠ¨åˆ° (xâˆ’1,y,z)(x-1,y,z)(xâˆ’1,y,z) æˆ– (x,yâˆ’1,z)(x,y-1,z)(x,yâˆ’1,z)æˆ– (x,y,zâˆ’1)(x,y,z-1)(x,y,zâˆ’1)ã€‚ è¿™ä¸ªç©ºé—´çš„å¤–å›´æ˜¯å¢™å£ï¼Œä¸å¯ç©¿è¿‡ã€‚ç”±äºç©ºé—´å†…å¾ˆæš—ï¼Œé“ƒå¹¶ä¸çŸ¥é“è‡ªå·±æ˜¯å¦èµ°åˆ°äº†å¢™è¾¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¥¹åœ¨éšæœºé€‰æ‹©ä¸‰ç§æ–¹å‘å°è¯•ç§»åŠ¨æ—¶ï¼Œæœ‰å¯èƒ½æ’åœ¨å¢™ä¸Šã€‚ é“ƒæƒ³è¦çŸ¥é“ï¼Œè‡ªå·±åœ¨ç¬¬ä¸€æ¬¡æ’å¢™æ—¶ï¼Œã€Œåˆ°æ¾ªçš„æ›¼å“ˆé¡¿è·ç¦»ï¼ˆåœ¨æœ¬é¢˜ä¸­çš„æƒ…å†µå°±æ˜¯ x,y,zx,y,zx,y,zåæ ‡ä¹‹å’Œï¼‰ã€çš„kkkæ¬¡æ–¹çš„æœŸæœ›å€¼ã€‚ ä½ åªéœ€è¦æ±‚å‡ºç­”æ¡ˆå¯¹ 998244353998244353998244353å–æ¨¡çš„ç»“æœã€‚ èŒƒå›´é™åˆ¶ 1â‰¤A,B,Câ‰¤5Ã—106,1â‰¤kâ‰¤1071 \\le A, B, C \\le 5 \\times 10 ^ 6, 1 \\le k \\le 10 ^ 71â‰¤A,B,Câ‰¤5Ã—106,1â‰¤kâ‰¤107ã€‚ è§£æ³•","link":"/2022/10/03/NaCly-Fish-s-Math-Contest/"},{"title":"P2508 [HAOI2008]åœ†ä¸Šçš„æ•´ç‚¹","text":"P2508 [HAOI2008]åœ†ä¸Šçš„æ•´ç‚¹ é¢˜è§£ é¢˜ç›®å¤§æ„ ç»™å®šrrr, æ±‚x2+y2=r2x^2 + y^2 = r^2x2+y2=r2 çš„æ•´æ•°è§£çš„ä¸ªæ•°, å…¶ä¸­râ‰¤2000000000r \\le 2000000000râ‰¤2000000000ã€‚ è§£æ³• é¢˜ç›®å…¶å®å°±æ˜¯åœ¨æ±‚ä»¥åŸç‚¹ä¸ºåœ†å¿ƒï¼Œä»¥rrrä¸ºåŠå¾„çš„åœ†ä¸Šæœ‰å¤šå°‘ä¸ªæ•´ç‚¹ã€‚ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å…ˆå°†äºŒç»´å¹³é¢çœ‹åšå…¨ä½“å¤æ•°ï¼Œæ»¡è¶³é¢˜ç›®ä¸­çš„å¼å­çš„è§£å…¶å®å°±æ˜¯æ»¡è¶³ï¼Œ(a+bi)(aâˆ’bi)=r2(a + bi)(a - bi) = r^2(a+bi)(aâˆ’bi)=r2çš„è§£çš„ä¸ªæ•°ã€‚ ç„¶åè¯´æ˜ä¸€ä¸ªæ•°å­¦å®šä¹‰ï¼Œ å¦‚æœè™šæ•°a+bia + bia+bi ä¸­a,ba, ba,bå‡ä¸ºæ•´æ•°ï¼Œ åˆ™ç§°è¿™ä¸ªè™šæ•°ä¸ºé«˜æ–¯æ•´æ•°ï¼Œ ç°åœ¨é—®é¢˜åˆè¿›ä¸€æ­¥è½¬åŒ–ä¸ºï¼Œ æœ‰å¤šå°‘ä¸ªé«˜æ–¯æ•´æ•°zzzæ»¡è¶³å…¶æœ¬èº«ä¸å…¶å…±è½­å¤æ•°zË‰\\bar{z}zË‰çš„ä¹˜ç§¯ä¸ºr2r ^ 2r2ã€‚ ç°åœ¨éœ€è¦è®¨è®ºçš„æ˜¯ä¸€ä¸ªæ•´æ•°å¦‚ä½•åˆ†è§£æˆé«˜æ–¯æ•´æ•°ã€‚ é¦–å…ˆå¯¹äºæ¯ä¸€ä¸ªæ•´æ•°ï¼Œæ ¹æ®ç®—æœ¯åŸºæœ¬å®šç†éƒ½èƒ½å°†å…¶åˆ†è§£æˆè‹¥å¹²ä¸ªç´ æ•°çš„ä¹˜ç§¯ï¼ŒåŒæ ·çš„ï¼Œ ä¸€ä¸ªæ•´æ•°NNNä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºè‹¥å¹²ä¸ªå¤æ•°å› å­çš„ä¹˜ç§¯ï¼Œè¿™äº›å› å­åœ¨é«˜æ–¯æ•´æ•°ä¸Šèƒ½å†åˆ†ï¼Œä¹Ÿå°±æ˜¯é«˜æ–¯ç´ æ•°ã€‚ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å…ˆå°†ä¸€ä¸ªæ•´æ•°NNNåœ¨æ•´æ•°ä¸Šåˆ†è§£ä¸ºè‹¥å¹²ä¸ªç´ æ•°çš„ä¹˜ç§¯ï¼Œç„¶åå†å°†å…¶ä¸­çš„éé«˜æ–¯ç´ æ•°è¿›ä¸€æ­¥åˆ†è§£ã€‚ æ¥ä¸‹æ¥éœ€è¦è§£å†³çš„æ˜¯å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªç´ æ•°æ˜¯ä¸æ˜¯é«˜æ–¯ç´ æ•°ã€‚ å¼•å…¥è´¹é©¬å¹³æ–¹å’Œå®šç†ï¼š å¥‡ç´ æ•°pppå¯ä»¥è¡¨ç¤ºä¸ºä¸¤ä¸ªæ­£æ•´æ•°çš„å¹³æ–¹å’Œï¼Œå½“ä¸”ä»…å½“p=4k+1p = 4 k + 1p=4k+1ï¼Œ å¹¶ä¸”æ–¹æ³•å”¯ä¸€ã€‚ é€šè¿‡è¯¥å®šç†æˆ‘ä»¬å¯ä»¥å¾—çŸ¥ï¼Œ 4k+34k + 34k+3å‹çš„ç´ æ•°ä¸ºé«˜æ–¯ç´ æ•°ï¼Œ 4k+14k + 14k+1å‹çš„ç´ æ•°å¯ä»¥è¢«åˆ†è§£ä¸ºä¸€å¯¹å…±è½­å¤æ•°çš„ä¹˜ç§¯ï¼Œ 222å¯ä»¥è¢«åˆ†è§£ä¸º(1+i)(1âˆ’i)(1 + i) (1 - i)(1+i)(1âˆ’i)ã€‚ å‡è®¾p=4k+1p = 4k + 1p=4k+1å‹ç´ æ•°ï¼Œ q=4k+3q = 4k + 3q=4k+3å‹ç´ æ•°ï¼ŒNNNå°±å¯ä»¥è¢«è¡¨ç¤ºä¸ºï¼š N=2nâˆqi=4k+3qimiâˆpj=4k+1pjkjN = 2^n \\prod _ {q_i = 4k + 3}q_i ^ {m_i} \\prod _{p _j = 4 k + 1} p_j ^{k_j} N=2nqiâ€‹=4k+3âˆâ€‹qimiâ€‹â€‹pjâ€‹=4k+1âˆâ€‹pjkjâ€‹â€‹ ç„¶åå°±å¯ä»¥æ¥ç€åˆ†è§£pjp _jpjâ€‹ä¸ºä¸€å¯¹å…±è½­å¤æ•°ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è®¨è®ºæ¯ä¸€ç§ç´ æ•°çš„è´¡çŒ®æ¥ç»Ÿè®¡æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚ 4k+14k + 14k+1å‹ç´ æ•°çš„è´¡çŒ® å¯¹äºæ¯ä¸€ä¸ªpjp_jpjâ€‹ï¼Œå°†å…¶åˆ†è§£ä¸ºzjz_jzjâ€‹ å’ŒzjË‰\\bar{z_j}zjâ€‹Ë‰â€‹ï¼Œç„¶åä¸€ä¸ªåˆ†åœ¨å‰ä¸€ä¸ªå› å­ï¼Œ ä¸€ä¸ªåˆ†åœ¨åä¸€ä¸ªå› å­ï¼Œä¿è¯å…±è½­æˆ–è€…ç›¸åï¼Œæœ‰ä¸¤ç§åˆ†é…æ–¹å¼ï¼Œ é‚£ä¹ˆå¯¹äºpjkJp_j ^ {k _J}pjkJâ€‹â€‹ï¼Œ å°±ä¼šæœ‰kj+1k_j + 1kjâ€‹+1 ç§åˆ†é…æ–¹å¼ã€‚ 4k+34k + 34k+3å‹ç´ æ•°çš„è´¡çŒ® ç”±äºé«˜æ–¯ç´ æ•°ä¸èƒ½åˆ†ä¸ºå¯¹åº”çš„ä¹˜ç§¯å½¢å¼ï¼Œ å¯ä»¥å°†å…¶åˆ†è§£ä¸º(a+0i)(aâˆ’0i)(a+0i)(a-0i)(a+0i)(aâˆ’0i)ï¼Œé‚£ä¹ˆå¯¹äºqimiq_i^{m_i}qimiâ€‹â€‹ï¼Œä¸ºäº†ä¿è¯å…±è½­ï¼Œ2âˆ£mi2 \\mid m_i2âˆ£miâ€‹æ—¶è´¡çŒ®ä¸º111, å½“2âˆ£Ì¸mi2 \\not\\mid m_i2î€ â€‹âˆ£miâ€‹æ—¶å¯¹åº”å¾—è´¡çŒ®å°±ä¸º000ã€‚ ç´ æ•°222çš„è´¡çŒ® ç”±äº2=(1+i)(1âˆ’i)2 = (1 + i) (1 - i)2=(1+i)(1âˆ’i)ï¼Œç„¶è€Œ1+i1 + i1+i å’Œ1âˆ’i1-i1âˆ’içš„å¤¹è§’ä¸º90âˆ˜90^\\circ90âˆ˜ï¼Œæœ€åç»Ÿè®¡ç­”æ¡ˆÃ—4\\times 4Ã—4æ—¶è®¡ç®—é‡å¤ï¼Œè®¡ç®—æ—¶å…¶ä¸åº”è¯¥äº§ç”Ÿä»»ä½•è´¡çŒ®ã€‚ å‡è®¾åˆ†è§£rrrå¾—ï¼š r=2nâˆqi=4k+3qimiâˆpj=4k+1pjkjr = 2 ^ n \\prod _{q_i = 4k + 3}q_i ^ {m _ i} \\prod _{p _ j = 4k + 1} p_j ^ {k _j} r=2nqiâ€‹=4k+3âˆâ€‹qimiâ€‹â€‹pjâ€‹=4k+1âˆâ€‹pjkjâ€‹â€‹ å¯¹åº”å¾—NNN å°±å¯åˆ†è§£ä¸ºï¼š N=22nâˆqi=4k+3qi2miâˆpj=4k+1pj2kjN = 2 ^ {2n} \\prod _{q_i = 4k + 3}q_i ^ {2m _ i} \\prod _{p _ j = 4k + 1} p_j ^ {2k _j} N=22nqiâ€‹=4k+3âˆâ€‹qi2miâ€‹â€‹pjâ€‹=4k+1âˆâ€‹pj2kjâ€‹â€‹ è¿™æ ·çš„è¯æ¯ä¸€ä¸ªé«˜æ–¯ç´ æ•°çš„å› å­éƒ½ä¸ºå¶æ•°ï¼Œéƒ½æœ‰è´¡çŒ®ï¼Œé‚£ä¹ˆæœ€åçš„ç­”æ¡ˆä¸ºï¼š 4âˆpj=4k+1(2kj+1)4 \\prod_{p _j =4k + 1 } (2 k_j + 1) 4pjâ€‹=4k+1âˆâ€‹(2kjâ€‹+1) å¤æ‚åº¦ä¸ºO(r)O(\\sqrt r)O(râ€‹)ã€‚ 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint r, ans = 1;signed main(){ cin &gt;&gt; r; for(int i = 2; i * i &lt;= r; i++) { if(r % i != 0)continue; int cnt = 0; while(r % i == 0)r /= i, cnt++; if(i % 4 == 1)ans *= (cnt * 2 + 1); } if(r != 1 &amp;&amp; r % 4 == 1)ans *= (1 * 2 + 1); cout &lt;&lt; ans * 4; return 0;} tips: å‹¾è‚¡æ•°ç»„å®šç†ï¼Œ æ¯ä¸ªæœ¬åŸå‹¾è‚¡æ•°ç»„(a,b,c)(a, b, c)(a,b,c)ï¼Œ å…¶ä¸­2âˆ£Ì¸a,2âˆ£b2 \\not \\mid a, 2 \\mid b2î€ â€‹âˆ£a,2âˆ£bï¼Œéƒ½å¯ä»¥ä»ä»¥ä¸‹å…¬å¼å¾—å‡ºã€‚ a=st,b=s2âˆ’t22,c=s2+t22a = st, b = \\frac{s^2 - t^2}{2}, c = \\frac{s^2 + t^2}{2}a=st,b=2s2âˆ’t2â€‹,c=2s2+t2â€‹ï¼Œ å…¶ä¸­s&gt;tâ‰¥0s &gt; t \\ge 0s&gt;tâ‰¥0æ˜¯ä»»æ„æ²¡æœ‰å…¬å› æ•°çš„å¥‡æ•°ã€‚","link":"/2022/09/08/P2508-HAOI2008-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/"},{"title":"P3768 ç®€å•çš„æ•°å­¦é¢˜","text":"P3768 ç®€å•çš„æ•°å­¦é¢˜ é¢˜è§£ é¢˜æ„ ç»™å®šn,pn,pn,p æ±‚ï¼š (âˆ‘i=1nâˆ‘j=1nijgcdâ¡(i,j)) mod p\\bigg( \\sum_{i = 1}^n \\sum_{j =1}^n i j \\gcd(i,j) \\bigg) \\bmod p (i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ijgcd(i,j))modp å…¶ä¸­ï¼Œnâ‰¤1010,5.8Ã—108â‰¤pâ‰¤1.1Ã—109n \\le 10 ^ {10}, 5.8 \\times 10 ^ 8 \\le p \\le 1.1 \\times 10 ^ 9nâ‰¤1010,5.8Ã—108â‰¤pâ‰¤1.1Ã—109 è§£æ³• é¦–å…ˆè§‚å¯Ÿåˆ°nnn çš„æ•°æ®èŒƒå›´ï¼Œè‚¯å®šæ˜¯è¦ä»¥ä¸€ä¸ªäºšçº¿æ€§æ—¶é—´å¤æ‚åº¦è·‘è¿‡å»çš„ï¼Œé¡»æœ‰ç”¨åˆ°æœæ•™ç­›æˆ–Min_25ç­›ï¼Œè¿™é‡Œç”¨çš„æœæ•™ç­›ã€‚ é¦–å…ˆåŒ–ç®€å¼å­ï¼š âˆ‘i=1nâˆ‘j=1nijgcdâ¡(i,j)=âˆ‘d=1ndâˆ‘i=1nâˆ‘j=1nij[gcdâ¡(i,j)==d]=âˆ‘d=1nd3âˆ‘i=1âŒŠndâŒ‹âˆ‘j=1âŒŠndâŒ‹ij[gcdâ¡(i,j)==1]\\begin{aligned} \\sum_{i = 1}^n \\sum_{j =1}^n i j \\gcd(i,j) &amp; = \\sum_{d = 1}^n d \\sum_{i = 1}^n \\sum_{j = 1}^n ij \\left[ \\gcd(i,j) == d \\right] \\\\ &amp; = \\sum_{d = 1}^n d^3 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} i j \\left[ \\gcd(i,j) == 1 \\right] \\\\ \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ijgcd(i,j)â€‹=d=1âˆ‘nâ€‹di=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ij[gcd(i,j)==d]=d=1âˆ‘nâ€‹d3i=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹ij[gcd(i,j)==1]â€‹ åé¢æ˜¯ä¸ªç»å…¸çš„å¼å­ï¼Œè®¾ä¸ºS(n)S(n)S(n)ï¼Œæ¥ç€åŒ–ç®€ï¼š S(n)=âˆ‘i=1nâˆ‘j=1nij[gcdâ¡(i,j)==1]=âˆ‘i=1nâˆ‘j=1nijâˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘d=1nÎ¼(d)d2âˆ‘i=1âŒŠndâŒ‹âˆ‘j=1âŒŠndâŒ‹1\\begin{aligned} S(n) &amp; = \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} i j \\left[ \\gcd(i,j) == 1 \\right] \\\\ &amp; = \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} i j \\sum_{d \\mid \\gcd(i,j)} \\mu(d) \\\\ &amp; = \\sum_{d = 1}^{n} \\mu(d) d^2 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} 1 \\end{aligned} S(n)â€‹=i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ij[gcd(i,j)==1]=i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ijdâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=d=1âˆ‘nâ€‹Î¼(d)d2i=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹1â€‹ åé¢çš„å¼å­å¯ä»¥O(1)O(1)O(1)å¤„ç†ï¼Œå†å¥—ä¸Šä¸€ä¸ªæ•°è®ºåˆ†å—ï¼Œç„¶åå°±å¯ä»¥å¾—åˆ°60åˆ†äº†ï¼Œç„¶è€Œè¿™å¹¶ä¸èƒ½è§£å†³è¿™é“é¢˜ï¼Œå…¶å®å¯ä»¥åœ¨å…¶ä¸­çš„ä¸€æ­¥æ¢ä¸€ç§æ–¹å¼å»å·muï¼Œä½†æ˜¯æœ‰æ›´ç®€å•çš„åšæ³•ï¼Œé‡æ–°è€ƒè™‘å¼å­ï¼Œå¯¹å…¶ä½¿ç”¨æ¬§æ‹‰åæ¼”ï¼š æœ‰ï¼š Ï†âˆ—1=Id\\varphi \\ast 1 = Id Ï†âˆ—1=Id å³ï¼š âˆ‘dâˆ£nÏ†(d)=n\\sum_{d\\mid n}\\varphi(d) = n dâˆ£nâˆ‘â€‹Ï†(d)=n åŸæ¥çš„å¼å­å¯ä»¥åŒ–ä¸ºï¼š âˆ‘i=1nâˆ‘j=1nijgcdâ¡(i,j)=âˆ‘i=1nâˆ‘j=1nijâˆ‘dâˆ£i,dâˆ£jÏ†(d)=âˆ‘d=1nÏ†(d)d2âˆ‘i=1âŒŠndâŒ‹âˆ‘j=1âŒŠndâŒ‹ij\\begin{aligned} \\sum_{i = 1}^n \\sum_{j = 1}^n i j \\gcd(i,j) &amp; = \\sum_{i = 1}^n \\sum_{j = 1}^n i j \\sum_{d\\mid i, d\\mid j}\\varphi(d) \\\\ &amp; = \\sum_{d = 1}^n \\varphi(d) d^2 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} i j \\end{aligned} i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ijgcd(i,j)â€‹=i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹ijdâˆ£i,dâˆ£jâˆ‘â€‹Ï†(d)=d=1âˆ‘nâ€‹Ï†(d)d2i=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠdnâ€‹âŒ‹â€‹ijâ€‹ æ˜¾ç„¶åé¢çš„å¼å­å¯ä»¥O(1)O(1)O(1)è®¡ç®—ï¼Œ n2(n+1)24\\frac{n^2 (n+1)^2}{4} 4n2(n+1)2â€‹ ç°åœ¨è€ƒè™‘å¦‚ä½•è®¡ç®—å‰é¢çš„ âˆ‘d=1nÏ†(d)d2\\sum_{d = 1}^n \\varphi(d) d^2 d=1âˆ‘nâ€‹Ï†(d)d2 æ—¢ç„¶Ï†âˆ—1=Id\\varphi \\ast 1 = IdÏ†âˆ—1=Id,å°†Ï†(d)d2\\varphi(d)d^2Ï†(d)d2è®¾ä¸ºfff,è®¾g=Id2g = Id^2g=Id2æ˜¾ç„¶æœ‰ (fâˆ—g)n=âˆ‘dâˆ£nÏ†(d)d2(nd)2=n3\\bigg(f \\ast g\\bigg)n = \\sum_{d \\mid n} \\varphi(d)d^2 (\\frac{n}{d})^2 = n ^3 (fâˆ—g)n=dâˆ£nâˆ‘â€‹Ï†(d)d2(dnâ€‹)2=n3 çœ‹æ¥é—®é¢˜å·²ç»è§£å†³äº†ï¼ŒS(n)S(n)S(n)ä¸ºæˆ‘ä»¬æƒ³è¦æ±‚çš„å’Œï¼Œ âˆ‘i=1n(fâˆ—g)i=âˆ‘i=1ng(i)S(âŒŠniâŒ‹)=âˆ‘i=1ni3\\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i = \\sum_{i = 1} ^ n g(i) S(\\left\\lfloor \\frac{n}{i} \\right\\rfloor) = \\sum_{i = 1}^n i ^ 3 i=1âˆ‘nâ€‹(fâˆ—g)i=i=1âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹)=i=1âˆ‘nâ€‹i3 ç„¶åä½¿ç”¨æŠ€å·§ï¼Œ g(1)S(n)=âˆ‘i=1n(fâˆ—g)iâˆ’âˆ‘i=2ng(i)S(âŒŠniâŒ‹)g(1)S(n) = \\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i - \\sum_{i = 2}^ng(i)S(\\left\\lfloor \\frac{n}{i}\\right\\rfloor) g(1)S(n)=i=1âˆ‘nâ€‹(fâˆ—g)iâˆ’i=2âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹) åˆå› ä¸ºg(1)=1g(1) = 1g(1)=1,å¾—åˆ°é€’å½’å¼ï¼Œ S(n)=âˆ‘i=1n(fâˆ—g)iâˆ’âˆ‘i=2ng(i)S(âŒŠniâŒ‹)S(n) = \\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i - \\sum_{i = 2}^ng(i)S(\\left\\lfloor \\frac{n}{i}\\right\\rfloor) S(n)=i=1âˆ‘nâ€‹(fâˆ—g)iâˆ’i=2âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹) éœ€è¦ç”¨åˆ°ï¼š âˆ‘i=1ni2=n(n+1)(2n+1)6âˆ‘i=1ni3=n2(n+1)24\\sum_{i = 1}^n i ^2 = \\frac{n(n+1)(2n+1)}{6} \\\\ \\sum_{i = 1}^n i ^3 = \\frac{n^2 (n+1)^2}{4} i=1âˆ‘nâ€‹i2=6n(n+1)(2n+1)â€‹i=1âˆ‘nâ€‹i3=4n2(n+1)2â€‹ ç”¨æœæ•™ç­›ï¼Œæ—¶é—´å¤æ‚åº¦O(n23)O(n^{\\frac{2}{3}})O(n32â€‹) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;#define int long longconst int N = 5e6 + 10;int mod;int inv4, inv6;inline int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a%mod; a = a * a%mod; b &gt;&gt;= 1; } return t%mod;}int cnt, prime[N], phi[N];int S_phi[N];bool vis[N];inline void init(int n){ phi[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!vis[i]) { prime[++cnt] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= n; j++) { vis[i * prime[j]] = true; if(i % prime[j] == 0) { phi[i * prime[j]] = prime[j] * phi[i]; break; } phi[i * prime[j]] = phi[i] * phi[prime[j]]; } } for(int i = 1; i &lt;= n; i++) S_phi[i] = (S_phi[i-1] + phi[i]%mod * i%mod * i%mod)%mod;}inline int f(int n){ return n %mod* n%mod * (n + 1ll)%mod * (n + 1)%mod *inv4 %mod;}inline int g(int n){ return n%mod * (n + 1)%mod * (n * 2ll%mod + 1ll)%mod *inv6 %mod;}unordered_map&lt;int, int&gt; Phi;int S(int n){ if(n &lt;= 5e6)return S_phi[n]%mod; if(Phi.count(n))return Phi[n]; int sum = f(n)%mod; for(int l = 2, r; l &lt;= n; l = r + 1) { r = n/(n/l); sum = (sum - S(n/l)%mod * (g(r) - g(l-1)) %mod + mod)%mod; } return Phi[n] = sum;}signed main(){ int n; scanf(&quot;%lld%lld&quot;, &amp;mod, &amp;n); inv4 = qpow(4, mod-2); inv6 = qpow(6, mod-2); init(5e6); int ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1) { r = n/(n/l); ans = (ans + f(n/l)%mod * (S(r) - S(l-1) + mod)%mod)%mod; } printf(&quot;%lld&quot;, ans); return 0;} tips: æ¬§æ‹‰åæ¼”çš„è¯æ˜ âˆ‘dâˆ£nÏ†(d)=n\\sum_{d \\mid n} \\varphi(d) = n dâˆ£nâˆ‘â€‹Ï†(d)=n è®¾f(n)=âˆ‘dâˆ£nÏ†(d)f(n) = \\sum_{d \\mid n} \\varphi(d)f(n)=âˆ‘dâˆ£nâ€‹Ï†(d)ï¼Œ mâŠ¥nm \\perp nmâŠ¥nï¼Œæ ¹æ®æ¬§æ‹‰å‡½æ•°çš„ç§¯æ€§å‡½æ•°çš„æ€§è´¨æœ‰ï¼š f(n)Ã—f(m)=âˆ‘iâˆ£nÏ†(i)âˆ‘jâˆ£mÏ†(j)=âˆ‘iâˆ£nâˆ‘jâˆ£mÏ†(i)Ï†(j)=âˆ‘iâˆ£nâˆ‘jâˆ£mÏ†(ij)=âˆ‘dâˆ£nmÏ†(d)=f(nm)\\begin{aligned} f(n) \\times f(m) &amp; = \\sum_{i \\mid n} \\varphi(i) \\sum_{j \\mid m} \\varphi(j) \\\\ &amp; = \\sum_{i \\mid n} \\sum_{j \\mid m} \\varphi(i) \\varphi(j) \\\\ &amp; = \\sum_{i \\mid n} \\sum_{j \\mid m} \\varphi(ij) \\\\ &amp; = \\sum_{d \\mid nm} \\varphi(d) \\\\ &amp; = f(nm) \\end{aligned} f(n)Ã—f(m)â€‹=iâˆ£nâˆ‘â€‹Ï†(i)jâˆ£mâˆ‘â€‹Ï†(j)=iâˆ£nâˆ‘â€‹jâˆ£mâˆ‘â€‹Ï†(i)Ï†(j)=iâˆ£nâˆ‘â€‹jâˆ£mâˆ‘â€‹Ï†(ij)=dâˆ£nmâˆ‘â€‹Ï†(d)=f(nm)â€‹ å°†nnnè´¨å› æ•°åˆ†è§£p1c1Ã—p2c2Ã—p3c3Ã—â‹¯Ã—pkckp_1 ^ {c_{1}} \\times p_2 ^ {c_{2}} \\times p_3 ^ {c_{3}} \\times \\cdots \\times p_k ^ {c_{k}}p1c1â€‹â€‹Ã—p2c2â€‹â€‹Ã—p3c3â€‹â€‹Ã—â‹¯Ã—pkckâ€‹â€‹ã€‚ æ‰€ä»¥æœ‰ï¼Œ f(n)=f(p1c1)Ã—f(p2c2)Ã—â‹¯Ã—f(pkck)f(n) = f(p_1 ^ {c_{1}}) \\times f(p_2 ^ {c_{2}}) \\times \\cdots \\times f(p_k ^ {c_{k}}) f(n)=f(p1c1â€‹â€‹)Ã—f(p2c2â€‹â€‹)Ã—â‹¯Ã—f(pkckâ€‹â€‹) å…¶ä¸­çš„æ¯ä¸€é¡¹æœ‰ï¼š f(pc)=âˆ‘i=0cÏ†(pi)=pcf(p ^ c) = \\sum_{i = 0}^ c \\varphi(p^i) = p^c f(pc)=i=0âˆ‘câ€‹Ï†(pi)=pc æ‰€ä»¥å¾—è¯ï¼š f(n)=f(p1c1)Ã—f(p2c2)Ã—â‹¯Ã—f(pkck)=Î i=1kpici=n=âˆ‘dâˆ£nÏ†(d)f(n) = f(p_1 ^ {c_{1}}) \\times f(p_2 ^ {c_{2}}) \\times \\cdots \\times f(p_k ^ {c_{k}}) = \\Pi_{i =1}^k p_i^{c_i} = n = \\sum_{d \\mid n} \\varphi(d) f(n)=f(p1c1â€‹â€‹)Ã—f(p2c2â€‹â€‹)Ã—â‹¯Ã—f(pkckâ€‹â€‹)=Î i=1kâ€‹piciâ€‹â€‹=n=dâˆ£nâˆ‘â€‹Ï†(d)","link":"/2022/08/28/P3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"title":"P3338 [ZJOI2014]åŠ›","text":"P3338 [ZJOI2014]åŠ› é¢˜è§£ é¢˜æ„ ç»™å‡ºnnnä¸ªæ•°q1,q2,â€¦,qnq_1,q_2, \\dots, q_nq1â€‹,q2â€‹,â€¦,qnâ€‹å®šä¹‰ Fj=âˆ‘i=1jâˆ’1qiÃ—qj(iâˆ’j)2âˆ’âˆ‘i=j+1nqiÃ—qj(iâˆ’j)2Ei=FiqiF_j= \\sum_{i = 1} ^ {j - 1} \\frac{q_i \\times q_j}{(i - j)^2} - \\sum_{i = j + 1} ^ n \\frac{q_i \\times q_j}{(i - j) ^2} \\\\ E_i = \\frac{F_i} {q_i} Fjâ€‹=i=1âˆ‘jâˆ’1â€‹(iâˆ’j)2qiâ€‹Ã—qjâ€‹â€‹âˆ’i=j+1âˆ‘nâ€‹(iâˆ’j)2qiâ€‹Ã—qjâ€‹â€‹Eiâ€‹=qiâ€‹Fiâ€‹â€‹ å¯¹äº1â‰¤iâ‰¤n1 \\le i \\le n1â‰¤iâ‰¤n, æ±‚EiE_iEiâ€‹çš„å€¼ã€‚ 1â‰¤nâ‰¤1051 \\le n \\le 10 ^ 51â‰¤nâ‰¤105 è§£æ³• é¦–å…ˆè¿™ä¸ªé¢˜çš„æ•°æ®èŒƒå›´æœ‰å¾ˆå¤§çš„é—®é¢˜ï¼Œ åŸé¢˜ç›®ä¸­ç»™å‡ºçš„æ•°æ®èŒƒå›´ä¸º0&lt;qi&lt;1090 &lt; q_i &lt;10^ 90&lt;qiâ€‹&lt;109ï¼Œ ä½†æ˜¯æ•°æ®ä¸­å­˜åœ¨qi=0q_i = 0qiâ€‹=0çš„æƒ…å†µï¼Œ æ‰€ä»¥éœ€è¦åœ¨è®¡ç®—æ—¶å…ˆå°†qiq_iqiâ€‹æ¶ˆå»ï¼Œï¼ˆå¾ˆè®©äººä¸çˆ½ï¼‰ã€‚ ç°åœ¨è¦æ±‚è®¡ç®—çš„å°±æ˜¯ Fi=âˆ‘j=1iâˆ’1qj(iâˆ’j)2âˆ’âˆ‘i=j+1nqj(iâˆ’j)2F_i = \\sum_{j = 1} ^ {i - 1} \\frac{q_j}{(i - j)^2} - \\sum_{i = j + 1} ^ n \\frac{q_j}{(i - j)^2} Fiâ€‹=j=1âˆ‘iâˆ’1â€‹(iâˆ’j)2qjâ€‹â€‹âˆ’i=j+1âˆ‘nâ€‹(iâˆ’j)2qjâ€‹â€‹ é¦–å…ˆè€ƒè™‘æ‹†å¼€è®¡ç®—ï¼Œè®¾ä¸ºFi=Aiâˆ’BiF_i = A_i - B_iFiâ€‹=Aiâ€‹âˆ’Biâ€‹ï¼Œ Ai=âˆ‘j=1jâˆ’1qj(iâˆ’j)2A_i = \\sum_{j = 1} ^ {j - 1} \\frac{q_j}{(i - j)^2}Aiâ€‹=âˆ‘j=1jâˆ’1â€‹(iâˆ’j)2qjâ€‹â€‹ï¼Œè§‚å¯Ÿå¯çŸ¥ï¼Œæ˜¯ä¸€ä¸ªå·ç§¯çš„å½¢å¼ï¼Œå¯ä»¥å˜ä¸º Ai=âˆ‘j+k=iqjÃ—1k2A_i = \\sum_{j + k = i}q_j \\times \\frac{1}{k ^2} Aiâ€‹=j+k=iâˆ‘â€‹qjâ€‹Ã—k21â€‹ ç„¶åç”¨FFTå°±å¯ä»¥è®¡ç®—å‡ºAAAäº†ï¼Œç„¶åè€ƒè™‘BBBçš„å½¢å¼å’ŒAAAçš„ä¸€æ ·ï¼Œ å¯ä»¥ç›´æ¥å°†qiq_iqiâ€‹,reverseä¸€ä¸‹ï¼Œç„¶åè®¡ç®—å‡ºBBBå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int N =4e5 + 10;const double pi = acos(-1.0);struct Complex{ double x, y; Complex(double a = 0, double b = 0) : x(a), y(b) {} friend Complex operator + (Complex a, Complex b) {return Complex(a.x + b.x, a.y + b.y);} friend Complex operator - (Complex a, Complex b) {return Complex(a.x - b.x, a.y - b.y);} friend Complex operator * (Complex a, Complex b) {return Complex(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x);}};int n;double q[N], a[N], b[N];Complex F[N], G[N];int rev[N], len = 1;void FFT(Complex *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; rev[i])swap(a[i], a[rev[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { Complex x(cos(pi / k), type * sin(pi / k)); for(int i = 0; i &lt; len; i += k &lt;&lt; 1) { Complex w(1, 0); for(int j = 0; j &lt; k; j++) { Complex y = a[i + j]; Complex z = w * a[i + j + k]; a[i + j] = y + z; a[i + j + k] = y - z; w = w * x; } } } if(type == -1) for(int i = 0; i &lt; len; i++) a[i].x /= len;}void init(){ memset(F, 0, sizeof(F)); memset(G, 0, sizeof(G));}void Get(){ for(int i = 1; i &lt;= n; i++) F[i].x = q[i]; for(int i = 1; i &lt;= n; i++) G[i].x = 1.0 / i / i; FFT(F, len, 1), FFT(G, len, 1); for(int i = 0; i &lt;= len; i++) F[i] = F[i] * G[i]; FFT(F, len, -1);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;q[i]); int cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt;= len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); init(); Get(); for(int i = 1; i &lt;= n; i++) a[i] = F[i].x; reverse(q + 1, q + n + 1); init(); Get(); for(int i = 1; i &lt;= n; i++) b[i] = F[i].x; reverse(q + 1, q + n + 1); for(int i = 1; i &lt;= n; i++) printf(&quot;%.8lf\\n&quot;, a[i] - b[n - i + 1]); return 0;}","link":"/2022/11/06/P3338%20%5BZJOI2014%5D%E5%8A%9B/"},{"title":"Kruskalé‡æ„æ ‘","text":"æµ…è°ˆé‡æ„æ ‘ Kruskal é‡æ„æ ‘ ç®€ä»‹ Kruskalé‡æ„æ ‘å…¶å®å°±æ˜¯åœ¨Kruscalç®—æ³•è¿›è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€æ¬¡åŠ è¾¹éƒ½ä¼šåˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œæˆ‘ä»¬å¯ä»¥æ–°å»ºä¸€ä¸ªç‚¹ï¼Œå°†è¿™ä¸ªç‚¹çš„ç‚¹æƒè®¾ä¸ºæ–°åŠ çš„è¾¹çš„æƒå€¼ï¼ŒåŒæ—¶å°†ä¸¤ä¸ªé›†åˆçš„æ ¹èŠ‚ç‚¹åˆ†åˆ«è®¾ä¸ºæ–°å»ºçš„ç‚¹çš„å·¦å„¿å­å’Œå³å„¿å­ã€‚ç„¶åå°†ä¸¤ä¸ªé›†åˆå’Œæ–°å»ºç‚¹åˆå¹¶æˆä¸€ä¸ªé›†åˆã€‚å°†æ–°å»ºç‚¹è®¾ä¸ºæ ¹ã€‚ è¿™æ ·å»ºæˆçš„ä¸€æ£µäºŒå‰æ ‘å°±æ˜¯Kruskalé‡æ„æ ‘ã€‚ å¦‚ï¼š æ­¤å›¾çš„Kruskalé‡æ„æ ‘å¦‚ä¸‹ï¼š æ€§è´¨ è¯¥æ ‘æ»¡è¶³äºŒå‰å †çš„æ€§è´¨ï¼› è¿™é¢—äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ä¸º2nâˆ’12n-12nâˆ’1 ï¼Œæ·±åº¦æœ€å¤§ä¸ºnnn; é‡æ„æ ‘ä¸­ä»£è¡¨åŸæ ‘ä¸­çš„ç‚¹çš„èŠ‚ç‚¹å…¨æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå…¶ä½™èŠ‚ç‚¹éƒ½ä»£è¡¨äº†ä¸€æ¡è¾¹çš„è¾¹æƒï¼› åŸå›¾ä¸­ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒçš„æœ€å°å€¼ = Kruskal é‡æ„æ ‘ä¸Šä¸¤ç‚¹ä¹‹é—´çš„ LCA çš„æƒå€¼ã€‚ å› ä¸ºåœ¨åŠ è¾¹çš„æ—¶å€™æ‰€æœ‰çš„è¾¹éƒ½æ˜¯å·²ç»æ’åºè¿‡çš„æ‰€ä»¥ç¬¦åˆäºŒå‰å †çš„æ€§è´¨ã€‚ åˆå› ä¸ºäºŒå‰å †çš„æ€§è´¨æ‰€ä»¥Kruskal é‡æ„æ ‘ä¸Šä¸¤ç‚¹ä¹‹é—´çš„ LCA çš„æƒå€¼å³ä¸ºåŸå›¾ä¸­ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒçš„æœ€å°å€¼ã€‚ è‹¥æ±‚ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šæœ€å°è¾¹æƒçš„æœ€å¤§å€¼ï¼Œè¦å»ºæœ€å¤§ç”Ÿæˆæ ‘ã€‚ æ„é€  é¦–å…ˆå¯¹è¾¹æ’åº ç„¶åä½¿ç”¨å¹¶æŸ¥é›†è¾…åŠ©åŠ è¾¹ï¼š æ¯æ–°å»ºä¸€æ¡è¾¹æ—¶ï¼Œæ–°å»ºä¸€ä¸ªç‚¹ï¼Œè®¾æ–°å»ºç‚¹çš„æƒå€¼ä¸ºæ–°åŠ è¾¹çš„è¾¹æƒï¼Œåˆå¹¶é›†åˆã€‚ ä»£ç ï¼š 1234567891011121314151617void kruskal(){ sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n*2;i++)f[i]=i;// 2n-1ä¸ªèŠ‚ç‚¹ for(int i=1;i&lt;=m;i++) { if(cnt==2*n-1)break; int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt; tree[cnt].push_back(y); tree[cnt].push_back(x); w[cnt]=e[i].c; } return;} æ—¶é—´å¤æ‚åº¦O(nlog2n)O(nlog_2n)O(nlog2â€‹n)ã€‚ åº”ç”¨ Kruskalé‡æ„æ ‘èƒ½å¤Ÿæ›´å¿«æœ‰æ•ˆè§£å†³ä¸€äº›é™æ€çš„æ ‘å‰–é—®é¢˜ï¼Œè€Œä¸”å¤æ‚åº¦è¿˜å¾ˆä¼˜ç§€ã€‚ luogu U92652 ã€æ¨¡æ¿ã€‘Kruskalé‡æ„æ ‘ ä¸€é“æ¿å­é¢˜ï¼ˆæ³¨æ„å»ºæˆçš„åº”æ˜¯ä¸€ä¸ªæ£®æ—ï¼‰ã€‚ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;const int Max=300010;int n,m,q,cnt;struct node{ int u,v,c;}e[Max];int f[Max*2],w[Max*2],lg[Max*2];int depth[Max*2],fa[Max*2][30];vector&lt;int&gt; mp[Max*2];int cmp(node x,node y){ return x.c&lt;y.c;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruskal(){ for(int i=1;i&lt;=n*2;i++)f[i]=i; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) { int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=cnt;f[y]=cnt; w[cnt]=e[i].c; mp[cnt].push_back(x); mp[cnt].push_back(y); } return;}void dfs(int now,int father){ depth[now]=depth[father]+1; fa[now][0]=father; for(int i=1;i&lt;=lg[depth[now]];i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;mp[now].size();i++) { int x=mp[now][i]; if(depth[x])continue; dfs(x,now); } return;}int LCA(int x,int y){ if(Find(x)!=Find(y))return -1; if(depth[x]&lt;depth[y])swap(x,y); while(depth[x]&gt;depth[y]) x=fa[x][lg[depth[x]-depth[y]]]; if(x==y)return w[x]; for(int i=lg[depth[x]];i&gt;=0;i--) { if(fa[x][i]==fa[y][i])continue; x=fa[x][i]; y=fa[y][i]; } return w[fa[x][0]];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); cnt=n; for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].c); kruskal(); for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); for(int i=1;i&lt;=cnt;i++) { if(f[i]!=i)continue; if(depth[f[i]])continue; dfs(f[i],0); } for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,LCA(x,y)); } return 0;} luogu P1967 è´§è½¦è¿è¾“ å…¶å®è¯¥é—®é¢˜å¯ä»¥è½¬æ¢ä¸ºæ±‚xxxå·åŸå¸‚åˆ°yyyå·åŸå¸‚æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šå°è¾¹æƒçš„æœ€å¤§å€¼ï¼ˆæ³¨æ„è¯¥å›¾å»ºæˆçš„ä¸ºä¸€ä¸ªæ£®æ—ï¼‰ã€‚ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;const int maxm=5e4+10;int n,m,q,cnt;struct node{ int u,v,c;}e[maxm];int f[maxn*2],depth[maxn*2],father[maxn*2][30];int lg[maxn*2],w[maxn*2];vector&lt;int&gt; mp[maxn*2];int cmp(node x,node y){ return x.c&gt;y.c;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruscal(){ for(int i=1;i&lt;=n*2;i++)f[i]=i; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) { int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt;w[cnt]=e[i].c; mp[cnt].push_back(x); mp[cnt].push_back(y); } return;}void dfs(int now,int fa){ depth[now]=depth[fa]+1; father[now][0]=fa; for(int i=1;i&lt;=lg[depth[now]];i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=0;i&lt;mp[now].size();i++) { int x=mp[now][i]; if(depth[x])continue; dfs(x,now); } return;}int LCA(int x,int y){ if(Find(x)!=Find(y))return -1; if(depth[x]&lt;depth[y])swap(x,y); while(depth[x]&gt;depth[y]) x=father[x][lg[depth[x]-depth[y]]]; if(x==y)return w[x]; for(int i=lg[depth[x]];i&gt;=0;i--) { if(father[x][i]==father[y][i])continue; x=father[x][i];y=father[y][i]; } return w[father[x][0]];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].c); cnt=n; kruscal(); for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); for(int i=1;i&lt;=cnt;i++) { if(f[i]!=i)continue; if(depth[f[i]])continue; dfs(f[i],0); } scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,LCA(x,y)); } return 0;} luogu P4768 [NOI2018] å½’ç¨‹ è¿™é“é¢˜ä¸»è¦åœ¨äºæ±‚æœ€å°çš„æ­¥è¡Œè·¯ç¨‹ï¼Œä¸ç”¨è€ƒè™‘å¼€è½¦æ‰€ç»è¿‡çš„è·¯ç¨‹ã€‚ æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¸¤ç‚¹ä¹‹é—´è·¯å¾„ä¸Šçš„è¾¹æƒæœ€å°å€¼æœ€å¤§å³å¯ï¼Œè®¾è¿™ä¸ªå€¼ä¸ºhhh,è‹¥h&gt;Sh&gt;Sh&gt;S,åˆ™æ­¥è¡Œè·¯ç¨‹ä¸ºé›¶ï¼Œè‹¥hâ‰¤Sh\\le Shâ‰¤Sï¼Œæˆ‘ä»¬ä¾¿éœ€è¦å»åˆ¤æ–­åœ¨å“ªé‡Œä¸‹è½¦ã€‚ åœ¨Kruskalé‡æ„æ ‘ä¸­ï¼Œä»»æ„èŠ‚ç‚¹çš„å­æ ‘èŠ‚ç‚¹éƒ½æ˜¯å¯ä»¥ç›¸äº’æŠµè¾¾çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨æ ‘ä¸Šå€å¢å»æ±‚å‡ºï¼Œè¿™æ£µæ ‘ä¸Šå¤§äºæ°´ä½çº¿çš„æœ€å°å€¼ï¼Œç„¶åè¾“å‡ºè¿™ä¸ªèŠ‚ç‚¹å­æ ‘ä¸­ï¼Œåˆ°è¾¾ç»ˆç‚¹çš„æœ€çŸ­è·¯çš„æœ€å°å€¼ã€‚ æœ€çŸ­è·¯+æ ‘ä¸Šå€å¢+Kruskalé‡æ„æ ‘ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e5+10;const int maxm=4e5+10;const ll INF=5147483647;int T,n,m,q,k,s,cnt;ll lastans;int f[maxn*2],lg[maxn];int depth[maxn*2],fa[maxn*2][31];struct node{ int u,v,l,a;}e[maxm];struct road{ int to,cost;};struct power{ ll w,l;}p[maxn*2];vector&lt;road&gt; mp[maxn];vector&lt;int&gt; tree[maxn*2];typedef pair&lt;ll,int&gt; Pair;void _clean(){ memset(f,0,sizeof(f)); memset(depth,0,sizeof(depth)); for(int i=0;i&lt;=cnt;i++) for(int j=0;j&lt;=30;j++) fa[i][j]=0; for(int i=1;i&lt;=n;i++)mp[i].clear(); for(int i=1;i&lt;=cnt;i++)tree[i].clear(); cnt=0;lastans=0;}void makelog(){ for(int i=1;i&lt;=maxn;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); return;}bool cmp(node x,node y){ return x.a&gt;y.a;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruscal(){ sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n*2;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { if(cnt==2*n-1)break; int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt; tree[cnt].push_back(y); tree[cnt].push_back(x); p[cnt].w=e[i].a; } for(int i=1;i&lt;=cnt;i++)p[i].l=INF; return;}void dij(){ priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt; q; bool vis[maxn];ll dis[maxn]; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;i++)dis[i]=INF; dis[1]=0; q.push(make_pair(0,1)); while(!q.empty()) { int x=q.top().second; int c=q.top().first; q.pop(); if(vis[x])continue; vis[x]=true; for(int i=0;i&lt;mp[x].size();i++) { if(dis[mp[x][i].to]&gt;dis[x]+mp[x][i].cost) { dis[mp[x][i].to]=dis[x]+mp[x][i].cost; q.push(make_pair(dis[mp[x][i].to],mp[x][i].to)); } } } for(int i=1;i&lt;=n;i++)p[i].l=dis[i]; return;}void dfs(int now,int father){ depth[now]=depth[father]+1; fa[now][0]=father; for(int i=1;i&lt;=lg[depth[now]];i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;tree[now].size();i++) { dfs(tree[now][i],now); p[now].l=min(p[now].l,p[tree[now][i]].l);// æ›´æ–°æœ€çŸ­è·¯æœ€å°å€¼ } return;}ll ask(int x,int y){ for(int i=lg[depth[x]];i&gt;=0;i--) if(p[fa[x][i]].w&gt;y)x=fa[x][i]; return p[x].l;}int main(){ makelog(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); cnt=n; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].l,&amp;e[i].a); mp[e[i].u].push_back((road){e[i].v,e[i].l}); mp[e[i].v].push_back((road){e[i].u,e[i].l}); } kruscal(); dij(); dfs(cnt,0); scanf(&quot;%d%d%d&quot;,&amp;q,&amp;k,&amp;s); for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int vx=(x+k*lastans-1)%n+1; int py=(y+k*lastans)%(s+1); lastans=ask(vx,py); printf(&quot;%lld\\n&quot;,lastans); } _clean(); } return 0;} å®Œç»“æ’’èŠ±~~","link":"/2022/06/13/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"title":"P3830 [SHOI2012]éšæœºæ ‘","text":"P3830 [SHOI2012]éšæœºæ ‘ é¢˜è§£ é¢˜æ„ è§£æ³• é¦–å…ˆè§£å†³ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå¶èŠ‚ç‚¹å¹³å‡æ·±åº¦çš„æœŸæœ›å€¼ï¼Œå¯ä»¥è®¾fif_ifiâ€‹è¡¨ç¤ºæœ‰iiiä¸ªå¶å­èŠ‚ç‚¹çš„éšæœºæ ‘çš„å¹³å‡æ·±åº¦çš„æœŸæœ›å€¼ï¼Œå¯ä»¥å¾—åˆ°è½¬ç§»æ–¹ç¨‹ä¸º fi=fiâˆ’1Ã—(iâˆ’1)âˆ’fiâˆ’1+(fiâˆ’1+1)Ã—2if_i = \\frac{f_{i - 1} \\times (i - 1) - f_{i - 1} + (f_{i - 1} + 1) \\times 2}{i} fiâ€‹=ifiâˆ’1â€‹Ã—(iâˆ’1)âˆ’fiâˆ’1â€‹+(fiâˆ’1â€‹+1)Ã—2â€‹ å…¶å®å°±æ˜¯è®¡ç®—å½“å‰æœ‰iiiä¸ªå¶å­èŠ‚ç‚¹æ—¶åœ¨iâˆ’1i - 1iâˆ’1ä¸ªå¶å­èŠ‚ç‚¹çš„æƒ…å†µä¸‹ï¼Œå±•å¼€ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®¡ç®—å…¶æ·±åº¦çš„å½±å“ï¼ŒåŒ–ç®€åä¹Ÿå°±æ˜¯ fi=fiâˆ’1+2if_i= f_{i- 1} + \\frac{2} {i} fiâ€‹=fiâˆ’1â€‹+i2â€‹ ç„¶åç¬¬äºŒä¸ªé—®é¢˜å°±éº»çƒ¦äº†ï¼Œæ ‘æ·±åº¦çš„æœŸæœ›å€¼ï¼Œé¦–å…ˆæ ¹æ®æœŸæœ›çš„çº¿æ€§æ€§æœ‰ E(x)=âˆ‘i=1+âˆP(iâ‰¤x)E(x) = \\sum_{i = 1} ^ {+ \\infty} P(i \\le x) E(x)=i=1âˆ‘+âˆâ€‹P(iâ‰¤x) ç„¶åå¯ä»¥è®¾fi,jf_{i, j}fi,jâ€‹ä¸ºæœ‰iiiä¸ªå¶å­èŠ‚ç‚¹ä¸”æ·±åº¦å¤§äºç­‰äºjjjçš„æ ‘çš„å‡ºç°æ¦‚ç‡ï¼Œå¾—å‡ºè½¬ç§»æ–¹ç¨‹ä¸º fi,j=âˆ‘k=1iâˆ’1fk,jâˆ’1+fiâˆ’k,jâˆ’1âˆ’fk,jâˆ’1Ã—fiâˆ’k,jâˆ’1iâˆ’1f_{i, j} = \\sum_{k = 1} ^ {i - 1} \\frac{f_{k, j - 1} + f_{i - k, j - 1} - f_{k, j - 1} \\times f_{i - k, j - 1}}{i- 1} fi,jâ€‹=k=1âˆ‘iâˆ’1â€‹iâˆ’1fk,jâˆ’1â€‹+fiâˆ’k,jâˆ’1â€‹âˆ’fk,jâˆ’1â€‹Ã—fiâˆ’k,jâˆ’1â€‹â€‹ é¦–å…ˆkkkæ—¶æšä¸¾çš„å·¦å­æ ‘ä¸­å¶å­èŠ‚ç‚¹çš„æ•°é‡ï¼Œç„¶åæ±‚å·¦å­æ ‘ä¸­æ·±åº¦å¤§äºç­‰äºjâˆ’1j - 1jâˆ’1 çš„æ¦‚ç‡ï¼Œç”±äºå·¦å³å­æ ‘æ·±åº¦éƒ½å¤§äºjâˆ’1j - 1jâˆ’1çš„æƒ…å†µåœ¨fk,jâˆ’1f_{k , j - 1}fk,jâˆ’1â€‹å’Œfiâˆ’k,jâˆ’1f_ {i - k, j - 1}fiâˆ’k,jâˆ’1â€‹ä¸­éƒ½ç»Ÿè®¡è¿‡ï¼Œæ‰€ä»¥è¦å»å‡å»é‡å¤çš„éƒ¨åˆ†ï¼Œå¯¹äºé™¤ä»¥iâˆ’1i - 1iâˆ’1çš„éƒ¨åˆ†å¯ä»¥å»çœ‹è¿™ä¸ªè¯æ˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n, q;namespace SubTask1{ double f[N]; void getans() { for(int i = 2; i &lt;= n; i++) f[i] = f[i - 1] + 2.0 / i; printf(&quot;%.6lf&quot;, f[n]); }}namespace SubTask2{ double f[N][N]; void getans() { for(int i = 1; i &lt;= n; i++) f[i][0] = 1; for(int i = 2; i &lt;= n; i++) { for(int j = 1; j &lt; i; j++) { for(int k = 1; k &lt; i; k++) f[i][j] += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1]; f[i][j] /= (i - 1) * 1.0; } } double ans = 0; for(int i = 1; i &lt; n; i++) ans += f[n][i]; printf(&quot;%.6lf&quot;, ans); }}int main(){ scanf(&quot;%d%d&quot;, &amp;q, &amp;n); if(q == 1)SubTask1::getans(); if(q == 2)SubTask2::getans(); return 0;}","link":"/2022/11/01/P3830%20%5BSHOI2012%5D%E9%9A%8F%E6%9C%BA%E6%A0%91/"},{"title":"P4841 [é›†è®­é˜Ÿä½œä¸š2013]åŸå¸‚è§„åˆ’","text":"P4841 [é›†è®­é˜Ÿä½œä¸š2013]åŸå¸‚è§„åˆ’ é¢˜è§£ é¢˜æ„ æ±‚nnnä¸ªç‚¹çš„ç®€å•(æ— é‡è¾¹æ— è‡ªç¯)æœ‰æ ‡å·æ— å‘è¿é€šå›¾æ•°ç›®ï¼Œå¯¹100453580910045358091004535809å–æ¨¡ã€‚ è§£æ³• è®¾f(n)f(n)f(n)ä¸ºç‚¹æ•°ä¸ºnnnçš„æ— å‘è¿é€šå›¾çš„æ•°é‡ï¼Œg(n)g(n)g(n)ä¸ºç‚¹æ•°ä¸ºnnnçš„æ— å‘å›¾ä¹‹é—´è¿è¾¹çš„æ–¹æ¡ˆæ•°ï¼Œå¯¹äºä»»æ„ä¸¤ä¸ªç‚¹å¯ä»¥è¿æˆ–ä¸è¿ï¼Œæ˜“å¾—g(n)=2(n2)g(n) = 2 ^ {\\binom{n}{2}}g(n)=2(2nâ€‹)ï¼Œç„¶åé’¦å®šä¸€ä¸ªç‚¹ï¼Œ æšä¸¾è®¾è¿™ä¸ªç‚¹çš„è¿é€šå—å¤§å°ï¼Œå¾— g(n)=âˆ‘i=1n(nâˆ’1iâˆ’1)f(i)g(nâˆ’i)g(n) = \\sum_{i = 1} ^ n \\dbinom{n - 1}{i - 1}f(i) g(n - i) g(n)=i=1âˆ‘nâ€‹(iâˆ’1nâˆ’1â€‹)f(i)g(nâˆ’i) ç„¶ååŒ–ç®€å¼å­ 2(n2)=âˆ‘i=1n(nâˆ’1iâˆ’1)f(i)2(nâˆ’i2)2(n2)(nâˆ’1)!=âˆ‘i=1nf(i)(iâˆ’1)!2(nâˆ’i2)(nâˆ’i)!2^{\\binom{n}{2}} = \\sum_{ i= 1}^n \\dbinom{n - 1}{i - 1}f(i)2^{\\binom{n - i}{2}}\\\\ \\frac{2 ^ {\\binom{n}{2}}}{(n - 1) !} = \\sum_{i = 1} ^ n \\frac{f(i)}{(i - 1) !} \\frac{2 ^ {\\binom{n - i}{2}}}{(n - i)!} 2(2nâ€‹)=i=1âˆ‘nâ€‹(iâˆ’1nâˆ’1â€‹)f(i)2(2nâˆ’iâ€‹)(nâˆ’1)!2(2nâ€‹)â€‹=i=1âˆ‘nâ€‹(iâˆ’1)!f(i)â€‹(nâˆ’i)!2(2nâˆ’iâ€‹)â€‹ å¯ä»¥çœ‹å‡ºæ˜¯ä¸€ä¸ªå·ç§¯çš„å½¢å¼ï¼Œç„¶åæ„é€ å¤šé¡¹å¼ F(x)=âˆ‘i=1âˆf(i)(iâˆ’1)!xiG(x)=âˆ‘i=0âˆ2(i2)i!xiH(x)=âˆ‘i=1âˆ2(i2)(iâˆ’1)!xiF(x) = \\sum_{i = 1} ^ {\\infty} \\frac{f(i)}{(i - 1) !}x^i \\\\ G(x) = \\sum_{i = 0} ^ {\\infty}\\frac{2 ^ {\\binom{i}{2}}}{i!}x^i \\\\ H(x) = \\sum_{i = 1} ^ {\\infty} \\frac{2 ^ {\\binom{i}{2}}}{(i - 1) !}x^i F(x)=i=1âˆ‘âˆâ€‹(iâˆ’1)!f(i)â€‹xiG(x)=i=0âˆ‘âˆâ€‹i!2(2iâ€‹)â€‹xiH(x)=i=1âˆ‘âˆâ€‹(iâˆ’1)!2(2iâ€‹)â€‹xi ä¹‹å‰æ¨å‡ºæ¥H=Fâˆ—GH = F \\ast GH=Fâˆ—Gï¼Œ æ‰€ä»¥F=Hâˆ—Gâˆ’1(modxn+1)F = H \\ast G ^{-1} \\pmod {x ^ {n + 1}}F=Hâˆ—Gâˆ’1(modxn+1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;bits/stdc++.h&gt;using namespace std;namespace Poly// ä½¿ç”¨NTTå®ç°{ #define int long long #define vec vector &lt;int&gt; const int mod = 1004535809; // æ¨¡æ•° const int g = 3; // åŸæ ¹ const int gi = 334845270; // é€†å…ƒ const int N = 6e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// å¿«é€Ÿå¹‚ int inv(int x) { return qpow(x, mod - 2);}// é€†å…ƒ void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// åˆå§‹åŒ– void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// ä¹˜æ³•é€† void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// å¤šé¡¹å¼æ±‚å¯¼ void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// å¤šé¡¹å¼ç§¯åˆ† poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// å¤šé¡¹å¼lnå‡½æ•° void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼expå‡½æ•° const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼å¼€æ ¹ void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// å¤šé¡¹å¼å¹‚å‡½æ•° #undef int}using namespace Poly;#define int long longint n;int fac[N], ifac[N];int c(int n, int m){ if(n &lt; m)return 0; return n * (n - 1) / 2 % (mod - 1);}signed main(){ scanf(&quot;%lld&quot;, &amp;n); n = n + 1; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); poly F, G, H; G.clear(n); for(int i = 0; i &lt; n; i++) G.v[i] = qpow(2, c(i, 2)) * ifac[i] % mod; H.clear(n); for(int i = 1; i &lt; n; i++) H.v[i] = qpow(2, c(i, 2)) * ifac[i - 1] % mod; F.clear(n); inverse(G, F, n); F = F * H; printf(&quot;%lld&quot;, F.v[n - 1] * fac[n - 2] % mod); return 0;}","link":"/2022/10/08/P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/"},{"title":"UVA10173 Smallest Bounding Rectangle","text":"UVA10173 Smallest Bounding Rectangle é¢˜æ„ ç»™å®šå¤šç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®ç»™å®š nnn ä¸ªåæ ‡ï¼Œæ±‚èƒ½è¦†ç›–è¿™nnnä¸ªç‚¹çš„æœ€å°çŸ©å½¢ï¼Œå¹¶è¾“å‡ºå…¶é¢ç§¯ã€‚ æ€è·¯ å…¶å®è¿™é“é¢˜è·ŸP3187 [HNOI2007]æœ€å°çŸ©å½¢è¦†ç›–å¹¶æ²¡æœ‰å¤šå¤§çš„åŒºåˆ«ï¼Œè€Œä¸”ä¹Ÿçœå»äº†æ±‚çŸ©å½¢é¡¶ç‚¹åæ ‡çš„æ­¥éª¤ï¼Œï¼ˆå½“æ—¶å†…å¿ƒæ˜¯éå¸¸å¼€å¿ƒï¼Œä½†å‘ç°è¿™æ•°æ®æ¯”P3187å¼ºå¾—å¤šçš„æ—¶å€™ï¼Œå†…å¿ƒæ˜¯å´©æºƒçš„ã€‚ã€‚ã€‚ï¼‰ï¼Œä½†è¿™é“é¢˜æ˜¾ç„¶æ•°æ®æ˜¯å¼ºå¾—å¤ªå¤šäº†ï¼Œæˆ‘ä¸€ä»½Aäº†P3187çš„ä»£ç å¹¶æ²¡æœ‰è¿‡ä¸äº†è¿™é“é¢˜ã€‚ã€‚ï¼ˆæˆ‘åæ¥æ”¹äº†ä¸€ä¸‹æ‰¾å·¦è¾¹ç‚¹æ—¶çš„æ—‹è½¬æ–¹å‘å¥½åƒå°±Aäº†ï¼‰æƒ³è¦æ¯”è¾ƒå¼ºçš„æ•°æ®çš„è¯å¯ä»¥ä¸Šè¿™é‡Œã€‚ å¯¹äºæœ€å°çŸ©å½¢è¦†ç›–ï¼Œå…¶æœ€å°çŸ©å½¢çš„ä¸€æ¡è¾¹å¿…å®šåœ¨è¿™nnnä¸ªç‚¹çš„å‡¸åŒ…ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬å°±å…ˆæ±‚å‡ºå‡¸åŒ…å†ä½¿ç”¨æ—‹è½¬å¡å£³ï¼Œæ‰¾åˆ°åœ¨ä»¥å½“å‰è¾¹ä¸ºçŸ©å½¢çš„ä¸€æ¡è¾¹æ—¶ï¼Œåœ¨æœ€å·¦è¾¹ï¼Œæœ€å³è¾¹ï¼Œæœ€ä¸Šè¾¹çš„ç‚¹ï¼Œç„¶åç”¨å‘é‡åŠ å‡çš„æ–¹æ³•æ±‚å‡ºçŸ©å½¢çš„é«˜å’Œå®½ï¼Œå†è¿›ä¸€æ­¥æ±‚é¢ç§¯å°±å¥½äº†ã€‚ ï¼ˆåˆ«å¿˜äº†ä¼šå‡ºç°æœ€å°çŸ©å½¢è¦†ç›–æ— è§£çš„æƒ…å†µï¼‰ã€‚ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define double long double #define eps 1e-18using namespace std;const int maxn=5e4+10;struct geometric { double x, y; geometric(double X=0, double Y=0) :x(X), y(Y) {} friend geometric operator + (const geometric a, const geometric b) { return geometric(a.x+b.x, a.y+b.y); } friend geometric operator - (const geometric a, const geometric b) { return geometric(a.x-b.x, a.y-b.y); } friend geometric operator * (const geometric a, double p) { return geometric(a.x*p, a.y*p); } friend geometric operator / (const geometric a, double p) { return geometric(a.x/p, a.y/p); }// å‘é‡çš„å››åˆ™è¿ç®—}p[maxn], st[maxn];int n, cnt, top;double S=1e20;double dis(geometric a, geometric b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } // å‘é‡æ¨¡é•¿double dot(geometric a1, geometric a2, geometric b1, geometric b2) { return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y); }// ç‚¹ç§¯double cross(geometric a1, geometric a2, geometric b1, geometric b2) { return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x); } // å‰ç§¯bool cmp(geometric a, geometric b){ double tmp; tmp=cross(p[1], a, p[1], b); if(tmp&gt;0)return true; if(tmp==0)return dis(p[1], a)&lt;=dis(p[1], b); return false;}int main(){ while(true) { memset(st,0,sizeof(st)); memset(p,0,sizeof(p)); scanf(&quot;%d&quot;, &amp;n); if(n==0)break; top=0;cnt=0;S=1e20; for(int i=1;i&lt;=n;i++) { double x, y; scanf(&quot;%Lf%Lf&quot;, &amp;x, &amp;y); p[++cnt]=geometric(x, y); if(i==1) continue; if(p[cnt].y&lt;p[1].y) swap(p[cnt], p[1]); if(p[cnt].y==p[1].y&amp;&amp;p[cnt].x&gt;p[1].x) swap(p[cnt], p[1]); } sort(p+2, p+cnt+1, cmp); st[++top]=p[1]; for(int i=2;i&lt;=cnt;i++) { while(top&gt;1&amp;&amp;cross(st[top-1], st[top], st[top], p[i])&lt;=0) top--; st[++top]=p[i]; } st[++top]=p[1]; // æ±‚å‡¸åŒ… if(top&lt;=3) { printf(&quot;0.0000\\n&quot;); continue; } // å‡¸åŒ…é¡¶ç‚¹åªæœ‰ä¸¤ä¸ªæ—¶ï¼Œæœ€å°çŸ©å½¢è¦†ç›–æ— è§£ã€‚ st[0]=st[top-1]; for(int i=2, j=3,l,r;i&lt;=top;i++) { r=(i==top)?1:i;l=i-1; while(cross(st[i-1], st[i], st[i], st[j])&lt;cross(st[i-1], st[i], st[i], st[j+1])) j=(j==top-1)?1:j+1; // æ‰¾æœ€ä¸Šè¾¹çš„ç‚¹ while(dot(st[i-1], st[i], st[i], st[r])&lt;dot(st[i-1], st[i], st[i], st[r+1])) r=(r==top-1)?1:r+1; // æ‰¾æœ€å³è¾¹çš„ç‚¹ while(dot(st[i], st[i-1], st[i-1], st[l])&lt;dot(st[i], st[i-1], st[i-1], st[l-1])) l=(l==1)?top-1:l-1; // æ‰¾æœ€å·¦è¾¹çš„ç‚¹ double wide, high, len=dis(st[i-1], st[i]); wide=fabs(dot(st[i], st[i-1], st[i-1], st[l]))/len+fabs(dot(st[i-1], st[i], st[i], st[r]))/len+len; // å®½ high=fabs(cross(st[i-1], st[i], st[i-1], st[j]))/len; // é«˜ S=min(S, high*wide); } printf(&quot;%.4Lf\\n&quot;, S); } return 0;} æ„Ÿè°¢è§‚çœ‹ï¼ï¼ï¼","link":"/2022/06/29/UVA10173-Smallest-Bounding-Rectangle/"},{"title":"P3312 [SDOI2014]æ•°è¡¨","text":"P3312 [SDOI2014]æ•°è¡¨ é¢˜è§£ é¢˜æ„ æ±‚ï¼Œ âˆ‘i=1nâˆ‘j=1mÏƒ(gcdâ¡(i,j))[Ïƒ(gcdâ¡(i,j))â‰¤k]\\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\sigma(\\gcd(i, j)) [\\sigma(\\gcd(i, j)) \\le k] i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹Ïƒ(gcd(i,j))[Ïƒ(gcd(i,j))â‰¤k] 1â‰¤n,mâ‰¤105ï¼Œ1â‰¤Tâ‰¤2Ã—1041 \\le n, m \\le 10 ^ 5ï¼Œ 1 \\le T \\le 2 \\times 10 ^ 41â‰¤n,mâ‰¤105ï¼Œ1â‰¤Tâ‰¤2Ã—104ã€‚ è§£æ³• è€ƒè™‘åˆ°TTTç»„æ•°æ®æ˜¾ç„¶ä¸èƒ½æ¯æ¬¡éƒ½é‡æ–°å¤„ç†ä¸€éï¼Œå…ˆä¸è€ƒè™‘é™åˆ¶ï¼ŒåŒ–ä¸€ä¸‹æŸ¿å­ï¼Œ ans=âˆ‘i=1nâˆ‘j=1mÏƒ(gcdâ¡(i,j))=âˆ‘t=1Ïƒ(t)âˆ‘i=1âŒŠntâŒ‹âˆ‘j=1âŒŠmtâŒ‹[gcdâ¡(i,j)=1]=âˆ‘t=1Ïƒ(t)âˆ‘i=1âŒŠntâŒ‹âˆ‘j=1âŒŠmtâŒ‹âˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘t=1Ïƒ(t)âˆ‘d=1Î¼(d)âˆ‘i=1âŒŠntdâŒ‹âˆ‘j=1âŒŠmtdâŒ‹1\\begin{aligned} ans &amp; = \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\sigma(\\gcd(i, j)) \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} [\\gcd(i, j) = 1] \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} \\sum_{d | \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{d = 1} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} 1 \\end{aligned} ansâ€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹Ïƒ(gcd(i,j))=t=1âˆ‘â€‹Ïƒ(t)i=1âˆ‘âŒŠtnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtmâ€‹âŒ‹â€‹[gcd(i,j)=1]=t=1âˆ‘â€‹Ïƒ(t)i=1âˆ‘âŒŠtnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtmâ€‹âŒ‹â€‹dâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=t=1âˆ‘â€‹Ïƒ(t)d=1âˆ‘â€‹Î¼(d)i=1âˆ‘âŒŠtdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtdmâ€‹âŒ‹â€‹1â€‹ åŠ ä¸Šé™åˆ¶æŸ¿å­å˜ä¸ºï¼Œ ans=âˆ‘Ïƒ(t)â‰¤kâˆ‘d=1Î¼(d)âˆ‘i=1âŒŠntdâŒ‹âˆ‘j=1âŒŠmtdâŒ‹1ans = \\sum_{\\sigma(t) \\le k} \\sum_{d = 1} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} 1 ans=Ïƒ(t)â‰¤kâˆ‘â€‹d=1âˆ‘â€‹Î¼(d)i=1âˆ‘âŒŠtdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtdmâ€‹âŒ‹â€‹1 ç„¶åæšä¸¾tdtdtdï¼Œ ans=âˆ‘p=1âŒŠnpâŒ‹âŒŠmpâŒ‹âˆ‘1â‰¤Ïƒ(d)â‰¤kÏƒ(d)Î¼(pd)ans = \\sum_{p = 1} \\lfloor \\frac{n}p \\rfloor \\lfloor \\frac{m}{p} \\rfloor \\sum_{1 \\le \\sigma(d) \\le k} \\sigma(d) \\mu({\\frac{p}{d}}) ans=p=1âˆ‘â€‹âŒŠpnâ€‹âŒ‹âŒŠpmâ€‹âŒ‹1â‰¤Ïƒ(d)â‰¤kâˆ‘â€‹Ïƒ(d)Î¼(dpâ€‹) å¯ä»¥å…ˆå°†è¯¢é—®ç¦»çº¿ä¸‹æ¥ï¼ŒæŒ‰kkkæ’åºï¼Œæ ‘çŠ¶æ•°ç»„åŠ¨æ€ç»´æŠ¤å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(Tnlogâ¡n+nlogâ¡2n)O(T\\sqrt n \\log n + n \\log^2 n)O(Tnâ€‹logn+nlog2n)ã€‚ (æ³¨æ„çº¦æ•°å’Œä¸æ˜¯å•è°ƒé€’å¢çš„(ç»´ç”Ÿç´ b)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 10;const int M = 1e5;const ll mod = (1ll &lt;&lt; 31);int n, m;struct query{ int n, m, k, i; query(int n = 0, int m = 0, int k = 0, int i = 0) : n(n), m(m), k(k), i(i) {} friend bool operator &lt; (query a, query b) {return a.k &lt; b.k;}};query q[N];ll ans[N];struct BIT{ ll b[N]; BIT(){memset(b, 0, sizeof(b));} int lowbit(int x){return x &amp; (-x);} void add(int x, ll k) { for(int i = x; i &lt;= M; i += lowbit(i)) b[i] = (b[i] + k) % mod; } ll sum(int x) { ll s = 0; for(int i = x; i &gt;= 1; i -= lowbit(i)) s = (s + b[i]) % mod; return s; } ll query(int l, int r) { return (sum(r) - sum(l - 1) + mod) % mod; }};BIT bit;int prime[N], cnt, mu[N];bool vis[N];struct node{ int i, s; friend bool operator &lt; (node a, node b) {return a.s &lt; b.s;}};node S[N];void init(){ mu[1] = 1; for(int i = 2; i &lt;= M; i++) { if(!vis[i])prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= M; j++) { vis[i * prime[j]] = true; if(i % prime[j] == 0)break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= M; i++) S[i].i = i; for(int i = 1; i &lt;= M; i++) for(int j = i; j &lt;= M; j += i) S[j].s = (S[j].s + i * 1ll) % mod; sort(S + 1, S + M + 1);}int main(){ init(); int T; scanf(&quot;%d&quot;, &amp;T); for(int i = 1; i &lt;= T; i++) { int n, m, k; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); q[i] = query(n, m, k, i); } sort(q + 1, q + T + 1); for(int i = 1, j = 1; i &lt;= T; i++) { while(S[j].s &lt;= q[i].k &amp;&amp; j &lt; M) { for(int k = S[j].i; k &lt;= M; k += S[j].i) bit.add(k, (S[j].s * mu[k / S[j].i] % mod + mod) % mod); j++; } int n = q[i].n, m = q[i].m, id = q[i].i; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans[id] = (ans[id] + 1ll * (n / l) * (m / l) % mod * bit.query(l, r) % mod + mod) % mod; } } for(int i = 1; i &lt;= T; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;}","link":"/2022/11/11/P3312%20%5BSDOI2014%5D%E6%95%B0%E8%A1%A8/"},{"title":"ä¸‰è§’å‰–åˆ†","text":"å’•å’•å’•äº† blog blog","link":"/2022/08/16/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"},{"title":"ä½¿ç”¨GitHub Actions æŒç»­é›†æˆéƒ¨ç½²Hexo","text":"ä½¿ç”¨GitHub Actions æŒç»­é›†æˆéƒ¨ç½²Hexo ä½¿ç”¨GitHub Actions æŒç»­é›†æˆéƒ¨ç½²Hexo Hexo ä½œä¸ºä¸€ä¸ªé™æ€çš„åšå®¢æ¡†æ¶ï¼Œç›¸æ¯”äºwordpressï¼Œä¹Ÿæ˜¯æœ‰å…¶è½»ä¾¿ï¼Œé€Ÿåº¦å¿«çš„ä¼˜ç‚¹ï¼Œä½†æ˜¯æ¯•ç«Ÿæ˜¯é™æ€çš„ï¼Œéƒ¨ç½²èµ·æ¥å¹¶æ²¡æœ‰é‚£ä¹ˆæ–¹ä¾¿ï¼Œå¦‚æœåœ¨æœ¬åœ°çš„è¯æ¯æ¬¡æ›´æ–°ï¼Œéƒ½éœ€è¦hexo clean -d, ä¼šå¾ˆéº»çƒ¦ã€‚Github Actions æ—©åœ¨2018å¹´å°±å‘å¸ƒäº†æœ€åˆçš„ç‰ˆæœ¬ï¼Œ ä½œä¸ºä¸€ä¸ªæ–¹ä¾¿çš„å¯ä»¥æŒç»­é›†æˆéƒ¨ç½²çš„å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥éƒ¨ç½²hexoï¼Œè®©blogä»¥åçš„æ›´æ–°ç»´æŠ¤æ›´åŠ æ–¹ä¾¿å¿«æ·ã€‚ éœ€è¦ä¸¤ä¸ªä»“åº“ï¼Œä¸€ä¸ªæ¥æ”¾blogçš„æºç ï¼Œ ä¸€ä¸ªæ”¾html, å¦‚name.github.io ã€‚ é¦–å…ˆåœ¨git bashä¸­è¿è¡Œï¼š ç”Ÿæˆå¯†é’¥ yaml >folded1ssh-keygen -t rsa -f github-deploy-key æ­¤æ—¶å¯ä»¥å¾—åˆ°ä¸¤ä¸ªæ–‡ä»¶ä¸€ä¸ªæ˜¯ github-deploy-key, å¦ä¸€ä¸ªæ˜¯github-deploy-key.pub, é¦–å…ˆå¤åˆ¶github-deploy-keyçš„å†…å®¹ç„¶åï¼Œåˆ°åšå®¢çš„æºç ä»“åº“ï¼Œæ‰“å¼€Settings-&gt;Secrets-&gt;Actionsï¼Œ é€‰æ‹©New Secretsï¼ŒName å¡«HEXO_DEPLOY_PRI,(è¿™ä¸ªåé¢æ–‡ä»¶ä¼šç”¨åˆ°å»ºè®®ä¸åšæ›´æ”¹)ï¼Œç„¶åæ‰“å¼€åšå®¢é¡µé¢æ–‡ä»¶æ‰€åœ¨çš„ä»“åº“ï¼Œæ‰“å¼€Settings-&gt;Deploy Keyï¼Œ é€‰æ‹©Add deploy keyï¼Œ åå­—å¡«HEXO_DEPLOY_PUB, æŠŠgithub-deploy-key.pubçš„å†…å®¹å¤åˆ¶è¿›å»ã€‚ åœ¨åšå®¢æºç çš„ä»“åº“ä¸­æ–°å»º.github/workflows/deploy.yml, æ¥ä¸‹æ¥å°±æ˜¯é…ç½®Github Actionsï¼Œæ ¹æ®æ³¨é‡Šä¿®æ”¹å†…å®¹ï¼Œ å¡«åœ¨deploy.ymlï¼Œ ä¸­ï¼š Actions yaml >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162name: Hexo deployon: push: branches: - main #å½“è¯¥åˆ†æ”¯çš„å†…å®¹æ”¹å˜æ—¶ä¼šè§¦å‘Actionsï¼Œè¯·æ ¹æ®å®é™…æƒ…å†µæ›´æ”¹æˆå¯¹åº”åˆ†æ”¯env: GIT_USER: #ç”¨æˆ·å GIT_EMAIL: #é‚®ç®± DEPLOY_REPO: #ç”¨æˆ·å/name.github.io DEPLOY_BRANCH: #å’Œä¸Šä¸ªåˆ†æ”¯ç›¸åŒjobs: build: name: Build on node $ and $ runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] # ä½¿ç”¨æœ€æ–°çš„Ubuntuç¯å¢ƒ steps: - name: Checkout uses: actions/checkout@v3 #ä½¿ç”¨ actions/checkout@v3 ç‰ˆæœ¬ä¸º node.16 - name: Checkout deploy repo uses: actions/checkout@v3 with: repository: $ ref: $ path: .deploy_git - name: Use Node.js $ uses: actions/setup-node@v3 #ä½¿ç”¨ actions/setup-node@v3 ç‰ˆæœ¬ä¸º node.16 with: node-version: 16 - name: Configuration environment env: HEXO_DEPLOY_PRI: $ run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;&quot; #ç”¨æˆ·å git config --global user.email &quot;&quot; # é‚®ç®± - name: Install dependencies run: | npm install npm install hexo-cli -g # éƒ¨ç½²hexo ç¯å¢ƒ - name: Deploy hexo run: | hexo clean hexo g hexo d #éƒ¨ç½² depoly æ ¹æ®å®é™…æƒ…å†µæ›´æ”¹å³å¯ ï¼Œæ¨èæ­é…GitHubçš„Cloud VSCode ä½¿ç”¨æ•ˆæœæ›´ä½³ã€‚","link":"/2022/10/12/%E4%BD%BF%E7%94%A8GitHub%20Actions%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2Hexo/"},{"title":"åŠ¨æ€DP","text":"åŠ¨æ€DPğŸ™ˆâœï¸ åŠ¨æ€DP å‰è¨€ ç¨å¾®å†™äº†å†™ï¼Œä¸ç®—éš¾æƒ³ï¼Œå°±æ˜¯éš¾å†™ã€‚ æ­£æ–‡ åŠ¨æ€DP åŠ¨æ€DP(DDP)ï¼Œæ˜¯ç”¨æ¥è§£å†³ä¸€äº›åœ¨ç‰¹å®šæ¡ä»¶ä¸‹å¾…ä¿®çš„DPé—®é¢˜ã€‚ ä¾‹å¦‚P4719&quot;åŠ¨æ€ DP&quot;&amp;åŠ¨æ€æ ‘åˆ†æ²»ã€‚ä¸»è¦è¿˜æ˜¯è§£å†³è¿™ç±»é—®é¢˜ï¼Œå°±æ‹¿è¿™ä¸ªä¸¾ä¾‹å­å§ã€‚ é¦–å…ˆä¸éš¾åˆ—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œ è®¾f0/1f_{0 / 1}f0/1â€‹è¡¨ç¤ºå½“å‰ç‚¹é€‰æˆ–ä¸é€‰çš„æœ€å¤§æƒå€¼ï¼Œå¯å¾— {fx,0=fx,0+âˆ‘maxâ¡(fv,1,fv,0)fx,1=fx,1+âˆ‘fv,0+wx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = f_{x, 0} + \\sum \\max(f_{v, 1}, f_{v, 0})\\\\ &amp;f_{x, 1} = f_{x, 1} + \\sum f_{v, 0} + w_x \\end{aligned} \\right. â©â¨â§â€‹â€‹fx,0â€‹=fx,0â€‹+âˆ‘max(fv,1â€‹,fv,0â€‹)fx,1â€‹=fx,1â€‹+âˆ‘fv,0â€‹+wxâ€‹â€‹ ç„¶è€Œé¢˜ç›®ä¸­æœ‰è¦æ±‚å¸¦ä¿®ï¼Œæ¯æ¬¡é‡æ–°è·‘ä¸€è¾¹DPæ˜¯O(nm)O(nm)O(nm)çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ•°æ®ç»“æ„ç»´æŠ¤ã€‚ å¹¿ä¹‰çŸ©é˜µä¹˜æ³• æˆ‘ä»¬å°†çŸ©é˜µä¹˜æ³•å®šä¹‰ä¸º AÃ—B=âˆ‘i=1nâˆ‘j=1nâˆ‘k=1nmaxâ¡{Ai,k+Bk,j}A \\times B = \\sum_{i = 1}^n\\sum_{j = 1}^n\\sum_{k = 1}^n \\max\\{ A_{i, k} + B_{k, j}\\} AÃ—B=i=1âˆ‘nâ€‹j=1âˆ‘nâ€‹k=1âˆ‘nâ€‹max{Ai,kâ€‹+Bk,jâ€‹} ç„¶åè€ƒè™‘æ¯æ¬¡çš„ä¿®æ”¹å…¶å®å°±å¯ä»¥çœ‹ä½œå¯¹å½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šçš„ä¿¡æ¯è¿›è¡Œäº†ä¿®æ”¹ï¼Œå¯ä»¥ç”¨æ ‘å‰–é™ä½æ—¶é—´å¤æ‚åº¦ï¼Œè®¾g0/1g_{0 / 1}g0/1â€‹è¡¨ç¤ºå½“å‰ç‚¹ä¸è€ƒè™‘é‡å„¿å­çš„å½±å“ä¸‹çš„ç­”æ¡ˆï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹å˜ä¸ºï¼Œ {fx,0=gx,0+maxâ¡(fson,1,fson,0)fx,1=gx,1+fson,0\\left \\{ \\begin{aligned} &amp;f_{x, 0} = g_{x, 0} + \\max(f_{son, 1}, f_{son, 0})\\\\ &amp;f_{x, 1} = g_{x, 1} + f_{son, 0} \\\\ \\end{aligned} \\right. {â€‹fx,0â€‹=gx,0â€‹+max(fson,1â€‹,fson,0â€‹)fx,1â€‹=gx,1â€‹+fson,0â€‹â€‹ ç„¶ååˆ—å‡ºè½¬ç§»çŸ©é˜µä¸ºï¼Œ [gx,0gx,0gx,1âˆ’âˆ]Ã—[fson,0fson,1]=[fx,0fx,1]\\begin{bmatrix} g_{x, 0} &amp; g_{x, 0} \\\\ g_{x, 1} &amp; -\\infty \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son, 0} \\\\ f_{son, 1} \\\\ \\end{bmatrix} = \\begin{bmatrix} f_{x,0} \\\\ f_{x, 1} \\\\ \\end{bmatrix} [gx,0â€‹gx,1â€‹â€‹gx,0â€‹âˆ’âˆâ€‹]Ã—[fson,0â€‹fson,1â€‹â€‹]=[fx,0â€‹fx,1â€‹â€‹] çº¿æ®µæ ‘ç»´æŠ¤å³å¯ï¼Œæ¯æ¬¡æŸ¥è¯¢æŸ¥è¯¢å½“å‰èŠ‚ç‚¹æ‰€å’‹é‡é“¾çš„ç­”æ¡ˆå³å¯ã€‚ å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 1e9;int n, m;int a[N];int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ int dat[3][3]; Matrix(){memset(dat, 0, sizeof(dat));} int *operator [] (int i){return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 1; i &lt;= 2; i++) for(int j = 1; j &lt;= 2; j++) for(int k = 1; k &lt;= 2; k++) C[i][j] = max(C[i][j], A[i][k] + B[k][j]); return C; }};int fa[N], depth[N], siz[N], son[N], top[N];int id[N], w[N], tot, ed[N];void dfs1(int x, int father){ fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[son[x]] &lt; siz[v]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; w[tot] = x; ed[topfather] = tot; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}int f[N][2], g[N][2];Matrix v[N];void dp(int x){ f[x][1] = g[x][1] = a[x]; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dp(v); f[x][0] += max(f[v][0], f[v][1]); f[x][1] += f[v][0]; if(v == son[x])continue; g[x][0] += max(f[v][0], f[v][1]); g[x][1] += f[v][0]; }}struct Segmentree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1)};Segmentree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) { Matrix A; int x = w[l]; A[1][1] = g[x][0]; A[1][2] = g[x][0]; A[2][1] = g[x][1]; A[2][2] = -INF; v[x] = A; return void(t[p].val = A); } build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r, rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r) return void(t[p].val = v[w[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, int val){ v[x][2][1] += val - a[x]; a[x] = val; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; v[x][1][1] += max(A[1][1], A[2][1]) - max(B[1][1], B[2][1]); v[x][1][2] = v[x][1][1]; v[x][2][1] += A[1][1] - B[1][1]; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 1); dp(1); build(1, n, 1); for(int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); update(x, y); Matrix ans = query(1, n, 1, 1, ed[1]); printf(&quot;%d\\n&quot;, max(ans[1][1], ans[2][1])); } return 0;} åº”ç”¨ P5024 ä¿å«ç‹å›½ ç›´æ¥åˆ—å‡ºè½¬ç§»æ–¹ç¨‹ä¸ºï¼Œ {fx,0=fx,1+âˆ‘fx,1fx,1=fx,0+âˆ‘minâ¡(fx,0,fx,1)+cx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = f_{x, 1} + \\sum f_{x , 1} \\\\ &amp;f_{x, 1} = f_{x, 0} + \\sum \\min(f_{x, 0}, f_{x, 1}) + c_x \\end{aligned} \\right. â©â¨â§â€‹â€‹fx,0â€‹=fx,1â€‹+âˆ‘fx,1â€‹fx,1â€‹=fx,0â€‹+âˆ‘min(fx,0â€‹,fx,1â€‹)+cxâ€‹â€‹ è€ƒè™‘é¢˜ç›®ä¸­çš„å¼ºåˆ¶é€‰å…¶å®å°±æ˜¯åœ¨å¯¹åº”å€¼ä¸ŠåŠ ä¸Šâˆ’âˆ-\\inftyâˆ’âˆï¼Œå¼ºåˆ¶é€‰å°±æ˜¯åŠ ä¸Šâˆ\\inftyâˆï¼Œç„¶åè®¾g0/1g_{0/1}g0/1â€‹åˆ—å‡ºæ–¹ç¨‹ä¸º {fx,0=gx,0+fson,1fx,1=fx,1+minâ¡(fson,0,fson,1)+cx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = g_{x, 0} + f_{son , 1} \\\\ &amp;f_{x, 1} = f_{x, 1} + \\min(f_{son, 0}, f_{son, 1}) + c_x \\end{aligned} \\right. {â€‹fx,0â€‹=gx,0â€‹+fson,1â€‹fx,1â€‹=fx,1â€‹+min(fson,0â€‹,fson,1â€‹)+cxâ€‹â€‹ åˆ—å‡ºè½¬ç§»çŸ©é˜µä¸ºï¼Œ [gx,1gx,1gx,0+âˆ]Ã—[fson,0fson,1]=[fx,1fx,0]\\begin{bmatrix} g_{x,1} &amp;g_{x, 1} \\\\ g_{x, 0} &amp; + \\infty \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son,0} \\\\ f_{son,1} \\\\ \\end{bmatrix} = \\begin{bmatrix} f_{x, 1} \\\\ f_{x, 0} \\\\ \\end{bmatrix} [gx,1â€‹gx,0â€‹â€‹gx,1â€‹+âˆâ€‹]Ã—[fson,0â€‹fson,1â€‹â€‹]=[fx,1â€‹fx,0â€‹â€‹] ç„¶åç»´æŠ¤ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 10;const ll INF = 1e18;int n, m;int cnt, head[N];ll p[N];char s[2];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ ll dat[3][3]; Matrix(){memset(dat, 0x3f, sizeof(dat));} ll *operator [] (int i){return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 1; i &lt;= 2; i++) for(int j = 1; j &lt;= 2; j++) for(int k = 1; k &lt;= 2; k++) C[i][j] = min(C[i][j], A[i][k] + B[k][j]); return C; }};int fa[N], depth[N], siz[N], top[N], son[N];int id[N], tot, w[N], ed[N];void dfs1(int x, int father){ fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[son[x]] &lt; siz[v]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; w[tot] = x; ed[topfather] = tot; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}ll f[N][2], g[N][2];Matrix v[N];void dp(int x){ f[x][1] = g[x][1] = p[x]; f[x][0] = g[x][0] = 0; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dp(v); f[x][1] += min(f[v][1], f[v][0]); f[x][0] += f[v][1]; if(v == son[x])continue; g[x][1] += min(f[v][1], f[v][0]); g[x][0] += f[v][1]; }}struct Segmentree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1)};Segmentree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) { Matrix A; int x = w[l]; A[1][1] = g[x][1]; A[1][2] = g[x][1]; A[2][1] = g[x][0]; A[2][2] = INF; v[x] = A; return void(t[p].val = A); } build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r, rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r)return void(t[p].val = v[w[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, ll val){ v[x][1][1] += val - p[x]; v[x][1][2] += val - p[x]; p[x] = val; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; v[x][1][1] += min(A[1][1], A[2][1]) - min(B[1][1], B[2][1]); v[x][1][2] = v[x][1][1]; v[x][2][1] += A[1][1] - B[1][1]; }}int main(){ scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, s); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;p[i]); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 1); dp(1); build(1, n, 1); for(int i = 1; i &lt;= m; i++) { int a, x, b, y; ll tmp; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;x, &amp;b, &amp;y); if(!x &amp;&amp; !y &amp;&amp; (fa[a] == b || fa[b] == a)) {printf(&quot;-1\\n&quot;);continue;} tmp = (x ? INF : 0) + (y ? INF : 0); ll A = p[a], B = p[b]; update(a, x ? A - INF : A + INF); update(b, y ? B - INF : B + INF); Matrix ans = query(1, n, 1, id[1], ed[1]); printf(&quot;%lld\\n&quot;, min(ans[1][1], ans[2][1]) + tmp); update(a, A); update(b, B); } return 0;} P6021 æ´ªæ°´ ä¸éš¾è®¾å‡ºè½¬ç§»æ–¹ç¨‹ä¸ºï¼Œ fx=minâ¡(wx,âˆ‘fv)f_x = \\min(w_x, \\sum f_v) fxâ€‹=min(wxâ€‹,âˆ‘fvâ€‹) ç›´æ¥è®¾gxg_xgxâ€‹ï¼Œåˆ—å‡ºè½¬ç§»çŸ©é˜µï¼Œ [gxwx00]Ã—[fson0]=[fx0]\\begin{bmatrix} g_x &amp; w_x \\\\ 0 &amp; 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son} \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} f_x \\\\ 0 \\\\ \\end{bmatrix} [gxâ€‹0â€‹wxâ€‹0â€‹]Ã—[fsonâ€‹0â€‹]=[fxâ€‹0â€‹] ç®€å•ç»´æŠ¤ä¸€ä¸‹å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5 + 10;const int INF = 1e14;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ int dat[2][2]; Matrix() {dat[0][0] = dat[0][1] = dat[1][0] = dat[1][1] = INF;} int * operator [] (int i) {return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) C[i][j] = min(C[i][j], A[i][k] + B[k][j]); return C; }};Matrix M[N];int fa[N], top[N], siz[N], son[N];int id[N], ed[N], tot, a[N];int f[N], w[N];void dfs1(int x, int father){ fa[x] = father; int s = 0; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x]) continue; dfs1(v, x); s += f[v]; siz[x] += siz[v]; if(siz[v] &gt; siz[son[x]]) son[x] = v; } if(siz[x] == 1)f[x] = w[x]; else f[x] = min(s, w[x]);}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; a[tot] = x; ed[topfather] = tot; M[x][0][0] = 0, M[x][0][1] = w[x], M[x][1][0] = 0, M[x][1][1] = 0; if(!son[x]) return void(M[x][0][0] = w[x]); dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); M[x][0][0] += f[v]; }}struct Segementree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1)};Segementree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) return void(t[p].val = M[a[l]]); build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r ,rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r)return void(t[p].val = M[a[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, int v){ M[x][0][1] += v; w[x] += v; if(siz[x] == 1)M[x][0][0] += v; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; M[x][0][0] += A[0][0] - B[0][0]; }}signed main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for(int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); } dfs1(1, 0); dfs2(1, 1); build(1, n, 1); cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { char opt; int x, y; cin &gt;&gt; opt; if(opt == 'Q') { cin &gt;&gt; x; Matrix ans = query(1, n, 1, id[x], ed[top[x]]); cout &lt;&lt; ans[0][0] &lt;&lt; endl; } else { cin &gt;&gt; x &gt;&gt; y; update(x, y); } } return 0;} åè®° debugç ´é˜²äº†ğŸ˜…ğŸ˜…ğŸ˜…","link":"/2022/11/09/%E5%8A%A8%E6%80%81DP/"},{"title":"Emoji","text":"ğŸ˜€","link":"/2022/06/15/emoji/"},{"title":"Loj#6670.ã€ŒXXOI 2019ã€ä¸€ä¸ªå¸Œæœ›ç›´æ¥å®ç°","text":"Loj#6670.ã€ŒXXOI 2019ã€ä¸€ä¸ªå¸Œæœ›ç›´æ¥å®ç° é¢˜è§£ é¢˜æ„ å®šä¹‰ä¸€ä¸ª1âˆ’n1 - n1âˆ’nçš„æ’åˆ—PPPçš„kkkåˆ’åˆ†ä¸ºï¼šæŠŠPPPä»å·¦åˆ°å³æ¯kkkä¸ªåˆ’åˆ†æˆä¸€ç»„ï¼Œ å¦‚æœæœ‰å‰©ä¸‹çš„ï¼Œåˆ™å‰©ä¸‹çš„ä¸€å…±æˆä¸€ç»„ã€‚ å®šä¹‰PPPçš„kkkæœ€å°å–æ ·ä¸ºï¼šæŠŠå®ƒçš„kkkåˆ’åˆ†Pâ€²P'Pâ€²ä¸­ï¼Œæ¯ç»„åªä¿ç•™è¿™ä¸€ç»„ä¸­æœ€å°çš„æ•°ã€‚ é‚£ä¹ˆå°±ä¼šå¾—åˆ°nk\\frac{n}{k}knâ€‹ä¸ªæ•°ï¼Œå¦‚æœå®ƒä»¬ä»å·¦åˆ°å³æ„æˆä¸€ä¸ªé€’å¢çš„ç­‰å·®æ•°åˆ—ï¼Œ åˆ™ç§°å…¶ä¸ºã€Œå¯ä»¥è¾¾æˆæ„¿æœ›ã€çš„ã€‚ å¦‚æœPPPçš„kkkæœ€å°å–æ ·æ˜¯ã€Œå¯ä»¥è¾¾æˆæ„¿æœ›ã€çš„ï¼Œåˆ™f(P,k)=1f(P, k) = 1f(P,k)=1ï¼Œ å¦åˆ™f(P,k)=0f(P, k) = 0f(P,k)=0ã€‚ ç»™å®šnnnï¼Œå®šä¹‰PnP_nPnâ€‹ä¸º1âˆ’n1 - n1âˆ’nçš„å…¨æ’åˆ—çš„é›†åˆï¼Œ æ±‚ï¼š âˆ‘pâˆˆPnâˆ‘kâˆ£nf(P,k)\\sum_{p \\in P_n } \\sum_{k | n}f(P, k) pâˆˆPnâ€‹âˆ‘â€‹kâˆ£nâˆ‘â€‹f(P,k) å¯¹998244353998244353998244353å–æ¨¡ã€‚ è§£æ³• é¦–å…ˆå‡è®¾å—é•¿ä¸ºkkkï¼Œ ä¸éš¾å‘ç°ï¼Œæ»¡è¶³æ¡ä»¶çš„ç­‰å·®æ•°åˆ—çš„é¦–é¡¹ä¸€å®šæ˜¯111ï¼Œå…¬å·®dâˆˆ[1,k]d \\in [1, k]dâˆˆ[1,k]ï¼Œç„¶åæˆ‘ä»¬åªéœ€è¦å»æšä¸¾çº¦æ•°ï¼Œå»æ±‚å¯¹åº”çš„kkkï¼Œ ç„¶åæšä¸¾å…¬å·®dddï¼Œå»ç¡®å®šå¯¹åº”çš„æ–¹æ¡ˆæ•°ï¼Œç¡®å®šå…¬å·®åå¯¹åº”çš„ç­‰å·®æ•°åˆ—ä¹Ÿå°±ç¡®å®šä¸ºï¼š 1,1+d,1+2d,â‹¯ ,1+(kâˆ’1)d1,1 + d, 1 + 2d , \\cdots ,1 + (k - 1)d 1,1+d,1+2d,â‹¯,1+(kâˆ’1)d ç„¶åè€ƒè™‘æœ€åä¸€ä¸ªå—ï¼Œä¼šæœ‰å¤šå‡ºæ¥çš„èƒ½å¡«çš„æ•°ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å…¶å¡«åœ¨å‰é¢ï¼Œæ¥ä¸‹æ¥è€ƒè™‘ç­‰å·®æ•°åˆ—æ¯ä¸€é¡¹ä¹‹é—´çš„æ•°ï¼Œè¿™ä¹‹é—´çš„æ•°è‚¯å®šä¸èƒ½å¡«åœ¨åé¢çš„å—å†…ï¼Œå€’ç€å¡«æ•°çš„æ—¶å€™åªèƒ½å¡«åœ¨è¿™ä¸ªå—å’Œè¿™ä¸ªå—ä¹‹å‰ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡å¡«æ•°ä¼šå°‘kâˆ’1k - 1kâˆ’1ä¸ªæ•°ï¼Œå¤šdâˆ’1d - 1dâˆ’1ä¸ªæ•°ï¼Œä¹Ÿæ„æˆäº†ä¸€ä¸ªç­‰å·®æ•°åˆ—ã€‚æ¯”å¦‚n=9,k=3n = 9, k = 3n=9,k=3æ—¶ï¼Œ å¯¹åº”çš„æ–¹æ¡ˆæ•°ä¸ºA22Ã—A32Ã—A42Ã—33A_2^2 \\times A_3^2 \\times A_4^2 \\times 3 ^ 3A22â€‹Ã—A32â€‹Ã—A42â€‹Ã—33ï¼Œç”±äºæˆ‘ä»¬åªè€ƒè™‘äº†é™¤äº†ç­‰å·®æ•°åˆ—ä¹‹å¤–çš„æ•°ï¼Œæ‰€ä»¥å¿…é¡»æœ€åä¹˜ä¸Šæ¯ä¸ªå—å†…çš„æœ€å°å€¼çš„æ’åˆ—æ–¹æ¡ˆæ•°ã€‚ code >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 3e5 + 10;const int mod = 998244353;int n;int fac[N], ifac[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int A(int n, int m){ return fac[n] % mod * ifac[n - m] % mod;}int calc(int x){ int sum = 0, len = n / x; for(int d = 1; d &lt;= x; d++) { int res = 1; for(int i = 0, j = x - 1; i &lt; len; i++, j += x - d) res = res * A(j, x - 1) % mod * x % mod; sum = (sum + res) % mod; } return sum;}signed main(){ int sum = 0; cin &gt;&gt; n; int ans = 0; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); for(int i = 1; i &lt; n; i++) { if(n % i)continue; ans = (ans + calc(i)) % mod; } ans = (ans + fac[n] + mod) % mod; cout &lt;&lt; ans; return 0;}","link":"/2022/09/25/%E3%80%8CXXOI-2019%E3%80%8D%E4%B8%80%E4%B8%AA%E5%B8%8C%E6%9C%9B%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0/"},{"title":"å¤šé¡¹å¼å­¦ä¹ ç¬”è®°","text":"è¶…å…¨çš„å¤šé¡¹å¼å…¨å®¶æ¡¶(âÂ´â—¡`â) æ„Ÿè°¢Meteorshower-Yçš„å¤§åŠ›æ”¯æŒå’ŒæŒ‡å¯¼ï¼Œ è¿™æ˜¯å¤§ä½¬çš„blogï¼ï¼ãƒ¾(â‰§â–½â‰¦*)o å¤šé¡¹å¼å­¦ä¹ ç¬”è®° å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(FFT) å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(FFT)ï¼Œä¸»è¦ç”¨äºåŠ é€Ÿå¤šé¡¹å¼ä¹˜æ³•ï¼Œå¯¹äºä¸¤ä¸ªå¤šé¡¹å¼AAAå’ŒBBBï¼Œ FFTå¯ä»¥å°†æœ´ç´ çš„O(n2)O(n^2)O(n2)ä¼˜åŒ–ä¸ºO(nlogâ¡n)O(n \\log n)O(nlogn)ã€‚ å•ä½å…ƒ å…ˆçœ‹ä¸€ä¸‹å•ä½å…ƒçš„å‡ ä¸ªæ€§è´¨ï¼Œåœ¨æ¥ä¸‹æ¥çš„ç®—æ³•ä¸­æœ‰å¾ˆå¤§çš„ç”¨é€”ã€‚ Ï‰nk=e2Ï€ikn\\omega_n ^ k = e ^{\\frac{2\\pi i k}{n}}Ï‰nkâ€‹=en2Ï€ikâ€‹ Ï‰dndk=Ï‰nk\\omega_{dn} ^ {dk} = \\omega_n^kÏ‰dndkâ€‹=Ï‰nkâ€‹ Ï‰nk=a+bi,Ï‰nâˆ’k=aâˆ’bi\\omega_n^k = a + bi, \\omega_n^{-k} = a - biÏ‰nkâ€‹=a+bi,Ï‰nâˆ’kâ€‹=aâˆ’bi Ï‰nk+n2=âˆ’Ï‰nk\\omega _n ^{k + \\frac{n}{2}} = - \\omega_n^kÏ‰nk+2nâ€‹â€‹=âˆ’Ï‰nkâ€‹ ä»¥ä¸Šå˜æ¢å‡å¯ç”±æ¬§æ‹‰å…¬å¼eiÎ¸=cosâ¡Î¸+isinâ¡Î¸e^{i \\theta} = \\cos \\theta + i\\sin \\thetaeiÎ¸=cosÎ¸+isinÎ¸æ¨å¾—ã€‚ ç¦»æ•£å‚…é‡Œå¶å˜æ¢(DFT) ç¦»æ•£å‚…é‡Œå¶å˜æ¢(DFT) ä¸»è¦æ˜¯åˆ©ç”¨åˆ†æ²»æ€æƒ³ï¼Œæ ¹æ®ä¸€ä¸ªnnnæ¬¡çš„å¤šé¡¹å¼å¯ä»¥ç”±n+1n + 1n+1ä¸ªç‚¹å”¯ä¸€ç¡®å®šï¼Œ é¦–å…ˆå°†å¤šé¡¹å¼ A(x)=âˆ‘i=0naixiA(x) = \\sum_{i=0} ^n a_i x^i A(x)=i=0âˆ‘nâ€‹aiâ€‹xi å…¶ç³»æ•°è¿›è¡Œå¥‡å¶æ€§åˆ†ç±»ï¼Œå¾—åˆ°ï¼Œ A0(x)=a0+a2x1+a4x2+â‹¯A1(x)=a1+a3x1+a5x2+â‹¯A_0(x)= a_0+a_2 x^1 +a_4 x^2 + \\cdots \\\\ A_1(x)= a_1+a_3 x^1 +a_5 x^2 + \\cdots \\\\ A0â€‹(x)=a0â€‹+a2â€‹x1+a4â€‹x2+â‹¯A1â€‹(x)=a1â€‹+a3â€‹x1+a5â€‹x2+â‹¯ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¡¨ç¤ºä¸º ï¼š A(x)=A0(x2)+xâ‹…A1(x2)A(x) = A_0 (x^2) +x \\cdot A_1(x^2) A(x)=A0â€‹(x2)+xâ‹…A1â€‹(x2) å°† Ï‰nk\\omega_n^kÏ‰nkâ€‹ ä¸ Ï‰nk+n2\\omega_n^{k+ \\frac{n}{2}}Ï‰nk+2nâ€‹â€‹ä»£å…¥å¾—ï¼š {A(Ï‰nk)=A0(Ï‰n2k)+Ï‰nkA1(Ï‰n2k)A(Ï‰nk+n2)=A0(Ï‰n2k)âˆ’Ï‰nkA1(Ï‰n2k)\\left\\{ \\begin{aligned} &amp;A(\\omega_n^k) = A_0(\\omega_n^{2k})+\\omega_n^k A_1(\\omega_n^{2k}) \\\\ &amp;A(\\omega_n^{k+ \\frac{n}{2}}) = A_0(\\omega_n^{2k})-\\omega_n^k A_1(\\omega_n^{2k}) \\\\ \\end{aligned} \\right. {â€‹A(Ï‰nkâ€‹)=A0â€‹(Ï‰n2kâ€‹)+Ï‰nkâ€‹A1â€‹(Ï‰n2kâ€‹)A(Ï‰nk+2nâ€‹â€‹)=A0â€‹(Ï‰n2kâ€‹)âˆ’Ï‰nkâ€‹A1â€‹(Ï‰n2kâ€‹)â€‹ åŒæ—¶æˆ‘ä»¬å¯ä»¥å‘ç°ä¸¤ä¸ªå¼å­åªæœ‰å¸¸æ•°ä¸ä¸€æ ·ï¼Œé€’å½’è®¡ç®—å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn) ã€‚ åœ¨è¿™é‡Œæˆ‘ä»¬å°†ç³»æ•°å˜æˆäº†ç‚¹å€¼ã€‚ ç¦»æ•£å‚…é‡Œå¶é€†å˜æ¢(IDFT) ç¦»æ•£å‚…é‡Œå¶é€†å˜æ¢(IDFT)ï¼Œå¯ä»¥å°†ç‚¹å€¼å¿«é€Ÿè½¬åŒ–ä¸ºç³»æ•°ï¼Œä»è€Œå¾—å‡ºç»“æœå¤šé¡¹å¼ã€‚ éœ€è¦ç”¨åˆ°å•ä½æ ¹åæ¼”ï¼š 1nâˆ‘i=0nâˆ’1Ï‰nxâˆ—i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1â€‹i=0âˆ‘nâˆ’1â€‹Ï‰nxâˆ—iâ€‹=[xmodn=0] è¯æ˜ ï¼š ç”±äº Ï‰nxâˆ—i=Ï‰nxâˆ—(iâˆ’1)âˆ—Ï‰nx\\omega_n ^ {x \\ast i} = \\omega_n^ {x \\ast (i-1)} \\ast \\omega_n^xÏ‰nxâˆ—iâ€‹=Ï‰nxâˆ—(iâˆ’1)â€‹âˆ—Ï‰nxâ€‹ æ‰€ä»¥Ï‰nxâˆ—i\\omega _n ^{x\\ast i}Ï‰nxâˆ—iâ€‹ ä¸ºç­‰æ¯”æ•°åˆ—ï¼Œ âˆ´1nâˆ‘i=0nâˆ’1Ï‰nxâˆ—i={1nâˆ‘i=0nâˆ’11i=nn=1x mod n=01nâ‹…1âˆ’Ï‰nnâˆ—x1âˆ’Ï‰nx=1nâ‹…1âˆ’1x1âˆ’Ï‰nx=0x mod nâ‰ 0\\therefore \\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i}= \\left\\{ \\begin{aligned} &amp;\\frac{1}{n} \\sum_{i=0}^{n-1} 1^i = \\frac{n}{n} = 1 &amp; x \\bmod n=0\\\\ &amp;\\frac{1}{n} \\cdot \\frac{1- \\omega _n ^ {n \\ast x}}{1-\\omega _n ^ x} = \\frac{1}{n} \\cdot \\frac{1-1^x}{1-\\omega_n^x} =0 &amp; x\\bmod n \\ne 0 \\end{aligned} \\right. âˆ´n1â€‹i=0âˆ‘nâˆ’1â€‹Ï‰nxâˆ—iâ€‹=â©âªâªâªâªâ¨âªâªâªâªâ§â€‹â€‹n1â€‹i=0âˆ‘nâˆ’1â€‹1i=nnâ€‹=1n1â€‹â‹…1âˆ’Ï‰nxâ€‹1âˆ’Ï‰nnâˆ—xâ€‹â€‹=n1â€‹â‹…1âˆ’Ï‰nxâ€‹1âˆ’1xâ€‹=0â€‹xmodn=0xmodnî€ â€‹=0â€‹ è¯æ˜ è®¾c=aâˆ—bci=âˆ‘j=0iajâ‹…biâˆ’j=âˆ‘p=0âˆ‘q=0apâ‹…bq[(p+q) mod n=0]nci=âˆ‘p=0âˆ‘q=0apâ‹…bqâˆ‘j=0Ï‰n(p+qâˆ’i)j=âˆ‘j=0Ï‰n(âˆ’i)j(âˆ‘p=0Ï‰npjap)(âˆ‘q=0Ï‰nqjbq)è®¾fa(j)=âˆ‘i=0Ï‰nijai,faâˆ’1(j)=âˆ‘i=0Ï‰n(âˆ’i)jainci=âˆ‘j=0Ï‰n(âˆ’i)jfa(j)fb(j)=âˆ‘j=0Ï‰n(âˆ’i)jfc(j)=ffcâˆ’1(i)è®¾ c= a\\ast b \\\\ \\begin{aligned} c_i &amp;= \\sum_{j=0}^i a_j \\cdot b_{i-j} \\\\ &amp;=\\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q [(p+q) \\bmod n=0] \\\\ nc_i &amp;= \\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q \\sum_{j=0} \\omega_n^{(p+q-i)j}\\\\ &amp;= \\sum_{j=0}\\omega_n^{(-i)j} \\bigg( \\sum_{p=0} \\omega_n^{pj} a_p\\bigg) \\bigg( \\sum_{q=0} \\omega_n^{qj} b_q\\bigg) \\end{aligned} \\\\ è®¾ f_a(j) = \\sum_{i=0} \\omega_n^{ij} a_i , f_a^{-1}(j) =\\sum_{i=0} \\omega_n^{(-i)j} a_i \\\\ \\begin{aligned} nc_i &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_a(j)f_b(j) \\\\ &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_c(j) \\\\ &amp;= f_{f_c}^{-1} (i) \\end{aligned} è®¾c=aâˆ—bciâ€‹nciâ€‹â€‹=j=0âˆ‘iâ€‹ajâ€‹â‹…biâˆ’jâ€‹=p=0âˆ‘â€‹q=0âˆ‘â€‹apâ€‹â‹…bqâ€‹[(p+q)modn=0]=p=0âˆ‘â€‹q=0âˆ‘â€‹apâ€‹â‹…bqâ€‹j=0âˆ‘â€‹Ï‰n(p+qâˆ’i)jâ€‹=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹(p=0âˆ‘â€‹Ï‰npjâ€‹apâ€‹)(q=0âˆ‘â€‹Ï‰nqjâ€‹bqâ€‹)â€‹è®¾faâ€‹(j)=i=0âˆ‘â€‹Ï‰nijâ€‹aiâ€‹,faâˆ’1â€‹(j)=i=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹aiâ€‹nciâ€‹â€‹=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹faâ€‹(j)fbâ€‹(j)=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹fcâ€‹(j)=ffcâ€‹âˆ’1â€‹(i)â€‹ å› ä¸º faf_afaâ€‹ å°±æ˜¯ aaa åœ¨ DFT åçš„ç»“æœï¼Œæ‰€ä»¥faâˆ’1f_a^{-1}faâˆ’1â€‹å°±æ˜¯ å¯¹åº”çš„IDFTï¼Œæœ€åé™¤ä»¥å¯¹åº”é•¿åº¦nnnï¼Œå³ä¸ºæ‰€æ±‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e6 + 10;const double pi = acos(-1.0);int n, m;struct Complex{ double a, b; Complex(double x = 0, double y = 0) : a(x), b(y) {} friend Complex operator + (Complex x, Complex y) {return Complex(x.a + y.a, x.b + y.b);} friend Complex operator - (Complex x, Complex y) {return Complex(x.a - y.a, x.b - y.b);} friend Complex operator * (Complex x, Complex y) {return Complex(x.a * y.a - x.b * y.b, x.b * y.a + y.b * x.a);}};int recover[N];Complex F[N], G[N], H[N];void FFT(Complex *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { Complex x(cos(pi / k), type * sin(pi / k)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { Complex w(1, 0); for(int j = 0; j &lt; k; j++) { Complex y = a[i + j]; Complex z = w * a[i + j + k]; a[i + j] = y + z; a[i + j + k] = y - z; w = w * x; } } } if(type == -1) for(int i = 0; i &lt; len; i++) a[i].a /= len;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;F[i].a); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;G[i].a); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt;= len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); FFT(F, len, 1), FFT(G, len, 1); for(int i = 0; i &lt;= len; i++) H[i] = F[i] * G[i]; FFT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%d &quot;, (int)(H[i].a + 0.5)); return 0;} å¿«é€Ÿæ•°è®ºå˜æ¢(NTT) å¿«é€Ÿæ•°è®ºå˜æ¢(NTT)ç›¸æ¯”äºFFTè™½ç„¶æ—¶é—´å¤æ‚åº¦å‡ä¸ºO(nlogâ¡n)O(n\\log n)O(nlogn)ï¼Œä½†æ˜¯FFTçš„ç²¾åº¦å´éš¾ä»¥ä¿è¯ï¼Œå¹¶ä¸”å¸¸æ•°å¾ˆå¤§ï¼Œ æ‰€ä»¥æœ‰æ—¶NTTæ‰æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚ åŸæ ¹ åŸæ ¹å®šä¹‰ä¸ºï¼šè®¾mmmä¸ºæ­£æ•´æ•°ï¼Œaaaæ˜¯æ•´æ•°ï¼Œè‹¥a mod ma \\bmod mamodmçš„é˜¶ç­‰äºÏ†(m)\\varphi (m)Ï†(m)ï¼Œåˆ™ç§°aaaä¸º mod m\\bmod mmodmçš„ä¸€ä¸ªåŸæ ¹ã€‚ åŸæ ¹æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„æ€§è´¨å¯ä»¥æ”¯æŒåƒFFTä¸­å•ä½æ ¹ä¸€æ ·çš„è¿ç®—ï¼Œå³ï¼šè‹¥PPPä¸ºç´ æ•°ï¼Œ å‡è®¾ä¸€ä¸ªæ•°gggæ˜¯PPPçš„åŸæ ¹ï¼Œ é‚£ä¹ˆgi mod Pg^i \\bmod PgimodPçš„ç»“æœä¸¤ä¸¤ä¸åŒã€‚ å¯ä»¥å¾—åˆ°ï¼š Ï‰nâ‰¡gpâˆ’1n(modp)\\omega_n \\equiv g^{\\frac{p - 1}{n}} \\pmod p Ï‰nâ€‹â‰¡gnpâˆ’1â€‹(modp) ç„¶åæˆ‘ä»¬å°±å¯ä»¥å°†FFTä¸­çš„Ï‰n\\omega _nÏ‰nâ€‹æ›¿æ¢ä¸ºgpâˆ’1ng^{\\frac{p - 1}{n}}gnpâˆ’1â€‹ ä½†æ˜¯æ³¨æ„çš„æ˜¯NTTå¯¹æ¨¡æ•°æœ‰è¦æ±‚ï¼Œå…¶æ¨¡æ•°å¿…é¡»è¦æ»¡è¶³åŸæ ¹çš„å®šä¹‰ï¼Œå¦åˆ™æ˜¯ä¸èƒ½ä½¿ç”¨NTTçš„ï¼Œæ¯”å¦‚998244353998244353998244353å°±ä¸ºNTTæ¨¡æ•°ï¼Œ å…¶åŸæ ¹ä¸º333ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e6 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int n, m;int F[N], G[N], H[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int recover[N];void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j]; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = (w * x) % mod; } } } if(type == -1) { int inv = qpow(len, mod - 2); for(int i = 0; i &lt; len; i++) a[i] = a[i] * inv % mod; }}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;G[i]); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(F, len, 1), NTT(G, len, 1); for(int i = 0; i &lt; len; i++) H[i] = (F[i] * G[i]) % mod; NTT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%lld &quot;, H[i]); return 0;} å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢ (FWT) ç»™å®šä¸¤ä¸ªé•¿åº¦ä¸º2n2 ^ n2nçš„ä¸¤ä¸ªåºåˆ—A,BA,BA,Bï¼Œ æ±‚åºåˆ—CCCï¼Œ Ci=âˆ‘jâŠ•k=iAjÃ—BkC_i = \\sum_{j \\oplus k = i} A_j \\times B_k Ciâ€‹=jâŠ•k=iâˆ‘â€‹Ajâ€‹Ã—Bkâ€‹ å…¶ä¸­âŠ•\\oplusâŠ•è¡¨ç¤ºä½è¿ç®—ä¸ï¼Œæˆ–ï¼Œå¼‚æˆ–ã€‚ æˆ–è¿ç®— é¦–å…ˆæ±‚åºåˆ—FWT[A]=âˆ‘i=iâˆ£jAjFWT[A] = \\sum_{i = i | j} A _ jFWT[A]=âˆ‘i=iâˆ£jâ€‹Ajâ€‹ï¼Œæ¥æ±‚å‡ºæ»¡è¶³æ¡ä»¶çš„iiiçš„å­é›†ï¼Œæ˜¾ç„¶ä¼šæœ‰ Ci=âˆ‘i=jâˆ£kAjÃ—Bkâ‡’FWT[C]=FWT[A]Ã—FWT[B]C_i = \\sum_{i = j | k} A_j \\times B_k \\Rightarrow FWT[C] = FWT[A] \\times FWT[B] Ciâ€‹=i=jâˆ£kâˆ‘â€‹Ajâ€‹Ã—Bkâ€‹â‡’FWT[C]=FWT[A]Ã—FWT[B] æ¥ä¸‹æ¥å°±æ˜¯è€ƒè™‘å¦‚ä½•è¿›è¡ŒFWTFWTFWTè¿ç®—ï¼Œ æœ‰ FWT[A]=merge(FWT[A0],FWT[A0]+FWT[A1])IFWT[A]=merge(IFWT[A0],IFWT[A1]âˆ’FWT[A0])FWT[A] = merge(FWT[A_0], FWT[A_0] + FWT[A_1]) \\\\ IFWT[A] = merge(IFWT[A_0], IFWT[A_1] - FWT[A_0]) FWT[A]=merge(FWT[A0â€‹],FWT[A0â€‹]+FWT[A1â€‹])IFWT[A]=merge(IFWT[A0â€‹],IFWT[A1â€‹]âˆ’FWT[A0â€‹]) 12345678910111213void FWT_or(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { a[i + j + k] = ((a[i + j + k] + a[i + j] * type + mod) % mod + mod) % mod; } } }} ä¸è¿ç®— åŒæˆ–è¿ç®—ï¼Œæœ‰ FWT[A]=merge(FWT[A0]+FWT[A1],FWT[A1])IFWT[A]=merge(IFWT[A0]âˆ’IFWT[A1],IFWT[A1])FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_1])\\\\ IFWT[A] = merge(IFWT[A_0] - IFWT[A_1], IFWT[A_1]) FWT[A]=merge(FWT[A0â€‹]+FWT[A1â€‹],FWT[A1â€‹])IFWT[A]=merge(IFWT[A0â€‹]âˆ’IFWT[A1â€‹],IFWT[A1â€‹]) 12345678910111213void FWT_and(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { a[i + j] = ((a[i + j] + a[i + j + k] * type + mod) % mod + mod) % mod; } } }} å¼‚æˆ–è¿ç®— æ¨å¯¼å¾— FWT[A]=merge(FWT[A0]+FWT[A1],FWT[A0]âˆ’FWT[A1])IFWT[A]=merge(IFWT[A0]+IFWT[A1]2,IFWT[A0]âˆ’IFWT[A1]2)FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_0] - FWT[A_1]) \\\\ IFWT[A] = merge(\\frac{IFWT[A_0] + IFWT[A_1]}{2}, \\frac{IFWT[A_0] - IFWT[A_1]}{2}) \\\\ FWT[A]=merge(FWT[A0â€‹]+FWT[A1â€‹],FWT[A0â€‹]âˆ’FWT[A1â€‹])IFWT[A]=merge(2IFWT[A0â€‹]+IFWT[A1â€‹]â€‹,2IFWT[A0â€‹]âˆ’IFWT[A1â€‹]â€‹) 123456789101112131415void FWT_xor(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { int x = a[i + j], y = a[i + j + k]; a[i + j] = ((x + y) % mod * type + mod) % mod; a[i + j + k] = ((x - y + mod) % mod * type + mod) % mod; } } }} ä»»æ„æ¨¡æ•°å¿«é€Ÿæ•°è®ºå˜æ¢ æ™®é€šçš„NTTå¯¹æ¨¡æ•°æ˜¯æœ‰è¦æ±‚çš„å…¶å¿…é¡»æ»¡è¶³åŸæ ¹çš„ç›¸å…³å®šä¹‰ï¼Œæ¨¡æ•°å¿…é¡»å¯ä»¥å†™æˆaâ‹…2k+1a \\cdot 2 ^ k + 1aâ‹…2k+1çš„å½¢å¼ã€‚ æ¯”å¦‚ï¼š 469762049=7Ã—226+1(g=3)998244353=119Ã—223+1(g=3)1004535809=479Ã—221+1(g=3)469762049 = 7 \\times 2 ^ {26} + 1 (g = 3) \\\\ 998244353 = 119 \\times 2 ^{23} + 1(g = 3) \\\\ 1004535809 = 479 \\times 2 ^ {21} + 1(g = 3) 469762049=7Ã—226+1(g=3)998244353=119Ã—223+1(g=3)1004535809=479Ã—221+1(g=3) å¦‚æœé¢˜ç›®ä¸­æ¨¡æ•°ä¸º1e9+71e9 + 71e9+7ï¼Œé‚£ä¹ˆNTTå°±ä¼šå—åˆ°é™åˆ¶ï¼Œç„¶åå°±å¯ä»¥ä½¿ç”¨ä»»æ„æ¨¡æ•°NTTï¼Œï¼ˆä¹Ÿå¯ä»¥ç§°ä¸ºä¸‰æ¨¡æ•°NTTï¼‰ï¼Œ è®¡ç®—æ—¶å¯ä»¥å…ˆæ‰¾ä¸‰ä¸ªå¤§è´¨æ•°ï¼Œ åˆ†åˆ«è®¡ç®—ç»“æœï¼Œç„¶åç”¨ä¸­å›½å‰©ä½™å®šç†CRTåˆå¹¶å³å¯ã€‚ é¦–å…ˆè®°ä¸‰æ¬¡NTTçš„ç»“æœä¸ºï¼š ansâ‰¡a1(modp1)ansâ‰¡a2(modp2)ansâ‰¡a3(modp3)ans \\equiv a_1 \\pmod {p_1} \\\\ ans \\equiv a_2 \\pmod {p_2} \\\\ ans \\equiv a_3 \\pmod {p_3} ansâ‰¡a1â€‹(modp1â€‹)ansâ‰¡a2â€‹(modp2â€‹)ansâ‰¡a3â€‹(modp3â€‹) å…ˆåˆå¹¶å‰ä¸¤ä¸ªå¾—åˆ°: ansâ‰¡a4(modp1p2)ans \\equiv a_4 \\pmod {p_1 p_2} ansâ‰¡a4â€‹(modp1â€‹p2â€‹) å°†å…¶è½¬åŒ–ä¸ºç­‰å¼ä¸ºï¼š ans=kp1p2+a4ans = k p_1 p_2 + a_4 ans=kp1â€‹p2â€‹+a4â€‹ æ¥ç€æ±‚kkkï¼š k=(a3âˆ’a4)p1âˆ’1p2âˆ’1(modp3)k = (a_3 - a_4)p_1^{-1} p_2 ^ {-1} \\pmod {p_3} k=(a3â€‹âˆ’a4â€‹)p1âˆ’1â€‹p2âˆ’1â€‹(modp3â€‹) æ‰€ä»¥ï¼š ansâ‰¡kp1p2+a4(modp1p2p3)ans \\equiv kp_1 p_2 + a_4 \\pmod {p_1p_2p_3} ansâ‰¡kp1â€‹p2â€‹+a4â€‹(modp1â€‹p2â€‹p3â€‹) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define int __int128const int N = 4e5 + 10;const int g = 3;int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){if(ch == '-')f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x*10 + ch-'0'; ch = getchar();} return x * f;}void write(int x){ char ch[100], len = 0; if(x == 0)ch[++len] = '0'; while(x)ch[++len] = x%10 + '0', x /= 10; while(len)putchar(ch[len--]); printf(&quot; &quot;);}int p[3] = {469762049, 998244353, 1004535809};int qpow(int a, int b, int i){ int t = 1; while(b != 0) { if(b &amp; 1) t = t * a % p[i]; a = a * a % p[i]; b &gt;&gt;= 1; } return t % p[i];}int inv(int x, int i){ return qpow(x, p[i] - 2, i);}int gi[3];void init(){ for(int i = 0; i &lt; 3; i++) gi[i] = inv(g, i);}int F[N], G[N], H[N];int recover[N];void NTT(int *a, int len, int type, int f){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi[f], (p[f] - 1) / (k &lt;&lt; 1), f); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % p[f]; int z = w * a[i + j + k] % p[f]; a[i + j] = (y + z) % p[f]; a[i + j + k] = (y - z + p[f]) % p[f]; w = w * x % p[f]; } } } if(type == -1) { int iv = inv(len, f); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % p[f]; }}int A[N], B[N], C[3][N];void CRT(int len){ int M = p[0] * p[1]; for(int i = 0; i &lt;= len; i++) { H[i] = (p[1] * C[0][i] % M * inv(p[1], 0) % M + p[0] * C[1][i] % M * inv(p[0], 1) % M) % M; }}int n, m, mod;void merge(int len){ for(int i = 0; i &lt;= len; i++) { int k = ((C[2][i] - H[i]) % p[2] + p[2]) % p[2] * inv(p[0] * p[1], 2) % p[2]; H[i] = ((k * p[0] * p[1] % mod + H[i] % mod) % mod + mod) % mod; }}void prework(){ memcpy(A, F, sizeof(F)); memcpy(B, G, sizeof(G));}void update(int x, int len){ for(int i = 0; i &lt; len; i++) C[x][i] = A[i] * B[i] % p[x];}signed main(){ init(); n = read(), m = read(), mod = read(); for(int i = 0; i &lt;= n; i++) F[i] = read(); for(int i = 0; i &lt;= m; i++) G[i] = read(); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; 3; i++) { prework(); NTT(A, len, 1, i), NTT(B, len, 1, i); update(i, len); NTT(C[i], len, -1, i); } CRT(n + m); merge(n + m); for(int i = 0; i &lt;= (n + m); i++) write(H[i]); return 0;} å¤šé¡¹å¼ä¹˜æ³•é€† å®šä¹‰å¤šé¡¹å¼Fâˆ’1F ^ {-1}Fâˆ’1ä¸ºå¤šé¡¹å¼FFFçš„ä¹˜æ³•é€†å…ƒï¼Œæ»¡è¶³ Fâˆ—Fâˆ’1â‰¡1(modxn)F \\ast F ^ {-1} \\equiv 1 \\pmod{x^n} Fâˆ—Fâˆ’1â‰¡1(modxn) å‡è®¾æˆ‘ä»¬å·²ç»å¾—çŸ¥Fâˆ—Gâ€²â‰¡1(modxn2)F \\ast G' \\equiv 1 \\pmod {x ^ {\\frac{n}{2}}}Fâˆ—Gâ€²â‰¡1(modx2nâ€‹)ï¼Œ æ¥æ±‚Fâˆ—Gâ‰¡1(modxn)F \\ast G \\equiv 1 \\pmod {x ^ n}Fâˆ—Gâ‰¡1(modxn) âˆµFâˆ—Gâ€²â‰¡1mod xn2,Fâˆ—Gâ‰¡1(modxn)âˆ´Fâˆ—Gâ‰¡1(modxn2)âˆ´Gâ€²âˆ’Gâ‰¡0(modxn2)âˆ´(Gâ€²âˆ’G)2â‰¡0(modxn)Gâ€²2âˆ’2GGâ€²+G2â‰¡0(modxn)\\because F \\ast G' \\equiv 1 \\mod {x ^ {\\frac{n}{2}}} , F \\ast G \\equiv 1 \\pmod {x ^ n} \\\\ \\therefore F \\ast G \\equiv 1 \\pmod {x ^ {\\frac{n}{2}}} \\\\ \\therefore G' - G \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ \\therefore (G' - G) ^ 2 \\equiv 0 \\pmod {x ^ n} \\\\ G'^2 - 2 G G' + G^2 \\equiv 0 \\pmod {x ^ n} \\\\ âˆµFâˆ—Gâ€²â‰¡1modx2nâ€‹,Fâˆ—Gâ‰¡1(modxn)âˆ´Fâˆ—Gâ‰¡1(modx2nâ€‹)âˆ´Gâ€²âˆ’Gâ‰¡0(modx2nâ€‹)âˆ´(Gâ€²âˆ’G)2â‰¡0(modxn)Gâ€²2âˆ’2GGâ€²+G2â‰¡0(modxn) æ¥ä¸‹æ¥ä¸¤è¾¹åŒæ—¶âˆ—F\\ast Fâˆ—Fï¼Œ FGâ€²2âˆ’2Gâ€²+Gâ‰¡0(modxn)âˆ´Gâ‰¡2Gâ€²âˆ’FGâ€²2(modxn)F G'^2 - 2 G' + G \\equiv 0 \\pmod {x ^ n} \\\\ \\therefore G \\equiv 2 G' - FG'^2 \\pmod {x ^ n} FGâ€²2âˆ’2Gâ€²+Gâ‰¡0(modxn)âˆ´Gâ‰¡2Gâ€²âˆ’FGâ€²2(modxn) ç„¶åç›´æ¥é€’å½’å³å¯ï¼Œ ä½¿ç”¨NTTï¼Œ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int F[N], G[N];int recover[N];void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}int c[N];void mul(int n, int *a, int *b){ if(n == 1) { b[0] = inv(a[0]); return; } mul((n + 1) &gt;&gt; 1, a, b); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}signed main(){ int n; scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); mul(n, F, G); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, (G[i] % mod + mod) % mod); return 0;} å¤šé¡¹å¼å¯¹æ•°å‡½æ•°(å¤šé¡¹å¼æ±‚ln) å®šä¹‰å¤šé¡¹å¼å¯¹æ•°å‡½æ•°ä¸º G=lnâ¡(F)(modxn)G = \\ln (F) \\pmod {x ^ n} G=ln(F)(modxn) å‡è®¾æˆ‘ä»¬æœ‰å¤šé¡¹å¼F(x)F(x)F(x)å’ŒG(x)G(x)G(x)ï¼Œ è®°G=lnâ¡F(modxn)G = \\ln F \\pmod {x ^ n}G=lnF(modxn)ï¼Œ Gâ‰¡lnâ¡F(modxn)Gâ€²â‰¡(lnâ¡F)â€™(modxn)Gâ€²â‰¡(lnâ¡â€²F)âˆ—Fâ€²(modxn)Gâ€²â‰¡Fâ€²F(modxn)G \\equiv \\ln F \\pmod {x ^ n} \\\\ G'\\equiv (\\ln F)â€™ \\pmod {x ^ n} \\\\ G' \\equiv (\\ln' F )\\ast F ' \\pmod {x ^n} \\\\ G' \\equiv \\frac{F'}{F} \\pmod {x^n} Gâ‰¡lnF(modxn)Gâ€²â‰¡(lnF)â€™(modxn)Gâ€²â‰¡(lnâ€²F)âˆ—Fâ€²(modxn)Gâ€²â‰¡FFâ€²â€‹(modxn) å¤šé¡¹å¼æ±‚é€†ï¼Œå†ç§¯å›å»å°±å¥½å•¦ã€‚ éœ€è¦ç”¨åˆ°æ±‚å¯¼ï¼šxaâ€²=axaâˆ’1x ^ {a'} = ax ^ {a - 1}xaâ€²=axaâˆ’1ï¼Œ ç§¯åˆ†ï¼šâˆ«xadx=1a+1xa+1\\int x^a \\mathrm{d}x = \\frac{1}{a + 1}x ^ {a + 1}âˆ«xadx=a+11â€‹xa+1ã€‚éœ€è¦ä¿è¯F0=1F_0 = 1F0â€‹=1ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}void diff(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i - 1] = i * a[i] % mod; b[n - 1] = 0;}void integ(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i] = a[i - 1] * inv(i) % mod; b[0] = 0;}int F[N], G[N], H[N];void polyln(int *a, int *b, int n){ int f[N], h[N]; memset(f, 0, sizeof(f)); memset(h, 0, sizeof(h)); diff(a, f, n); inverse(a, h, n); mul(f, h, H, n, n); integ(H, b, n);}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polyln(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} å¤šé¡¹å¼æŒ‡æ•°å‡½æ•°(å¤šé¡¹å¼exp) å®šä¹‰å¤šé¡¹å¼æŒ‡æ•°å‡½æ•°ä¸º G(x)=eF(x)(modxn)G(x) = e ^ {F(x)} \\pmod {x ^ n} G(x)=eF(x)(modxn) ç‰›é¡¿è¿­ä»£ ç‰›é¡¿è¿­ä»£ç”¨äºæ±‚å‡½æ•°é›¶ç‚¹ï¼Œé€šè¿‡ä¸æ–­åœ°åˆ‡çº¿é€¼è¿‘æ‰€æ±‚å€¼ï¼Œä½†æœ€ç»ˆä¹Ÿåªæ˜¯è¿‘ä¼¼å€¼ï¼Œè¿­ä»£çš„æ¬¡æ•°è¶Šå¤šï¼Œç²¾ç¡®åº¦è¶Šé«˜ï¼Œè¯¯å·®è¶Šå°ã€‚ å‡å¦‚æˆ‘ä»¬è¦å¯¹ä¸€ä¸ªéå¸¸å¤§çš„æ•°aaaå¼€æ–¹ï¼Œæ‰‹ç®—ï¼Œåˆ©ç”¨ç‰›é¡¿æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…¶å®æœ¬è´¨ä¸Šæ˜¯æ±‚å¾—f(x)=x2âˆ’af(x) = x ^2 - af(x)=x2âˆ’aç²¾ç¡®åˆ°æ•´æ•°å¾—é›¶ç‚¹ï¼Œå‡è®¾æˆ‘ä»¬å·²ç»æ±‚å¾—äº†ä¸€ä¸ªè¿‘ä¼¼å€¼x0x_0x0â€‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è¿‡(x0,f(x0))(x_0, f(x_0))(x0â€‹,f(x0â€‹))è¿™ä¸ªç‚¹ï¼Œ ä½œè¿™ä¸ªå‡½æ•°å›¾åƒçš„åˆ‡çº¿ï¼Œå–åˆ‡çº¿ä¸xxxè½´çš„äº¤ç‚¹ä½œä¸ºæ–°çš„x0x_0x0â€‹ã€‚ å‡è®¾æˆ‘ä»¬è¦æ±‚ä¸€ä¸ªå‡½æ•°f(x)f(x)f(x)çš„é›¶ç‚¹ï¼Œ åˆå§‹è¿‘ä¼¼å€¼æ˜¯x0x_0x0â€‹ï¼Œåˆ™åˆ‡çº¿æ–¹ç¨‹ä¸º y=fâ€²(x0)(xâˆ’x0)+f(x0)y = f'(x_0)(x - x_0) + f(x_0) y=fâ€²(x0â€‹)(xâˆ’x0â€‹)+f(x0â€‹) ä»¤y=0y = 0y=0ï¼Œå¾—åˆ°x=x0âˆ’f(x0)fâ€²(x0)x = x_0 - \\frac{f(x_0)}{f'(x_0)}x=x0â€‹âˆ’fâ€²(x0â€‹)f(x0â€‹)â€‹ã€‚ å‡è®¾æˆ‘ä»¬ç°åœ¨è¦æ±‚F(G(x))â‰¡0F(G(x)) \\equiv 0F(G(x))â‰¡0ï¼Œç„¶ååˆ©ç”¨ä¸Šé¢çš„å¼å­æ¯ä¸€æ¬¡ä»¤ G(x)=G0(x)âˆ’F(G0(x))Fâ€²(G0(x))G(x) = G_0(x) - \\frac{F(G_0(x))}{F'(G_0(x))} G(x)=G0â€‹(x)âˆ’Fâ€²(G0â€‹(x))F(G0â€‹(x))â€‹ ç„¶åå°±å¯ä»¥å¾ˆå¿«çš„é€¼è¿‘çœŸå®å€¼ã€‚ æ¥ä¸‹æ¥æ¨ä¸€ä¸‹å¤šé¡¹å¼exp B(x)â‰¡eA(x)(modxn)lnâ¡B(x)âˆ’A(x)â‰¡0(modxn)B(x) \\equiv e ^ {A(x)} \\pmod {x ^ n} \\\\ \\ln B(x) - A(x) \\equiv 0 \\pmod {x^ n} B(x)â‰¡eA(x)(modxn)lnB(x)âˆ’A(x)â‰¡0(modxn) ç°åœ¨é—®é¢˜å˜ä¸ºäº†ä½¿å¾—F(G(x))=lnâ¡G(x)âˆ’A(x)â‰¡0F(G(x)) = \\ln G(x) - A(x) \\equiv 0F(G(x))=lnG(x)âˆ’A(x)â‰¡0ã€‚ ç„¶åæ±‚å¯¼ï¼Œ Fâ€²(G0(x))=1G0(x)F'(G_0(x)) = \\frac{1}{G_0(x)} Fâ€²(G0â€‹(x))=G0â€‹(x)1â€‹ ç„¶åæ¥ç€å¸¦å…¥ä¸Šé¢ç‰›é¡¿è¿­ä»£çš„å¼å­ï¼Œ G(x)=G0(x)(1âˆ’lnâ¡G0(x)+A(x))G(x) = {G_0(x)(1 - \\ln G_0(x) + A(x))} G(x)=G0â€‹(x)(1âˆ’lnG0â€‹(x)+A(x)) æ¯æ¬¡è¿­ä»£ï¼Œä½¿ç”¨å¤šé¡¹å¼æ±‚lnâ¡\\lnlnï¼Œç„¶åå†åšä¸€éå¤šé¡¹å¼ä¹˜æ³•ï¼Œç„¶åå°±å¯ä»¥å¾—åˆ°ç­”æ¡ˆï¼Œæ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn)ã€‚ éœ€è¦ä¿è¯F0=0F_0 = 0F0â€‹=0ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}void diff(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i - 1] = i * a[i] % mod; b[n - 1] = 0;}void integ(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i] = a[i - 1] * inv(i) % mod; b[0] = 0;}int F[N], G[N], H[N];void polyln(int *a, int *b, int n){ int f[N], h[N]; memset(f, 0, sizeof(f)); memset(h, 0, sizeof(h)); diff(a, f, n); inverse(a, h, n); mul(f, h, H, n, n); integ(H, b, n);}void polyexp(int *a, int *b, int n){ if(n == 1) { b[0] = 1; return; } polyexp(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); c[0] = 1; int f[N]; memset(f, 0, sizeof(f)); polyln(b, f, n); add(c, a, c, n, n, 1); add(c, f, c, n, n, -1); mul(c, b, c, n, n); for(int i = 0; i &lt; n; i++) b[i] = c[i]; for(int i = n; i &lt; len; i++) b[i] = 0;}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polyexp(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} å¤šé¡¹å¼å¼€æ ¹ å¤šé¡¹å¼å¼€æ ¹ç”¨æ¥è§£å†³ G2(x)â‰¡F(x)(modxn)G^2(x) \\equiv F(x) \\pmod {x^n} G2(x)â‰¡F(x)(modxn) å‡è®¾æˆ‘ä»¬æœ‰Gâ€²2(x)â‰¡F(x)(modxn2),H(G(x))=G2(x)âˆ’FG'^2(x) \\equiv F(x) \\pmod {x ^ {\\frac{n}{2}}}, H(G(x)) = G^2(x) - FGâ€²2(x)â‰¡F(x)(modx2nâ€‹),H(G(x))=G2(x)âˆ’Fï¼Œæ±‚G2(x)â‰¡F(x)(modxn)G^2(x) \\equiv F(x) \\pmod {x ^ n}G2(x)â‰¡F(x)(modxn)ï¼Œ Gâ€²2(x)â‰¡F(x)mod xn2,G2(x)â‰¡F(x)(modxn2)G2(x)âˆ’Fâ‰¡0(modxn2)H(G)â‰¡0(modxn2)Gâ‰¡Gâ€²âˆ’H(Gâ€²)Hâ€²(Gâ€²)(modxn)Gâ‰¡Gâ€²2+F2Gâ€²(modxn)G'^2 (x) \\equiv F(x) \\mod x ^ {\\frac{n}{2}} , G^2(x) \\equiv F(x) \\pmod {x ^ {\\frac{n}{2}}} \\\\ G^2(x) - F \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ H(G) \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ G \\equiv G' - \\frac{H(G')}{H'(G')} \\pmod {x ^ n} \\\\ G \\equiv \\frac{G'^2 + F} {2G'} \\pmod {x ^ n} Gâ€²2(x)â‰¡F(x)modx2nâ€‹,G2(x)â‰¡F(x)(modx2nâ€‹)G2(x)âˆ’Fâ‰¡0(modx2nâ€‹)H(G)â‰¡0(modx2nâ€‹)Gâ‰¡Gâ€²âˆ’Hâ€²(Gâ€²)H(Gâ€²)â€‹(modxn)Gâ‰¡2Gâ€²Gâ€²2+Fâ€‹(modxn) éœ€è¦ä¿è¯F0=1F_0 = 1F0â€‹=1ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int inv2 = inv(2);void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}int F[N], G[N], H[N];void polysqrt(int *a, int *b, int n){ if(n == 1) { b[0] = 1; return; } polysqrt(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); int f[N]; memset(f, 0, sizeof(f)); inverse(b, f, n); for(int i = 0; i &lt; n; i++) c[i] = a[i]; NTT(f, len, 1), NTT(b, len, 1), NTT(c, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (b[i] + c[i] * f[i] % mod) % mod * inv2 % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++) b[i] = 0;}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polysqrt(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} å¤šé¡¹å¼å¹‚å‡½æ•° å¤šé¡¹å¼å¹‚å‡½æ•°æ˜¯ç”¨æ¥è§£å†³ G(x)â‰¡(F(x))kmod xnG(x) \\equiv (F(x)) ^ k \\mod x ^ n G(x)â‰¡(F(x))kmodxn å…ˆæ±‚ä¸€élnâ¡\\lnlnç„¶åä¹˜ä»¥kkkå†ä½¿ç”¨expâ¡\\expexpï¼Œå°±å¥½å•¦ã€‚ éœ€ä¿è¯F0=1F_0 = 1F0â€‹=1ã€‚ å¤šé¡¹å¼çš„ä¸€äº›æ™®é€šæƒ…å†µ å¤šé¡¹å¼æ±‚ln ä¸ä¿è¯F0=1F_0 = 1F0â€‹=1ã€‚ä¸å­˜åœ¨ï¼Œæœ‰å®šç†ï¼š åœ¨æ¨¡æ„ä¹‰ä¸‹å½“ä¸”ä»…å½“F0=1F_0 = 1F0â€‹=1ï¼Œ F(x)F(x)F(x)æœ‰å¯¹æ•°å¤šé¡¹å¼é—®é¢˜ã€‚ å¤šé¡¹å¼æ±‚exp ä¸ä¿è¯F0=0F_0 = 0F0â€‹=0 ã€‚åŒå¤šé¡¹å¼æ±‚lnâ¡\\lnlnã€‚ å¤šé¡¹å¼å¼€æ ¹ ä¸ä¿è¯F0=1F_0 = 1F0â€‹=1ï¼Œä½†ä¿è¯F0F_0F0â€‹æ˜¯ mod 998244353\\bmod 998244353mod998244353ä¸‹çš„äºŒæ¬¡å‰©ä½™ã€‚ è¾¹ç•Œæ±‚ä¸€éäºŒæ¬¡å‰©ä½™å³å¯ã€‚ å¤šé¡¹å¼å¹‚å‡½æ•° ä¸ä¿è¯F0=1F_0 = 1F0â€‹=1ã€‚å¯ä»¥å…ˆæ‰¾åˆ°ç³»æ•°ä¸ä¸º000çš„ä¸€é¡¹ï¼Œç„¶åè®©å¼å­é™¤ä»¥è¿™ä¸€é¡¹æœ€åå†ä¹˜å›æ¥å°±å¥½äº† F(x)k=(F(x)xt)kxtkF(x)^k = \\bigg( \\frac{F(x)}{x ^ t} \\bigg) ^ k x ^ {tk} F(x)k=(xtF(x)â€‹)kxtk åˆ†æ²»FFT/NTT ç»™å®šåºåˆ—gggå’Œfffï¼Œ å…¶ä¸­ fi=âˆ‘j=1ifiâˆ’jgjf_i= \\sum_{j = 1} ^ i f _{i - j} g _ j fiâ€‹=j=1âˆ‘iâ€‹fiâˆ’jâ€‹gjâ€‹ æ±‚fffï¼Œ è¿™é‡Œç»™å‡ºä¸€ä¸ªå¤šé¡¹å¼æ±‚é€†çš„æ–¹æ³•ï¼Œï¼ˆæ‰¾æ—¶é—´å†è¡¥åˆ†æ²»FFT / NTTï¼‰ è®¾F(x)=âˆ‘i=0âˆfixi,G(x)=âˆ‘i=0âˆgixiF(x) = \\sum_{i = 0} ^ {\\infty} f_i x ^ i , G(x) = \\sum_{i = 0} ^ {\\infty}g_i x ^ iF(x)=âˆ‘i=0âˆâ€‹fiâ€‹xi,G(x)=âˆ‘i=0âˆâ€‹giâ€‹xiï¼Œä¸”g0=0g_0 = 0g0â€‹=0ï¼Œ æ‰€ä»¥æœ‰ F(x)G(x)=âˆ‘i=0âˆâˆ‘j+k=ifjgk=F(x)âˆ’f0x0F(x)G(x)â‰¡F(x)âˆ’f0(modxn)F(x)â‰¡(1âˆ’G(x))âˆ’1(modxn)F(x) G(x) = \\sum_{i = 0} ^ {\\infty} \\sum_{j + k = i}f_jg_k = F(x) - f_0 x ^ 0 \\\\ F(x)G(x) \\equiv F(x) - f_0 \\pmod {x ^ n} \\\\ F(x) \\equiv (1 - G(x)) ^ {-1} \\pmod {x ^ n} F(x)G(x)=i=0âˆ‘âˆâ€‹j+k=iâˆ‘â€‹fjâ€‹gkâ€‹=F(x)âˆ’f0â€‹x0F(x)G(x)â‰¡F(x)âˆ’f0â€‹(modxn)F(x)â‰¡(1âˆ’G(x))âˆ’1(modxn) ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³• å‡è®¾æˆ‘ä»¬å·²çŸ¥nnnæ¬¡å¤šé¡¹å¼f(x)f(x)f(x)åœ¨[0,n][0, n][0,n]çš„ç‚¹å€¼ï¼Œ æ±‚å®ƒçš„ä¸‹é™å¹‚è¡¨ç¤ºï¼Œ è®¾f(x)=âˆ‘i=0nbixiâ€¾=âˆ‘i=0nbix!(xâˆ’i)!f(x) = \\sum_{i = 0} ^ n b_i x^{\\underline{i}} = \\sum_{i = 0} ^ n b_i\\frac{x!}{(x -i)!}f(x)=âˆ‘i=0nâ€‹biâ€‹xiâ€‹=âˆ‘i=0nâ€‹biâ€‹(xâˆ’i)!x!â€‹ï¼Œåˆ™æœ‰ f(x)x!=âˆ‘i=0nbi1(xâˆ’i)!=bâˆ—ex\\frac{f(x)}{x!} = \\sum_{i = 0} ^ n b_i \\frac{1}{(x - i) !} = b \\ast e^x x!f(x)â€‹=i=0âˆ‘nâ€‹biâ€‹(xâˆ’i)!1â€‹=bâˆ—ex å…ˆè½¬åŒ–ä¸ºç‚¹å€¼æœ€åå·ä¸Šexe^xexå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;const int g = 3;const int gi = 332748118;const int N = 8e5 + 10;int recover[N];int n, m;int A[N], B[N], F[N], G[N], H[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}int fac[N], ifac[N];signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;G[i]); int len = 1, cnt = 0, Len = max(n, m) &lt;&lt; 1; while(len &lt;= (Len &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= Len; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= Len; i++) ifac[i] = inv(fac[i]); for(int i = 0; i &lt;= Len; i++) { if(i &amp; 1)B[i] = ((mod - ifac[i]) % mod + mod) % mod; else B[i] = ifac[i]; A[i] = ifac[i]; } NTT(A, len, 1); NTT(B, len, 1); NTT(F, len, 1); NTT(G, len, 1); for(int i = 0; i &lt; len; i++) { F[i] = A[i] * F[i] % mod; G[i] = A[i] * G[i] % mod; } NTT(F, len, -1); NTT(G, len, -1); for(int i = 0; i &lt;= Len; i++) H[i] = F[i] % mod * G[i] % mod * fac[i] % mod; NTT(H, len, 1); for(int i = 0; i &lt; len; i++) H[i] = H[i] * B[i] % mod; NTT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%lld &quot;, H[i]); return 0;} å¤šé¡¹å¼é™¤æ³• ç»™å®šä¸€ä¸ªnnnæ¬¡å¤šé¡¹å¼F(x)F(x)F(x)å’Œä¸€ä¸ªmmmæ¬¡å¤šé¡¹å¼G(x)G(x)G(x)ï¼Œ æ±‚å¤šé¡¹å¼A(x),B(x)A(x),B(x)A(x),B(x)ï¼Œæ»¡è¶³ï¼š A(x)A(x)A(x)æ¬¡æ•°ä¸ºnâˆ’mn - mnâˆ’mï¼Œ B(x)B(x)B(x)æ¬¡æ•°å°äºmmm F(x)=A(x)âˆ—G(x)+B(x)F(x) = A(x) \\ast G(x) + B(x)F(x)=A(x)âˆ—G(x)+B(x) æ‰€æœ‰è¿ç®—åœ¨æ¨¡998244353998244353998244353ä¸‹è¿›è¡Œã€‚ å®šä¹‰ä¸€ç§è®©å¤šé¡¹å¼åè½¬çš„æ“ä½œä¸ºAâ€²(x)=xnA(1x)A'(x) = x^n A(\\frac{1}{x})Aâ€²(x)=xnA(x1â€‹)ï¼Œç„¶ååŒ–ç®€å¼å­ F(x)=A(x)âˆ—G(x)+B(x)xnF(1x)=xnâˆ’mA(1x)âˆ—xmG(1x)+xnâˆ’m+1âˆ—xmâˆ’1B(1x)Fâ€²(x)=Aâ€²(x)âˆ—Gâ€²(x)+xnâˆ’m+1âˆ—Bâ€²(x)Fâ€²(x)â‰¡Aâ€²(x)âˆ—Gâ€²(x)(modxnâˆ’m+1)Aâ€²(x)â‰¡Fâ€²(x)âˆ—Gâ€²âˆ’1(x)(modxnâˆ’m+1)F(x) = A(x) \\ast G(x) + B(x) \\\\ x^n F(\\frac{1}{x}) = x^{n - m} A(\\frac{1}{x}) \\ast x^m G(\\frac{1}{x}) + x^{n - m + 1}\\ast x ^{m - 1} B(\\frac{1}{x}) \\\\ F'(x) = A'(x) \\ast G'(x) + x^{n - m + 1} \\ast B'(x) \\\\ F'(x) \\equiv A'(x) \\ast G'(x) \\pmod {x^{n - m + 1}} \\\\ A'(x) \\equiv F'(x) \\ast G'^{-1}(x) \\pmod {x^{n - m + 1}} F(x)=A(x)âˆ—G(x)+B(x)xnF(x1â€‹)=xnâˆ’mA(x1â€‹)âˆ—xmG(x1â€‹)+xnâˆ’m+1âˆ—xmâˆ’1B(x1â€‹)Fâ€²(x)=Aâ€²(x)âˆ—Gâ€²(x)+xnâˆ’m+1âˆ—Bâ€²(x)Fâ€²(x)â‰¡Aâ€²(x)âˆ—Gâ€²(x)(modxnâˆ’m+1)Aâ€²(x)â‰¡Fâ€²(x)âˆ—Gâ€²âˆ’1(x)(modxnâˆ’m+1) å…ˆè¿›è¡Œå¤šé¡¹å¼æ±‚é€†ï¼Œç„¶åå†æ¨B(x)=F(x)âˆ’A(x)âˆ—G(x)B(x) = F(x) - A(x) \\ast G(x)B(x)=F(x)âˆ’A(x)âˆ—G(x)ã€‚ å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ å’•å’•å’• å¤šé¡¹å¼å¤åˆå‡½æ•° æœ‰F(x),G(x)F(x), G(x)F(x),G(x)ï¼Œæ±‚ H(x)â‰¡F(G(x))(modxn+1)H(x) \\equiv F(G(x)) \\pmod {x^{n + 1}} H(x)â‰¡F(G(x))(modxn+1) å³ï¼š H(x)â‰¡âˆ‘i=0n[xi]F(x)Ã—G(x)i(modxn+1)H(x) \\equiv \\sum_{i = 0} ^n[x^i] F(x) \\times G(x)^i \\pmod {x^{n + 1}} H(x)â‰¡i=0âˆ‘nâ€‹[xi]F(x)Ã—G(x)i(modxn+1) å¯¹998244353998244353998244353å–æ¨¡ã€‚ è®¾m=nm = \\sqrt nm=nâ€‹ï¼Œåˆ™ âˆ‘i=0n[xi]F(x)G(x)i=âˆ‘i=0mâˆ’1âˆ‘j=0mâˆ’1[xim+j]F(x)G(x)im+j=âˆ‘i=0mâˆ’1G(x)imâˆ‘j=0mâˆ’1[xim+j]F(x)G(x)j\\sum_{i = 0} ^ n [x^i] F(x)G(x) ^ i = \\sum_{i = 0} ^ {m - 1} \\sum_{j = 0} ^ {m - 1}[x^{im + j}]F(x)G(x)^{im + j} = \\sum_{i = 0}^{m - 1}G(x)^{im}\\sum_{j = 0} ^ {m - 1}[x^{im+j}]F(x)G(x)^j i=0âˆ‘nâ€‹[xi]F(x)G(x)i=i=0âˆ‘mâˆ’1â€‹j=0âˆ‘mâˆ’1â€‹[xim+j]F(x)G(x)im+j=i=0âˆ‘mâˆ’1â€‹G(x)imj=0âˆ‘mâˆ’1â€‹[xim+j]F(x)G(x)j ç„¶åé¢„å¤„ç†G(x)imG(x)^{im}G(x)imå’ŒG(x)jG(x)^jG(x)jï¼Œå…¶å®ƒçš„ç›´æ¥æš´åŠ›è®¡ç®—ï¼Œ æ—¶é—´å¤æ‚åº¦O(n2+nnlogâ¡n)O(n^2 + n \\sqrt n \\log n)O(n2+nnâ€‹logn)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &lt;bits/stdc++.h&gt;using namespace std;namespace Poly// ä½¿ç”¨NTTå®ç°{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // æ¨¡æ•° const int g = 3; // åŸæ ¹ const int gi = 332748118; // é€†å…ƒ const int N = 8e4 + 10; // size int save[3][32]; int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// å¿«é€Ÿå¹‚ int inv(int x) { return qpow(x, mod - 2);}// é€†å…ƒ void prework() { for(int i = 1, k = 1; i &lt;= 20; i++, k &lt;&lt;= 1) { save[0][i] = qpow(g, (mod - 1) / (k &lt;&lt; 1)); save[1][i] = qpow(gi, (mod - 1) / (k &lt;&lt; 1)); save[2][i] = inv(k); } } void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// åˆå§‹åŒ– void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); int cnt = 1; for(int k = 1; k &lt; len; k &lt;&lt;= 1, cnt++) { int x = (type == 1) ? save[0][cnt] : save[1][cnt]; for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = save[2][cnt]; for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// ä¹˜æ³•é€† void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// å¤šé¡¹å¼æ±‚å¯¼ void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// å¤šé¡¹å¼ç§¯åˆ† poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// å¤šé¡¹å¼lnå‡½æ•° void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼expå‡½æ•° const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼å¼€æ ¹ void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// å¤šé¡¹å¼å¹‚å‡½æ•° #undef int}using namespace Poly;int n, m;poly Gpow[200], Gm[200];int main(){ prework(); cin &gt;&gt; n &gt;&gt; m; n = n + 1; m = m + 1; poly F, G, H; F.clear(n); G.clear(m); for(int i = 0; i &lt; n; i++) cin &gt;&gt; F.v[i]; for(int i = 0; i &lt; m; i++) cin &gt;&gt; G.v[i]; int l = sqrt(n) + 1; Gpow[0].v[0] = 1; Gm[0].v[0] = 1; Gpow[0].length(n); Gm[0].length(n); Gpow[1] = G; Gpow[1].length(n); for(int i = 2; i &lt;= l; i++) { Gpow[i] = Gpow[i - 1] * G; Gpow[i].length(n); Gpow[i].memset0(n, n &lt;&lt; 1); } Gm[1] = Gpow[l]; Gm[1].length(n); for(int i = 2; i &lt;= l; i++) { Gm[i] = Gm[i - 1] * Gpow[l]; Gm[i].length(n); Gm[i].memset0(n, n &lt;&lt; 1); } poly A; A.clear(n); H.clear(n); for(int i = 0; i &lt; l; i++) { A.memset0(0, n &lt;&lt; 1); A.length(n); for(int j = 0; j &lt; l; j++) { for(int k = 0; k &lt; n; k++) A.v[k] = (A.v[k] + F.v[i * l + j] * Gpow[j].v[k]) % mod; } A = A * Gm[i]; A.length(n); H = H + A; } for(int i = 0; i &lt; n; i++) cout &lt;&lt; H.v[i] &lt;&lt; &quot; &quot;; return 0;} å¤šé¡¹å¼å¤åˆé€† æœ‰F(x)F(x)F(x)ï¼Œæ±‚ G(F(x))â‰¡x(modxn)G(F(x)) \\equiv x \\pmod {x ^ n} G(F(x))â‰¡x(modxn) å¯¹998244353998244353998244353å–æ¨¡ã€‚ æœ‰æ‹‰æ ¼æœ—æ—¥åæ¼”å…¬å¼ï¼š [xn]G(x)=1n[xnâˆ’1](xF(x))n[x^n]G(x) = \\frac{1}{n}[x^{n - 1}](\\frac{x}{F(x)})^n [xn]G(x)=n1â€‹[xnâˆ’1](F(x)xâ€‹)n è¿™ä¸ªæ˜¯æ±‚å•é¡¹ç³»æ•°çš„ï¼Œ éœ€è¦æ±‚çš„æ˜¯æ‰€æœ‰ç³»æ•°ã€‚ åˆ©ç”¨è§£å†³å¤šé¡¹å¼å¤åˆå‡½æ•°çš„æ–¹æ³•ï¼Œ ä»¤m=nm = \\sqrt nm=nâ€‹ï¼Œ åˆ™ G(x)=âˆ‘i=1n(1i[xiâˆ’1](xF(x))i)=âˆ‘i=0mâˆ’1âˆ‘j=1m(1im+j[xim+jâˆ’1](xF(x))im+j)xim+j=âˆ‘i=0mâˆ’1âˆ‘j=1m(1im+j[xim+jâˆ’1](xF(x))im(xF(x))j)xim+jG(x) = \\sum_{i = 1}^{n}\\bigg ( \\frac{1}{i}[x^{i - 1}] (\\frac{x}{F(x)})^i \\bigg) = \\sum_{i = 0}^{m - 1}\\sum_{j = 1} ^{m }\\bigg( \\frac{1}{im + j}[x^{im + j - 1}](\\frac{x}{F(x)})^{im + j} \\bigg)x^{im + j} = \\sum_{i = 0}^{m - 1}\\sum_{j = 1} ^ m \\bigg( \\frac{1}{im + j} [x^{im + j - 1}](\\frac{x}{F(x)})^im (\\frac{x}{F(x)})^j \\bigg)x^{im + j} G(x)=i=1âˆ‘nâ€‹(i1â€‹[xiâˆ’1](F(x)xâ€‹)i)=i=0âˆ‘mâˆ’1â€‹j=1âˆ‘mâ€‹(im+j1â€‹[xim+jâˆ’1](F(x)xâ€‹)im+j)xim+j=i=0âˆ‘mâˆ’1â€‹j=1âˆ‘mâ€‹(im+j1â€‹[xim+jâˆ’1](F(x)xâ€‹)im(F(x)xâ€‹)j)xim+j ç„¶åå°±æ˜¯å’Œå¤šé¡¹å¼å¤åˆå‡½æ•°çš„ä¸€æ ·çš„å¤„ç†æ–¹æ³•ï¼Œæ—¶é—´å¤æ‚åº¦O(n2+nlogâ¡n)O(n^2 + \\sqrt n \\log n)O(n2+nâ€‹logn)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define vec vector &lt;int&gt;const int N = 8e4 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;struct poly{ vector &lt;int&gt; v; poly(){v.resize(N);}};int save[3][32];int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void prework(){ for(int i = 1, k = 1; i &lt;= 20; i++, k &lt;&lt;= 1) { save[0][i] = qpow(g, (mod - 1) / (k &lt;&lt; 1)); save[1][i] = qpow(gi, (mod - 1) / (k &lt;&lt; 1)); save[2][i] = inv(k); }}void NTT(vec &amp;a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); int cnt = 1; for(int k = 1; k &lt; len; k &lt;&lt;= 1, cnt++) { int x = (type == 1) ? save[0][cnt] : save[1][cnt]; for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = save[2][cnt]; for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}vec tmp;void inverse(poly &amp;A, poly &amp;B, int n){ if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0;}int n;poly Finv[200], Fm[200];signed main(){ poly F; prework(); cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; F.v[i]; for(int i = 0; i &lt; n; i++) F.v[i] = F.v[i + 1]; n = n - 1; int m = sqrt(n) + 1; poly A; inverse(F, A, n); Finv[0].v[0] = Fm[0].v[0] = 1; int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); Finv[1] = A; NTT(A.v, len, 1); for(int i = 2; i &lt;= m; i++) { NTT(Finv[i - 1].v, len, 1); for(int j = 0; j &lt; len; j++) Finv[i].v[j] = Finv[i - 1].v[j] * A.v[j] % mod; NTT(Finv[i].v, len, -1); NTT(Finv[i - 1].v, len, -1); for(int j = n; j &lt; (n &lt;&lt; 1); j++) Finv[i].v[j] = 0; } A = Finv[m]; NTT(A.v, len, 1); Fm[1] = Finv[m]; for(int i = 2; i &lt;= m; i++) { NTT(Fm[i - 1].v, len, 1); for(int j = 0; j &lt; len; j++) Fm[i].v[j] = Fm[i - 1].v[j] * A.v[j] % mod; NTT(Fm[i].v, len, -1); NTT(Fm[i - 1].v, len, -1); for(int j = n; j &lt; (n &lt;&lt; 1); j++) Fm[i].v[j] = 0; } poly G; bool res = false; for(int i = 0; i &lt;= m; i++) { for(int j = 1; j &lt;= m; j++) { if(i * m + j - 1 &gt; n) { res = true; break; } int sum = 0; for(int k = 0; k &lt;= i * m + j - 1; k++) sum = (sum + Finv[j].v[k] * Fm[i].v[i * m + j - 1 - k] % mod) % mod; G.v[i * m + j] = sum * inv(i * m + j) % mod; } if(res)break; } for(int i = 0; i &lt;= n; i++) cout &lt;&lt; G.v[i] &lt;&lt; &quot; &quot;; return 0;}","link":"/2022/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"å¤šé¡¹å¼æ¿å­","text":"å¤šé¡¹å¼æ¿å­ å¤šé¡¹å¼æ¨¡æ¿ ç›®å‰æ”¯æŒ å¤šé¡¹å¼ä¹˜æ³• å¤šé¡¹å¼æ±‚é€† å¤šé¡¹å¼å¼€æ ¹ å¤šé¡¹å¼å¹‚å‡½æ•° å¤šé¡¹å¼å¯¹æ•°å‡½æ•° å¤šé¡¹å¼æŒ‡æ•°å‡½æ•° ä»»æ„æ¨¡æ•°NTT ï¼ˆå¸¸æ•°å·¨å¤§, å¡å¸¸çš„è¯å»ºè®®é¢„å¤„ç†åŸæ ¹ï¼‰ ä¸å«ä»»æ„æ¨¡æ•°NTTï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178namespace Poly// ä½¿ç”¨NTTå®ç°{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // æ¨¡æ•° const int g = 3; // åŸæ ¹ const int gi = 332748118; // é€†å…ƒ const int N = 6e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// å¿«é€Ÿå¹‚ int inv(int x) { return qpow(x, mod - 2);}// é€†å…ƒ void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// åˆå§‹åŒ– void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} int &amp;operator [] (int i){return v[i];} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A[i] = (A[i] + B[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A[i] = ((A[i] - B[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A[i] = (A[i] * B[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = inv(A[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B[i] = (2 - B[i] * tmp[i] % mod + mod) % mod * B[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B[i] = 0; }// ä¹˜æ³•é€† void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B[i - 1] = i * A[i] % mod; B[n - 1] = 0; B.length(n); }// å¤šé¡¹å¼æ±‚å¯¼ void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B[i] = A[i - 1] * inv(i) % mod; B[0] = 0; B.length(n); }// å¤šé¡¹å¼ç§¯åˆ† poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// å¤šé¡¹å¼lnå‡½æ•° void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B[i] = C[i]; for(int i = n; i &lt; len; i++)B[i] = 0; }// å¤šé¡¹å¼expå‡½æ•° const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G[i] = A[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B[i] = (B[i] + G[i] * H[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B[i] = 0; }// å¤šé¡¹å¼å¼€æ ¹ void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I[i] *= k) %= mod; Exp(I, B, n); }// å¤šé¡¹å¼å¹‚å‡½æ•° #undef int}using namespace Poly; å«ä»»æ„æ¨¡æ•°NTT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313namespace Poly// ä½¿ç”¨NTTå®ç°{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // æ¨¡æ•° const int g = 3; // åŸæ ¹ const int gi = 332748118; // é€†å…ƒ const int N = 4e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// å¿«é€Ÿå¹‚ int inv(int x) { return qpow(x, mod - 2);}// é€†å…ƒ void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// åˆå§‹åŒ– void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// ä¹˜æ³•é€† void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// å¤šé¡¹å¼æ±‚å¯¼ void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// å¤šé¡¹å¼ç§¯åˆ† poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// å¤šé¡¹å¼lnå‡½æ•° void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼expå‡½æ•° const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// å¤šé¡¹å¼å¼€æ ¹ void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// å¤šé¡¹å¼å¹‚å‡½æ•° #undef int namespace anyNTT // ä»»æ„æ¨¡æ•°NTT { #define int __int128 int read() { int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){if(ch == '-')f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x*10 + ch-'0'; ch = getchar();} return x * f; } void write(int x) { char ch[100]; int len = 0; if(x == 0)ch[++len] = '0'; while(x)ch[++len] = x%10 + '0', x /= 10; while(len)putchar(ch[len--]); printf(&quot; &quot;); } int p[3] = {469762049, 998244353, 1004535809}; int qpow(int a, int b, int i) { int t = 1; while(b != 0) { if(b &amp; 1) t = t * a % p[i]; a = a * a % p[i]; b &gt;&gt;= 1; } return t % p[i]; } int inv(int x, int i) { return qpow(x, p[i] - 2, i); } int gi[3]; void init() { for(int i = 0; i &lt; 3; i++) gi[i] = inv(g, i); } int F[N], G[N], H[N]; int recover[N]; void NTT(int *a, int len, int type, int f) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi[f], (p[f] - 1) / (k &lt;&lt; 1), f); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % p[f]; int z = w * a[i + j + k] % p[f]; a[i + j] = (y + z) % p[f]; a[i + j + k] = (y - z + p[f]) % p[f]; w = w * x % p[f]; } } } if(type == -1) { int iv = inv(len, f); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % p[f]; } } int A[N], B[N], C[3][N]; void CRT(int len) { int M = p[0] * p[1]; for(int i = 0; i &lt;= len; i++) { H[i] = (p[1] * C[0][i] % M * inv(p[1], 0) % M + p[0] * C[1][i] % M * inv(p[0], 1) % M) % M; } } int n, m, mod; void merge(int len) { for(int i = 0; i &lt;= len; i++) { int k = ((C[2][i] - H[i]) % p[2] + p[2]) % p[2] * inv(p[0] * p[1], 2) % p[2]; H[i] = ((k * p[0] * p[1] % mod + H[i] % mod) % mod + mod) % mod; } } void prework() { memcpy(A, F, sizeof(F)); memcpy(B, G, sizeof(G)); } void update(int x, int len) { for(int i = 0; i &lt; len; i++) C[x][i] = A[i] * B[i] % p[x]; } void anyNTT(poly F, poly G, poly &amp;H, int p) { init(); mod = (int)p; for(int i = 0; i &lt; F.len; i++) anyNTT::F[i] = (int)F.v[i]; for(int i = 0; i &lt; G.len; i++) anyNTT::G[i] = (int)G.v[i]; n = F.len, m = G.len; int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; 3; i++) { prework(); NTT(A, len, 1, i), NTT(B, len, 1, i); update(i, len); NTT(C[i], len, -1, i); } CRT(n + m); merge(n + m); for(int i = 0; i &lt;= (n + m); i++) H.v[i] = (long long)anyNTT::H[i]; } } #undef int}using namespace Poly;","link":"/2022/09/30/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90/"},{"title":"åæ¼”å˜æ¢","text":"ç”¨çš„å¥½åƒå¾ˆå°‘ï¼Œæ¯•ç«Ÿæ˜¯æ•°ç«çŸ¥è¯†ã€‚ åæ¼”å˜æ¢ å‰è¨€ åæ¼”å˜æ¢é€‚ç”¨äºé¢˜ç›®ä¸­å‡ºç°å¤šä¸ªåœ†æˆ–ç›´çº¿ä¹‹é—´çš„ç›¸åˆ‡å…³ç³»çš„æƒ…å†µï¼Œåæ¼”å˜æ¢å¯ä»¥æœ‰æ•ˆç®€ä¾¿çš„è§£å†³è¿™ç±»é—®é¢˜ã€‚ å®šä¹‰ è®¾åœ¨å¹³é¢å†…ç»™å®šä¸€ç‚¹OOOå’Œå¸¸æ•°kkkï¼Œå¯¹äºå¹³é¢å†…ä»»æ„ä¸€AAAï¼Œç¡®å®šAâ€²A'Aâ€²ï¼Œä½¿Aâ€²A'Aâ€²ä¸ºç›´çº¿OAOAOAä¸Šä¸€ç‚¹ï¼Œå¹¶ä¸”OAâƒ—â‹…OAâ€²âƒ—=k\\vec{OA} \\cdot \\vec{OA'} = kOAâ‹…OAâ€²=kï¼Œæˆ‘ä»¬ç§°è¿™ç§å˜æ¢ä¸ºåæ¼”å˜æ¢ï¼Œç‚¹OOOå³ä¸ºåæ¼”ä¸­å¿ƒAâ€²A'Aâ€²ä¸ºAAAå…³äºç‚¹OOOçš„åæ¼”ç‚¹ã€‚ åæ¼”å˜æ¢æœ¬è´¨ä¸Šæ˜¯å±äºå¹³ç§»ï¼Œæ—‹è½¬ï¼Œåå°„ä¸€ç±»çš„å‡ ä½•å˜æ¢ã€‚ ä»¥OOOç‚¹ä¸ºåœ†å¿ƒï¼Œâˆ£kâˆ£\\sqrt{|k|}âˆ£kâˆ£â€‹ä¸ºåŠå¾„ä½œåœ†ï¼Œå°±å¾—åˆ°äº†ä¸€ä¸ªåœ†çš„åæ¼”å˜æ¢ï¼š æ¥ä¸‹æ¥è®¨è®ºå…¶ç›¸å…³æ€§è´¨ã€‚ æ€§è´¨ æ€§è´¨1 åæ¼”å˜æ¢å¯é€† å¯¹äºå®šä¹‰é‡Œçš„æè¿°ï¼ŒAâ€²A'Aâ€²ä¸ºAAAå…³äºOOOç‚¹çš„åæ¼”ç‚¹ï¼ŒåŒæ—¶å°±æœ‰AAAæ˜¯å…³äºAâ€²A'Aâ€²çš„åæ¼”ç‚¹ã€‚ æ€§è´¨2 åœ¨åœ†å†…çš„ç‚¹å…¶åæ¼”ç‚¹ä¸€ç‚¹åœ¨åœ†å¤– åœ¨åœ†å¤–çš„ç‚¹å…¶åæ¼”ç‚¹ä¸€å®šåœ¨åœ†å†… åœ¨åœ†ä¸Šçš„ç‚¹çš„åæ¼”ç‚¹ä¸å…¶åœ¨åŒä¸€ä¸ªä½ç½® è§‚å¯Ÿå›¾å½¢å¾ˆå®¹æ˜“å¾—åˆ°çš„æ€§è´¨ã€‚ æ¥ä¸‹æ¥å¼•å…¥ä¸€äº›å‡ ä½•å›¾å½¢å…³äºåœ†çš„åæ¼”ã€‚ æ€§è´¨3 è¿‡åæ¼”ä¸­å¿ƒçš„ç›´çº¿å…¶åæ¼”åä¸ºè‡ªèº« ä¸è¿‡åæ¼”ä¸­å¿ƒçš„ç›´çº¿ï¼Œåæ¼”åä¸ºè¿‡åæ¼”ä¸­å¿ƒçš„åœ† ä¹Ÿè®¸éœ€è¦è¯æ˜ï¼Ÿä¹ŸæŒºå¥½æ¨çš„ï¼Œè®¾åæ¼”ä¸­å¿ƒä¸ºåŸç‚¹ï¼Œç›´çº¿è§£æå¼ä¸ºy=k1x+by = k_1 x+by=k1â€‹x+bï¼Œåæ¼”å¾—åˆ°çš„çº¿æ®µä¸ºy=k2xy = k_2xy=k2â€‹xï¼Œå¯ä»¥æ¨å¾—äº¤ç‚¹ä¸ºbk2âˆ’k1\\frac{b}{k2-k1}k2âˆ’k1bâ€‹ï¼Œè®¾ä¸ºcccï¼Œå†è®¾äº¤ç‚¹çš„åæ¼”ç‚¹ä¸º(x,k2x)(x,k_2x)(x,k2â€‹x)ï¼Œå†æ ¹æ®åæ¼”çš„å®šä¹‰å¾—(c2+k22c2)(x2+k2x2)=r4(c^2 + k_2^2 c^2)(x^2 + k^2x^2) = r^4(c2+k22â€‹c2)(x2+k2x2)=r4,æ‹†å¼€åå»æ‰å¸¸æ•°é¡¹ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªxy+y2=C(CâˆˆR)x^y + y^2 = C \\quad (C\\in \\mathbb{R})xy+y2=C(CâˆˆR)çš„åœ†çš„æ–¹ç¨‹ã€‚ æ€§è´¨4 ä¸è¿‡åæ¼”ä¸­å¿ƒçš„åœ†ï¼Œå…¶åæ¼”åä»ä¸ºä¸€ä¸ªä¸è¿‡åæ¼”ä¸­å¿ƒçš„åœ† è¿‡åæ¼”ä¸­å¿ƒçš„åœ†ï¼Œå…¶åæ¼”åä¸ºä¸è¿‡åæ¼”ä¸­å¿ƒçš„ä¸€æ¡ç›´çº¿ è¯æ˜çš„è¯ä¾ç„¶æ˜¯åˆ©ç”¨è§£æå¼å»è¯æ˜ï¼Œå’Œä¸Šä¸ªæ€§è´¨è¯æ˜è¿‡ç¨‹æ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚ æ€§è´¨5 ä¸¤æ¡ç›´çº¿æˆ–æ›²çº¿çš„å¤¹è§’å¤§å°åœ¨åæ¼”å˜æ¢ä¸‹æ˜¯ä¸å˜çš„ã€‚ ä½“ç°äº†åæ¼”çš„åå‘ä¿è§’æ€§ æ€§è´¨6 ä¸¤ä¸ªåœ†ç›¸åˆ‡ï¼Œå®ƒä»¬çš„åæ¼”å›¾å½¢ä¹Ÿç›¸åˆ‡ ï¼ˆæ˜“è¯ï¼‰ åè®° ç°åœ¨ä½ å¯ä»¥å»å°è¯•æš´åˆ‡CMOäº†","link":"/2022/08/17/%E5%8F%8D%E6%BC%94%E5%8F%98%E6%8D%A2/"},{"title":"å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨","text":"åˆæ¢å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨ å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨ å®šä¹‰ è®¾æœ‰æ•°åˆ—a0,a1,a2,â‹¯ ,ana_0, a_1, a_2, \\cdots , a_na0â€‹,a1â€‹,a2â€‹,â‹¯,anâ€‹æ»¡è¶³çº¿æ€§å…³ç³», an=âˆ‘i=1kanâˆ’iÃ—fia_n= \\sum_{i = 1} ^ k a_{n-i} \\times f_i anâ€‹=i=1âˆ‘kâ€‹anâˆ’iâ€‹Ã—fiâ€‹ åˆ™ç§°è¿™ä¸ªæ•°åˆ—æ»¡è¶³kkké˜¶é½æ¬¡çº¿æ€§é€’æ¨å…³ç³»ã€‚ çŸ©é˜µä¹˜æ³• è®¾æœ‰ä¸€ä¸ªæ»¡è¶³é½æ¬¡çº¿æ€§é€’æ¨å…³ç³»çš„æ•°åˆ—aaaï¼Œ æ»¡è¶³ä¸Šè¿°å®šä¹‰ï¼Œç°åœ¨æ±‚ana_nanâ€‹ã€‚ å‡è®¾ç°åœ¨ç»´æŠ¤ä¸€ä¸ªåˆ—çŸ©é˜µï¼Œè¡Œæ•°ä¸ºkkkï¼Œ A=(ananâˆ’1â‹¯anâˆ’k+2anâˆ’k+1)A = \\begin{pmatrix}a_n\\\\a_{n-1}\\\\ \\cdots \\\\ a_{n-k+2} \\\\ a_{n-k + 1} \\end{pmatrix} A=ââœâœâœâœâ›â€‹anâ€‹anâˆ’1â€‹â‹¯anâˆ’k+2â€‹anâˆ’k+1â€‹â€‹â âŸâŸâŸâŸââ€‹ è®¾ M=(f1f2f3â‹¯fkâˆ’2fkâˆ’1100â‹¯00010â‹¯00â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯000010)M = \\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix} M=ââœâœâœâœâ›â€‹f1â€‹10â‹¯0â€‹f2â€‹01â‹¯0â€‹f3â€‹00â‹¯0â€‹â‹¯â‹¯â‹¯â‹¯0â€‹fkâˆ’2â€‹00â‹¯1â€‹fkâˆ’1â€‹00â‹¯0â€‹â âŸâŸâŸâŸââ€‹ å°±å¯å¾— (f1f2f3â‹¯fkâˆ’2fkâˆ’1100â‹¯00010â‹¯00â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯000010)Ã—(anâˆ’1anâˆ’2â‹¯anâˆ’k+1anâˆ’k)=(ananâˆ’1â‹¯anâˆ’k+2anâˆ’k+1)\\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix} \\times \\begin{pmatrix} a_{n-1}\\\\ a_{n-2}\\\\ \\cdots \\\\ a_{n-k+1} \\\\ a_{n-k} \\end{pmatrix} = \\begin{pmatrix} a_{n}\\\\ a_{n-1}\\\\ \\cdots \\\\ a_{n-k+2} \\\\ a_{n-k+1} \\end{pmatrix} ââœâœâœâœâ›â€‹f1â€‹10â‹¯0â€‹f2â€‹01â‹¯0â€‹f3â€‹00â‹¯0â€‹â‹¯â‹¯â‹¯â‹¯0â€‹fkâˆ’2â€‹00â‹¯1â€‹fkâˆ’1â€‹00â‹¯0â€‹â âŸâŸâŸâŸââ€‹Ã—ââœâœâœâœâ›â€‹anâˆ’1â€‹anâˆ’2â€‹â‹¯anâˆ’k+1â€‹anâˆ’kâ€‹â€‹â âŸâŸâŸâŸââ€‹=ââœâœâœâœâ›â€‹anâ€‹anâˆ’1â€‹â‹¯anâˆ’k+2â€‹anâˆ’k+1â€‹â€‹â âŸâŸâŸâŸââ€‹ æ¥ä¸‹æ¥ç”¨çŸ©é˜µå¿«é€Ÿå¹‚å°±å¯ä»¥åšåˆ°O(k3log2n)O(k^3log_2 n)O(k3log2â€‹n)äº† (f1f2f3â‹¯fkâˆ’2fkâˆ’1100â‹¯00010â‹¯00â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯000010)nÃ—(akâˆ’1akâˆ’2â‹¯a1a0)=(an+kâˆ’1an+kâˆ’2â‹¯an+1an)\\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix}^n \\times \\begin{pmatrix} a_{k-1}\\\\ a_{k-2}\\\\ \\cdots \\\\ a_{1} \\\\ a_{0} \\end{pmatrix} = \\begin{pmatrix} a_{n+k-1}\\\\ a_{n+k-2}\\\\ \\cdots \\\\ a_{n+1} \\\\ a_{n} \\end{pmatrix} ââœâœâœâœâ›â€‹f1â€‹10â‹¯0â€‹f2â€‹01â‹¯0â€‹f3â€‹00â‹¯0â€‹â‹¯â‹¯â‹¯â‹¯0â€‹fkâˆ’2â€‹00â‹¯1â€‹fkâˆ’1â€‹00â‹¯0â€‹â âŸâŸâŸâŸââ€‹nÃ—ââœâœâœâœâ›â€‹akâˆ’1â€‹akâˆ’2â€‹â‹¯a1â€‹a0â€‹â€‹â âŸâŸâŸâŸââ€‹=ââœâœâœâœâ›â€‹an+kâˆ’1â€‹an+kâˆ’2â€‹â‹¯an+1â€‹anâ€‹â€‹â âŸâŸâŸâŸââ€‹ ç‰¹å¾å¤šé¡¹å¼ å’•å’•å’•ã€‚","link":"/2022/09/03/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"title":"å¹¶æŸ¥é›†","text":"æµ…è°ˆå¹¶æŸ¥é›† å¹¶æŸ¥é›† å¹¶æŸ¥é›†ï¼ˆå†°èŒ¶å§¬Disjointâˆ’SetDisjoint-SetDisjointâˆ’Setï¼‰æ˜¯ä¸€ç§æ ‘å½¢çš„æ•°æ®ç»“æ„ï¼Œå®ƒå¯ä»¥å¤„ç†ä¸€äº›ä¸äº¤é›†çš„åˆå¹¶ä»¥åŠæŸ¥è¯¢é—®é¢˜ã€‚ä¸»è¦ä¸ºä¸¤ç§æ“ä½œï¼š æŸ¥æ‰¾ï¼ˆFindï¼‰ï¼šç¡®å®šæŸä¸ªå…ƒç´ å¤„äºå“ªä¸ªå­é›†ï¼› åˆå¹¶ï¼ˆMergeï¼‰ï¼šå°†ä¸¤ä¸ªå­é›†åˆå¹¶æˆä¸€ä¸ªé›†åˆã€‚ åˆå§‹åŒ– 12345void makeSet(int size) { for (int i = 0; i &lt; size; i++) fa[i] = i; // iå°±åœ¨å®ƒæœ¬èº«çš„é›†åˆé‡Œ return;} æŸ¥æ‰¾ é€šä¿—åœ°è®²ä¸€ä¸ªæ•…äº‹ï¼šå‡ ä¸ªå®¶æ—è¿›è¡Œå®´ä¼šï¼Œä½†æ˜¯å®¶æ—æ™®éé•¿å¯¿ï¼Œæ‰€ä»¥äººæ•°ä¼—å¤šã€‚ç”±äºé•¿æ—¶é—´çš„åˆ†ç¦»ä»¥åŠå¹´é¾„çš„å¢é•¿ï¼Œè¿™äº›äººé€æ¸å¿˜æ‰äº†è‡ªå·±çš„äº²äººï¼Œåªè®°å¾—è‡ªå·±çš„çˆ¸çˆ¸æ˜¯è°äº†ï¼Œè€Œæœ€é•¿è€…ï¼ˆç§°ä¸ºã€Œç¥–å…ˆã€ï¼‰çš„çˆ¶äº²å·²ç»å»ä¸–ï¼Œä»–åªçŸ¥é“è‡ªå·±æ˜¯ç¥–å…ˆã€‚ä¸ºäº†ç¡®å®šè‡ªå·±æ˜¯å“ªä¸ªå®¶æ—ï¼Œä»–ä»¬æƒ³å‡ºäº†ä¸€ä¸ªåŠæ³•ï¼Œåªè¦é—®è‡ªå·±çš„çˆ¸çˆ¸æ˜¯ä¸æ˜¯ç¥–å…ˆï¼Œä¸€å±‚ä¸€å±‚çš„å‘ä¸Šé—®ï¼Œç›´åˆ°é—®åˆ°ç¥–å…ˆã€‚å¦‚æœè¦åˆ¤æ–­ä¸¤äººæ˜¯å¦åœ¨åŒä¸€å®¶æ—ï¼Œåªè¦çœ‹ä¸¤äººçš„ç¥–å…ˆæ˜¯ä¸æ˜¯åŒä¸€äººå°±å¯ä»¥äº†ã€‚ åœ¨è¿™æ ·çš„æ€æƒ³ä¸‹ï¼Œå¹¶æŸ¥é›†çš„æŸ¥æ‰¾ç®—æ³•è¯ç”Ÿäº†ã€‚ 123456789int fa[MAXN]; // è®°å½•æŸä¸ªäººçš„çˆ¸çˆ¸æ˜¯è°ï¼Œç‰¹åˆ«è§„å®šï¼Œç¥–å…ˆçš„çˆ¸çˆ¸æ˜¯ä»–è‡ªå·±int find(int x) { // å¯»æ‰¾xçš„ç¥–å…ˆ if (fa[x] == x) // å¦‚æœxæ˜¯ç¥–å…ˆåˆ™è¿”å› return x; else return find(fa[x]); // å¦‚æœä¸æ˜¯åˆ™xçš„çˆ¸çˆ¸é—®xçš„çˆ·çˆ·} è·¯å¾„å‹ç¼© ä¸€å±‚ä¸€å±‚çš„æ‰¾çˆ¶äº²æ•ˆç‡å¤ªä½äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥æŠŠåœ¨è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ç›´æ¥è¿æ¥åˆ°æ ¹ä¸Šï¼Œè¿™å°±æ˜¯è·¯å¾„å‹ç¼©ã€‚ 123456int find(int x) { if (x != fa[x]) // xä¸æ˜¯è‡ªèº«çš„çˆ¶äº²ï¼Œå³xä¸æ˜¯è¯¥é›†åˆçš„ä»£è¡¨ fa[x] = find(fa[x]); // æŸ¥æ‰¾xçš„ç¥–å…ˆç›´åˆ°æ‰¾åˆ°ä»£è¡¨,äºæ˜¯é¡ºæ‰‹è·¯å¾„å‹ç¼© return fa[x];} åˆå¹¶ å®´ä¼šä¸Šï¼Œä¸€ä¸ªå®¶æ—çš„ç¥–å…ˆçªç„¶å¯¹å¦ä¸€ä¸ªå®¶æ—è¯´ï¼šæˆ‘ä»¬ä¸¤ä¸ªå®¶æ—äº¤æƒ…è¿™ä¹ˆå¥½ï¼Œä¸å¦‚åˆæˆä¸€å®¶å¥½äº†ã€‚å¦ä¸€ä¸ªå®¶æ—ä¹Ÿæ¬£ç„¶æ¥å—äº†ã€‚ æˆ‘ä»¬ä¹‹å‰è¯´è¿‡ï¼Œå¹¶ä¸åœ¨æ„ç¥–å…ˆç©¶ç«Ÿæ˜¯è°ï¼Œæ‰€ä»¥åªè¦å…¶ä¸­ä¸€ä¸ªç¥–å…ˆå˜æˆå¦ä¸€ä¸ªç¥–å…ˆçš„å„¿å­å°±å¯ä»¥äº†ã€‚ 1234567void MergeSet(int x, int y) { // x ä¸ y æ‰€åœ¨å®¶æ—åˆå¹¶ x = find(x); y = find(y); fa[x] = y; // æŠŠ x çš„ç¥–å…ˆå˜æˆ y çš„ç¥–å…ˆçš„å„¿å­} å¯å‘å¼åˆå¹¶ (å¥‡æŠ€æ·«å·§) åœ¨åˆå¹¶é›†åˆæ—¶ï¼Œæ— è®ºå°†å“ªä¸€ä¸ªé›†åˆè¿æ¥åˆ°å¦ä¸€ä¸ªé›†åˆçš„ä¸‹é¢ï¼Œéƒ½èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚ä½†ä¸åŒçš„è¿æ¥æ–¹æ³•å­˜åœ¨æ—¶é—´å¤æ‚åº¦çš„å·®å¼‚ã€‚ æ‰€ä»¥åˆå¹¶æ—¶åˆ©ç”¨ç‚¹æ•°å’Œæ·±åº¦çš„ä¼°ä»·å‡½æ•°æ¥é™ä½æ—¶é—´å¤æ‚åº¦ã€‚ â€œç§©â€ï¼šæ ‘çš„æ·±åº¦(æœªè·¯å¾„å‹ç¼©) / é›†åˆå¤§å° ã€‚å‡æ‘Šå¤æ‚åº¦ O(logN)O(logN)O(logN)ã€‚ 1234567891011121314151617181920212223//è®°å½•å¹¶åˆå§‹åŒ–å­æ ‘çš„å¤§å°ä¸º 1void MergeSet(int x, int y) { int x=find(x), y=find(y); if (x==y) return; if (size[x] &gt; size[y]) // ä¿è¯å°çš„åˆåˆ°å¤§çš„é‡Œ swap(x, y); fa[x] = y; size[y] += size[x];}//æŒ‰å¤§å°åˆå¹¶int depth[maxn];// æ·±åº¦void MergeSet(int x, int y) { int x=find(x),y=find(y) if(depth[x]&lt;depth[y])fa[x]=y; if(depth[x]&gt;depth[y])fa[y]=x; if(depth[x]==depth[y]) { depth[y]++; fa[x]=y; }// æ·±åº¦å°çš„åˆå¹¶åˆ°æ·±åº¦å¤§çš„é›†åˆé‡Œ}//æŒ‰ç§©åˆå¹¶ åŒæ—¶é‡‡ç”¨ â€œè·¯å¾„å‹ç¼©â€ å’Œ â€œæŒ‰ç§©åˆå¹¶â€ ä¼˜åŒ–çš„å¹¶æŸ¥é›†ï¼Œ æ¯æ¬¡Getæ“ä½œå¤æ‚åº¦å¯è¿›ä¸€æ­¥é™ä½åˆ°O(Î±(N))O(Î±(N))O(Î±(N))(ä¸€ä¸ªæ¯”å¯¹æ•°å‡½æ•°å¢é•¿è¿˜æ…¢çš„å‡½æ•°ï¼Œå¯¹äºâˆ€Nâ©½221019729\\forall N \\leqslant 2^{2^{10^{19729}}}âˆ€Nâ©½221019729ï¼Œéƒ½æœ‰Î±(N)&lt;5\\alpha(N)&lt;5Î±(N)&lt;5ï¼Œæ•…Î±(N)\\alpha(N)Î±(N)ï¼Œå¯è¿‘ä¼¼çœ‹æˆä¸€ä¸ªå¸¸æ•°ï¼Œç”±è‘—åè®¡ç®—æœºç§‘å­¦å®¶R.E.Tarjanäº1975å¹´å‘è¡¨çš„è®ºæ–‡ä¸­ç»™å‡ºäº†è¯æ˜)ã€‚ å¸¦æƒå¹¶æŸ¥é›† å¹¶æŸ¥é›†å…¶å®å°±æ˜¯ä¸€ä¸ªæ£®æ—ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ ‘ä¸Šçš„æ¯æ¡è¾¹ä¸Šè®°å½•ä¸€ä¸ªæƒå€¼ï¼Œç»´æŠ¤ä¸€ä¸ªæ•°ç»„ddd,ç”¨d[x]d[x]d[x]ä¿å­˜èŠ‚ç‚¹xxxåˆ°çˆ¶èŠ‚ç‚¹fa[x]fa[x]fa[x]ä¹‹é—´çš„è¾¹æƒï¼Œåœ¨è·¯å¾„å‹ç¼©çš„åŒæ—¶ä¸æ–­æ›´æ–°dddæ•°ç»„ã€‚ 1234567int find(int x){ if(x==fa[x])return x; int root=find(fa[x]); // æ±‚é›†åˆä»£è¡¨ d[x]+=d[fa[x]]; // è¾¹æƒæ±‚å’Œï¼Œç»´æŠ¤dæ•°ç»„ return fa[x]=root; // è·¯å¾„å‹ç¼©} å¹¶æŸ¥é›†çš„åº”ç”¨ å¹¶æŸ¥é›†èƒ½åœ¨ä¸€å¼ æ— å‘å›¾ä¸­ç»´æŠ¤èŠ‚ç‚¹ä¹‹é—´çš„è¿é€šæ€§ï¼Œè¿™æ˜¯å¹¶æŸ¥é›†çš„ä¸€ä¸ªåŸºæœ¬ç”¨é€”ï¼Œå®é™…ä¸Šï¼Œå¹¶æŸ¥é›†å¯ä»¥åŠ¨æ€ç»´æŠ¤å…·æœ‰ä¼ é€’æ€§çš„å…³ç³»ã€‚ æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ä¸­çš„KruskalKruskalKruskalå’Œæœ€è¿‘å…¬å…±ç¥–å…ˆä¸­çš„TarjanTarjanTarjanç®—æ³•éƒ½æ˜¯åŸºäºå¹¶æŸ¥é›†çš„ç®—æ³•ã€‚ ä¾‹é¢˜ğŸš€ï¸ luoguP1196 é“¶æ²³è‹±é›„ä¼ è¯´ è¿™é“é¢˜å‘¢å°±æ˜¯ç”¨åˆ°äº†å¸¦æƒå¹¶æŸ¥é›†ï¼Œåœ¨æœ¬é¢˜ä¸­æˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸¤å·ç›¸é‚»çš„æˆ˜èˆ°ä¹‹é—´çš„æƒå€¼çœ‹ä¸º111ã€‚ ä¸¤å·æˆ˜èˆ°ä¹‹é—´çš„æˆ˜èˆ°æ•°ç›®ï¼Œå…¶å®å°±æ˜¯ç¬¬iiiå·æˆ˜èˆ°çš„æ·±åº¦ä¸ç¬¬jjjå·æˆ˜èˆ°çš„æ·±åº¦çš„å·®çš„ç»å¯¹å€¼-111ã€‚ å¹¶ä¸”æˆ‘ä»¬è¿˜éœ€è¦ç”¨ä¸€ä¸ªsizesizesizeæ•°ç»„å»å­˜æ¯ä¸ªé›†åˆçš„å¤§å°ï¼Œå»æ›´æ–°æ¯ä¸ªç‚¹çš„æ·±åº¦ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int T,f[30010],dep[30010],size[30010];int find(int x){ if(x==f[x])return x; int fn=find(f[x]); dep[x]+=dep[f[x]];// æ›´æ–°æƒå€¼ return f[x]=fn;}// æŸ¥æ‰¾é›†åˆä»£è¡¨void Union(int x,int y){ x=find(x); y=find(y); dep[x]+=size[y]; f[x]=y; size[y]+=size[x]; size[x]=0;// è¿™ä¸€åˆ—ä¸Šå·²ç»æ²¡æœ‰æˆ˜èˆ° return;}// åˆå¹¶int main(){ scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=30000;i++)f[i]=i,size[i]=1;// åˆå§‹åŒ–æ¯ä¸ªé›†åˆçš„ä»£è¡¨ä¸ºè‡ªå·±ï¼Œæ¯ä¸€åˆ—ä¸Šåªæœ‰ä¸€è‰˜æˆ˜èˆ° while(T!=0) { T--; char a;int b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a=='M')Union(b,c); if(a=='C') { if(find(b)!=find(c))printf(&quot;-1\\n&quot;);// ä¸åœ¨åŒä¸€åˆ—ï¼Œè¾“å‡º-1 else printf(&quot;%d\\n&quot;,abs(dep[b]-dep[c])-1);// è®¡ç®—æœ‰å¤šå°‘è‰˜æˆ˜èˆ° } } return 0;} luoguP2502 æ—…è¡Œ è¿™æ˜¯ä¸€é“æšä¸¾åŠ å¹¶æŸ¥é›†ï¼Œé¦–å…ˆæˆ‘ä»¬å¯ä»¥å…ˆæŠŠæ¯æ¡è¾¹æŒ‰é€Ÿåº¦ä»å¤§åˆ°å°æ’åºç„¶åå»æšä¸¾æœ€å¤§è¾¹å’Œæœ€å°è¾¹ï¼Œä½¿é€Ÿåº¦æ¯”æœ€å°ã€‚ æšä¸¾çš„åŒæ—¶ä¸æ–­åŠ è¾¹ï¼Œç”¨å¹¶æŸ¥é›†æ¥åˆ¤æ–­èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦è”é€š,è¾“å‡ºæ—¶ä¸è¦å¿˜è®°åˆ†å­åˆ†æ¯åŒé™¤æœ€å¤§å…¬å› æ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm=5e3+10;int n,m,s,t,f[510],xl,yl;double Min=2147483647;struct node{ int u,v,c;};// ç»“æ„ä½“å­˜è¾¹node edge[maxm];int _find(int x){ if(x==f[x])return x; return f[x]=_find(f[x]);}// æŸ¥æ‰¾é›†åˆä»£è¡¨void _union(int x,int y){ x=_find(x); y=_find(y); f[x]=y; return;}// åˆå¹¶int cmp(node x,node y){ return x.c&gt;y.c;}// æ’åºint gcd(int x,int y){ if(y==0)return x; return gcd(y,x%y);}// æ±‚æœ€å¤§å…¬å› æ•°ï¼Œè¾—è½¬ç›¸é™¤æ³•int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].c); _union(edge[i].u,edge[i].v); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); if(_find(s)!=_find(t)) { printf(&quot;IMPOSSIBLE&quot;); return 0; }// å¦‚æœæŠŠæ‰€æœ‰è¾¹åŠ å…¥åèµ·ç‚¹ç»ˆç‚¹ä¸è¿é€šï¼Œè¾“å‡ºIMPOSSIBLE sort(edge+1,edge+m+1,cmp); for(int i=1;i&lt;=m;i++)// æšä¸¾æœ€å¤§è¾¹ { for(int j=1;j&lt;=n;j++)f[j]=j; for(int j=i;j&lt;=m;j++)// æšä¸¾æœ€å°è¾¹ { _union(edge[j].u,edge[j].v); if(_find(s)==_find(t)) { double tim=(1.0*edge[i].c)/(1.0*edge[j].c); if(tim&lt;Min) { xl=edge[i].c; yl=edge[j].c; Min=tim;// æ‰¾æœ€å°é€Ÿåº¦æ¯” } break; } } } if(gcd(xl,yl)==yl)cout&lt;&lt;xl/yl; else cout&lt;&lt;xl/gcd(xl,yl)&lt;&lt;'/'&lt;&lt;yl/gcd(xl,yl);// è¾“å‡º return 0;} luoguP1955 ç¨‹åºè‡ªåŠ¨åˆ†æ é¢˜ç›®è¯»èµ·æ¥å¾ˆç®€å•ï¼Œåªéœ€è¦å…ˆç”¨å¹¶æŸ¥é›†å¤„ç†æ˜¯ç­‰äºçš„çº¦æŸæ¡ä»¶ï¼Œä¹‹ååœ¨å¤„ç†ä¸ç­‰äºçš„æ¡ä»¶ï¼Œå¦‚æœä¸ç­‰äºçš„ä¸¤ä¸ªæ•°åœ¨åŒä¸€è”é€šå—å°±è¾“å‡ºNONONOï¼Œå¦åˆ™è¾“å‡ºYESYESYESã€‚ ä½†æ˜¯æœ¬é¢˜çš„æ•°æ®èŒƒå›´è¿‡å¤§ï¼Œæ— æ³•æŠŠè¾“å…¥çš„xxxä½œä¸ºæ•°ç»„ä¸‹æ ‡å­˜å‚¨ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨åˆ°ç¦»æ•£åŒ–ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int t,f[maxn],book[maxn*2];struct node{ int a,b,e;};int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ x=Find(f[x]); y=Find(f[y]); f[x]=y; return;}int cmp(node x,node y){ return x.e&gt;y.e;}int main(){ scanf(&quot;%d&quot;,&amp;t); while(t!=0) { t--; int n,tot=0; scanf(&quot;%d&quot;,&amp;n); node p[maxn]; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d&quot;,&amp;p[i].a,&amp;p[i].b,&amp;p[i].e); book[++tot]=p[i].a; book[++tot]=p[i].b; } sort(book+1,book+tot+1); int indx=unique(book+1,book+tot+1)-book-1; for(int i=1;i&lt;=n;i++) { p[i].a=lower_bound(book+1,book+indx+1,p[i].a)-book; p[i].b=lower_bound(book+1,book+indx+1,p[i].b)-book; } bool k=true; for(int i=1;i&lt;=indx;i++)f[i]=i; sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(p[i].e==1) Union(p[i].a,p[i].b); else { if(Find(p[i].a)==Find(p[i].b)) { cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; k=false; break; } } } if(k==true)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; } return 0;} luoguP2024 é£Ÿç‰©é“¾ è¿™æ˜¯ä¸€é“ç§ç±»å¹¶æŸ¥é›†ï¼Œéœ€è¦åˆ†ææ¸…æ¥šAAAç§ç¾¤ï¼ŒBBBç§ç¾¤ï¼ŒCCCç§ç¾¤ä¹‹é—´çš„å…³ç³»ã€‚ é¦–å…ˆè¿™ä¸‰ä¸ªç§ç¾¤ä¹‹é—´çš„å…³ç³»åªæœ‰åŒç±»ã€çŒç‰©å’Œå¤©æ•Œï¼Œè¿™ä¸‰ç§ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¼€ä¸€ä¸ªä¸‰å€çš„å¹¶æŸ¥é›†ï¼Œä¸€å€å­˜åŒç±»ï¼ŒäºŒå€å­˜çŒç‰©ï¼Œä¸‰å€å­˜å¤©æ•Œï¼Œç„¶åä¸æ–­å»åˆ¤æ–­å°±å¥½äº†ï¼Œå…·ä½“çœ‹ä»£ç æ³¨é‡Šï¼ˆç”¨åˆ°äº†æ‹“å±•åŸŸçš„å¹¶æŸ¥é›†ï¼‰ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int n,k,f[maxn*3],ans;int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ f[Find(f[x])]=Find(f[y]); return;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n*3;i++)f[i]=i; for(int i=1;i&lt;=k;i++) { int flag,x,y; scanf(&quot;%d%d%d&quot;,&amp;flag,&amp;x,&amp;y); if(x&gt;n||y&gt;n) { ans++;continue; }// å¦‚æœä¸åœ¨å½“å‰é£Ÿç‰©é“¾èŒƒå›´å†…ï¼Œå°±æ˜¯å‡è¯ if(flag==1) { if(Find(x+n)==Find(y)||Find(x+2*n)==Find(y)) { ans++;continue; }// å¦‚æœxæ˜¯yçš„çŒç‰©æˆ–å¤©æ•Œï¼Œä¸ºå‡è¯ Union(x,y);Union(x+n,y+n);Union(x+2*n,y+2*n); // å¦‚æœæ˜¯çœŸï¼Œxçš„åŒç±»å°±æ˜¯yçš„åŒç±»ï¼Œxçš„çŒç‰©å°±æ˜¯yçš„çŒç‰©ï¼Œxçš„å¤©æ•Œå°±æ˜¯yçš„å¤©æ•Œ } else { if(x==y) { ans++;continue; } if(Find(x)==Find(y)||Find(x)==Find(y+n)) { ans++;continue; }// å¦‚æœxæ˜¯yçš„åŒç±»æˆ–çŒç‰©ä¸ºå‡è¯ Union(x+n,y);Union(x+2*n,y+n);Union(x,y+2*n); // å¦‚æœä¸ºçœŸï¼Œxçš„çŒç‰©å°±æ˜¯yçš„åŒç±»ï¼Œxçš„å¤©æ•Œå°±æ˜¯yçš„çŒç‰©ï¼Œxçš„åŒç±»å°±æ˜¯yçš„å¤©æ•Œ } } printf(&quot;%d&quot;,ans); return 0;} luoguP1197 æ˜Ÿçƒå¤§æˆ˜ å¦‚æœæˆ‘ä»¬æ­£ç€æŒ‰é¡ºåºå»æ‘§æ¯ï¼Œæ˜¾ç„¶åœ¨æ—¶é—´å¤æ‚åº¦ä¸Šä¸å…è®¸ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å»ä½¿ç”¨é€†å‘æ€ç»´ï¼ŒæŠŠæ‘§æ¯æ”¹ä¸ºä¿®å»ºå†åˆ©ç”¨å¹¶æŸ¥é›†åˆ¤æ–­è”é€šæ€§å°±å¯ä»¥äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=4e5+10;int n,k,m,b[maxn],B[maxn],f[maxn];int tot,ans[maxn];vector&lt;int&gt; mp[maxn];int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ f[Find(f[x])]=Find(f[y]);}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { int x,y;cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); mp[y].push_back(x); }// å­˜åŒå‘å›¾ cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;b[i]; B[b[i]]=1; }// æ ‡è®°æ˜¯å¦è¢«æ‘§æ¯ tot=n-k;// æ‘§æ¯åæœ‰å‡ ä¸ªè”é€šå— for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;mp[i].size();j++) { if(!B[i]&amp;&amp;!B[mp[i][j]]&amp;&amp;Find(i)!=Find(mp[i][j]))// å¦‚æœæ²¡æœ‰è¢«æ‘§æ¯åˆå¹¶ { tot--;// æ¯å‡ä¸€æ¡è¾¹è”é€šå—-1 Union(i,mp[i][j]); } } }// å»ºå¥½æ‘§æ¯åçš„è”é€šå— ans[k+1]=tot; for(int i=k;i&gt;=1;i--) { tot++;B[b[i]]=0;// ä¿®å»º for(int j=0;j&lt;mp[b[i]].size();j++) { if(!B[mp[b[i]][j]]&amp;&amp;Find(b[i])!=Find(mp[b[i]][j])) { tot--; Union(b[i],mp[b[i]][j]); } } ans[i]=tot; } for(int i=1;i&lt;=k+1;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; return 0;} å¯æŒä¹…åŒ–å¹¶æŸ¥é›† å¹¶æŸ¥é›†ä½œä¸ºä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œä¹Ÿæ˜¯æœ‰å¯æŒä¹…åŒ–ç‰ˆæœ¬çš„ã€‚ é¡¾åæ€ä¹‰ï¼Œå¯æŒä¹…åŒ–å¹¶æŸ¥é›†=å¯æŒä¹…åŒ–+å¹¶æŸ¥é›†=å¯æŒä¹…åŒ–æ•°ç»„+å¹¶æŸ¥é›†=ä¸»å¸­æ ‘+å¹¶æŸ¥é›†ã€‚ğŸ‘€ï¸ é¦–å…ˆï¼Œå› ä¸ºéœ€è¦è®°å½•å†å²ç‰ˆæœ¬ï¼Œæ‰€ä»¥è·¯å¾„å‹ç¼©æ˜¾ç„¶æ˜¯ä¸èƒ½ç”¨çš„ï¼› å…¶æ¬¡ï¼Œä¸ºäº†è®©å¹¶æŸ¥é›†çš„é«˜åº¦å°½é‡ä¿æŒå¹³è¡¡ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°æŒ‰ç§©åˆå¹¶ã€‚ï¼ˆå¦‚æœå¹¶æŸ¥é›†é€€åŒ–åˆ°ä¸€æ¡é“¾çš„æƒ…å†µä¸‹ï¼Œæ•ˆç‡ä¼šéå¸¸ä½ï¼‰ å¯æŒä¹…åŒ–å¹¶æŸ¥é›†çš„æ“ä½œæœ‰ä»¥ä¸‹å‡ ç§ï¼š å›åˆ°å†å²ç‰ˆæœ¬ï¼ˆæ¯•ç«Ÿæ˜¯å¯æŒä¹…åŒ–æ•°ç»„ï¼‰ï¼› åˆå¹¶ï¼ˆæ¯•ç«Ÿæ˜¯å¹¶æŸ¥é›†ï¼‰ï¼› æŸ¥è¯¢ç¥–å…ˆã€‚ å¯¹äºç¬¬ä¸€ä¸ªæ“ä½œï¼š 1root[i]=root[k]; å¯¹äºç¬¬äºŒä¸ªæ“ä½œï¼šå…¶å®å°±æ˜¯æŒ‰ç§©åˆå¹¶ï¼› å¯¹äºç¬¬ä¸‰ä¸ªæ“ä½œï¼šåœ¨å¯æŒç»­åŒ–æ•°ç»„ä¸­æŸ¥è¯¢ã€‚ åˆå§‹å»ºæ ‘ 12345678910111213int build(int l,int r){ cnt++;int p=cnt; if(l==r) { t[p].fa=l; return p; } int mid=(l+r)&gt;&gt;1; t[p].ls=build(l,mid); t[p].rs=build(mid+1,r); return p;} åˆå¹¶ 1234567891011121314int merge(int now,int l,int r,int fat,int son){ cnt++;int p=cnt; t[p]=t[now]; if(l==r) { t[p].fa=fat; return p; } int mid=(l+r)&gt;&gt;1; if(son&lt;=mid)t[p].ls=merge(t[p].ls,l,mid,fat,son); else t[p].rs=merge(t[p].rs,mid+1,r,fat,son); return p;} æŒ‰ç§©åˆå¹¶çš„ä¿®æ”¹æ·±åº¦ 1234567891011void add(int p,int l,int r,int x){ if(l==r) { t[p].depth++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)add(t[p].ls,l,mid,x); else add(t[p].rs,mid+1,r,x);} å¾—åˆ°å…ƒç´ åœ¨å½“å‰ç‰ˆæœ¬çš„å…ƒç´ ç¼–å· 1234567int get_indx(int p,int l,int r,int x){ if(l==r)return p; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return get_indx(t[p].ls,l,mid,x); else return get_indx(t[p].rs,mid+1,r,x);} æŸ¥è¯¢ç¥–å…ˆ 123456int find(int now,int x){ int father=get_indx(now,1,n,x); if(x==t[father].fa)return father; return find(now,t[father].fa);} æœ€åæ”¾ä¸€ä¸‹å®Œæ•´ä»£ç å§ï¼ˆQWQï¼‰ã€‚ code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm=2e5+10;int n,m,root[maxm],cnt;struct TREE{ int ls,rs,fa,depth;}t[maxm&lt;&lt;5];int build(int l,int r){ cnt++;int p=cnt; if(l==r) { t[p].fa=l; return p; } int mid=(l+r)&gt;&gt;1; t[p].ls=build(l,mid); t[p].rs=build(mid+1,r); return p;}void add(int p,int l,int r,int x){ if(l==r) { t[p].depth++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)add(t[p].ls,l,mid,x); else add(t[p].rs,mid+1,r,x);}int get_indx(int p,int l,int r,int x){ if(l==r)return p; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return get_indx(t[p].ls,l,mid,x); else return get_indx(t[p].rs,mid+1,r,x);}int find(int now,int x){ int father=get_indx(now,1,n,x); if(x==t[father].fa)return father; return find(now,t[father].fa);}int merge(int now,int l,int r,int fat,int son){ cnt++;int p=cnt; t[p]=t[now]; if(l==r) { t[p].fa=fat; return p; } int mid=(l+r)&gt;&gt;1; if(son&lt;=mid)t[p].ls=merge(t[p].ls,l,mid,fat,son); else t[p].rs=merge(t[p].rs,mid+1,r,fat,son); return p;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); root[0]=build(1,n); for(int i=1;i&lt;=m;i++) { int opt;scanf(&quot;%d&quot;,&amp;opt); if(opt==1) { int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); root[i]=root[i-1]; int f1=find(root[i],a); int f2=find(root[i],b); if(t[f1].fa==t[f2].fa)continue; if(t[f1].depth&gt;t[f2].depth)swap(f1,f2); root[i]=merge(root[i-1],1,n,t[f2].fa,t[f1].fa); if(t[f1].depth==t[f2].depth)add(root[i],1,n,t[f2].fa); } if(opt==2) { int k;scanf(&quot;%d&quot;,&amp;k); root[i]=root[k]; } if(opt==3) { int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); root[i]=root[i-1]; int f1=find(root[i],a); int f2=find(root[i],b); if(t[f1].fa==t[f2].fa)printf(&quot;1\\n&quot;); else printf(&quot;0\\n&quot;); } } return 0;} æ‹“å±•â€”å¯æŒä¹…åŒ–å¸¦æƒå¹¶æŸ¥é›† å¯æŒä¹…åŒ–å¹¶æŸ¥é›†+è¾¹å¸¦æƒï¼ˆé€ƒï¼‰ã€‚ æœ€åé™„ä¸Šæˆ‘çš„é¢˜å•ã€‚ å®Œç»“æ’’èŠ±~~ï¼ˆç»ˆäºå†™å®Œäº†ï¼‰ğŸ‰ï¸ ğŸ‰ï¸ ğŸ‰ï¸ PSï¼š ï¼ˆä¸€äº›èµ„æ–™å’Œå›¾ä¾‹å‚è€ƒè‡ªOIwikiå’Œç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—QwQ~,ä¸å–œå‹¿å–·ï¼‰","link":"/2022/06/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","text":"åˆæ¢å¤šé¡¹å¼ å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ å‰ç½®çŸ¥è¯† å¤æ•° 1.å‰è¨€ å¿«é€Ÿå‚…é‡Œå¶å˜æ¢æ˜¯ç”¨æ¥åŠ é€Ÿå¤šé¡¹å¼ä¹˜æ³•çš„ï¼Œå¯¹äºä¸¤ä¸ªå¤šé¡¹å¼ AAA å’ŒBBB ï¼Œæœ´ç´ è®¡ç®—æ—¶çš„n2n^2n2æ˜¯æ»¡è¶³ä¸äº†éœ€æ±‚çš„,å¿«é€Ÿå‚…é‡Œå¶å˜æ¢å¯ä»¥åœ¨O(logâ¡n)O(\\log n)O(logn)çš„æ—¶é—´å†…è®¡ç®—AÃ—BA \\times BAÃ—B ã€‚ å…ˆçœ‹ä¸€ä¸‹å•ä½å…ƒçš„å‡ ä¸ªæ€§è´¨ï¼Œåœ¨æ¥ä¸‹æ¥çš„ç®—æ³•ä¸­æœ‰å¾ˆå¤§çš„ç”¨é€”ã€‚ Ï‰nk=e2Ï€ikn(1,1)\\tag{1,1} \\omega_n^k = e ^{\\frac{2 \\pi i k}{n}} Ï‰nkâ€‹=en2Ï€ikâ€‹(1,1) Ï‰dndk=Ï‰nk(1,2)\\tag{1,2} \\omega_{dn}^{dk} = \\omega_n^k Ï‰dndkâ€‹=Ï‰nkâ€‹(1,2) Ï‰nk=a+biÏ‰nâˆ’k=aâˆ’bi(1,3)\\tag{1,3} \\omega_{n}^k = a+bi \\\\ \\omega_{n}^{-k} = a-bi Ï‰nkâ€‹=a+biÏ‰nâˆ’kâ€‹=aâˆ’bi(1,3) Ï‰nk+n2=âˆ’Ï‰nk(1,4)\\tag{1,4} \\omega_n^{k+ \\frac{n}{2}} = - \\omega_n^k Ï‰nk+2nâ€‹â€‹=âˆ’Ï‰nkâ€‹(1,4) ä»¥ä¸Šå˜æ¢å‡å¯ç”±æ¬§æ‹‰å…¬å¼ eiÎ¸=cosâ¡Î¸+iâ‹…sinâ¡Î¸e^{i \\theta}= \\cos\\theta + i \\cdot \\sin\\thetaeiÎ¸=cosÎ¸+iâ‹…sinÎ¸ æ¨å¾—ã€‚ 2.ç¦»æ•£å‚…é‡Œå¶å˜æ¢ ç¦»æ•£å‚…é‡Œå¶å˜æ¢(DFT) ä¸»è¦æ˜¯åˆ©ç”¨åˆ†æ²»æ€æƒ³ï¼Œ é¦–å…ˆå°†å¤šé¡¹å¼ A(x)=âˆ‘i=0naixi(2,1)\\tag{2,1} A(x) = \\sum_{i=0} ^n a_i x^i A(x)=i=0âˆ‘nâ€‹aiâ€‹xi(2,1) å…¶ç³»æ•°è¿›è¡Œå¥‡å¶æ€§åˆ†ç±»ï¼Œå¾—åˆ°ï¼Œ A0(x)=a0+a2x1+a4x2+â‹¯A1(x)=a1+a3x1+a5x2+â‹¯(2,2)\\tag{2,2} A_0(x)= a_0+a_2 x^1 +a_4 x^2 + \\cdots \\\\ A_1(x)= a_1+a_3 x^1 +a_5 x^2 + \\cdots \\\\ A0â€‹(x)=a0â€‹+a2â€‹x1+a4â€‹x2+â‹¯A1â€‹(x)=a1â€‹+a3â€‹x1+a5â€‹x2+â‹¯(2,2) æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¡¨ç¤ºä¸º ï¼š A(x)=A0(x2)+xâ‹…A1(x2)(2,3)\\tag{2,3} A(x) = A_0 (x^2) +x \\cdot A_1(x^2) A(x)=A0â€‹(x2)+xâ‹…A1â€‹(x2)(2,3) å°† Ï‰nk\\omega_n^kÏ‰nkâ€‹ ä¸ Ï‰nk+n2\\omega_n^{k+ \\frac{n}{2}}Ï‰nk+2nâ€‹â€‹ä»£å…¥å¾—ï¼š {A(Ï‰nk)=A(Ï‰n2k)+Ï‰nkA1(Ï‰n2k)A(Ï‰nk+n2)=A(Ï‰n2k)âˆ’Ï‰nkA1(Ï‰n2k)(2,4)\\tag{2,4} \\left\\{ \\begin{aligned} &amp;A(\\omega_n^k) &amp;= &amp;A(\\omega_n^{2k})+\\omega_n^k A_1(\\omega_n^{2k}) \\\\ &amp;A(\\omega_n^{k+ \\frac{n}{2}}) &amp;= &amp;A(\\omega_n^{2k})-\\omega_n^k A_1(\\omega_n^{2k}) \\\\ \\end{aligned} \\right. {â€‹A(Ï‰nkâ€‹)A(Ï‰nk+2nâ€‹â€‹)â€‹==â€‹A(Ï‰n2kâ€‹)+Ï‰nkâ€‹A1â€‹(Ï‰n2kâ€‹)A(Ï‰n2kâ€‹)âˆ’Ï‰nkâ€‹A1â€‹(Ï‰n2kâ€‹)â€‹(2,4) åŒæ—¶æˆ‘ä»¬å¯ä»¥å‘ç°ä¸¤ä¸ªå¼å­åªæœ‰å¸¸æ•°ä¸€æ ·ï¼Œé€’å½’è®¡ç®—å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn) ã€‚ åœ¨è¿™é‡Œæˆ‘ä»¬å°†ç³»æ•°å˜æˆäº†ç‚¹å€¼ 3. ç¦»æ•£å‚…é‡Œå¶é€†å˜æ¢ ç¦»æ•£å‚…é‡Œå¶é€†å˜æ¢IDFT å¯ä»¥å°†ç‚¹å€¼å¿«é€Ÿè½¬åŒ–ä¸ºç³»æ•°ï¼Œä»è€Œå¾—å‡ºç»“æœå¤šé¡¹å¼ã€‚ éœ€è¦ç”¨åˆ°å•ä½æ ¹çš„ä¸€ä¸ªæ€§è´¨ï¼š 1nâˆ‘i=0nâˆ’1Ï‰nxâˆ—i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1â€‹i=0âˆ‘nâˆ’1â€‹Ï‰nxâˆ—iâ€‹=[xmodn=0] è¯æ˜ ï¼š ç”±äº Ï‰nxâˆ—i=Ï‰nxâˆ—(iâˆ’1)âˆ—Ï‰nx\\omega_n ^ {x \\ast i} = \\omega_n^ {x \\ast (i-1)} \\ast \\omega_n^xÏ‰nxâˆ—iâ€‹=Ï‰nxâˆ—(iâˆ’1)â€‹âˆ—Ï‰nxâ€‹ æ‰€ä»¥Ï‰nxâˆ—i\\omega _n ^{x\\ast i}Ï‰nxâˆ—iâ€‹ ä¸ºç­‰æ¯”æ•°åˆ— âˆ´1nâˆ‘i=0nâˆ’1Ï‰nxâˆ—i={1nâˆ‘i=0nâˆ’11i=nn=1x mod n=01nâ‹…1âˆ’Ï‰nnâˆ—x1âˆ’Ï‰nx=1nâ‹…1âˆ’1x1âˆ’Ï‰nx=0x mod nâ‰ 0(3,1)\\tag{3,1} \\therefore \\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i}= \\left\\{ \\begin{aligned} &amp;\\frac{1}{n} \\sum_{i=0}^{n-1} 1^i = \\frac{n}{n} = 1 &amp; x \\bmod n=0\\\\ &amp;\\frac{1}{n} \\cdot \\frac{1- \\omega _n ^ {n \\ast x}}{1-\\omega _n ^ x} = \\frac{1}{n} \\cdot \\frac{1-1^x}{1-\\omega_n^x} =0 &amp; x\\bmod n \\ne 0 \\end{aligned} \\right. âˆ´n1â€‹i=0âˆ‘nâˆ’1â€‹Ï‰nxâˆ—iâ€‹=â©âªâªâªâªâ¨âªâªâªâªâ§â€‹â€‹n1â€‹i=0âˆ‘nâˆ’1â€‹1i=nnâ€‹=1n1â€‹â‹…1âˆ’Ï‰nxâ€‹1âˆ’Ï‰nnâˆ—xâ€‹â€‹=n1â€‹â‹…1âˆ’Ï‰nxâ€‹1âˆ’1xâ€‹=0â€‹xmodn=0xmodnî€ â€‹=0â€‹(3,1) è¯æ˜ï¼š è®¾c=aâˆ—bci=âˆ‘j=0iajâ‹…biâˆ’j=âˆ‘p=0âˆ‘q=0apâ‹…bq[(p+q) mod n=0]nci=âˆ‘p=0âˆ‘q=0apâ‹…bqâˆ‘j=0Ï‰n(p+qâˆ’i)j=âˆ‘j=0Ï‰n(âˆ’i)j(âˆ‘p=0Ï‰npjap)(âˆ‘q=0Ï‰nqjbq)è®¾fa(j)=âˆ‘i=0Ï‰nijai,faâˆ’1(j)=âˆ‘i=0Ï‰n(âˆ’i)jainci=âˆ‘j=0Ï‰n(âˆ’i)jfa(j)fb(j)=âˆ‘j=0Ï‰n(âˆ’i)jfc(j)=ffcâˆ’1(i)(3,2)\\tag{3,2} è®¾ c= a\\ast b \\\\ \\begin{aligned} c_i &amp;= \\sum_{j=0}^i a_j \\cdot b_{i-j} \\\\ &amp;=\\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q [(p+q) \\bmod n=0] \\\\ nc_i &amp;= \\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q \\sum_{j=0} \\omega_n^{(p+q-i)j}\\\\ &amp;= \\sum_{j=0}\\omega_n^{(-i)j} \\bigg( \\sum_{p=0} \\omega_n^{pj} a_p\\bigg) \\bigg( \\sum_{q=0} \\omega_n^{qj} b_q\\bigg) \\end{aligned} \\\\ è®¾ f_a(j) = \\sum_{i=0} \\omega_n^{ij} a_i , f_a^{-1}(j) =\\sum_{i=0} \\omega_n^{(-i)j} a_i \\\\ \\begin{aligned} nc_i &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_a(j)f_b(j) \\\\ &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_c(j) \\\\ &amp;= f_{f_c}^{-1} (i) \\end{aligned} è®¾c=aâˆ—bciâ€‹nciâ€‹â€‹=j=0âˆ‘iâ€‹ajâ€‹â‹…biâˆ’jâ€‹=p=0âˆ‘â€‹q=0âˆ‘â€‹apâ€‹â‹…bqâ€‹[(p+q)modn=0]=p=0âˆ‘â€‹q=0âˆ‘â€‹apâ€‹â‹…bqâ€‹j=0âˆ‘â€‹Ï‰n(p+qâˆ’i)jâ€‹=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹(p=0âˆ‘â€‹Ï‰npjâ€‹apâ€‹)(q=0âˆ‘â€‹Ï‰nqjâ€‹bqâ€‹)â€‹è®¾faâ€‹(j)=i=0âˆ‘â€‹Ï‰nijâ€‹aiâ€‹,faâˆ’1â€‹(j)=i=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹aiâ€‹nciâ€‹â€‹=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹faâ€‹(j)fbâ€‹(j)=j=0âˆ‘â€‹Ï‰n(âˆ’i)jâ€‹fcâ€‹(j)=ffcâ€‹âˆ’1â€‹(i)â€‹(3,2) å› ä¸º faf_afaâ€‹ å°±æ˜¯ aaa åœ¨ DFT åçš„ç»“æœï¼Œæ‰€ä»¥faâˆ’1f_a^{-1}faâˆ’1â€‹å°±æ˜¯ å¯¹åº”çš„IDFTï¼Œæœ€åé™¤ä»¥å¯¹åº”é•¿åº¦nnnï¼Œå³ä¸ºæ‰€æ±‚ã€‚ 4.ä»£ç å®ç° åœ¨å†™FFT æ—¶å¯ä»¥å°†DFTå’ŒIDFTåˆåœ¨ä¸€èµ·è¿™æ ·ä¼šæ›´ç®€ä¾¿ï¼ŒåŒæ—¶ä½¿ç”¨ä½é€†åºå˜æ¢ï¼Œæ›´åŠ ç®€ä¾¿å¿«æ·ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;const double pi=acos(-1.0);struct Complex{ double a,b; Complex(double x=0,double y=0):a(x),b(y) {} friend Complex operator + (Complex x,Complex y){ return Complex(x.a+y.a,x.b+y.b); } friend Complex operator - (Complex x,Complex y){ return Complex(x.a-y.a,x.b-y.b); } friend Complex operator * (Complex x,Complex y){ return Complex(x.a*y.a-x.b*y.b,x.b*y.a+y.b*x.a); }};int n,m,recover[maxn];Complex F[maxn],G[maxn],H[maxn];void FFT(Complex *a,int len,int type){ for(int i=0;i&lt;len;i++) if(i&lt;recover[i])swap(a[i],a[recover[i]]); for(int k=1;k&lt;len;k&lt;&lt;=1) { Complex x(cos(pi/k),type*sin(pi/k)); for(int i=0;i&lt;len;i+=(k&lt;&lt;1)) { Complex w(1,0); for(int j=0;j&lt;k;j++) { Complex y=a[i+j]; Complex z=w*a[i+j+k]; a[i+j]=y+z;a[i+j+k]=y-z; w=w*x; } } } if(type==-1) for(int i=0;i&lt;len;i++)a[i].a/=len;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) { double x; scanf(&quot;%lf&quot;,&amp;x); F[i].a=x; } for(int i=0;i&lt;=m;i++) { double x; scanf(&quot;%lf&quot;,&amp;x); G[i].a=x; } int len=1,cnt=0; while(len&lt;=(n+m))len&lt;&lt;=1,cnt++; for(int i=0;i&lt;len;i++) recover[i]=(recover[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(cnt-1)); FFT(F,len,1);FFT(G,len,1); for(int i=0;i&lt;=len;i++)H[i]=F[i]*G[i]; FFT(H,len,-1); for(int i=0;i&lt;=n+m;i++) printf(&quot;%d &quot;,(int)(H[i].a+0.5)); return 0;}","link":"/2022/07/21/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"title":"æ‰©å±•Lucaså®šç†","text":"ç”¨çš„æ¯”è¾ƒå¤šçš„lucaså®šç†å§ æ‰©å±•Lucaså®šç† å‰ç½®çŸ¥è¯† Lucaså®šç† ä¸­å›½å‰©ä½™å®šç† é€†å…ƒ é—®é¢˜ é¦–å…ˆ LucasLucasLucas å’Œ ExLucasExLucasExLucas éƒ½æ˜¯ç”¨æ¥æ±‚è§£å½¢å¦‚ï¼š Cnmmod pC^m_n \\mod p Cnmâ€‹modp çš„é—®é¢˜ å¯¹äº ppp ä¸ºè´¨æ•°çš„æƒ…å†µå°±å¯ä»¥ç›´æ¥ç”¨ LucasLucasLucas æ¥è§£å†³ï¼Œä½†æ˜¯å¯¹äº ppp ä¸æ˜¯è´¨æ•°çš„è¯ï¼Œå°±éœ€è¦ç”¨åˆ° ExLucasExLucasExLucas ã€‚ æ±‚è§£ ç”±äº ppp ä¸ä¸ºè´¨æ•°å¯ä»¥å°† ppp è¿›è¡Œè´¨å› æ•°åˆ†è§£: ï¼ˆä¸åˆ†è§£è‚¯å®šè¦Té£ï¼‰ p=âˆi=1npikip= \\prod_{i=1}^n p_i^{k_i} p=i=1âˆnâ€‹pikiâ€‹â€‹ åˆ†è§£å®Œåç”±äºä¸¤ä¸¤äº’è´¨å¯ä»¥ç”¨ä¸­å›½å‰©ä½™å®šç†è¿›è¡Œåˆå¹¶æ±‚è§£ã€‚ è¿›ä¸€æ­¥åŒ–ç®€ï¼š Cnmmod pkC^m_n \\mod p^k Cnmâ€‹modpk ä¸ºï¼š n!m!Ã—(nâˆ’m)!mod pk\\dfrac{n!}{m! \\times (n-m)!} \\mod p^k m!Ã—(nâˆ’m)!n!â€‹modpk æ˜¾ç„¶éœ€è¦æ±‚é€†å…ƒä½†æ˜¯åˆ†æ¯ä¸Šçš„ä¸¤é¡¹ä¸ä¸€å®šä¸æ¨¡æ•°äº’è´¨ï¼Œä¸èƒ½æ±‚å‡ºç›´æ¥çš„é€†å…ƒï¼Œè¿›è¡Œè¿›è¿›ä¸€æ­¥æ‹†åˆ†ï¼Œ æå‡º n!n!n! çš„ä¸­çš„ ppp çš„å€æ•°ï¼š n!=pâŒŠnpâŒ‹Ã—âŒŠnpâŒ‹!Ã—âˆpâˆ¤inin! = p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor} \\times \\left\\lfloor\\frac{n}{p}\\right\\rfloor ! \\times \\prod_{p \\nmid i}^n i n!=pâŒŠpnâ€‹âŒ‹Ã—âŒŠpnâ€‹âŒ‹!Ã—pâˆ¤iâˆnâ€‹i é¦–å…ˆ pâŒŠnpâŒ‹p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor}pâŒŠpnâ€‹âŒ‹ å¯ä»¥ç›´æ¥å¿«é€Ÿå¹‚ï¼Œ âŒŠnpâŒ‹!\\left\\lfloor\\frac{n}{p}\\right\\rfloor ! âŒŠpnâ€‹âŒ‹! è€ƒè™‘é€’å½’æ±‚è§£ï¼Œé‚£ä¹ˆåé¢ä¸èƒ½è¢«æ•´é™¤çš„æ•°è¯¥æ€ä¹ˆåŠï¼Ÿ ä»”ç»†è§‚å¯ŸğŸ¤” å¯ä»¥çœ‹å‡ºï¼Œæœ‰å¾ªç¯èŠ‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è¿™æ ·ç»Ÿè®¡: ((pâˆ’1)!)âŒŠnpâŒ‹mod p((p-1)!)^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor} \\mod p ((pâˆ’1)!)âŒŠpnâ€‹âŒ‹modp è¿™é‡Œçš„ p ä¸ºæ¨¡æ•° pçš„kæ¬¡æ–¹å“¦ å¯ä»¥ç›´æ¥ç»Ÿè®¡é˜¶ä¹˜å†åŠ ä¸Šä¸€ä¸ªå¿«é€Ÿå¹‚ï¼Œç”±äºæœ‰ pâŒŠnpâŒ‹p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor} pâŒŠpnâ€‹âŒ‹ è¿™ä¸€é¡¹ï¼Œä¸èƒ½ç›´æ¥æ±‚é€†å…ƒï¼Œåº”åœ¨æ±‚ç»„åˆæ•°æ—¶å¤„ç†ã€‚ æœ€åç”¨ä¸­å›½å‰©ä½™å®šç†åˆå¹¶å³ä¸ºç­”æ¡ˆã€‚ å¦å¤–å¯¹äºç»Ÿè®¡pppçš„æŒ‡æ•°éœ€è¦ç”¨åˆ°ä¸€ä¸ªæŸ¿å­ï¼š âˆ‘i=1âŒŠnpiâŒ‹\\sum_{i=1}\\left\\lfloor\\frac{n}{p^i}\\right\\rfloor \\\\\\\\ i=1âˆ‘â€‹âŒŠpinâ€‹âŒ‹ å…¶å®å°±æ˜¯ç»Ÿè®¡è´¡çŒ®ã€‚ æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡n)O(\\log n)O(logn) çº§åˆ«çš„ ã€‚ é¢˜ç›® è¿™é‡Œæ”¾ä¸Šæˆ‘çš„ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int maxn=1e6+10;ll cnt,prime[maxn],b[maxn],tot,pk[maxn];bool vis[maxn];ll qpow(ll a,ll b,ll mod){ ll tot=1; while(b!=0) { if(b&amp;1)tot=(tot*a)%mod; a=a*a%mod;b&gt;&gt;=1; } return tot;}// å¿«é€Ÿå¹‚ll fac(ll x,ll p,ll k)// k ä¸º pçš„kæ¬¡æ–¹{ if(!x)return 1; ll f=1; for(int i=2;i&lt;=k;i++) if(i%p)f=f*i%k;// å¤„ç†å¾ªç¯èŠ‚ f=qpow(f,x/k,k); for(int i=2;i&lt;=x%k;i++) if(i%p)f=f*i%k;// å¤šä½™éƒ¨åˆ† return f*fac(x/p,p,k)%k;// è®¡ç®—æå‡ºpåçš„éƒ¨åˆ†}ll sta(ll x,ll p){ ll sum=0; for(ll i=p;i&lt;=x;i*=p)sum+=x/i; return sum;}// ç»Ÿæœ‰å¤šå°‘ä¸ªå› å­pvoid exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if(b==0){x=1,y=0;return;} exgcd(b,a%b,x,y); ll z=x;x=y;y=z-a/b*y;}// æ‰©æ¬§ll inv(ll v,ll p){ ll x,y; exgcd(v,p,x,y); return (x+p)%p;} // é€†å…ƒll C(ll n,ll m,ll p,ll k){ if(n&lt;m)return 0; return fac(n,p,k)%k*inv(fac(m,p,k),k)%k*inv(fac(n-m,p,k),k)%k*qpow(p,sta(n,p)-sta(m,p)-sta(n-m,p),k)%k;}// ç»„åˆæ•°ll exlucas(ll n,ll m,ll mod){ ll x=mod; for(int i=2;x!=1;i++) { if(x%i==0) { ll tmp=1; while(x%i==0) { tmp*=i; x/=i; } b[++tot]=C(n,m,i,tmp); pk[tot]=tmp; }//è´¨å› æ•°åˆ†è§£ï¼Œå’Œè®¡ç®—éƒ¨åˆ†ç­”æ¡ˆ } ll ans=0; for(int i=1;i&lt;=tot;i++) { ll Mi=mod/pk[i]; ans=(ans+Mi*b[i]*inv(Mi,pk[i]))%mod; } return ans%mod;}// CRT åˆå¹¶ç»Ÿè®¡ç­”æ¡ˆint main(){ ll n,m,mod; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;mod); printf(&quot;%lld&quot;,exlucas(n,m,mod)%mod); return 0;} ğŸ™€ ğŸ™€ ğŸ™€ åº”ç”¨ [å›½å®¶é›†è®­é˜Ÿ]ç¤¼ç‰© å…¶å®å°±æ˜¯æ±‚ï¼š âˆi=1mCnâˆ’âˆ‘j=1iâˆ’1w[j]w[i]mod P\\prod_{i=1}^m C_{n-\\sum_{j=1}^{i-1} w[j]}^{w[i]} \\mod P i=1âˆmâ€‹Cnâˆ’âˆ‘j=1iâˆ’1â€‹w[j]w[i]â€‹modP ç”±äº PPP ä¸ä¸ºè´¨æ•°æ‰€ä»¥éœ€è¦ç”¨åˆ° ExLucasExLucasExLucas codeï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int maxn=1e5+10;ll w[maxn],S[maxn];ll qpow(ll a,ll b,ll p){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%p; a=a*a%p;b&gt;&gt;=1; } return t%p;}ll stac(ll n,ll p){ ll sum=0; for(ll i=p;i&lt;=n;i*=p)sum+=n/i; return sum;}void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if(b==0){x=1,y=0;return;} exgcd(b,a%b,x,y); ll z=x;x=y;y=z-a/b*y;}ll inv(ll v,ll p){ ll x,y; exgcd(v,p,x,y); return(x+p)%p;}ll fact(ll n,ll p,ll k){ if(n==0)return 1; ll res=1; for(ll i=1;i&lt;=k;i++) if(i%p)res=res*i%k; res=qpow(res,n/k,k); for(ll i=1;i&lt;=n%k;i++) if(i%p)res=res*i%k; return res*fact(n/p,p,k)%k;}ll C(ll n,ll m,ll p,ll k){ if(n&lt;m)return 0; return fact(n,p,k)%k*inv(fact(m,p,k),k)%k*inv(fact(n-m,p,k),k)%k*qpow(p,stac(n,p)-stac(m,p)-stac(n-m,p),k)%k;}ll exlucas(ll n,ll m,ll mod){ int k=0; ll x=mod,b[maxn],a[maxn]; for(ll i=2;x!=1;i++) { if(x%i==0) { ll tmp=1; while(x%i==0) { tmp*=i; x/=i; } b[++k]=tmp; a[k]=C(n,m,i,tmp); } } ll ans=0; for(int i=1;i&lt;=k;i++) { ll Mi=mod/b[i]; ans=(ans+Mi*inv(Mi,b[i])*a[i])%mod; } return ans;}int main(){ ll n,m,mod; scanf(&quot;%lld&quot;,&amp;mod); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { scanf(&quot;%lld&quot;,&amp;w[i]); S[i]=S[i-1]+w[i]; } if(S[m]&gt;n) { printf(&quot;Impossible\\n&quot;); return 0; } ll ans=1; for(int i=1;i&lt;=m;i++) ans=(ans*exlucas(n-S[i-1],w[i],mod))%mod; printf(&quot;%lld&quot;,ans); return 0;}","link":"/2022/07/19/%E6%89%A9%E5%B1%95Lucas%E5%AE%9A%E7%90%86/"},{"title":"æ•°å€¼ç§¯åˆ†","text":"é«˜æ•°å¿…å¤‡ æ•°å€¼ç§¯åˆ† å‰ç½®çŸ¥è¯† æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆçªç„¶æ¥åˆ°äº†é«˜ç­‰æ•°å­¦ï¼Œé‚£å°±èƒ¡ä¸€ä¸‹å§ï¼Œä¹Ÿè®¸ä¸»è¦å†™çš„æ˜¯é«˜ç­‰æ•°å­¦ï¼Ÿã€‚ tips:ä»¥ä¸‹å†…å®¹ä»…ä¾›å‚è€ƒï¼Œæ¯•ç«Ÿæ˜¯èƒ¡çš„ å¯¼æ•° å¯¼æ•°(Derivative)ï¼Œä¹Ÿç§°ä¸ºå¯¼å‡½æ•°å€¼ï¼Œåˆåå¾®å•†ã€‚åœ¨æ•°å­¦ä¸­å‘æŒ¥ç€å¾ˆé‡è¦çš„ä½œç”¨ã€‚ å¯¼æ•°æ˜¯å‡½æ•°çš„å±€éƒ¨æ€§è´¨ã€‚ä¸€ä¸ªå‡½æ•°åœ¨æŸä¸€ç‚¹çš„å¯¼æ•°æè¿°äº†è¿™ä¸ªå‡½æ•°åœ¨è¿™ä¸€ç‚¹é™„è¿‘çš„å˜åŒ–ç‡ã€‚å¦‚æœå‡½æ•°çš„è‡ªå˜é‡å’Œå–å€¼éƒ½æ˜¯å®æ•°çš„è¯ï¼Œå‡½æ•°åœ¨æŸä¸€ç‚¹çš„å¯¼æ•°å°±æ˜¯è¯¥å‡½æ•°æ‰€ä»£è¡¨çš„æ›²çº¿åœ¨è¿™ä¸€ç‚¹ä¸Šçš„åˆ‡çº¿æ–œç‡ã€‚å¯¼æ•°çš„æœ¬è´¨æ˜¯é€šè¿‡æé™çš„æ¦‚å¿µå¯¹å‡½æ•°è¿›è¡Œå±€éƒ¨çš„çº¿æ€§é€¼è¿‘ã€‚ â€”â€”â€“â€“baidu å…¶å®é€šä¿—çš„æ¥è®²å¯¼æ•°å°±æ˜¯ä¸€ä¸ªå‡½æ•°çš„å˜åŒ–ç‡ï¼Œæ¯”è¾ƒç»å…¸çš„å°±æ˜¯äºŒæ¬¡å‡½æ•°æ±‚åˆ‡çº¿ã€‚ å‡è®¾æˆ‘ä»¬è¦æ±‚æŸä¸€å…‰æ»‘æ›²çº¿åœ¨MMMç‚¹çš„åˆ‡çº¿ï¼Œå…ˆåœ¨å‡½æ•°å›¾åƒä¸Šå–ä¸€ç‚¹NNNï¼Œå‡è®¾ç›´çº¿MTMTMTä¸ºMMMç‚¹çš„åˆ‡çº¿ï¼Œå½“âˆ NMT\\angle {NMT}âˆ NMTæ— é™å°æ—¶æ­¤æ—¶çš„ç›´çº¿MNMNMNå°±å·²ç»æˆä¸ºåˆ‡çº¿ï¼Œè®¾ç›´çº¿MNMNMNçš„æ–œç‡ä¸ºtanâ¡Ï•\\tan \\phitanÏ•ï¼Œæœ‰ï¼š tanâ¡Ï•=f(x)âˆ’f(x0)xâˆ’x0\\tan \\phi = \\frac{f(x) - f(x_0)}{x-x_0} tanÏ•=xâˆ’x0â€‹f(x)âˆ’f(x0â€‹)â€‹ å½“NNNé€¼è¿‘ä¸MMMæ—¶ï¼Œ tanâ¡Ï•=limâ¡xâ†’x0f(x)âˆ’f(x0)xâˆ’x0\\tan \\phi = \\lim\\limits_{x \\to x_0} \\frac{f(x) - f(x_0)}{x-x_0} tanÏ•=xâ†’x0â€‹limâ€‹xâˆ’x0â€‹f(x)âˆ’f(x0â€‹)â€‹ ä»¤Î”x=xâˆ’x0\\Delta x = x-x_0Î”x=xâˆ’x0â€‹ï¼Œæ‰€ä»¥ tanâ¡Ï•=limâ¡xâ†’0f(x0+Î”x)âˆ’f(x0)Î”x\\tan \\phi = \\lim\\limits_{x \\to 0} \\frac{f(x_0+\\Delta x) - f(x_0)}{\\Delta x} tanÏ•=xâ†’0limâ€‹Î”xf(x0â€‹+Î”x)âˆ’f(x0â€‹)â€‹ æ­¤å¤„ tanâ¡Ï•\\tan \\phitanÏ•å³ä¸ºå‡½æ•°åœ¨x0x_0x0â€‹å¤„å¯¼æ•°çš„å–å€¼ï¼Œç°åœ¨å¼•å‡ºå¯¼æ•°çœŸæ­£çš„ emp å®šä¹‰ ã€‚ å‡è®¾å‡½æ•°y=f(x)y = f(x)y=f(x)åœ¨ç‚¹x0x_0x0â€‹å¤„çš„é‚»åŸŸæœ‰å®šä¹‰ï¼Œå½“è‡ªå˜é‡xxxåœ¨x0x_0x0â€‹å¤„å–å¾—å¢é‡Î”x\\Delta xÎ”x(ä»ç„¶åœ¨é‚»åŸŸå†…)ï¼Œç›¸åº”çš„å‡½æ•°å–å¾—å¢é‡Î”y=f(x0+Î”x)âˆ’f(x0)\\Delta y = f(x_0+\\Delta x) - f(x_0)Î”y=f(x0â€‹+Î”x)âˆ’f(x0â€‹)ï¼Œå¦‚æœÎ”yÎ”x\\frac{\\Delta y}{\\Delta x}Î”xÎ”yâ€‹åœ¨Î”xâ†’0\\Delta x \\to 0Î”xâ†’0æ—¶çš„æé™å­˜åœ¨ï¼Œç§°ä¸ºå‡½æ•°y=f(x)y = f(x)y=f(x)åœ¨x0x_0x0â€‹å¤„å¯å¯¼ï¼Œå®ƒçš„å¯¼æ•°å¯ä»¥å†™æˆ fâ€²(x0)=limâ¡xâ†’0f(x0+Î”x)âˆ’f(x0)Î”xf'(x_0) = \\lim\\limits_{x \\to 0} \\frac{f(x_0+\\Delta x) - f(x_0)}{\\Delta x} fâ€²(x0â€‹)=xâ†’0limâ€‹Î”xf(x0â€‹+Î”x)âˆ’f(x0â€‹)â€‹ fâ€²(x0)f'(x_0)fâ€²(x0â€‹)ä¹Ÿå¯ä»¥è®°æˆdydx\\frac{\\mathrm{d}y}{\\mathrm{d}x}dxdyâ€‹æˆ–è€…df(x)dx\\frac{\\mathrm{d}f(x)}{\\mathrm{d}x}dxdf(x)â€‹,å¦å¤–å‡½æ•°åœ¨x0x_0x0â€‹å¤„å¯å¯¼çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼Œå‡½æ•°åœ¨x0x_0x0â€‹å¤„çš„å·¦å³ä¸¤ä¾§çš„å¯¼æ•°éƒ½ å¿…é¡»å­˜åœ¨ï¼Œå¹¶ä¸”ç›¸ç­‰ ã€‚ å¦å¤–æœ‰ä¸€äº›å‡½æ•°çš„å¯¼æ•°éƒ½æ˜¯æ¯”è¾ƒç‰¹æ®Šçš„ï¼Œè¿™é‡Œå°±ä¸å†æ¶‰åŠã€‚ å¾®åˆ† é¦–å…ˆæ€è€ƒä¸€ä¸ªç®€ç­”çš„é—®é¢˜ï¼Œä¸€ä¸ªæ­£æ–¹å½¢é‡‘å±è–„ç‰‡è¾¹é•¿ä¸ºxxxï¼Œå—æ¸©åº¦å˜åŒ–å½±å“è¾¹é•¿å¢åŠ äº†Î”x\\Delta xÎ”xï¼Œæ±‚å…¶é¢ç§¯å˜åŒ–äº†å¤šå°‘ã€‚ è®¾æ­£æ–¹å½¢é¢ç§¯ä¸ºAAA ,è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªå‡½æ•°A=x2A = x^2A=x2ï¼Œè®¡ç®—Î”A\\Delta AÎ”Aä¸º: Î”A=(x0+Î”x)2âˆ’x02=2x0Î”x+(Î”x)2\\Delta A = (x_0+ \\Delta x)^2 - x_0^2 = 2x_0\\Delta x + (\\Delta x)^2 Î”A=(x0â€‹+Î”x)2âˆ’x02â€‹=2x0â€‹Î”x+(Î”x)2 é¦–å…ˆç¬¬ä¸€éƒ¨åˆ†2x0Î”x2 x_0 \\Delta x2x0â€‹Î”xä¸ºä¸€ä¸ªçº¿æ€§å‡½æ•°ï¼Œç¬¬äºŒéƒ¨åˆ†ä¸­å½“Î”xâ†’0\\Delta x \\to 0Î”xâ†’0æ—¶ï¼Œ(Î”x)2(\\Delta x)^2(Î”x)2æ˜¯æ¯”Î”x\\Delta xÎ”xé«˜é˜¶çš„æ— ç©·å°ï¼Œå³(Î”x)2=Î¿(Î”x)(\\Delta x)^2 =\\omicron(\\Delta x)(Î”x)2=Î¿(Î”x) å¥½äº†å¢é‡Î”y\\Delta yÎ”yç°åœ¨å·²ç»å¯ä»¥è¡¨ç¤ºä¸ºï¼š Î”y=AÎ”x+Î¿(Î”x)\\Delta y = A \\Delta x + \\omicron(\\Delta x ) Î”y=AÎ”x+Î¿(Î”x) å…¶ä¸­AAAæ˜¯ä¸ä¾èµ–Î”x\\Delta xÎ”xçš„å¸¸æ•°ï¼Œå¹¶ä¸”Î”y\\Delta yÎ”yä¸AÎ”xA\\Delta xAÎ”xçš„å·®ä¸ºï¼š Î”yâˆ’AÎ”x=Î¿(Î”x)\\Delta y - A\\Delta x =\\omicron(\\Delta x) Î”yâˆ’AÎ”x=Î¿(Î”x) æ˜¯æ¯”Î”x\\Delta xÎ”xæ›´é«˜é˜¶çš„æ— ç©·å°ï¼Œè¿™æ ·å½“Aâ‰ 0A \\ne 0Aî€ â€‹=0ï¼Œä¸”âˆ£Î”xâˆ£|\\Delta x |âˆ£Î”xâˆ£æ— ç©·å°æ—¶ï¼ŒÎ”y\\Delta yÎ”yå°±å¯ä»¥è¿‘ä¼¼çš„è¡¨ç¤ºä¸ºÎ”y=AÎ”x\\Delta y = A \\Delta xÎ”y=AÎ”xã€‚ æ¥ä¸‹æ¥ç»™å‡ºå®šä¹‰ ï¼Œè®¾å‡½æ•°y=f(x)y = f(x)y=f(x)åœ¨æŸåŒºé—´å†…æœ‰å®šä¹‰ï¼Œx0x_0x0â€‹åŠx0+Î”xx_0+ \\Delta xx0â€‹+Î”xåœ¨è¿™æ®µåŒºé—´å†…ï¼Œå¦‚æœå‡½æ•°çš„å¢é‡ Î”y=f(x0+Î”x)âˆ’f(x0)\\Delta y = f(x_0 + \\Delta x) - f(x_0) Î”y=f(x0â€‹+Î”x)âˆ’f(x0â€‹) å¯ä»¥è¡¨ç¤ºä¸º Î”y=AÎ”x+Î¿(Î”x)\\Delta y = A \\Delta x + \\omicron(\\Delta x) Î”y=AÎ”x+Î¿(Î”x) å…¶ä¸­AAAæ˜¯ä¸ä¾èµ–äºÎ”x\\Delta xÎ”xå¸¸æ•°ï¼Œé‚£ä¹ˆç§°å‡½æ•°y=f(x)y = f(x)y=f(x)åœ¨x0x_0x0â€‹å¤„æ˜¯å¯å¾®çš„ï¼Œè€ŒAÎ”xA\\Delta xAÎ”xå«åšå‡½æ•°y=f(x)y = f(x)y=f(x)åœ¨x0x_0x0â€‹å¤„ç›¸å½“äºè‡ªå˜é‡å¢é‡ Î”x\\Delta xÎ”xçš„ å¾®åˆ†(Differential) è®°ä½œdydydyï¼Œå³ dy=AÎ”x\\mathrm{d}y = A \\Delta x dy=AÎ”x ç§¯åˆ† ç§¯åˆ†(integral)æ˜¯å¾®ç§¯åˆ†å­¦ä¸æ•°å­¦åˆ†æçš„ä¸€ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‚é€šå¸¸åˆ†ä¸ºå®šç§¯åˆ†å’Œä¸å®šç§¯åˆ†ä¸¤ç§ã€‚ï¼ˆä¸»è¦åŒºåˆ«å°±æ˜¯å®šç§¯åˆ†å¾—åˆ°çš„ç»“æœæ˜¯ä¸€ä¸ªæ•°ï¼Œä¸å®šç§¯åˆ†å¾—åˆ°çš„æ˜¯å‡½æ•°ï¼‰ tipsï¼šä¸å®šç§¯åˆ†æ˜¯æ±‚å¯¼è¿ç®—çš„é€†è¿ç®—ã€‚è¿™ä¸€ç»“è®ºè¢«ç§°ä¸ºå¾®ç§¯åˆ†åŸºæœ¬å®šç† (fundamental theorem of calculus)ã€‚ ç›´è§‚çš„è¯´ï¼Œå¯¹äºä¸€ä¸ªç»™å®šçš„æ­£å®æ•°å€¼å‡½æ•°ï¼Œåœ¨ä¸€ä¸ªå®æ•°åŒºé—´ä¸Šçš„å®šç§¯åˆ†å¯ä»¥ç†è§£ä¸ºåœ¨åæ ‡å¹³é¢ä¸Šï¼Œç”±æ›²çº¿ï¼Œç›´çº¿ä»¥åŠè½´å›´å›´æˆçš„ æ›²è¾¹æ¢¯å½¢çš„é¢ç§¯å€¼ï¼ˆä¸€ç§ç¡®å®šçš„å®æ•°å€¼ï¼‰ å¦‚æœä¸€ä¸ªå‡½æ•°çš„ç§¯åˆ†å­˜åœ¨ï¼Œå¹¶ä¸”æœ‰é™ï¼Œå°±è¯´è¿™ä¸ªå‡½æ•°æ˜¯å¯ç§¯çš„ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¢«ç§¯å‡½æ•°ä¸ä¸€å®šåªæœ‰ä¸€ä¸ªå˜é‡ï¼Œç§¯åˆ†åŸŸä¹Ÿå¯ä»¥æ˜¯ä¸åŒç»´åº¦çš„ç©ºé—´ï¼Œç”šè‡³æ˜¯æ²¡æœ‰ç›´è§‚å‡ ä½•æ„ä¹‰çš„æŠ½è±¡ç©ºé—´ã€‚å¯¹äºåªæœ‰ä¸€ä¸ªå˜é‡xxxçš„å®å€¼å‡½æ•°fffåœ¨é—­åŒºé—´[a,b][a,b][a,b]ä¸Šçš„ç§¯åˆ†è®°ä½œï¼š âˆ«abf(x)dx\\int _{a}^{b} f(x) \\mathrm{d}x âˆ«abâ€‹f(x)dx å…¶ä¸­çš„dx\\mathrm{d}xdxå°±æ˜¯ç§¯åˆ†å˜é‡ã€‚ é»æ›¼ç§¯åˆ†(Riemann Integral)ï¼Œå°±æ˜¯æ‰€è¯´çš„æ­£å¸¸ç§¯åˆ†ï¼Œå®šç§¯åˆ†ã€‚å…¶æ±‚ç§¯åˆ†å€¼çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯é€šè¿‡æ— é™é€¼è¿‘æ¥ç¡®å®šè¿™ä¸ªç§¯åˆ†å€¼ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœf(x)f(x)f(x)å»è´Ÿå€¼ï¼Œåˆ™å¯¹åº”çš„é¢ç§¯å€¼ä¹Ÿä¸ºè´Ÿå€¼ã€‚ å¯¹äºä¸€ä¸ªé—­åŒºé—´[a,b][a,b][a,b]çš„åˆ†å‰²PPPå°±æ˜¯æŒ‡åœ¨è¿™ä¸€ä¸ªåŒºé—´ä¸­å–ä¸€ä¸ªæœ‰é™çš„ç‚¹åˆ—a=x0&lt;x1&lt;x2&lt;â‹¯&lt;xn=ba = x_0 &lt; x_1 &lt; x_2 &lt; \\cdots &lt; x_n = ba=x0â€‹&lt;x1â€‹&lt;x2â€‹&lt;â‹¯&lt;xnâ€‹=bæ¯ä¸ªå­åŒºé—´é•¿åº¦çš„æœ€å¤§å€¼å®šä¹‰ä¸ºÎ»=maxâ¡(xi+1âˆ’xi)\\lambda = \\max(x_{i+1}-x_i)Î»=max(xi+1â€‹âˆ’xiâ€‹)ã€‚ å®šä¹‰å–æ ·åˆ†å‰²ä¸ºåœ¨è¿›è¡Œåˆ†å‰²PPPååœ¨æ¯ä¸€ä¸ªå­åŒºé—´[xi,xi+1][x_{i},x_{i+1}][xiâ€‹,xi+1â€‹]ä¸­å–å‡ºä¸€ç‚¹xiâ‰¤tiâ‰¤xi+1x_i \\le t_i \\le x_{i+1}xiâ€‹â‰¤tiâ€‹â‰¤xi+1â€‹,å…¶åŒºé—´é•¿åº¦æœ€å¤§å€¼ä»ç”¨Î»\\lambdaÎ»æ¥è¡¨ç¤ºã€‚ å¯¹äºä¸€ä¸ªåœ¨åŒºé—´[a,b][a,b][a,b]æœ‰å®šä¹‰çš„å®å€¼å‡½æ•°fffï¼Œfffå…³äºå–æ ·åˆ†å‰²x0â‹¯xn,t0â‹¯tnâˆ’1x_0 \\cdots x_n , t_0 \\cdots t_{n-1}x0â€‹â‹¯xnâ€‹,t0â€‹â‹¯tnâˆ’1â€‹çš„é»æ›¼å’Œè¡¨ç¤ºä¸ºï¼š âˆ‘i=0nâˆ’1f(ti)(xi+1âˆ’xi)\\sum_{i=0}^{n-1}f(t_i)(x_{i+1}-x_i) i=0âˆ‘nâˆ’1â€‹f(tiâ€‹)(xi+1â€‹âˆ’xiâ€‹) ä¸Šè¿°å¼å­ä¸­çš„æ¯ä¸€é¡¹æ˜¯å­åŒºé—´é•¿åº¦xi+1âˆ’xix_{i+1}- x_ixi+1â€‹âˆ’xiâ€‹ä¸åœ¨tit_itiâ€‹å¤„çš„f(ti)f(t_i)f(tiâ€‹)çš„ä¹˜ç§¯ï¼Œå…¶å®ç›´è§‚çš„æ¥è¯´å°±æ˜¯å°†ä¸€ä¸ªæ›²çº¿æ¢¯å½¢åˆ†å‰²æˆæ— é™ä¸ªå°çš„å›¾å½¢å°†å…¶é¢ç§¯ç›¸åŠ ã€‚ çœ‹æ¥éœ€è¦ä¸€ä¸ªæ›´ä¸¥æ ¼çš„å®šä¹‰ï¼Œæˆ‘ä»¬éœ€è¦æŠŠÎ»\\lambdaÎ»è¶‹è¿‘äº0å‡½æ•°å€¼æ‰èƒ½æ›´ç²¾ç¡®ã€‚ è®¾SSSæ˜¯å‡½æ•°fffåœ¨é—­åŒºé—´[a,b][a,b][a,b]ä¸Šçš„é»æ›¼ç§¯åˆ†ï¼Œå½“ä¸”ä»…å½“âˆ€Ïµ&gt;0,âˆƒÎ´&gt;0\\forall \\epsilon &gt; 0, \\exists \\delta &gt; 0âˆ€Ïµ&gt;0,âˆƒÎ´&gt;0ï¼Œä½¿å¾—âˆ€x0â‹¯xn,t0â‹¯tnâˆ’1\\forall x_0 \\cdots x_n , t_0 \\cdots t_{n-1}âˆ€x0â€‹â‹¯xnâ€‹,t0â€‹â‹¯tnâˆ’1â€‹ï¼Œåªè¦å®ƒçš„å­åŒºé—´é•¿åº¦æœ€å¤§å€¼Î»â‰¤Î´\\lambda \\le \\deltaÎ»â‰¤Î´å°±æœ‰ï¼š âˆ£âˆ‘i=0nâˆ’1f(ti)(xi+1âˆ’xi)âˆ’Sâˆ£&lt;Ïµ\\bigg| \\sum_{i = 0}^{n-1} f(t_i)(x_{i+1} -x_i)-S \\bigg| &lt; \\epsilon âˆ£âˆ£âˆ£âˆ£â€‹i=0âˆ‘nâˆ’1â€‹f(tiâ€‹)(xi+1â€‹âˆ’xiâ€‹)âˆ’Sâˆ£âˆ£âˆ£âˆ£â€‹&lt;Ïµ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºä¸€ä¸ªå‡½æ•°fffï¼Œå¦‚æœåœ¨é—­åŒºé—´[a,b][a,b][a,b]ä¸Šæ— è®ºå¦‚ä½•å–æ ·åˆ†å‰²ï¼Œåªè¦å®ƒçš„å­åŒºé—´é•¿åº¦æœ€å¤§å€¼è¶³å¤Ÿå°ï¼Œå‡½æ•°fffçš„é»æ›¼å’Œéƒ½ä¼šè¶‹å‘ä¸€ä¸ªç¡®å®šçš„å€¼ï¼Œé‚£ä¹ˆåœ¨é—­åŒºé—´[a,b][a,b][a,b]ä¸Šçš„é»æ›¼ç§¯åˆ†å­˜åœ¨ï¼Œå¹¶ä¸”å®šä¹‰ä¸ºé»æ›¼å’Œçš„æé™ï¼Œè¿™æ—¶å€™æˆ‘ä»¬ç§°å‡½æ•°fffä¸ºé»æ›¼å¯ç§¯çš„ã€‚ é»æ›¼ç§¯åˆ†è¿˜æœ‰ä¸€ä¸ªæ›´æœ‰æ“ä½œæ€§çš„ç§¯åˆ†å®šä¹‰å«åšè¾¾å¸ƒç§¯åˆ†ï¼Œï¼ˆè‡ªè¡Œäº†è§£å§ï¼‰ã€‚ è¿˜æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„å®šç†ï¼Œ è‹¥F(x)F(x)F(x)ä¸ºf(x)f(x)f(x)çš„ä¸å®šç§¯åˆ† ï¼Œåˆ™f(x)f(x)f(x)ä¸ºF(x)F(x)F(x)çš„å¯¼æ•°ï¼›åä¹‹äº¦ç„¶ã€‚ æ ¹æ®ä»¥ä¸Šå®šç†ï¼Œæˆ‘ä»¬æœ‰ï¼š âˆ«abf(x)dx=F(b)âˆ’F(a)\\int_a^b f(x) \\mathrm{d}x = F(b)-F(a) âˆ«abâ€‹f(x)dx=F(b)âˆ’F(a) æ­£æ–‡ ç»ˆäºè¿›å…¥åˆ°äº†ä¸»é¢˜ã€‚ æ•°å€¼ç§¯åˆ†ï¼Œæ˜¯ç”¨æ¥æ±‚å®šç§¯åˆ†çš„è¿‘ä¼¼å€¼ã€‚ è¿™é‡Œæˆ‘ä»¬åªé˜è¿°ä¸€ç§æ•°å€¼ç§¯åˆ†çš„æ±‚æ³•ï¼Œä½¿ç”¨SimpsonSimpsonSimpsonå…¬å¼ã€‚ Simpsonå…¬å¼ SimpsonSimpsonSimpsonå…¬å¼å°±æ˜¯åœ¨ç§¯åˆ†åŒºé—´[a,b][a,b][a,b]ä¸­å»æ‰¾ä¸‰ä¸ªç‚¹a,ba,ba,bå’Œm=(a+b)/2m = (a+b)/2m=(a+b)/2ï¼Œè®¡ç®—å…¶åŸå‡½æ•°åœ¨æ­¤å¤„çš„å€¼ï¼Œç„¶åç”¨æŠ›ç‰©çº¿æ¥æ‹ŸåˆåŸå‡½æ•°ã€‚ tipsï¼šå¹‚å‡½æ•°çš„ç§¯åˆ†å…¬å¼ï¼š âˆ«xÎ±dx=1Î±+1xÎ±+1+C(Cä¸ºå¸¸æ•°é¡¹)\\int x^{\\alpha} \\mathrm{d}x = \\frac{1}{\\alpha+1}x^{\\alpha+1}+C \\quad (\\text{Cä¸ºå¸¸æ•°é¡¹}) âˆ«xÎ±dx=Î±+11â€‹xÎ±+1+C(Cä¸ºå¸¸æ•°é¡¹) å°è¯•æ¨å¯¼ä¸€ä¸‹å…¬å¼ğŸ¤” è®¾f(x)f(x)f(x)ä¸ºåŸå‡½æ•°ï¼Œg(x)=Ax2+Bx+Cg(x) = Ax^2 + Bx +Cg(x)=Ax2+Bx+Cä¸ºæ‹Ÿåˆåçš„å‡½æ•°ï¼Œæœ‰ï¼š âˆ«abf(x)dxâ‰ˆâˆ«abAx2+Bx+C=A3(b3âˆ’a3)+B2(b2âˆ’a2)+C(aâˆ’b)=(bâˆ’a)6(2A(b2+ab+a2)+3B(b+a)+6C)=(bâˆ’a)6(2Ab2+2Aab+2Aa2+3Bb+3Ba+6C)=(bâˆ’a)6(Aa2+Ba+C+Ab2+Bb+C+4(A(a+b2)2+B(a+b2)+C))=(bâˆ’a)6(f(a)+f(b)+4f(a+b2))\\begin{aligned} \\int_a^bf(x)\\mathrm{d}x &amp;\\approx \\int_a^b Ax^2 + Bx +C \\\\ &amp;= \\frac{A}{3}(b^3 - a^3) + \\frac{B}{2}(b^2 - a^2) + C(a-b) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(2A(b^2+ab+a^2)+3B(b+a)+6C \\bigg) \\\\ &amp;= \\frac{(b-a)}{6}(2Ab^2 + 2 Aab +2Aa^2+3Bb+3Ba+6C) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(Aa^2 + Ba+C+Ab^2 + Bb +C +4(A(\\frac{a+b}{2})^2 + B(\\frac{a+b}{2})+C)\\bigg) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(f(a)+f(b)+4f(\\frac{a+b}{2})\\bigg) \\end{aligned} âˆ«abâ€‹f(x)dxâ€‹â‰ˆâˆ«abâ€‹Ax2+Bx+C=3Aâ€‹(b3âˆ’a3)+2Bâ€‹(b2âˆ’a2)+C(aâˆ’b)=6(bâˆ’a)â€‹(2A(b2+ab+a2)+3B(b+a)+6C)=6(bâˆ’a)â€‹(2Ab2+2Aab+2Aa2+3Bb+3Ba+6C)=6(bâˆ’a)â€‹(Aa2+Ba+C+Ab2+Bb+C+4(A(2a+bâ€‹)2+B(2a+bâ€‹)+C))=6(bâˆ’a)â€‹(f(a)+f(b)+4f(2a+bâ€‹))â€‹ æœ€ç»ˆSimpsonSimpsonSimpsonå…¬å¼ä¸ºï¼š âˆ«abf(x)dxâ‰ˆ(bâˆ’a)(f(a)+f(b)+4f(a+b2))6\\int_a^b f(x) \\mathrm{d}x \\approx \\frac{(b-a)(f(a)+f(b)+4f(\\frac{a+b}{2}))}{6} âˆ«abâ€‹f(x)dxâ‰ˆ6(bâˆ’a)(f(a)+f(b)+4f(2a+bâ€‹))â€‹ 1234double simpson(double l, double r){ return (r - l)*(f(l) + f(r) + 4*f((l+r)/2))/6;} æœ‰ä¸€ä¸ªç»“è®ºï¼šSimpsonSimpsonSimpsonå…¬å¼çš„è¯¯å·®ä¸º âˆ’190(râˆ’l2)5f(4)(Î¾)-\\frac{1}{90}(\\frac{r-l}{2})^5f^{(4)}(\\xi) âˆ’901â€‹(2râˆ’lâ€‹)5f(4)(Î¾) å…¶ä¸­Î¾\\xiÎ¾ä¸ºåŒºé—´[l,r][l,r][l,r]ä¸­çš„æŸä¸ªå€¼ã€‚ æ˜¯ä¸æ˜¯è¿˜æ²¡è¯´æ•°å€¼ç§¯åˆ†å­¦è¿™ç©æ„å¹²å˜›ï¼Œå¾ˆæ˜æ˜¾æ˜¯è§£å†³ç§¯åˆ†é—®é¢˜çš„ï¼Œæƒ³æƒ³ä¸Šé¢æˆ‘ä»¬è¯´çš„é»æ›¼ç§¯åˆ†çš„å®šä¹‰ï¼Œå…¶ç²¾ç¡®åº¦å¾ˆæ˜æ˜¾æ˜¯ç”±åŒºé—´åˆ†å‰²å†³å®šçš„ï¼Œå¦‚ä½•åŒºé—´åˆ†å‰²å‘¢ï¼Ÿ è‡ªé€‚åº”Simpsonæ³• ç°åœ¨æ¥è§£å†³ç²¾åº¦é—®é¢˜ï¼Œè®©å…¶å®ç°è‡ªåŠ¨æ§åˆ¶åˆ†å‰²åŒºé—´çš„å¤§å°ã€‚ SimpsonSimpsonSimpsonå…¬å¼æ˜¯é€šè¿‡ä¸€ä¸ªäºŒæ¬¡å‡½æ•°å»æ‹ŸåˆåŸå‡½æ•°çš„ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å½“å‰åˆ†å‰²çš„åŒºé—´å¯¹åº”çš„å‡½æ•°å€¼è¶Šæ¥è¿‘ä¸€ä¸ªäºŒæ¬¡å‡½æ•°å›¾åƒï¼Œè¯¯å·®å°±è¶Šå°ã€‚ ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åœ¨è®¡ç®—æ—¶éœ€è¦åˆ¤æ–­å½“å‰åŒºé—´æ˜¯å¦æ¥è¿‘ä¸€ä¸ªäºŒæ¬¡å‡½æ•°ï¼Œåˆ¤æ–­è¿‡ç¨‹å¦‚ä¸‹ï¼š é¦–å…ˆå°†å½“å‰æ®µç›´æ¥ä»£å…¥æ±‚ç§¯åˆ†ï¼Œåœ¨å°†å½“å‰è¿™ä¸€æ®µåˆ†æˆä¸¤ä¸ªåŒºé—´ï¼Œæ±‚è¿™ä¸¤æ®µçš„ç§¯åˆ†ï¼Œå¦‚æœå½“å‰æ®µçš„ç§¯åˆ†å€¼å’Œåˆ†å‰²æˆä¸¤æ®µä¹‹åçš„ç§¯åˆ†ä¹‹å’Œç›¸å·®å¾ˆå°çš„è¯å°±å¯ä»¥ç›´æ¥è®¡ç®—äº†å¦åˆ™é€’å½’ã€‚ æœ‰ä¸€ä¸ªç»“è®ºï¼šä¸‰ç‚¹SimpsonSimpsonSimpsonä¸åˆ†æˆä¸¤ä¸ªå­åŒºé—´åä¸¤ä¸ªå­åŒºé—´SimpsonSimpsonSimpsonå’Œå·®å€¼æ˜¯åŸæ¥ç»å¯¹è¯¯å·®çš„115\\frac{1}{15}151â€‹ï¼ˆæˆ‘ä¸å¤ªä¼šè¯ï¼‰ 1234567891011double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L)+ auto_simpson(mid, r, eps/2, R);} The first question ç»™å®šç§¯åˆ†ï¼š âˆ«LRcx+dax+bdx\\int_L^R \\frac{cx+d}{ax+b} \\mathrm{d}x âˆ«LRâ€‹ax+bcx+dâ€‹dx ä¿ç•™è‡³å°æ•°ç‚¹åå…­ä½ã€‚ ç›´æ¥ä½¿ç”¨å…¬å¼å³å¯ã€‚ æˆ–è€…ç›´æ¥ç§¯å‡ºæ¥ï¼Œç›´æ¥æš´åˆ‡ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;double a, b, c, d;double f(double x){ return (c*x + d)/(a*x + b);}double simpson(double l, double r){ return (r - l)*(f(l) + f(r) + 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L)+ auto_simpson(mid, r, eps/2, R);}int main(){ double l, r; scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;l, &amp;r); printf(&quot;%.6lf&quot;, auto_simpson(l, r, 1e-6, simpson(l, r))); return 0;} The second question ç»™å®šç§¯åˆ†ï¼š âˆ«0âˆxaxâˆ’xdx\\int_0^{\\infty} x ^{\\frac{a}{x}-x} \\mathrm{d}x âˆ«0âˆâ€‹xxaâ€‹âˆ’xdx ä¿ç•™å°æ•°ç‚¹å5ä½ï¼Œä¼šå‡ºç°ç§¯åˆ†å‘æ•£çš„æƒ…å†µã€‚ å¥½åƒè¿™ä¸ªå¼å­æ˜¯ä¸€ä¸ªä¸å¯ç§¯åˆ†å‡½æ•°ï¼Œåªèƒ½ç”¨SimpsonSimpsonSimpsonï¼Œ(ä¹Ÿåªä¼šSimpsonSimpsonSimpson),ä½†æ˜¯ä¸‹ç•Œæ˜¯0ï¼Œä¸Šç•Œæ˜¯âˆ\\inftyâˆï¼Œéœ€è¦æ‰¾åˆ°å¼å­çš„ä¸€äº›æ€§è´¨ã€‚ å¯ä»¥è¯æ˜ï¼š a&lt;0a &lt; 0a&lt;0æ—¶åŸç§¯åˆ†å‘æ•£ âˆµaxâˆ’x=aâˆ’x2xâˆ´aâˆ’x2&lt;0,xaâˆ’x2x=1xx2âˆ’axâˆµxâ†’0,x2â†’0,1xâ†’âˆâˆ´0&lt;x&lt;1,xkâ†’0,kâ†’âˆâˆ´xâ†’0,f(x)â†’âˆ\\begin{aligned} &amp;\\because \\frac{a}{x} - x = \\frac{a-x^2}{x} \\\\ &amp;\\therefore a-x^2 &lt; 0,x^{\\frac{a-x^2}{x}} = \\frac{1}{x^{\\frac{x^2-a}{x}}}\\\\ &amp;\\because x \\to 0 ,x^2 \\to 0, \\frac{1}{x} \\to \\infty \\\\ &amp;\\therefore 0 &lt; x &lt; 1,x^k \\to 0,k \\to \\infty \\\\ &amp;\\therefore x\\to 0,f(x)\\to \\infty \\end{aligned} â€‹âˆµxaâ€‹âˆ’x=xaâˆ’x2â€‹âˆ´aâˆ’x2&lt;0,xxaâˆ’x2â€‹=xxx2âˆ’aâ€‹1â€‹âˆµxâ†’0,x2â†’0,x1â€‹â†’âˆâˆ´0&lt;x&lt;1,xkâ†’0,kâ†’âˆâˆ´xâ†’0,f(x)â†’âˆâ€‹ a&gt;0a&gt;0a&gt;0æ—¶åŸç§¯åˆ†æ”¶æ•› âˆµxaâˆ’x2x=1xx2âˆ’axâˆ´xâ†’âˆ,f(x)â†’0\\begin{aligned} &amp;\\because x^{\\frac{a-x^2}{x}} = \\frac{1}{x^{\\frac{x^2-a}{x}}} \\\\ &amp;\\therefore x \\to \\infty ,f(x)\\to 0 \\end{aligned} â€‹âˆµxxaâˆ’x2â€‹=xxx2âˆ’aâ€‹1â€‹âˆ´xâ†’âˆ,f(x)â†’0â€‹ å› ä¸ºåœ¨a&gt;0a&gt;0a&gt;0çš„æ—¶å€™æ”¶æ•›æ‰€ä»¥å³è¾¹ç•Œä¸ç”¨è®¾å¤ªå¤§ï¼Œå¯ä»¥è‡ªå·±æ‰“è¡¨è¯•ä¸€ä¸‹ã€‚ ç‰¹åˆ¤a&lt;0a&lt;0a&lt;0ï¼Œåœ¨[1eâˆ’8,20][1e-8,20][1eâˆ’8,20]ä½œä¸ºç§¯åˆ†èŒƒå›´å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;double a;double f(double x){ return pow(x, a/x - x);}double simpson(double l, double r){ return (r - l)*(f(l) + f(r)+ 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L+R-fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L) + auto_simpson(mid, r, eps/2, R);}int main(){ scanf(&quot;%lf&quot;, &amp;a); double l = 1e-9; double r = 20; if(a &lt; 0) printf(&quot;orz&quot;); else printf(&quot;%.5lf&quot;, auto_simpson(l, r, 1e-8, simpson(l, r))); return 0;} The third question ç»™å®šä¸€ä¸ªç”±åœ†å°å’Œåœ†é”¥æ„æˆçš„ç»„åˆä½“ï¼Œç»™å®šä¸€ä¸ªè§’åº¦æ±‚æ±‚å…¶åœ¨å¹³é¢ä¸Šçš„æŠ•å½±é¢ç§¯ã€‚ ä½“ç°äº†è‡ªé€‚åº”è¾›æ™®æ£®æ³•çš„ä¸€ä¸ªå¸¸è§ç”¨é€”ï¼Œç”¨æ¥æ±‚æ›²è¾¹å›¾å½¢çš„é¢ç§¯ ã€‚ å…ˆæ¥è€ƒè™‘æŠ•å½±çš„å½¢çŠ¶ï¼Œé¦–å…ˆä¸€ä¸ªåœ†çš„æŠ•å½±è‚¯å®šæ˜¯ä¸€ä¸ªå¤§å°ç›¸åŒçš„åœ†ï¼Œåœ†é”¥çš„æŠ•å½±å°±æ˜¯ä¸€ä¸ªåœ†åŠ ä¸Šäº†ä¸€ä¸ªç‚¹ï¼Œä¸€çº§è¿™ä¸ªç‚¹å’Œåœ†çš„ä¸¤æ¡åˆ‡çº¿ï¼Œåœ†å°çš„æŠ•å½±å°±æ˜¯ä¸¤ä¸ªåœ†åŠ ä¸Šå®ƒä»¬çš„å…¬åˆ‡çº¿ã€‚ è¿èµ·æ¥çš„è¯å°±æ˜¯ä¸€ä¸ªéå¸¸é¬¼ç•œçš„ä¸œè¥¿ã€‚ ç„¶åæš´åŠ›å³å¯ï¼ˆç”»çš„å¥½åƒä¸å¤ªæ ‡å‡†\\kkï¼‰ æ˜¯ä¸€ä¸ªå°é—­å›¾å½¢ï¼Œå¹¶ä¸”å°†å…¶çœ‹ä½œä¸€ä¸ªå‡½æ•°ç›´æ¥æ±‚ç§¯åˆ†å³å¯ã€‚ å†å»è§‚å¯Ÿå›¾å½¢ï¼Œæ­¤æ—¶è¿™æ£µæ ‘çš„æŠ•å½±å·²ç»å˜ä¸ºäº†è‹¥å¹²ä¸ªåœ†å¼§åŠ ä¸Šè‹¥å¹²ä¸ªæ¢¯å½¢å’Œä¸‰è§’å½¢ã€‚ æ—¢ç„¶æ˜¯æ±‚ç§¯åˆ†çš„è¯è€Œä¸”è¿˜å­˜åœ¨åœ†å¼§å¼§å°±éœ€è¦ç”¨çš„SimpsonSimpsonSimpsonå…¬å¼äº†ã€‚ éœ€è¦ç”¨æ¢¯å½¢è…°çš„å·¦å³ä¸¤ä¸ªç«¯ç‚¹ä½œä¸ºä¸€æ®µå‡½æ•°çš„å®šä¹‰åŸŸã€‚ ç„¶åå°±æ˜¯é«˜åº¦ä¸ºhhhçš„ç‰©ä½“æŠ•å½±åˆ°æ°´å¹³é¢ä¸Šé•¿åº¦ä¼šå˜ä¸ºhtanâ¡Î±\\frac{h}{\\tan \\alpha}tanÎ±hâ€‹ï¼Œæ¥ç¡®å®šæ¨ªåæ ‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#include &lt;pthread.h&gt;#define dwd 1919810.114514#define ochen 114514.1919810using namespace std;const int N = 510;int n;double alpha;double H, Tan;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// å‘é‡çš„å››åˆ™è¿ç®— double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} // å‘é‡æ¨¡é•¿ double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);}// ç‚¹ç§¯ double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} // å‰ç§¯ double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a2,b1,b2)/(dis(a1,a2)*dis(b1,b2));}// å‘é‡å¤¹è§’ double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));}// ä¸¤å‘é‡å›´æˆçš„å››è¾¹å½¢é¢ç§¯ double angle(geometric a){return atan2(a.y,a.x);}// æè§’ geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} // å‘é‡é€†æ—¶é’ˆæ—‹è½¬ geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} // å‘é‡é¡ºæ—¶é’ˆæ—‹è½¬}opt;struct circle{ geometric p; double r; circle(geometric _p = 0, double _r = 0): p(_p), r(_r) {}};circle c[N];struct line{ geometric a, b; line(geometric _a = 0, geometric _b = 0):a(_a), b(_b) {} double calc(double x) { double k = (b.y-a.y)/(b.x-a.x); double b = a.y-k*a.x; return k*x+b; }}seg[N];double f(double x){ double sum = 0; for(int i = 1; i &lt;= n; i++) { if(x &lt; c[i].p.x + c[i].r &amp;&amp; x &gt; c[i].p.x - c[i].r) sum = max(sum, sqrt(c[i].r*c[i].r-(x-c[i].p.x)*(x-c[i].p.x))); }//åœ¨åœ†é‡Œé¢ for(int i = 1; i &lt; n; i++) { if(x &gt; seg[i].a.x &amp;&amp; x &lt; seg[i].b.x) sum = max(sum, seg[i].calc(x)); }//åœ¨åˆ‡çº¿èŒƒå›´å†… //å–æœ€å¤§å¯ä»¥æ»¡è¶³æ‰€æœ‰æƒ…å†µ return sum;}double simpson(double l, double r){ return (r-l)*(f(l) + f(r) + 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L) + auto_simpson(mid, r, eps/2, R);}int main(){ scanf(&quot;%d%lf&quot;, &amp;n, &amp;alpha); Tan = 1.0/tan(alpha); n = n + 1; for(int i = 1; i &lt;= n; i++) { double h; scanf(&quot;%lf&quot;, &amp;h); c[i].p.x = h*Tan; c[i].p.x += c[i-1].p.x; } for(int i = 1; i &lt; n; i++) { double r; scanf(&quot;%lf&quot;, &amp;r); c[i].r = r; }// è¾“å…¥ c[n].r = 0; for(int i = 1; i &lt; n; i++) { double x1 = c[i].p.x; double x2 = c[i+1].p.x; double r1 = c[i].r; double r2 = c[i+1].r; double a1 = r1*(r1-r2)/(x2-x1); double a2 = r2*(r1-r2)/(x2-x1); seg[i] = line(geometric(x1+a1, sqrt(r1*r1-a1*a1)),geometric(x2+a2, sqrt(r2*r2-a2*a2))); }//è®¡ç®—çº¿æ®µ double l = c[1].p.x - c[1].r; double r = c[n].p.x - c[n].r; for(int i = 1; i &lt;= n; i++) { l = min(l, c[i].p.x - c[i].r); r = max(r, c[i].p.x + c[i].r); }//å¿…é¡»è®¡ç®—ç§¯åˆ†åŒºé—´ã€‚ printf(&quot;%.2lf&quot;, 2*auto_simpson(l, r, 1e-6, simpson(l, r))); // ä¸€éåªè®¡ç®—äº†ä¸€åŠ return 0;} åè®° å…¶å®é«˜æ•°æŒºå¤šå…¬å¼çš„ï¼Œæˆ‘è¿™é‡Œå°±ç®—éšä¾¿æäº†ä¸€ä¸‹å§ã€‚ å‚è€ƒæ–‡çŒ® [1] é«˜ç­‰æ•°å­¦ åŒæµå¤§å­¦æ•°å­¦ç³» [2]OIwiki-æ•°å€¼ç§¯åˆ† [3]ç™¾åº¦ç™¾ç§‘","link":"/2022/08/15/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"},{"title":"æœæ•™ç­›","text":"äºšçº¿æ€§ç­›ä¹‹ä¸€ æœæ•™ç­› å‰ç½®çŸ¥è¯† ç§¯æ€§å‡½æ•° å‰è¨€ é¦–å…ˆå…ˆçœ‹ä¸€ä¸‹ç§¯æ€§å‡½æ•°å§ï¼Œç§¯æ€§å‡½æ•°å°±æ˜¯åœ¨å¯¹äºæ‰€æœ‰çš„äº’è´¨çš„ aaa å’Œ bbb ï¼Œæ€»æœ‰ f(ab)=f(a)f(b)f(ab) = f(a)f(b)f(ab)=f(a)f(b) ï¼Œ åˆ™ f(x)f(x)f(x) ä¸ºç§¯æ€§å‡½æ•°ã€‚ æ¯”è¾ƒå¸¸è§çš„ä¸»è¦æœ‰ï¼š d(x)=âˆ‘iâˆ£n1Ïƒ(x)=âˆ‘iâˆ£niÏ†(x)=âˆ‘i=1x1[gcd(x,i)=1]Î¼(x)={1x=1(âˆ’1)kâˆi=1kqi=10maxâ¡{qi}&gt;1Ïµ(x)=[x=1]d(x)= \\sum_{i \\mid n} 1 \\\\ \\sigma (x) = \\sum_{i \\mid n} i \\\\ \\varphi (x) = \\sum_{i=1}^x 1 [gcd(x,i)=1] \\\\ \\mu (x) = \\left\\{ \\begin{aligned} &amp;1 &amp;x=1 \\\\ &amp;(-1)^k &amp;\\prod_{i=1}^k q_i=1 \\\\ &amp;0&amp;\\max\\left\\{ q_i \\right\\} &gt; 1 \\end{aligned} \\right. \\\\ \\epsilon (x) = [x=1] d(x)=iâˆ£nâˆ‘â€‹1Ïƒ(x)=iâˆ£nâˆ‘â€‹iÏ†(x)=i=1âˆ‘xâ€‹1[gcd(x,i)=1]Î¼(x)=â©âªâªâªâªâ¨âªâªâªâªâ§â€‹â€‹1(âˆ’1)k0â€‹x=1i=1âˆkâ€‹qiâ€‹=1max{qiâ€‹}&gt;1â€‹Ïµ(x)=[x=1] ç§¯æ€§å‡½æ•°æœ‰ä»¥ä¸‹æ€§è´¨ï¼š è‹¥ f(x),g(x)f(x),g(x)f(x),g(x)ä¸ºç§¯æ€§å‡½æ•°ï¼Œåˆ™ï¼Œ h(x)=f(xp)h(x)=fp(x)h(x)=f(x)g(x)h(x)=âˆ‘dâˆ£xf(d)g(xd)h(x) = f(x^p) \\\\ h(x) = f^p(x) \\\\ h(x) = f(x)g(x) \\\\ h(x) = \\sum_{d \\mid x} f(d)g(\\frac{x}{d}) h(x)=f(xp)h(x)=fp(x)h(x)=f(x)g(x)h(x)=dâˆ£xâˆ‘â€‹f(d)g(dxâ€‹) ä¸­çš„h(x)h(x)h(x)ä¹Ÿä¸ºç§¯æ€§å‡½æ•°ã€‚ æœæ•™ç­›ä¸»è¦æ˜¯ç”¨æ¥æ±‚åƒè¿™äº›ç§¯æ€§å‡½æ•°çš„å‰ç¼€å’Œã€‚ æ­£æ–‡ å¯¹äºæ±‚ä¸€ä¸ªæ•°è®ºå‡½æ•°çš„å‰ç¼€å’Œï¼Œæœæ•™ç­›å¯ä»¥åœ¨ä½äºçº¿æ€§æ—¶é—´çš„å¤æ‚åº¦å†…æ±‚è§£ã€‚ å¯¹äºæ•°è®ºå‡½æ•° fff ï¼Œ è¦æ±‚è®¡ç®— S(n)=âˆ‘i=1nf(i)S(n) = \\sum_{i=1}^n f(i)S(n)=âˆ‘i=1nâ€‹f(i) ã€‚ é¦–å…ˆæ„é€ ä¸€ä¸ª S(n)S(n)S(n) å…³äºS(âŒŠniâŒ‹)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor)S(âŒŠinâ€‹âŒ‹) çš„é€’æ¨å¼ å¯¹äºä»»æ„ä¸€ä¸ªæ•°è®ºå‡½æ•° ggg ï¼Œå¿…é¡»æ»¡è¶³ âˆ‘i=1nâˆ‘dâˆ£ig(d)f(id)=âˆ‘i=1ng(i)S(âŒŠniâŒ‹) âŸº âˆ‘i=1n(fâˆ—g)(i)=âˆ‘i=1ng(i)S(âŒŠniâŒ‹)\\sum_{i=1}^n \\sum_{d \\mid i}g(d)f(\\frac{i}{d})= \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\iff \\sum_{i=1}^n(f \\ast g)(i) = \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) i=1âˆ‘nâ€‹dâˆ£iâˆ‘â€‹g(d)f(diâ€‹)=i=1âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹)âŸºi=1âˆ‘nâ€‹(fâˆ—g)(i)=i=1âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹) ç®€å•çš„è¯æ˜ï¼š âˆ‘i=1nâˆ‘dâˆ£ig(d)f(id)=âˆ‘i=1nâˆ‘j=1âŒŠniâŒ‹g(i)f(j)=âˆ‘i=1ng(i)âˆ‘j=1âŒŠniâŒ‹f(j)=âˆ‘i=1ng(i)S(âŒŠniâŒ‹)\\sum_{i=1}^n \\sum_{d \\mid i}g(d)f(\\frac{i}{d})\\\\ = \\sum_{i=1}^n\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor} g(i)f(j)\\\\ = \\sum_{i=1}^ng(i)\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor} f(j)\\\\ = \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ i=1âˆ‘nâ€‹dâˆ£iâˆ‘â€‹g(d)f(diâ€‹)=i=1âˆ‘nâ€‹j=1âˆ‘âŒŠinâ€‹âŒ‹â€‹g(i)f(j)=i=1âˆ‘nâ€‹g(i)j=1âˆ‘âŒŠinâ€‹âŒ‹â€‹f(j)=i=1âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹) æ±‚å‡ºé€’æ¨å¼ g(1)S(n)=âˆ‘i=1n(fâˆ—g)(i)âˆ’âˆ‘i=2ng(i)S(âŒŠniâŒ‹)g(1)S(n)=\\sum_{i=1}^n(f \\ast g)(i)-\\sum_{i=2}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) g(1)S(n)=i=1âˆ‘nâ€‹(fâˆ—g)(i)âˆ’i=2âˆ‘nâ€‹g(i)S(âŒŠinâ€‹âŒ‹) å¯ä»¥ç”¨æ•°è®ºåˆ†å—å¯¹ååŠéƒ¨åˆ†å¿«é€Ÿæ±‚å‡ºç»“æœã€‚ é—®é¢˜ é¢˜ç›®ï¼šæ±‚ ï¼š S1(n)=âˆ‘i=1nÎ¼(i)S2(n)=âˆ‘i=1nÏ†(i)S_1(n)=\\sum_{i=1}^n \\mu(i)\\\\ S_2(n)=\\sum_{i=1}^n \\varphi(i) S1â€‹(n)=i=1âˆ‘nâ€‹Î¼(i)S2â€‹(n)=i=1âˆ‘nâ€‹Ï†(i) ç¬¬ä¸€éƒ¨åˆ†æ±‚è«æ¯”ä¹Œæ–¯å‡½æ•°å‰ç¼€å’Œ âˆµÏµ=Î¼âˆ—1âˆ´Ïµ=âˆ‘dâˆ£nÎ¼(d)S1(n)=âˆ‘i=1nÏµ(i)âˆ’âˆ‘i=2nS1(âŒŠniâŒ‹)=1âˆ’âˆ‘i=2nS1(âŒŠniâŒ‹)\\because \\epsilon =\\mu \\ast 1 \\\\ \\therefore \\epsilon = \\sum_{d \\mid n}\\mu (d) \\\\ S_1(n) = \\sum_{i=1}^n \\epsilon(i) -\\sum_{i=2}^nS_1(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ = 1-\\sum_{i=2}^nS_1(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) âˆµÏµ=Î¼âˆ—1âˆ´Ïµ=dâˆ£nâˆ‘â€‹Î¼(d)S1â€‹(n)=i=1âˆ‘nâ€‹Ïµ(i)âˆ’i=2âˆ‘nâ€‹S1â€‹(âŒŠinâ€‹âŒ‹)=1âˆ’i=2âˆ‘nâ€‹S1â€‹(âŒŠinâ€‹âŒ‹) ç›´æ¥æ•´é™¤åˆ†å— ç¬¬äºŒéƒ¨åˆ†æ±‚æ¬§æ‹‰å‡½æ•°å‰ç¼€å’Œ âˆµÏ†âˆ—1=IDâˆ´âˆ‘i=1n(Ï†âˆ—1)(i)=âˆ‘i=1n1â‹…S2(âŒŠniâŒ‹)âˆ‘i=1nID(i)=âˆ‘i=1n1â‹…S2(âŒŠniâŒ‹)12n(n+1)=âˆ‘i=1nS2(âŒŠniâŒ‹)S2(n)=12n(n+1)âˆ’âˆ‘i=2nS2(âŒŠniâŒ‹)\\because \\varphi \\ast 1 =ID \\\\ \\therefore \\sum_{i=1}^n (\\varphi \\ast 1)(i)=\\sum_{i=1}^n 1 \\cdot S_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ \\sum_{i=1}^n ID(i)= \\sum_{i=1}^n 1 \\cdot S_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ \\frac{1}{2}n(n+1) = \\sum_{i=1}^nS_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ S_2(n)=\\frac{1}{2}n(n+1)-\\sum_{i=2}^nS_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ âˆµÏ†âˆ—1=IDâˆ´i=1âˆ‘nâ€‹(Ï†âˆ—1)(i)=i=1âˆ‘nâ€‹1â‹…S2â€‹(âŒŠinâ€‹âŒ‹)i=1âˆ‘nâ€‹ID(i)=i=1âˆ‘nâ€‹1â‹…S2â€‹(âŒŠinâ€‹âŒ‹)21â€‹n(n+1)=i=1âˆ‘nâ€‹S2â€‹(âŒŠinâ€‹âŒ‹)S2â€‹(n)=21â€‹n(n+1)âˆ’i=2âˆ‘nâ€‹S2â€‹(âŒŠinâ€‹âŒ‹) æ—¶é—´å¤æ‚åº¦O(n23)O(n ^{\\frac{2}{3}})O(n32â€‹) codeï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e6+10;int T,cnt,n;ll mu[maxn],prime[maxn],S1[maxn],S2[maxn];bool vis[maxn];map&lt;ll,ll&gt; eit;void Mu(){ mu[1]=1; for(int i=2;i&lt;=2e6;i++) { if(!vis[i]) { prime[++cnt]=i; mu[i]=-1; } for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=2e6;j++) { vis[prime[j]*i]=true; if(i%prime[j]==0) { mu[prime[j]*i]=0; break; } mu[prime[j]*i]=-mu[i]; } } for(int i=1;i&lt;=2e6;i++) S1[i]=S1[i-1]+mu[i];}ll S_mu(ll x){ if(x&lt;=2e6)return S1[x]; if(eit[x])return eit[x]; ll res=1; for(ll l=2,r;l&lt;=x;l=r+1) { r=x/(x/l); res-=S_mu(x/l)*(r-l+1); } return eit[x]=res;}ll S_phi(ll x){ ll res=0; for(ll l=1,r;l&lt;=x;l=r+1) { r=x/(x/l); res+=(S_mu(r)-S_mu(l-1))*(x/l)*(x/l); } return (res-1)/2+1;}int main(){ Mu(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld %lld\\n&quot;,S_phi(n),S_mu(n)); } return 0;} å¯¹äºä¸€äº›ç­›æ³•çš„å°æŠ€å·§ï¼š å¯¹äºæ¯”è¾ƒå¤§çš„æ•°æ®æ—¶ï¼Œç­›æ³•åœ¨ç­›å‰åŠæ®µæ—¶èŠ±è´¹çš„æ—¶é—´æ˜¾ç„¶æ˜¯æ¯”è¾ƒé•¿çš„ï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥ç›´æ¥çº¿æ€§ç­›ä¸€éå…ˆè®°å½•ä¸‹æ¥ï¼Œåœ¨æ±‚ååŠæ®µæ—¶å°±å¯ä»¥çœä¸‹å¤§éƒ¨åˆ†æ—¶é—´ï¼Œç§°ä¸ºæ ¹å·åˆ†æ²»ã€‚","link":"/2022/07/19/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"title":"æ¬§æ‹‰è·¯æµ…è°ˆ","text":"çœŸçš„åªæ˜¯æµ…è°ˆï¼ æ¬§æ‹‰è·¯ æ¦‚å¿µ æ¬§æ‹‰è·¯ï¼šåœ¨ä¸€ä¸ªå›¾ä¸­ï¼Œå¯ä»¥ä»å…¶ä¸­ä¸€ç‚¹å‡ºå‘ï¼Œä¸é‡å¤åœ°èµ°å®Œå…¶æ‰€æœ‰è¾¹ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾å°±ç§°ä¸ºæ¬§æ‹‰å›¾ã€‚ å¦‚æœèµ·ç‚¹å’Œç»ˆç›¸åŒï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾ä¸ºæ¬§æ‹‰å›è·¯ã€‚ æ¬§æ‹‰è·¯è·¯å­˜åœ¨çš„å……è¦æ¡ä»¶ï¼š 1.å›¾æ˜¯è¿é€šçš„ï¼Œè‹¥ä¸è¿é€šä¸å¯èƒ½ä¸€æ¬¡æ€§éå†æ‰€æœ‰è¾¹ã€‚ 2.å¯¹äºæ— å‘å›¾ï¼šæœ‰ä¸”ä»…æœ‰ä¸¤ä¸ªç‚¹ï¼Œä¸å…¶ç›¸è¿çš„è¾¹æ•°ä¸ºå¥‡æ•°ï¼Œå…¶ä»–ç‚¹ç›¸è¿è¾¹æ•°ä¸ºå¶æ•°ï¼›æˆ–æ‰€æœ‰ç‚¹ä¸ºå¶æ•°ç‚¹ã€‚å¯¹äºä¸¤ä¸ªå¥‡æ•°ç‚¹ï¼Œä¸€ä¸ªä¸ºèµ·ç‚¹ï¼Œä¸€ä¸ªä¸ºç»ˆç‚¹ã€‚èµ·ç‚¹éœ€è¦å‡ºå»ï¼Œç»ˆç‚¹éœ€è¦è¿›å…¥ï¼Œæ‰€ä»¥ä¸å¥‡æ•°ä¸ªç‚¹ç›¸è¿ã€‚ å¦‚æœå­˜åœ¨è¿™æ ·ä¸€ä¸ªæ¬§æ‹‰è·¯ï¼Œå…¶æ‰€æœ‰ç‚¹ç›¸è¿è¾¹æ•°éƒ½ä¸ºå¶æ•°ï¼Œé‚£è¯´æ˜å®ƒæ˜¯æ¬§æ‹‰å›è·¯ã€‚ 3.å¯¹äºæœ‰å‘å›¾ï¼šé™¤å»ç»ˆç‚¹å’Œèµ·ç‚¹ï¼Œæ‰€æœ‰ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ç›¸ç­‰ã€‚èµ·ç‚¹å‡ºåº¦æ¯”å…¥åº¦å¤§1ï¼Œç»ˆç‚¹å…¥åº¦æ¯”å‡ºåº¦å¤§1.è‹¥èµ·ç‚¹å’Œç»ˆç‚¹å‡ºå…¥åº¦ä¹Ÿç›¸åŒï¼Œåˆ™ä¸ºæ¬§æ‹‰å›è·¯ã€‚ æ¬§æ‹‰è·¯ä¸€èˆ¬ç§°ä¸ºä¸€ç¬”ç”»é—®é¢˜ã€‚ æ±‚è§£ DFS è®¾ç»™å®šä¸€å¼ å›¾ï¼Œå·²çŸ¥è¿™å¼ å›¾æ˜¯æ¬§æ‹‰è·¯ï¼Œè¦æ±‚è¾“å‡ºæ•´æ¡æ¬§æ‹‰è·¯ã€‚ æ­¤æ—¶å¯ä»¥é‡‡ç”¨DFSæ¥éå†æ•´å¼ å›¾ï¼Œå¯»æ‰¾æ¬§æ‹‰è·¯ã€‚ ä½¿ç”¨DFSå¯»æ‰¾æ¬§æ‹‰è·¯çš„åŸºæœ¬æ€æƒ³å¦‚ä¸‹ï¼š DFSå¯»æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ— è¾¹å¯èµ°çš„èŠ‚ç‚¹ï¼Œåˆ™è¿™ä¸ªèŠ‚ç‚¹å¿…å®šä¸ºç»ˆç‚¹ã€‚ æ¥ä¸‹æ¥ç”±äºDFSçš„é€’å½’å›æº¯ï¼Œä¼šé€€å›ç»ˆç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§ç»­å¾€ä¸‹æœç´¢ï¼Œç›´åˆ°å¯»æ‰¾åˆ°ç¬¬äºŒä¸ªæ— è¾¹å¯èµ°çš„èŠ‚ç‚¹ï¼Œåˆ™è¿™ä¸ªèŠ‚ç‚¹å¿…å®šä¸ºæ¬§æ‹‰è·¯ä¸­ç»ˆç‚¹å‰æœ€åè®¿é—®çš„èŠ‚ç‚¹ã€‚ äºæ˜¯å½“é€šè¿‡DFSéå†å®Œæ•´å¼ å›¾åï¼Œå°±å¯ä»¥å€’åºå‚¨å­˜ä¸‹æ•´ä¸ªæ¬§æ‹‰è·¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int edge[1000][1000];//ä¸ºäº†æ–¹ä¾¿ä¼˜å…ˆè®¿é—®ç¼–å·å°çš„èŠ‚ç‚¹ï¼Œè¿™é‡Œä½¿ç”¨é‚»æ¥çŸ©é˜µæ¥å­˜è¾¹//å¦‚æœä½¿ç”¨vectoræ¥å­˜å›¾ï¼Œé‚£è¿˜éœ€è¦å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿æ¥çš„è¾¹è¿›è¡Œæ’åºint ans[1000000];int degree[1000];//ç”¨äºå‚¨å­˜æ¯ä¸ªç‚¹çš„åº¦ï¼Œä»¥æ±‚èµ·ç‚¹int p=0;void dfs(int now){ for(int i=1;i&lt;=1000;i++)//é¡ºåºå¯»æ‰¾å¯è®¿é—®çš„è¾¹ï¼Œä¼˜å…ˆæ‰¾ç¼–å·å°çš„èŠ‚ç‚¹ { if(edge[now][i])//è‹¥è¿™æ¡è¾¹å°šæœªè®¿é—®è¿‡ { edge[now][i]--;//å·²è®¿é—®è¿‡çš„è¾¹è¦åˆ å»ï¼Œé˜²æ­¢é‡å¤è®¿é—® edge[i][now]--;//æœ‰å‘å›¾çš„è¯è¯·åˆ å»è¿™ä¸€è¡Œ dfs(i); } } ans[++p]=now;//å°†è®¿é—®çš„èŠ‚ç‚¹å‚¨å­˜è¿›ç­”æ¡ˆæ•°ç»„ //ç”±äºé€’å½’çš„ç‰¹æ€§ï¼Œè¿™é‡Œå‚¨å­˜çš„æ˜¯é€†åºè¿‡ç¨‹}int main(){ int n; cin&gt;&gt;n;//è¾¹çš„ä¸ªæ•° for(int i=1;i&lt;=n;i++) { int a,b; cin&gt;&gt;a&gt;&gt;b; edge[a][b]++; edge[b][a]++;//æœ‰å‘å›¾çš„è¯åˆ å»è¿™è¡Œ degree[a]++,degree[b]++;//ä¸¤ä¸ªç‚¹çš„åº¦éƒ½+1 } int start=0; for(int i=1;i&lt;=1000;i++) { if(degree[i]%2)//å¦‚æœæ‰¾åˆ°å¥‡æ•°ç‚¹ { start=i;//é‚£è¿™ä¸ªå¥‡æ•°ç‚¹å°±ä½œä¸ºèµ·ç‚¹ï¼Œç”±äºé¡ºåºéå†ï¼Œè¿™ä¸ªèµ·ç‚¹ç¼–å·å¿…å®šæœ€å° break; } } if(!start)//å¦‚æœè¿˜æ²¡æ‰¾åˆ°å¥‡æ•°ç‚¹ï¼Œè¯´æ˜æ˜¯æ¬§æ‹‰å›è·¯ { for(int i=1;i&lt;=1000;i++) if(degree[i])//å¯»æ‰¾æœ€å°çš„æœ‰åº¦çš„ç‚¹å³å¯ { start=i; break; } } dfs(start);//dfså¯»æ‰¾æ¬§æ‹‰è·¯ for(int i=p;i&gt;=1;i--) cout&lt;&lt;ans[i];//è¾“å‡ºç»™å®šçš„æ¬§æ‹‰è·¯ return 0;}","link":"/2022/06/14/%E6%AC%A7%E6%8B%89%E8%B7%AF%E6%B5%85%E8%B0%88/"},{"title":"æ¯æ—¥æ€»ç»“","text":"æ¯æ—¥æ€»ç»“ æ¯æ—¥æ€»ç»“ 2022-7-18 ä»Šå¤©ï¼Œå­¦é•¿zh_douä¸ºæˆ‘ä»¬å‡†å¤‡äº†å››ä¸ªéå¸¸ç®€å•çš„æ•°è®ºé¢˜ï¼Œç»“æœæ•´å¯„äº† ğŸ˜‘ å‘œå‘œå‘œ~ ğŸ˜­ T1æ˜¯ä¸€é“è«å/å®¹æ–¥ï¼Œéƒ½æŒæ¡çš„ä¸å¤ªå¥½ï¼Œä¸»è¦è¿˜æ˜¯å­¦åˆ°äº†Dirichlet å‰ç¼€å’Œ: å¯¹äºå·²çŸ¥ä¸€ä¸ªåºåˆ— aaa ï¼Œæ±‚ ä¸€ä¸ªåºåˆ— bbb ï¼š bk=âˆ‘iâˆ£kaib_k = \\sum_{i | k} a_i bkâ€‹=iâˆ£kâˆ‘â€‹aiâ€‹ å¯ä»¥åœ¨O(nlogâ¡logâ¡n)O(n\\log\\log n)O(nloglogn)çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚å‡ºï¼š 123for(int i=1;i&lt;=cnt;i++) for(int j=1;j*prime[i]&lt;=n;j++) b[prime[i]*j]+=b[j]; T2æ‹“æ¬§+æ„é€ ï¼Œå¾ˆæœ‰æ„æ€ T3ç¥ä¸€èˆ¬çš„å®¹æ–¥ T4çº¯æ•°å­¦é¢˜ï¼Œéå¸¸è€ƒéªŒæ•°å­¦æŠ€å·§ã€‚ å¼€å§‹ææ•°å­¦äº†ğŸ™ƒ 2022-7-19 æ•°è®ºï¼ 2022-7-20 æ•°è®ºï¼ï¼ 2022-7-21 æ•°è®ºï¼ï¼ï¼ 2022-9-4 ç®—æ˜¯åšçš„ä¸€ç‚¹é¢˜å§ã€‚ Test 1 T1 Not Equal Rectangle ç„å­¦æ„é€ å³å¯ï¼Œé¦–å…ˆè€ƒè™‘n,mn,mn,méå¸¸å°çš„æƒ…å†µï¼Œä¸éš¾å‘ç°æ„é€ ä¸€ä¸ªæ¯æ¡å¯¹è§’çº¿ä¸Šæ•°å­—ç›¸åŒçš„çŸ©é˜µå°±å¯æ»¡è¶³ï¼Œå¯¹äºn&gt;25,m&gt;25n &gt; 25, m &gt; 25n&gt;25,m&gt;25æ—¶ï¼Œå¯ä»¥è€ƒè™‘å°†æ•´ä¸ªçŸ©é˜µåˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªä¸Šè¿°25Ã—2525 \\times 2525Ã—25çš„çŸ©é˜µï¼Œç„¶åå°†ä¸åŒå­çŸ©é˜µä¸Šå¡«çš„çš„æ•°é”™å¼€ï¼Œå³å¯ï¼Œæ¨¡æ•°ä¸º23å³å¯ï¼Œæ•°å­¦è¯æ˜ç•¥ã€‚ T2 One to One å¯ä»¥å‘ç°ï¼Œå»ºå¥½çš„è¾¹æŠŠç‚¹åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªåŸºç¯æ ‘å’Œæ ‘ã€‚ å¦‚æœä¸ºåŸºç¯æ ‘ï¼Œç›´æ¥è®¡ç®—è´¡çŒ®ä¸ºaÃ—nba \\times n^baÃ—nb å¦‚æœæ˜¯æ ‘ï¼Œè®¾fi,jf_{i,j}fi,jâ€‹ï¼Œè½¬ç§»æ–¹ç¨‹ä¸º fi,j=fiâˆ’1,j+fiâˆ’1,jâˆ’1Ã—sizeif_{i,j} = f_{i-1,j} + f_{i-1,j-1} \\times size_i fi,jâ€‹=fiâˆ’1,jâ€‹+fiâˆ’1,jâˆ’1â€‹Ã—sizeiâ€‹ å¦‚æœæœ‰kkkæ£µæ ‘ï¼Œç­”æ¡ˆå³ä¸º âˆ‘i=1kfk,iÃ—(iâˆ’1)!Ã—nkâˆ’i\\sum_{i = 1} ^ k f_{k,i} \\times (i-1)! \\times n^{k-i} i=1âˆ‘kâ€‹fk,iâ€‹Ã—(iâˆ’1)!Ã—nkâˆ’i T3 CF1109F Sasha and Algorithm of Silenceâ€™s Sounds LCT + Segment tree ç›´æ¥ç»´æŠ¤å³å¯ã€‚ Test 2 T1 ARC134E Modulo Nim é¦–å…ˆå¯ä»¥çœ‹å‡º0å¯¹ç»“æœæ— å½±å“ï¼Œä»¥åŠç›¸åŒçš„æ•°å¯¹ç»“æœä¹Ÿæ²¡æœ‰å½±å“ï¼Œæ¥ä¸‹æ¥è€ƒè™‘èƒœåˆ©æ¡ä»¶ï¼Œ å½“é›†åˆä¸­æœ‰æ•°â‰¤2\\le 2â‰¤2æ—¶ï¼Œå¾ˆæ˜æ˜¾ï¼Œ{1}, {2},å…ˆæ‰‹å¿…è´¥ï¼Œ {1ï¼Œ2} å…ˆæ‰‹å¿…èƒœã€‚ æ‰€æœ‰æ•°&gt;2&gt;2&gt;2æ—¶å¦‚æœæœ‰å¥‡æ•°ï¼Œåˆ™é€‰æ‹©m=2m = 2m=2ï¼Œå‰©ä½™é›†åˆ{1}, å…ˆæ‰‹å¿…èƒœã€‚ æ‰€æœ‰æ•°éƒ½æ˜¯å¶æ•°ä¸”æœ‰ mod 4=2\\bmod 4 = 2mod4=2æ—¶ï¼Œé€‰æ‹©m=4m = 4m=4ï¼Œå‰©ä½™é›†åˆ{2}ï¼Œå…ˆæ‰‹å¿…èƒœã€‚ è€ƒè™‘m=3m = 3m=3æ—¶ï¼Œè‹¥å‰©ä½™é›†åˆä¸º{1}æˆ–{2},å…ˆæ‰‹å¿…èƒœã€‚ è‹¥å‰©ä½™å‡ ä¸ªä¸º{1,2}ï¼Œä¸”æ‰€æœ‰æ•°éƒ½æ˜¯4çš„å€æ•°ï¼Œåˆ™å‰©ä½™æ•°åªèƒ½å½¢å¦‚12k+4,12k+812k+4, 12k+812k+4,12k+8ï¼Œè‹¥æ­¤æ—¶é›†åˆä¸º{4ï¼Œ8}. å…ˆæ‰‹å¿…è´¥ï¼Œå¦åˆ™é€‰æ‹©m=12m = 12m=12ï¼Œå…ˆæ‰‹å¿…èƒœã€‚ è‹¥å‰©ä½™é›†åˆä¸º{0}ï¼Œæ‰€æœ‰æ•°å¿…é¡»å½¢å¦‚12k12k12kï¼Œ æ­¤æ—¶èƒœè´¥ä¸ç¡®å®šã€‚ æ¥ä¸‹æ¥åˆ†æƒ…å†µè½¬ç§»ï¼ŒçŠ¶å‹è½¬ç§»èƒœè´Ÿï¼Œæœ€åç”¨æ‰€æœ‰æƒ…å†µå‡å»å¿…è´¥æƒ…å†µå³ä¸ºç­”æ¡ˆã€‚ T2 ARC134F Flipping Coins å¤šé¡¹å¼ + ç”Ÿæˆå‡½æ•°ã€‚ T3 CF1455G Forbidden Value é¦–å…ˆå°†æŒ‡ä»¤çœ‹æˆæ ‘å½¢ç»“æ„ï¼Œç„¶åä½¿ç”¨æ ‘å½¢dpå’Œå¯å‘å¼åˆå¹¶ã€‚ Test 3 T1 äºŒé¾™æˆç  å…¸å‹çš„å¡ç‰¹å…°æ•°ä¾‹é¢˜ï¼Œå…¶å®å°±æ˜¯æ±‚ä»(0,0)èµ°åˆ°(n,m) ä¸”ä¸ç»è¿‡ç›´çº¿y=Ax+By = Ax +By=Ax+Bä¸Šæ–¹çš„æ–¹æ¡ˆæ•°ã€‚ ç­”æ¡ˆå³ä¸º Cn+mnâˆ’AÃ—Cn+mnâˆ’1C_{n+m} ^ n - A \\times C_{n+m} ^ {n-1} Cn+mnâ€‹âˆ’AÃ—Cn+mnâˆ’1â€‹ T2 è€é¼ å·å¥¶é…ª æ¨¡æ‹Ÿã€‚ T3 è„‘è¢‹ç ¸æ ¸æ¡ƒ é—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºgcdå·ç§¯ï¼Œå³æ±‚âˆ‘gcdâ¡(i,j)=xaibj\\sum_{\\gcd(i,j) = x} a_i b_jâˆ‘gcd(i,j)=xâ€‹aiâ€‹bjâ€‹ï¼Œä½¿ç”¨åç¼€å’Œå’Œåç¼€å·®åˆ†å®ç°ã€‚ T4 å·¨æ–§ç å¤§æ ‘ LCT åŠ¨æ€ç»´æŠ¤æœ€å°ç”Ÿæˆæ ‘ã€‚ Test 4 T1 ARC124E Pass to Next å¦‚æœæ¯ä¸ªäººéƒ½è‡³å°‘ç»™å‡ºäº†ä¸€ä¸ªçƒï¼Œå…¶å®å¯ä»¥è®©æ¯ä¸ªäººéƒ½å°‘ç»™ç›¸åŒçš„ä¸ªæ•°ï¼Œæ•ˆæœç›¸åŒï¼Œæ‰€ä»¥è‡³å°‘æœ‰ä¸€ä¸ªäººæ²¡ç»™çƒã€‚ ç„¶åæ ¹æ®ç»“è®ºåˆ—å‡ºdpæ–¹ç¨‹å³å¯ã€‚ T2 CF1470E Strange Permutation ç”±äºæ“ä½œäº’ä¸é‡å ï¼Œå¯ä»¥å°†åŸé—®é¢˜è½¬åŒ–ä¸ºæ±‚ç¿»è½¬æ“ä½œï¼ŒäºŒåˆ† + é€’æ¨å³å¯ã€‚ T3 P8434 ã€ŒWHOI-2ã€D&amp;D é›†åˆ AAAçš„è£…é¥°å­é›†å³ä¸è¢«å…¶å®ƒä»»ä½•æ•°åŒ…å«çš„å­é›†ï¼Œaaa åŒ…å« bbb å½“ä¸”ä»…å½“ aâˆ£b=aa | b = aaâˆ£b=aï¼Œå³ bbb ä¸º 1 çš„ä½ aaa ä¹Ÿä¸º 1ã€‚ è€ƒè™‘åŸåºåˆ—çš„è£…é¥°å­é›† SSSï¼Œå‡è®¾ xâˆˆSx\\in SxâˆˆSï¼Œå› ä¸º xxx ä¸è¢«ä»»ä½•æ•°åŒ…å«ï¼Œæ‰€ä»¥å¯¹äºä»»æ„å­ä¸² [l,r],x[l,r], x[l,r],x åŒæ ·ä¸è¢«åŒºé—´å†…ä»»ä½•æ•°åŒ…å«ã€‚å› æ­¤ xxxå¿…ç„¶ä½œä¸ºæŸä¸ªåˆ’åˆ†å­ä¸²çš„è£…é¥°å­é›†å†…çš„ä¸€ä¸ªå…ƒç´ ã€‚æ‰€æœ‰å­ä¸²çš„è£…é¥°å­é›†åŒ…å« SSSã€‚ è€ƒè™‘ xâˆ‰Sx\\notin Sxâˆˆ/â€‹Sï¼Œå‡è®¾å­˜åœ¨ yâˆˆaiy\\in a_iyâˆˆaiâ€‹ åŒ…å« xxxã€‚å›  xxxä¸å¯èƒ½ä½œä¸º yyy æ‰€åœ¨å­ä¸²çš„è£…é¥°å­é›†ï¼Œæ•…æ‰€æœ‰å­ä¸²çš„è£…é¥°å­é›†ä¸åŒ…å« SSS ä»¥å¤–çš„å…ƒç´ ã€‚ è¿™è¯æ˜äº†æ‰€æœ‰å­ä¸²è£…é¥°å­é›†ç­‰äº SSSã€‚ ä»¤ lil_iliâ€‹ è¡¨ç¤ºä½¿å¾— [li,i][l_i, i][liâ€‹,i]åŒ…å«æ‰€æœ‰ SSSå†…å…ƒç´ çš„æœ€å¤§çš„ lil_iliâ€‹,æ˜¾ç„¶å¯ä»¥åŒæŒ‡é’ˆæ±‚å‡ºã€‚ å®¹æ˜“å¾—åˆ° DP fif_ifiâ€‹ è¡¨ç¤º [1,i][1, i][1,i]çš„ç­”æ¡ˆï¼Œf1=0f_1 = 0f1â€‹=0.è‹¥ lil_iliâ€‹ å­˜åœ¨ï¼Œåˆ™æœ‰è½¬ç§»æ–¹ç¨‹ fi=âˆ‘j=0liâˆ’1fjf_i = \\sum\\limits_{j = 0} ^ {l_i - 1} f_jfiâ€‹=j=0âˆ‘liâ€‹âˆ’1â€‹fjâ€‹ï¼Œè¡¨ç¤ºå°†[j,i](jâ‰¤li)[j, i](j \\le l_i)[j,i](jâ‰¤liâ€‹) åˆ’ä¸ºå­ä¸²ã€‚å‰ç¼€å’Œä¼˜åŒ–å³å¯åšåˆ° O(n)\\mathcal{O}(n)O(n)ã€‚ æ±‚ SSS ç›¸å½“å®¹æ˜“ï¼Œåªéœ€å¯¹æ¯ä¸ªæ•° aia_iaiâ€‹ æ£€æŸ¥æ˜¯å¦å­˜åœ¨ajâ‰ aia_j\\neq a_iajâ€‹î€ â€‹=aiâ€‹æœ‰ aja_jajâ€‹åŒ…å« aia_iaiâ€‹,å¯ä»¥å†æä¸ª DP ç®—è¿™ç©æ„ï¼Œä¹Ÿå¯ä»¥ç›´æ¥é«˜ç»´åç¼€å’Œï¼Œç›¸å½“å¥½å†™ã€‚ Test 5 T1 robo æ¨¡æ‹Ÿã€‚ T2 expand å…ˆé¢„å¤„ç†å‡ºæœ€çŸ­è·¯å’Œæœ€å¤§ä½“ç§¯ç„¶åçŠ¶å‹dpè½¬ç§»å³å¯ã€‚ T3 birthday æ ¹æ®æŠ½å±‰åŸç†å¯¹äºæ“ä½œ1å½“åŒºé—´é•¿åº¦å¤§äº13æ—¶è‚¯å®šä¼šå¾—åˆ°yesï¼Œæ‰€ä»¥å½“åŒºé—´é•¿åº¦å°äº14æ—¶äºŒåˆ†æœç´¢å³å¯ï¼Œå¯¹äºæ“ä½œ2çº¿æ®µæ ‘ç»´æŠ¤å³å¯ï¼Œåˆ°å¶å­èŠ‚ç‚¹æ—¶åœ¨ä¸‹ç©¿tagã€‚ Test 6 T1 trees è€ƒè™‘æ¯ä¸ªæƒå€¼çš„å½±å“ï¼Œå°†æƒå€¼ä»å°åˆ°å¤§æ’åºåï¼Œå³å¯å¾—åˆ°ç­”æ¡ˆä¸ºï¼š âˆ‘i=1nval[i]Ã—Ciâˆ’1kâˆ’1\\sum_{i = 1}^n val[i] \\times C_{i-1}^{k-1} i=1âˆ‘nâ€‹val[i]Ã—Ciâˆ’1kâˆ’1â€‹ T2 bridge çŸ©é˜µåŠ é€Ÿé€’æ¨ã€‚ T3 flowers å¯»æ‰¾å¾ªç¯èŠ‚å³å¯ã€‚ 2022-9-10 å°æ€»ç»“ï¼ˆ Test 1 T1 ARC100E Or Plus Max è€ƒè™‘æšä¸¾å­é›†ï¼Œç»´æŠ¤æ¯ä¸ªé›†åˆçš„æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ï¼Œæœ€åç»Ÿä¸€å–maxmaxmaxå³å¯ã€‚ T2 CF615F LEGOndary Grandmaster å¯ä»¥å¯¹é¢˜æ„ä½¿ç”¨æŠ€å·§, å°†åŸæ¥çš„010101ä¸²çš„å¶æ•°ç»´å–åï¼Œæ¯æ¬¡åœ¨åŸä¸²çš„å–åæ“ä½œç­‰ä»·äºåœ¨æ–°ä¸²ä¸­äº¤æ¢ä¸¤ä¸ªç›¸é‚»çš„å­—ç¬¦ï¼Œç„¶åå°±å¯ä»¥å·§å¦™çš„å°†é—®é¢˜è½¬åŒ–ä¸ºï¼šäº¤æ¢æ–°ä¸²çš„å­—ç¬¦ï¼Œå°†å…¶å˜ä¸ºç›®æ ‡ä¸²ã€‚ å¾ˆæ˜¾ç„¶ï¼Œé¦–å…ˆä¸¤ä¸ªä¸²çš„111çš„ä¸ªæ•°è¦ç›¸åŒï¼Œç„¶åä¸éš¾å¾—å‡ºï¼Œè®¾sssä¸­ç¬¬iiiä¸ª111çš„ä¸‹æ ‡ä¸ºxix_ixiâ€‹ï¼Œtttä¸­ç¬¬iiiä¸ª111çš„ä¸‹è¡¨ä¸ºyiy_iyiâ€‹ï¼Œæœ€å°‘äº¤æ¢æ¬¡æ•°å°±ä¸ºâˆ‘i=1nâˆ£xiâˆ’yiâˆ£\\sum_{i = 1}^n | x_i - y_i|âˆ‘i=1nâ€‹âˆ£xiâ€‹âˆ’yiâ€‹âˆ£ï¼Œnnnä¸ºå…¶ä¸­111çš„ä¸ªæ•°ï¼Œä½†æ˜¯æˆ‘ä»¬æ˜¾ç„¶éœ€è¦æ›´å¥½æ“ä½œçš„å½¢å¼ï¼Œè®¾aia_iaiâ€‹è¡¨ç¤ºsssä¸­å‰iiiä¸ªæ•°ä¸­111çš„ä¸ªæ•°ï¼Œ bib_ibiâ€‹è¡¨ç¤ºtttä¸­å‰iiiä¸ªæ•°ä¸­111çš„ä¸ªæ•°ï¼Œç­”æ¡ˆå°±å˜ä¸ºäº†âˆ‘i=1nâˆ£aiâˆ’biâˆ£\\sum_{i = 1} ^ n |a_i - b_i|âˆ‘i=1nâ€‹âˆ£aiâ€‹âˆ’biâ€‹âˆ£ï¼Œç„¶åç›´æ¥ç»Ÿè®¡å‰ç¼€ï¼Œ åç¼€ä¸­ç­‰äºaiâˆ’bi=ja_i - b_i = jaiâ€‹âˆ’biâ€‹=jçš„ä¸ªæ•°Ã—j\\times jÃ—jå°±å¥½äº†ã€‚ æ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2)ã€‚ T3 æ•°åˆ— æ˜¾ç„¶å¯¹äºæ²¡ä¸€ä¸ªä½ç½®çš„ç­”æ¡ˆå°±æ˜¯sufmaxâˆ’preminsuf _ {max}-pre_{min}sufmaxâ€‹âˆ’preminâ€‹ï¼Œç›´æ¥ç»Ÿè®¡åˆ å»æ¯ä¸ªæ•°çš„è´¡çŒ®å°±å¯ä»¥äº†ã€‚ Test 2 T1 æ’åˆ— å¦‚æœä¸åŠ ä»»ä½•é™åˆ¶ï¼Œæ˜¾ç„¶å°†æ‰€æœ‰çš„æ­£æ•°æ’åˆ—åœ¨ä¸€èµ·æ˜¯æœ€ä¼˜çš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´å½“æœ‰å¿…é¡»çš„é™åˆ¶ï¼Œè®©ä¸€ä¸ªè´Ÿæ•°å¤¹åœ¨ä¸¤ä¸ªè¯æ•°ä¹‹é—´æ—¶ï¼Œä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿå½±å“ï¼Œè¿™æ—¶ä¼šæœ‰ä¸‰ä¸ªé€‰æ‹©ï¼Œè¦ä¹ˆé€‰æ‹©å‰é¢çš„ç­”æ¡ˆï¼Œè¦ä¹ˆç®—ä¸Šè´Ÿæ•°ï¼Œè¦ä¹ˆé€‰æ‹©åé¢çš„ç­”æ¡ˆï¼Œ ä¸éš¾æƒ³åˆ°ï¼Œå¯ä»¥ç”¨æœ€å°å‰²æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ å°†æ¯ä¸ªä½ç½®æ‹†æˆä¸¤ä¸ªç‚¹l,rl, rl,rï¼Œå¦‚æœå½“å‰ä½ç½®æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå°†sssè¿å‘lllï¼Œ rrr è¿å‘tttï¼Œæƒå€¼ä¸ºæ­£æ•°çš„å€¼ï¼Œç»Ÿè®¡å’Œï¼Œå¦‚æœæ˜¯ä¸€ä¸ªè´Ÿæ•°ï¼Œå°±å°†lllè¿å‘rrrï¼Œ æƒå€¼ä¸ºå…¶ç»å¯¹å€¼ï¼Œå¯¹äºæ¯ä¸€ä¸ªé™åˆ¶(a,b)(a, b)(a,b)ï¼Œ å°†lal_alaâ€‹è¿å‘lbl_blbâ€‹ï¼Œ rar_araâ€‹è¿å‘rbr_brbâ€‹å°±å¥½äº†ï¼Œ è·‘æœ€å°å‰²æ¥å¾—åˆ°ç­”æ¡ˆã€‚ T2 ARC127F Â±AB ç»“è®ºé¢˜ï¼Œ ç±»ä¼¼æ¬§å‡ é‡Œå¾—ç®—æ³•ã€‚ T3 CF1616H Keep XOR Low å»º010101trie, è®¾f(u,v)f(u, v)f(u,v)è¡¨ç¤ºä»uuuçš„å­æ ‘å’Œvvvçš„å­æ ‘ä¸­é€‰ä¸€äº›æ•°ï¼Œä¸¤ä¸¤å¼‚æˆ–ä¸å¤§äºxxxçš„æ–¹æ¡ˆæ•°ï¼Œ ç±»ä¼¼æ ‘å½¢dpè½¬ç§»å³å¯ã€‚ Test 3 T1 ç æ±Ÿå¤œæ¸¸ ç”»ä¸€æ¬¡å‡½æ•°å›¾åƒå°±å¯ä»¥å¾ˆç›´è§‚çš„çœ‹å‡ºç­”æ¡ˆä¸€å®šæ˜¯æœ€é å³çš„ä¸distdistdistçš„äº¤ç‚¹ï¼Œ O(n)O(n)O(n)å³å¯è§£å†³ã€‚ T2 æ—…è¡Œè®¡åˆ’ æ¬§æ‹‰è·¯å¾„ T3 åŸºç«™å»ºè®¾ äºŒç»´åŒºé—´dpï¼Œ è½¬ç§»å³å¯ã€‚ Test 4 T1 ARC101E Ribbons on Tree å·§å¦™çš„æ ‘å½¢dpï¼Œ ç”¨äº†ä¸€æ‰‹å®¹æ–¥çš„æŠ€å·§ã€‚ T2 ARC088E Papple Sort å¾ˆæ˜æ˜¾çš„è´ªå¿ƒæ€è·¯å°±æ˜¯å¯¹äºæ¯ä¸€ç§å­—ç¬¦ï¼Œä½ç½®é å³çš„è‚¯å®šè¦å¯¹ä¸Šä½ç½®é å·¦çš„æ¥è®©ç§»åŠ¨æ­¥æ•°æœ€å°‘ï¼Œ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å…ˆå¯¹æ¯ä¸€ä¸ªå­—ç¬¦æ ‡ä¸Šç¼–å·ï¼Œ é—®é¢˜å°±è½¬åŒ–æˆäº†ç»Ÿè®¡é€†åºå¯¹ä¸ªæ•°ã€‚ T3 äº¤æ¢ åˆ†æ²»ç»´æŠ¤ä¸€ä¸ªæ ˆï¼ŒåŒæ—¶ç»Ÿè®¡æ–¹æ¡ˆæ•°ã€‚ Test 5 T1 CF1422F Boring Queries é¦–å…ˆå¯¹äºæ¯ä¸ªå¤§äº2e5\\sqrt {2e5}2e5â€‹çš„å¤§è´¨æ•°æ˜¾ç„¶åªä¼šå‡ºç°äº†ä¸€æ¬¡ï¼Œ å°äº2e5\\sqrt{2e5}2e5â€‹çš„è´¨æ•°æœ‰868686ä¸ªï¼Œ è¿™æ ·å°±å¯ä»¥å¯¹äºå°çš„è´¨æ•°ç”¨RMQæ±‚è§£ï¼Œå¤§è´¨æ•°å°±å¯ä»¥ç»Ÿè®¡[l,r][l,r][l,r]å†…ä¸åŒæ•°çš„ä¸ªæ•°æ¥è®¡ç®—è´¡çŒ®ï¼Œä¸»å¸­æ ‘ç»´æŠ¤ã€‚ T2 åºåˆ— ä¸é”™çš„æœŸæœ›dp T3 CF741D Arpaâ€™s letter-marked tree and Mehrdadâ€™s Dokhtar-kosh paths ä¸Šå¤ç¥é¢˜äº†ï¼Œç®—æ˜¯dsuçš„åº”ç”¨å¥½é¢˜ï¼Œï¼ˆæ¯•ç«Ÿæ˜¯ç®—æ³•æå‡ºè€…æœ¬äººå‡ºçš„é¢˜ï¼‰ã€‚ ç”±äºåªéœ€è¦ç»Ÿè®¡aâˆ’va - vaâˆ’vè¿™222222ä¸ªå­—æ¯ï¼Œå¯ä»¥è€ƒè™‘ç”¨äºŒè¿›åˆ¶å‹ç¼©ï¼Œå¯¹äºèƒ½ä»¥æ„æˆå›æ–‡è·¯å¾„çš„è‚¯å®šæ˜¯åªæœ‰ä¸€ä¸ªå­—ç¬¦å‡ºç°äº†å¥‡æ•°æ¬¡æˆ–å‡å‡ºç°äº†å¶æ•°æ¬¡ï¼Œå¯ä»¥äºŒè¿›åˆ¶å‹ç¼©è¡¨ç¤ºæ¯ä¸ªå­—ç¬¦çš„å¥‡å¶æ€§çŠ¶æ€ï¼Œç„¶åæ ¹æ®å¼‚æˆ–çš„æ€§è´¨ï¼Œç»´æŠ¤æ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„å¼‚æˆ–å€¼ï¼ŒdisxâŠ•disydis_x \\oplus dis_ydisxâ€‹âŠ•disyâ€‹ï¼Œ å°±å¯ä»¥å¾—åˆ°xxxåˆ°yyyçš„è·¯å¾„çš„çŠ¶æ€ã€‚ é¦–å…ˆåˆæ³•çš„çŠ¶æ€åªæœ‰232323ç§ï¼Œç›´æ¥å¯ä»¥å¼€æ¡¶è·‘dsu on treeï¼Œæš´åŠ›æšä¸¾çŠ¶æ€å°±å¯ä»¥è§£å†³äº†ã€‚ 2022-9-14 Test 1 T1 æ ‘ é¦–å…ˆè€ƒè™‘è«æ¯”ä¹Œæ–¯åæ¼”ï¼Œå˜ä¸ºç»Ÿè®¡ kâˆ£gcdkâˆ£gcdkâˆ£gcd çš„ç‚¹å¯¹æ•°é‡ã€‚ å¯¹äºæ¯ä¸ªè¾¹æƒï¼Œé¦–å…ˆå»æ‰é‡å¤çš„è´¨å› å­ï¼Œè¿™æ ·å®ƒçš„è´¨å› å­åªæœ‰ä¸è¶…è¿‡ c=7c=7c=7ä¸ªã€‚ é‚£ä¹ˆå¯¹äºæ¯ä¸ª kkkï¼Œå°†è¾¹æƒæ˜¯ kkk çš„å€æ•°çš„è¾¹å–å‡ºï¼Œç”¨å¹¶æŸ¥é›†è®¡ç®—ç­”æ¡ˆã€‚ å¯¹äºä¿®æ”¹æ¶‰åŠçš„è¾¹ï¼Œæˆ‘ä»¬ä¸€å¼€å§‹ä¸å°†å®ƒä»¬åŠ å…¥å¹¶æŸ¥é›†ã€‚ç„¶åæˆ‘ä»¬æšä¸¾ q+1q+1q+1 ä¸ªæ—¶åˆ»ï¼Œå†å°†è¿™äº›è¾¹åŠ å…¥ï¼Œç»Ÿè®¡ç­”æ¡ˆï¼Œå†åˆ å»å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦ O(L+(n+q2)2clogâ¡n)O(L+(n+q^2)2^c\\log n)O(L+(n+q2)2clogn)ã€‚ T2 ARC133D Range XOR æŠŠå®ƒä»¬æ¨¡4çš„ç»“æœè¿›è¡Œåˆ†ç±»ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°: w4x=xw4x+1=1w4x+2=x+1w4x+3=0 w_{4x}=x \\\\ w_{4x+1}=1\\\\ w_{4x+2}=x+1\\\\ w_{4x+3}=0\\\\ w4xâ€‹=xw4x+1â€‹=1w4x+2â€‹=x+1w4x+3â€‹=0 å¯ä»¥ç”¨æ•°ä½dpè§£å†³ï¼Œf[i][j][k]f[i][j][k]f[i][j][k]è¡¨ç¤ºè¿˜æœ‰ iii ä½,ç¬¬ä¸€ä¸ªæ•°æ˜¯å¦å¡ä¸Šç•Œï¼Œç¬¬äºŒä¸ªæ•°æ˜¯å¦å¡ä¸Šç•Œçš„æ–¹æ¡ˆæ•°ã€‚ T3 CF1503E 2-Coloring åˆæ³•çš„æƒ…å½¢å…¶å®å°±æ˜¯ä»¥ä¸‹æƒ…å†µï¼š ç„¶åå°†ç›´æ¥ç»Ÿè®¡å³å¯ã€‚ Test 2 T1 tree åœ¨AAAæ ‘ä¸Šå»ºä¸»å¸­æ ‘ï¼Œ æ¯ä¸ªç‚¹ä¸Šå‚¨å­˜åˆ°æ ¹è·¯å¾„ä¸Šçš„ä¿¡æ¯ã€‚æ±‚å‡ºæ¯ä¸ªç‚¹åœ¨BBBæ ‘ä¸Šçš„DFSåºï¼Œç„¶å˜åæˆä¸€ä¸ªåŒºé—´æœ€å¤§å€¼çš„é—®é¢˜ï¼Œè¿™æ ·å°±å¤„ç†å¥½äº†æ¯ä¸ªAAAæ ‘ä¸Šçš„ç‚¹åœ¨BBBæ ‘çš„è´¡çŒ®ã€‚ T2 ARC111E Simple Math 3 è€ƒè™‘iiiçš„å–å€¼ï¼Œ å¯ä»¥å¾—åˆ°iâ‰¤âŒŠdâˆ’2câˆ’bâŒ‹i \\le \\lfloor \\frac{d- 2}{c - b} \\rflooriâ‰¤âŒŠcâˆ’bdâˆ’2â€‹âŒ‹ï¼Œè®¾m=âŒŠdâˆ’2câˆ’bâŒ‹m = \\lfloor \\frac{d- 2}{c - b} \\rfloorm=âŒŠcâˆ’bdâˆ’2â€‹âŒ‹ç„¶åç­”æ¡ˆå°±ä¸ºï¼š mâˆ’âˆ‘i=1m(âŒŠa+cidâŒ‹âˆ’âŒŠaâˆ’1+bidâŒ‹)m - \\sum_{i = 1} ^ {m} (\\lfloor \\frac{a + ci}{d} \\rfloor - \\lfloor \\frac{a - 1+ bi}{d} \\rfloor) mâˆ’i=1âˆ‘mâ€‹(âŒŠda+ciâ€‹âŒ‹âˆ’âŒŠdaâˆ’1+biâ€‹âŒ‹) ç±»æ¬§å‡ é‡Œå¾—è§£å†³å³å¯ã€‚ T3 ARC101F Robots and Exits å°†æ“ä½œæ˜ å°„åˆ°å¹³é¢ç›´è§’åæ ‡ç³»ä¸Šå°±ä¸éš¾å¾—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œ æ ‘çŠ¶æ•°ç»„ä¼˜åŒ–ä¸€ä¸‹å°±å¥½äº†ã€‚ 2022-9-24 Test 1 T1 note å…¶å®å¯¹äºä¸€å®šæ»¡è¶³é¢˜æ„çš„NNNæœ€å¤§å¯ä»¥ä¸º102345678900000102345678900000102345678900000ï¼Œå…¶å®æ±‚è§£æ•°åˆ—AAAæ»¡è¶³Ai=Aiâˆ’1+1A_i = A_{i - 1} + 1Aiâ€‹=Aiâˆ’1â€‹+1ï¼Œå¹¶ä¸”æ„æˆAiA_iAiâ€‹çš„æ•°å­—ä¸­å¿…é¡»åŒ…æ¢æ•°åˆ—BBBï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å…ˆæšä¸¾æ•°åˆ—AAAï¼Œç›´æ¥æš´åŠ›å»æ±‚âŒŠA10âŒ‹\\lfloor \\frac{A}{10} \\rfloorâŒŠ10Aâ€‹âŒ‹ï¼Œå»åˆ¤æ–­æ»¡è¶³äº†é‚£äº›BiB_iBiâ€‹ ç„¶åå»é™¤è¿™ä¸€ä½å»æ„é€ æ–°çš„æ•°åˆ—Aâ€²A'Aâ€²è¿™æ ·åšçš„è¯æ¯æ¬¡æ•°åˆ—é•¿åº¦ä¼šå˜ä¸ºåŸå…ˆçš„110\\frac{1}{10}101â€‹ï¼Œå¤æ‚åº¦O(lgâ¡n)O(\\lg n)O(lgn)ã€‚ T2 CF1119H Triple é¦–å…ˆé¢˜ç›®è¦æ±‚çš„å…¶å®å°±æ˜¯nnnä¸ªæ¡¶xorxorxorå·ç§¯åçš„ç»“æœï¼Œä¸éš¾å†™å‡ºä¸€ä¸ªO(n2k)O(n2^k)O(n2k)çš„è½¬ç§»dpï¼Œä½†å…¶å®å¯ä»¥è½¬åŒ–ä¸ºå¤šé¡¹å¼çš„å½¢å¼ï¼Œç”¨FWTè§£å†³ï¼Œ é¦–å…ˆæ„é€ å¤šé¡¹å¼ä¸ºï¼š Fi,j=(âˆ’1)g(j&amp;ai)x+(âˆ’1)g(j&amp;bi)y+(âˆ’1)g(j&amp;ci)zF_{i, j} = (-1) ^ {g(j \\&amp; a_i)}x + (-1)^{g(j \\&amp; b_i)}y + (-1) ^ {g(j \\&amp; c_i)}z Fi,jâ€‹=(âˆ’1)g(j&amp;aiâ€‹)x+(âˆ’1)g(j&amp;biâ€‹)y+(âˆ’1)g(j&amp;ciâ€‹)z ç„¶åè€ƒè™‘åŒ–ç®€å¼å­ï¼š âˆFi,j=âˆ((âˆ’1)g(j&amp;ai)x+(âˆ’1)g(j&amp;bi)y+(âˆ’1)g(j&amp;ci)z)\\prod F_{i, j} = \\prod \\bigg( (-1) ^ {g(j \\&amp; a_i)}x + (-1)^{g(j \\&amp; b_i)}y + (-1) ^ {g(j \\&amp; c_i)}z \\bigg) âˆFi,jâ€‹=âˆ((âˆ’1)g(j&amp;aiâ€‹)x+(âˆ’1)g(j&amp;biâ€‹)y+(âˆ’1)g(j&amp;ciâ€‹)z) å°†å…¶éƒ½å¼‚æˆ–ä¸Šaia_iaiâ€‹ï¼Œç„¶åå°±å¯ä»¥è®¾å‡ºæ–¹ç¨‹ c1+c2âˆ’c3âˆ’c4=âˆ‘iFi,jc_1 + c_2 - c_3 - c_4 = \\sum_i F_{i, j} c1â€‹+c2â€‹âˆ’c3â€‹âˆ’c4â€‹=iâˆ‘â€‹Fi,jâ€‹ é—®é¢˜å°±å¯ä»¥å¾—åˆ°è§£å†³äº† T3 CF241B Friends ä¸»è¦æ˜¯ç”¨åˆ°äº†01trie ä¸ŠäºŒåˆ†çš„æ–¹å¼æ±‚å‡ºç¬¬kå¤§ï¼Œ ç„¶åå°†æ¯ä¸€ä½æ‹†å¼€ï¼Œ ä¸€ä½ä¸€ä½çš„åŠ å°±å¯ä»¥ç”¨O(nlogâ¡n)O(n \\log n)O(nlogn)çš„å¤æ‚åº¦è§£å†³è¿™ä¸ªé—®é¢˜äº† Test 2 T1 axelavir æ‰“è¡¨é¢˜ï¼Œ æœ‰OIESåšæ³•ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨dpè½¬ç§» T2 ARC111F Do you like query problems? é¦–å…ˆå¯ä»¥å°†å’Œå»è½¬æ¢æˆæœŸæœ›ï¼Œ æœ€åç­”æ¡ˆä¹˜ä¸Šæ–¹æ¡ˆæ•°ï¼Œ æ¯æ¬¡æ“ä½œå¯¹ç­”æ¡ˆçš„å½±å“å…¶å®å°±æ˜¯ 12m+1E(âˆ‘i=lrai,j)\\frac{1}{2 m + 1} E(\\sum_{i = l} ^ r a_{i, j}) 2m+11â€‹E(i=lâˆ‘râ€‹ai,jâ€‹) æ±‚çš„å°±æ˜¯å¯¹åº”çš„qqqæ¬¡æ±‚å’Œï¼Œç”±äºæœŸæœ›æ˜¯çº¿æ€§çš„å¯ä»¥å¯¹æ¯ä¸ªaia_iaiâ€‹å•ç‹¬è®¡ç®—è´¡çŒ®ï¼Œ âˆ‘j=1q12m+1E(âˆ‘i=lrai,j)=âˆ‘j=1q12m+1âˆ‘i=1ni(nâˆ’i+1)n(n+1)2E(ai,j)\\begin{aligned} \\sum_{j = 1} ^ q \\frac{1}{2 m + 1} E(\\sum_{i = l} ^ r a_{i, j}) &amp; = \\sum_{j = 1} ^ q \\frac{1}{2 m + 1} \\sum_{i = 1} ^ n \\frac{i (n - i + 1)}{\\frac{n (n + 1)}{2}} E(a_{i, j}) \\end{aligned} j=1âˆ‘qâ€‹2m+11â€‹E(i=lâˆ‘râ€‹ai,jâ€‹)â€‹=j=1âˆ‘qâ€‹2m+11â€‹i=1âˆ‘nâ€‹2n(n+1)â€‹i(nâˆ’i+1)â€‹E(ai,jâ€‹)â€‹ ç„¶ååŒ–ç®€å¼å­å³å¯å¾—åˆ°ç­”æ¡ˆä¸º mâˆ’1n(n+1)(2m+1)âˆ‘i=1ni(nâˆ’i+1)âˆ‘j=1q(1âˆ’(1âˆ’Pi)jâˆ’1)\\frac{m - 1} { n(n + 1)(2 m + 1)} \\sum_{i = 1} ^ n i(n - i + 1)\\sum_{j = 1} ^ q (1 - (1 - P_i)^ {j - 1}) n(n+1)(2m+1)mâˆ’1â€‹i=1âˆ‘nâ€‹i(nâˆ’i+1)j=1âˆ‘qâ€‹(1âˆ’(1âˆ’Piâ€‹)jâˆ’1) T3 ARC120E 1D Party é¦–å…ˆå¯¹äºæ¯ä¸ªç‚¹çš„è¿åŠ¨è¿‡ç¨‹å¯ä»¥ç”»æˆå›¾åƒï¼š ä¸åŒé¢œè‰²ä»£è¡¨ä¸åŒçš„è·¯å¾„å…¶å®å¯¹åº”çš„ç­”æ¡ˆå°±æ˜¯æœ€é«˜ç‚¹ï¼Œç„¶åå°†å…¶è½¬åŒ–ä¸ºè‹¥å¹²ä¸ªä¸‰è§’å½¢ ç„¶åå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªO(n2)O(n ^ 2)O(n2)çš„è½¬ç§»æ–¹ç¨‹ï¼š fi=minâ¡j=1iâˆ’2(maxâ¡(fj,aiâˆ’ajâˆ’12))f_i= \\min_{j= 1} ^ {i - 2} (\\max(f_j, \\frac{a_i - a_{j - 1}}{2})) fiâ€‹=j=1miniâˆ’2â€‹(max(fjâ€‹,2aiâ€‹âˆ’ajâˆ’1â€‹â€‹)) è€ƒè™‘ä¼˜åŒ–è½¬ç§»ï¼Œå…¶å®ä¸Šè¿°æ–¹ç¨‹æšä¸¾äº†è®¸å¤šæ— ç”¨çŠ¶æ€ï¼Œæ‰‹ç©å¯çŸ¥ï¼Œ åªéœ€è¦ä»æœ‰444ä¸ªç‚¹çš„ä¸‰è§’å½¢å’Œ555ä¸ªç‚¹çš„ä¸‰è§’å½¢è½¬ç§»è¿‡æ¥å°±è¡Œäº†ï¼Œ æ›´å¤šçš„ç‚¹çš„ä¸‰è§’å½¢å…¶å®å¯ä»¥æ‹†æˆ444ä¸ªç‚¹å’Œ555ä¸ªç‚¹çš„ã€‚ ç„¶åæ–¹ç¨‹å°±è½¬åŒ–ä¸ºäº† fi=minâ¡(maxâ¡(fiâˆ’2,aiâˆ’aiâˆ’32),maxâ¡(fiâˆ’3,aiâˆ’aiâˆ’42))f_i = \\min(\\max(f_{i - 2}, \\frac{a_i - a_{i - 3}}{2}),\\max(f_{i -3}, \\frac{a_i - a_{i -4}}{2})) fiâ€‹=min(max(fiâˆ’2â€‹,2aiâ€‹âˆ’aiâˆ’3â€‹â€‹),max(fiâˆ’3â€‹,2aiâ€‹âˆ’aiâˆ’4â€‹â€‹)) æ—¶é—´å¤æ‚åº¦O(n)O(n)O(n)ã€‚ Test 3 T1 å¯¼å‡ºå­å›¾ çŠ¶å‹dpå³å¯ T2 ARC135 F Delete 1, 4, 7, â€¦ è®¾f(i)=âŒŠ3i+12âŒ‹f(i) =\\lfloor \\frac{3i + 1}{2} \\rfloorf(i)=âŒŠ23i+1â€‹âŒ‹ï¼Œ é‚£ä¹ˆf(i)f(i)f(i)å…¶å®å°±æ˜¯ç¬¬ä¸€æ¬¡æ“ä½œåç¬¬iiiä¸ªä½ç½®çš„æ•°ï¼Œ è®¾ç¬¬kkkæ¬¡æ“ä½œåä½ç½®iiiä¸ºfk(i)f^k(i)fk(i)ï¼Œ ç„¶åæœ‰ fk(n+2k)=fkn+3kf^k(n + 2 ^ k) = f^k n + 3 ^ k fk(n+2k)=fkn+3k æ•°å­¦å½’çº³æ³•å¯è¯ï¼Œç„¶åé¢„å¤„ç†è¿›è¡ŒäºŒè¿›åˆ¶æ‹†åˆ†å³å¯åšåˆ°O(2ylogâ¡n+2xk)O(2^y \\log n + 2^x k)O(2ylogn+2xk)çš„æ—¶é—´å¤æ‚åº¦ã€‚ T3 ARC 138 D Priority Queue é¦–å…ˆæŠŠæ‰€æœ‰å¯èƒ½çš„æœ€ç»ˆé›†åˆæ’åºå¹¶æ‰¾åˆ°å­—å…¸åºï¼Œ æœ€å¤§çš„ï¼Œæ˜¾ç„¶å°±æ˜¯è´ªå¿ƒçš„å­å•Šç¬¬iiiæ¬¡æ’å…¥æ—¶æ’å…¥iiiå³å¯ï¼Œç„¶åå°±å¯ä»¥è®¾å‡ºä¸€ä¸ªO(n2)O(n ^ 2)O(n2)çš„dp,çŠ¶å‹ä¸€ä¸‹å³å¯ã€‚ Test 4 T1 å½’å¹¶ å…¶å®æ ¹æ®é¢˜æ„ä¸éš¾å‘ç°ï¼Œæ¯”è¾ƒæ—¶å¯¹äºè¿™ä¸¤æ®µåŒºé—´çš„æœ€å¤§å€¼æ˜¯é€’å¢çš„ï¼Œ æ’å…¥çš„åŒºé—´æ˜¯è¿ç»­çš„ï¼Œå¯ä»¥å»ºä¸€æ£µå¹³è¡¡æ ‘ï¼Œä¿®æ”¹æ—¶æ¯”è¾ƒä¸¤æ®µçš„å½“å‰æœ€å¤§å€¼å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯å‡æ‘Šçš„å¯ä»¥é€šè¿‡æ­¤é¢˜ã€‚ T2 ARC112E Cigar Box é¦–å…ˆè€ƒè™‘æ¯ä¸€æ¬¡æ“ä½œåªæœ‰æœ€åä¸€æ¬¡æ“ä½œæ‰æ˜¯æœ‰æ„ä¹‰çš„ï¼Œé¦–å…ˆè€ƒè™‘ä¸€ä¸ªé•¿åº¦ä¸ºkkkçš„æ“ä½œåºåˆ—ï¼Œ å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯(mk)\\dbinom{m}{k}(kmâ€‹)ï¼Œå†åŠ ä¸Šæ”¾çš„æ–¹å‘ä¸º(mk)2mâˆ’k\\dbinom{m}{k} 2 ^ {m - k}(kmâ€‹)2mâˆ’k,å†å»è€ƒè™‘é€’å¢åŒºé—´ä½œä¸ºåˆæ³•åŒºé—´çš„å½±å“ï¼Œ ç­”æ¡ˆå³ä¸º âˆ‘i=0f(i)(mi)2mâˆ’i\\sum _ {i = 0} f(i) \\dbinom{m}{i} 2 ^ {m - i} i=0âˆ‘â€‹f(i)(imâ€‹)2mâˆ’i T3 ARC120F Wine Thief å®šä¹‰f(n,k)f(n, k)f(n,k)ä¸ºåœ¨ä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„ç¯å†…å–kkkä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œg(n,k)g(n, k)g(n,k)ä¸ºåœ¨é•¿åº¦ä¸ºnnnçš„æ•°ç»„å†…å–kkkä¸ªæ•°çš„æ–¹æ¡ˆæ•°ï¼Œä¸éš¾å¾—å‡ºg(n,k)=(nâˆ’k+1k)g(n, k) = \\dbinom{n - k + 1}{k}g(n,k)=(knâˆ’k+1â€‹),f(n,k)=g(nâˆ’1,k)+g(nâˆ’3,kâˆ’1)f(n, k) = g(n - 1, k) + g(n - 3, k - 1)f(n,k)=g(nâˆ’1,k)+g(nâˆ’3,kâˆ’1)ï¼Œ ç»Ÿè®¡å‡ºç°æ¬¡æ•°è®¡ç®—ç­”æ¡ˆå³å¯ã€‚ 2022-9-27 Test 1 T1 ç‰›å ¡çš„åå­—è·¯å£ æ–œç‡ä¼˜åŒ–dp T2 CF1109E Sasha and a Very Easy Test å…¶å®å°±æ˜¯ç”¨æ•°æ®ç»“æ„ç»´æŠ¤ä»»æ„æ¨¡æ•°çš„åŒºé—´ä¹˜ï¼Œå•ç‚¹é™¤ï¼Œ åŒºé—´æ±‚å’Œï¼Œé¦–å…ˆè§‚å¯Ÿæ•°æ®èŒƒå›´ï¼Œæ¯ä¸ªæ•°è´¨å› æ•°åˆ†è§£åï¼Œè´¨å› æ•°çš„ä¸ªæ•°ä¸ä¼šè¶…è¿‡101010ä¸ªåœ¨è¿›è¡Œé™¤çš„æ—¶å€™ï¼Œç”±äºé¢˜ç›®ä¸­æ»¡è¶³ä¸€å®šå¯ä»¥æ•´é™¤ï¼Œå–æ¨¡æ—¶æŠŠæ•°æ‹†æˆä¸æ¨¡æ•°äº’è´¨å’Œä¸äº’è´¨çš„éƒ¨åˆ†ï¼Œç„¶åäº’è´¨çš„éƒ¨åˆ†ï¼Œ ä¹‹é—´æ±‚é€†å…ƒï¼Œ ä¸äº’è´¨çš„éƒ¨åˆ†å°±å»å¯¹è´¨å› å­è¿›è¡Œå‡æ“ä½œï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚ T3 ARC087F Squirrel Migration é¦–å…ˆè€ƒè™‘ä»€ä¹ˆæ ·çš„æ’åˆ—èƒ½å¤Ÿä½¿æƒå€¼æœ€å¤§ã€‚ è€ƒè™‘æƒå€¼ä¸Šç•Œï¼š å¯¹äºæ¯ä¸€æ¡è¾¹ï¼Œå¦‚æœæŠŠå®ƒåˆ‡æ‰åˆ™æ ‘ä¼šåˆ†æˆS1S_1S1â€‹ å’Œ S2S_2S2â€‹ ä¸¤ä¸ªè”é€šå—ï¼Œä¸å¦¨ è®¾âˆ£S1âˆ£â‰¤âˆ£S2âˆ£|S_1|\\le |S_2|âˆ£S1â€‹âˆ£â‰¤âˆ£S2â€‹âˆ£ã€‚ é‚£ä¹ˆè¿™ä¸€æ¡è¾¹æ˜¾ç„¶æœ€å¤šè¢«ç»è¿‡ 2âˆ£S1âˆ£2|S_1|2âˆ£S1â€‹âˆ£ æ¬¡ã€‚ æ­¤æ—¶ï¼Œâˆ€uâˆˆS1,puâˆˆS2\\forall u\\in S_1,p_u\\in S_2âˆ€uâˆˆS1â€‹,puâ€‹âˆˆS2â€‹ã€‚ è€ƒè™‘å°†é‡å¿ƒ GGG æ‹‰å‡ºæ¥ä½œä¸ºæ ¹ã€‚å¦‚æœå­˜åœ¨å¤šä¸ªé‡å¿ƒåˆ™éšä¾¿é€‰ä¸€ä¸ªå³å¯ã€‚ é‚£ä¹ˆç°åœ¨æ¯ä¸€ä¸ª S1S_1S1â€‹ ä¸€å®šæ˜¯ä¸€æ£µå­æ ‘ã€‚ å®¹æ˜“å‘ç°ï¼Œä½¿å¾—æƒå€¼æœ€å¤§çš„ç­‰ä»·æ¡ä»¶ä¸º âˆ€(G,v),uâˆˆsubtree(v),puâˆ‰subree(v)\\forall (G,v),u\\in subtree(v),p_u\\notin subree(v)âˆ€(G,v),uâˆˆsubtree(v),puâ€‹âˆˆ/â€‹subree(v)ã€‚ æœ‰äº†è¿™ä¸ªç»“è®ºï¼Œå°±å®¹æ˜“ä½¿ç”¨å®¹æ–¥æ±‚ç­”æ¡ˆäº†ã€‚ fif_ifiâ€‹ è¡¨ç¤ºé’¦å®š iii ä¸ªç‚¹ä¸æ»¡è¶³æ¡ä»¶ï¼Œå‰©ä¸‹ç‚¹ä»»æ„çš„æ–¹æ¡ˆæ•°ã€‚ åˆ™ Ans=âˆ‘(âˆ’1)ifi(nâˆ’i)!Ans=\\sum (-1)^if_i(n-i)!Ans=âˆ‘(âˆ’1)ifiâ€‹(nâˆ’i)! å•ç‹¬è€ƒè™‘æ¯ä¸€ä¸ª(G,v)(G,v)(G,v) çš„ subtree(v)subtree(v)subtree(v)ï¼Œè®¾å…¶å¤§å°ä¸º xxxã€‚ å®¹æ˜“å¾—åˆ°è¿™ä¸ªå­æ ‘ä¸­fi=(xi)2i!f_i=\\binom{x}{i}^2i!fiâ€‹=(ixâ€‹)2i!ã€‚ æœ€ç»ˆçš„ fff æŠŠæ‰€æœ‰çš„å­æ ‘ä½¿ç”¨èƒŒåŒ…åˆå¹¶èµ·æ¥å³å¯ï¼Œå¤æ‚åº¦ O(n2)O(n^2)O(n2)ã€‚ 2022-9-30 Test 1 T1 ä¼šè®®é€‰å€ é¦–å…ˆï¼Œ ä¸€ä¸ªç‚¹åœ¨ä¸€æ¡é“¾ä¸ŠåŠ¨çš„æ—¶å€™ï¼Œ dis(u,i)dis(u,i)dis(u,i)ä¸ºä¸€ä¸ªå‡¸å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨æ ‘åˆ†æ²»åŠ é€Ÿï¼Œ ä¸‰åº¦åŒ–å¹³è¡¡æ—¶é—´å¤æ‚åº¦ã€‚ T2 CF618G Combining Slimes å¯ä»¥æ ¹æ®æœŸæœ›çš„çº¿æ€§æ€§å¯¹æ¯ä¸ªæ•°åˆ†åˆ«ç»Ÿè®¡è´¡çŒ®ï¼Œè®¾æ¯ä¸ªæ ¼å­ä½¿å¾—jjjè‡³å°‘å‡ºç°ä¸€æ¬¡çš„æ¦‚ç‡ä¸ºci,jc_{i, j}ci,jâ€‹ï¼Œç„¶åå°±å¯ä»¥å¾—åˆ°è½¬ç§»ä¸º ci,j=ciâˆ’1,jâˆ’1Ã—ci,jâˆ’1c_{i,j} = c_{i-1, j - 1} \\times c_{i, j - 1} ci,jâ€‹=ciâˆ’1,jâˆ’1â€‹Ã—ci,jâˆ’1â€‹ å†è®¾Ci,jC_{i,j}Ci,jâ€‹è¡¨ç¤ºä½¿ç”¨iiiä¸ªå„è‡ªæ°å¥½å‡ºç°ä¸€æ¬¡jjjçš„æ¦‚ç‡ Ci,j=ci,hÃ—(1âˆ’ciâˆ’1,j)C_{i, j} = c_{i,h} \\times (1 - c_{i- 1, j}) Ci,jâ€‹=ci,hâ€‹Ã—(1âˆ’ciâˆ’1,jâ€‹) æœ€ç»ˆçš„è½¬ç§»æ–¹ç¨‹fi,jf_{i,j}fi,jâ€‹å³ä¸º fi,j=j+âˆ‘k=1jâˆ’1fiâˆ’1,kÃ—Ciâˆ’1,kâˆ‘k=1jâˆ’1Ciâˆ’1,kf_{i,j} = j + \\frac{\\sum_{k = 1} ^ {j - 1} f_{i - 1, k} \\times C_{i -1, k}}{\\sum _{k = 1} ^ {j - 1} C_{i - 1, k}} fi,jâ€‹=j+âˆ‘k=1jâˆ’1â€‹Ciâˆ’1,kâ€‹âˆ‘k=1jâˆ’1â€‹fiâˆ’1,kâ€‹Ã—Ciâˆ’1,kâ€‹â€‹ åªå¤„ç†å‰50é¡¹å³å¯ï¼ŒçŸ©ä¹˜ã€‚ T3 CF1609G A Stroll Around the Matrix ç”±äºa,ba, ba,bçš„å·®åˆ†æ•°åˆ—å‡ä¸ºå•è°ƒé€’å¢çš„ï¼Œå¯ä»¥è¯æ˜æ¯æ¬¡é€‰å·®åˆ†å€¼å°çš„èµ°ä¼šæœ€ä¼˜ï¼Œå†è€ƒè™‘æ¯ä¸ªå·®åˆ†å€¼çš„è´¡çŒ®ï¼Œ è´¡çŒ®å³ä¸º âˆ‘i=1n+mâˆ’2diÃ—(n+mâˆ’iâˆ’1)\\sum_{i = 1} ^ {n + m - 2} d_i \\times (n + m -i - 1) i=1âˆ‘n+mâˆ’2â€‹diâ€‹Ã—(n+mâˆ’iâˆ’1) æœ€åè¦åŠ ä¸Š(a[1]+b[1])Ã—(n+mâˆ’1)(a[1] + b[1]) \\times(n + m - 1)(a[1]+b[1])Ã—(n+mâˆ’1)å³ä¸ºç­”æ¡ˆã€‚ æ³¨æ„åˆ°nâ‰¤100n \\le 100nâ‰¤100ï¼Œ å¯ä»¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤bbbï¼Œ æš´åŠ›æ›´æ”¹aaaï¼Œæ¯æ¬¡å¯¹å·®åˆ†å€¼æ’åºï¼Œ å¯¹äºæ¯ä¸ªaia_iaiâ€‹åœ¨bbbçš„çº¿æ®µæ ‘ä¸ŠäºŒåˆ†å³å¯ã€‚ 2022-10-3 Test 1 T1 P3616 å¯Œé‡‘æ£®æ—å…¬å›­ è§‚å¯Ÿé¢˜ç›®å…¶å®æ˜¯åœ¨æ±‚å¯¹äºæ¯ä¸€ä¸ªè¯¢é—®çš„é«˜åº¦xxxï¼Œ æ±‚æ»¡è¶³hiâˆ’1&lt;xâ‰¤hih _ {i - 1} &lt; x \\le h_ihiâˆ’1â€‹&lt;xâ‰¤hiâ€‹çš„ä¸ªæ•°ï¼Œçº¿æ®µæ ‘åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢å³å¯ã€‚ T2 åŒºé—´æ’åº å¦‚æœæ’å®Œåºæƒ³è¦ç›¸åŒçš„è¯,é‚£ä¹ˆ maxâˆ’min+1=râˆ’l+1âˆ’xmax-min+1=r-l+1-xmaxâˆ’min+1=râˆ’l+1âˆ’xï¼ˆxxxæ˜¯åŒºé—´ä¸æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°çš„æ•°) åŒ–ç®€å¾— maxâˆ’min+x+l=rmax-min+x+l=rmaxâˆ’min+x+l=rä»åå¾€å³æ‰«,maxminmax minmaxmin ä½¿ç”¨å•è°ƒæ ˆç»´æŠ¤,xxxç”¨ä¸ªmapmapmapè®°å½•ä¸Šæ¬¡å‡ºç°ä½ç½®,læ˜¯å®šå€¼å³å¯,å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn)ã€‚ 2022-10-5 Test 1 T1 å°Kçš„å¤–æŒ‚ è®¾fif_ifiâ€‹ä¸ºå‘å·¦èµ°å†å‘å³è·³çš„æœ€å¤§å€¼ï¼Œgig_igiâ€‹ä¸ºæ¬¡å¤§å€¼ï¼Œ æ¯æ¬¡è·³çš„æ—¶å€™ï¼Œå¦‚æœé‡åˆ°æ ‡è®°çš„å°±å»è·³æ¬¡å¤§å€¼ï¼Œå¦åˆ™è·³æœ€å¤§å€¼ï¼Œå€å¢å³å¯ã€‚ T2 å°Zçš„ä½œä¸š è®¾fif_ifiâ€‹è¡¨ç¤ºä»¥iiiä¸ºå·¦ç«¯ç‚¹ï¼Œèƒ½æ»¡è¶³æ¡ä»¶çš„å³ç«¯ç‚¹çš„æœ€å°å€¼ï¼Œä¸éš¾å‘ç°fif_ifiâ€‹æ˜¯å•è°ƒé€’å¢çš„å¯ä»¥å€’ç€åŠ è¾¹ï¼ŒLCTç»´æŠ¤å»æ›´æ–°fif_ifiâ€‹ï¼ŒæŸ¥è¯¢æ˜¯O(1)O(1)O(1)çš„ï¼Œ ç”¨LCTç»´æŠ¤æ—¶å¼€ä¸€ä¸ªsetæ¥ç»´æŠ¤åŠ å…¥çš„èƒ½ä»¥è®©è”é€šå—å‡å°‘çš„è¾¹ï¼Œå½“åŠ å…¥è¾¹æ—¶å¦‚æœä¸¤ç‚¹å·²ç»è”é€šï¼Œå°±å»åˆ å»ä¸¤ç‚¹è·¯å¾„ä¸Šçš„ç¼–å·æœ€å¤§çš„è¾¹ï¼Œ æ€»ä½“æŠŠè¾¹å½“æˆç‚¹å»ºè¾¹å³å¯ã€‚ 2022-10-8 Test 1 T1 åˆ†ç»„ è€ƒè™‘è´ªå¿ƒå°†æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å€’è¿‡æ¥å»ºä¸€æ£µtrieæ ‘ï¼Œç„¶ååœ¨æ ‘ä¸Šè´ªå¿ƒå³å¯ã€‚ T2 ARC136E Non-coprime DAG ä»¤f(x)f(x)f(x)ä¸ºxxxçš„æœ€å°è´¨å› å­ï¼Œè€ƒè™‘xxxå¯ä»¥åˆ°è¾¾yyyçš„æ¡ä»¶ï¼ŒæŒ‰ç…§å¥‡å¶æ€§åˆ†ç±»ï¼š 2âˆ£x,2âˆ£y2 \\mid x, 2 \\mid y2âˆ£x,2âˆ£yï¼Œ xxxè‚¯å®šå¯ä»¥åˆ°è¾¾yyy 2âˆ£Ì¸x,2âˆ£y2 \\not \\mid x, 2 \\mid y2î€ â€‹âˆ£x,2âˆ£yï¼Œ x+f(x)â‰¤yx + f(x) \\le yx+f(x)â‰¤y 2âˆ£x,2âˆ£Ì¸y2 \\mid x, 2 \\not \\mid y2âˆ£x,2î€ â€‹âˆ£yï¼Œ2â‰¤yâˆ’f(y)2 \\le y - f(y)2â‰¤yâˆ’f(y) 2âˆ£Ì¸x,2âˆ£Ì¸y2 \\not \\mid x, 2 \\not \\mid y2î€ â€‹âˆ£x,2î€ â€‹âˆ£yï¼Œx+f(x)â‰¤yâˆ’f(y)x + f(x) \\le y - f(y)x+f(x)â‰¤yâˆ’f(y) ç„¶åè€ƒè™‘å¯¹åº”çš„è´¡çŒ®åŒºé—´ä¸º[xâˆ’f(x)+1ï¼Œn+f(x)âˆ’1][x - f(x) + 1ï¼Œn + f(x) - 1][xâˆ’f(x)+1ï¼Œn+f(x)âˆ’1]ï¼Œç„¶åå·®åˆ†å‰ç¼€å’Œå–maxâ¡\\maxmaxå³å¯ã€‚ T3 ç¾å¥½çš„æ¯ä¸€å¤©~ä¸è¿ç»­çš„å­˜åœ¨ æˆ‘çš„è¯„ä»·æ˜¯å¬è¯´galæŒºå¥½ç©ï¼Œå»ºè®®å»ç©ã€‚ Test 2 T1 å°Dçš„åºåˆ— å¯ä»¥ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼åˆ¤æ–­ã€‚ T2 å°Sæ’åº§ä½ è´ªå¿ƒå‰ç¼€åç¼€å³å¯ã€‚ Test 3 T1 sequence ä¸»å¸­æ ‘äºŒåˆ†ã€‚ T2 è®­ç»ƒ(train) åŒºé—´dpã€‚ T3 ç³–æœ(candy) è´ªå¿ƒï¼Œå…¶å®å°±åƒæ˜¯ä¸€ä¸ªäºŒåˆ†å›¾åŒ¹é…ï¼Œ å…ˆé¢„å¤„ç†å‡ºåœ¨æ¯ä¸ªç‚¹å¯ä»¥é€‰çš„ç¬¦åˆè¦æ±‚çš„ç‚¹ï¼Œç„¶åå†å¤„ç†å¯¹åº”çš„ç‚¹é›†ï¼Œ é€‰çš„æ—¶å€™ï¼Œé€‰ç‚¹é›†å¤§å°å°çš„ï¼Œå°±åƒä¸€ä¸ªäºŒåˆ†å›¾åŒ¹é…çš„è¿‡ç¨‹ã€‚ T4 é—è¿¹(ruin) ç»„åˆæ•°å­¦ + dpã€‚ Test 3 T1 é¢˜ç›® æŠ˜åŠæœç´¢å³å¯ã€‚ T2 åå­— æ®æœŸæœ›çº¿æ€§æ€§ï¼Œè¯¢é—®çš„ç­”æ¡ˆå°±æ˜¯ E(dep(u))+E(dep(v))âˆ’2Ã—E(dep(lca(u,v)))E(dep(u))+E(dep(v))âˆ’2Ã—E(dep(lca(u,v)))E(dep(u))+E(dep(v))âˆ’2Ã—E(dep(lca(u,v)))ã€‚ E(dep(u))E(dep(u))E(dep(u))å¾ˆå¥½æ±‚ï¼Œç›´æ¥æšä¸¾uuu çš„çˆ¶äº²æ˜¯è°å°±è¡Œ è®¾ u&lt;vu&lt;vu&lt;våˆ™ E(dep(lca(u,v)))E(dep(lca(u,v)))E(dep(lca(u,v)))åªè·Ÿ uuuæœ‰å…³ï¼Œè¯æ˜å³è€ƒè™‘ vvv ä¸€ç›´å‘ä¸Šè·³ï¼Œè·³åˆ°ç¬¬ä¸€ä¸ªç¼–å· â‰¤uâ‰¤uâ‰¤uçš„ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹ä»¥æ­£æ¯”äº aaa çš„æ¦‚ç‡åœ¨ [1,u][1,u][1,u]ä¸­éšæœºã€‚ å¦‚æœè·³åˆ°äº† uuuï¼Œé‚£ä¹ˆæœŸæœ›æ·±åº¦å°±æ˜¯ E(dep(u))E(dep(u))E(dep(u))åˆ™è®¾è·³åˆ°çš„ç‚¹æ˜¯ x(x&lt;u)x(x&lt;u)x(x&lt;u)æœŸæœ›æ·±åº¦å°±æ˜¯ E(dep(lca(x,u)))E(dep(lca(x,u)))E(dep(lca(x,u)))ï¼Œè¿™åªä¸xxxæœ‰å…³ï¼Œç”¨ç±»ä¼¼ä¸Šé¢çš„æ–¹æ³•é€’æ¨å°±è¡Œã€‚ æ—¶é—´å¤æ‚åº¦ O(nlogmod+q)O(nlogmod+q)O(nlogmod+q)ï¼Œå¯ä»¥ç¦»çº¿æ±‚é€†å…ƒåšåˆ° O(n+logmod+q)O(n+logmod+q)O(n+logmod+q)ã€‚ 2022-10-17 Test 1 T1 CF311B Cats Transport å¯¹äºæ¯ä¸€åªçŒ«å¯ä»¥è®¡ç®—å‡ºä½•æ—¶å‡ºå‘çš„äººå¯ä»¥æ­£å¥½æ¥èµ°å®ƒã€‚ å¦‚æ­¤å¾—åˆ°ä¸€ä¸ªé•¿ mmm çš„æ—¶é—´æ•°ç»„ tttï¼Œå°†å®ƒä»å°åˆ°å¤§æ’åºã€‚ é¢˜æ„å˜ä¸ºï¼šæŠŠæ•°ç»„åˆ†ä¸ºpppæ®µï¼Œæ¯æ®µçš„ä»£ä»·æ˜¯æ‰€æœ‰æ•°ä¸è¯¥æ®µæœ€å¤§å€¼çš„å·®å€¼ä¹‹å’Œã€‚æ±‚æœ€å°ä»£ä»·ã€‚ ä»¤SSS æ•°ç»„ä¸ºtttæ•°ç»„çš„å‰ç¼€å’Œã€‚ æ‰€æ±‚å³ä¸º fi,j=minâ¡k=0jâˆ’1{fiâˆ’1,k+tjÃ—(jâˆ’k)âˆ’Sj+Sk}f_{i, j} = \\min_{k = 0} ^ {j - 1} \\{ f_{i - 1, k} + t_j \\times (j - k) - S_j + S_k \\} fi,jâ€‹=k=0minjâˆ’1â€‹{fiâˆ’1,kâ€‹+tjâ€‹Ã—(jâˆ’k)âˆ’Sjâ€‹+Skâ€‹} ç„¶åæ–œç‡ä¼˜åŒ–å³å¯ã€‚ T2 CF1553F Pairwise Modulo é¦–å…ˆå…ˆå°†ç­”æ¡ˆæ‹†æˆä¸¤éƒ¨åˆ†è®¡ç®—ï¼Œç„¶åå¯¹äºæ¯ä¸€éƒ¨åˆ†ï¼Œè€ƒè™‘ç›´æ¥æš´åŠ›æšä¸¾ï¼Œ ç”±äºaia_iaiâ€‹äº’ä¸ç›¸åŒï¼Œæ—¶é—´å¤æ‚åº¦å‡æ‘Šä¸‹æ¥æ˜¯nlogâ¡mn \\log mnlogmçš„ï¼Œå¯ä»¥é€šè¿‡ã€‚ T3 CF1693D Decinc Dividing é¦–å…ˆè§‚å¯Ÿé¢˜ç›®ä¸éš¾å¾—å‡ºä¸€ä¸ªç»“è®ºé‚£å°±æ˜¯ï¼Œ å¯¹äºä¸€ä¸ªå­åŒºé—´[l,r][l, r][l,r]ï¼Œæœ‰è§£çš„å……è¦æ¡ä»¶æ˜¯ï¼Œ ä¸å­˜åœ¨lâ‰¤a&lt;b&lt;c&lt;dâ‰¤rl \\le a &lt; b &lt; c &lt; d \\le rlâ‰¤a&lt;b&lt;c&lt;dâ‰¤rï¼Œ ä½¿å¾—pb&gt;pa&gt;pd&gt;pcp_b &gt; p_a &gt; p_d &gt; p_cpbâ€‹&gt;paâ€‹&gt;pdâ€‹&gt;pcâ€‹æˆ–pb&lt;pa&lt;pd&lt;pcp_b &lt; p_a &lt; p_d &lt; p_cpbâ€‹&lt;paâ€‹&lt;pdâ€‹&lt;pcâ€‹ï¼Œç„¶åç›´æ¥ç”¨å•è°ƒæ ˆç»´æŠ¤å³å¯ã€‚ Test 2 T1 CF1396D Rainbow Rectangles ä¸å¦¨åè¿‡æ¥è€ƒè™‘ï¼Œå…ˆå¤„ç†å‡ºæœ€ç»ˆçš„ç­”æ¡ˆï¼Œç„¶åé€†ç€å¤„ç†ï¼Œæ¯æ¬¡åˆ é™¤ä¸€ä¸ªæ–°é¢œè‰² [prec,i][pre_c,i][precâ€‹,i]çš„ç­”æ¡ˆä¼šå–maxâ¡\\maxmaxï¼Œç„¶åæ¯æ¬¡æŸ¥è¯¢ä¸€æ¬¡å…¨å±€è´¡çŒ®å’Œã€‚æ˜¾ç„¶è¿™æ˜¯å¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘ç»´æŠ¤çš„ï¼Œç„¶è€Œç›´æ¥å– maxâ¡\\maxmax,ç”±äºf(l)f(l)f(l)æ˜¯å•è°ƒçš„å¯ä»¥ç›´æ¥å†™ä¸€ä¸ªçº¿æ®µæ ‘äºŒåˆ†æ‰¾åˆ°å¯¹åº”åŒºé—´ï¼Œ ç„¶åæ‰§è¡ŒåŒºé—´è¦†ç›–å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n2logâ¡n)O(n^2 \\log n)O(n2logn)ã€‚ T2 æœ€é•¿ä¸Šå‡è¿ç»­å­åºåˆ— ç›´æ¥æ„é€ å¤šé¡¹å¼æ±‚è§£ã€‚ T3 Die Siedler è€ƒè™‘è½¬åŒ–é—®é¢˜ï¼Œå°†æ¯ä¸ªä½ç½®çš„å¡ç‰Œè½¬ç§»åˆ°ç¬¬ä¸€ä¸ªä½ç½®ä¸Šæ¥ï¼Œé¦–å…ˆå¯¹äºè¿™ç§è½¬åŒ–æ–¹å¼å®¹æ˜“å¾—åˆ°å…¶å¾—åˆ°æ»¡è¶³è¦æ±‚çš„åºåˆ—æ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œæ˜¯ä¸åŸåºåˆ—æ˜¯ç­‰ä»·çš„ï¼ŒåŒæ—¶å¯¹äºæ¯ç§å¡åŒ…ï¼Œ ä¹Ÿç”¨ç›¸åŒçš„è½¬åŒ–æ–¹å¼ï¼Œç„¶åç›¸åŠ å‡çš„ç­”æ¡ˆå°±æ˜¯åŸåºåˆ—çš„ç­”æ¡ˆã€‚ å¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„åºåˆ—ï¼Œå…¶è½¬åŒ–å³ä¸º âˆ‘i=1nai2iâˆ’1(iâˆ’1)!\\sum_{i = 1} ^n a_i 2 ^ {i - 1} (i - 1) ! i=1âˆ‘nâ€‹aiâ€‹2iâˆ’1(iâˆ’1)! ç„¶åè€ƒè™‘å·²çŸ¥è¿™ç§è¡¨è¾¾æ–¹å¼å¦‚ä½•æ±‚è§£ï¼Œå…¶å®åªè¦è´ªå¿ƒå³å¯ï¼Œå»å€’ç€å¡«ï¼Œå¯¹äºç¬¬ä¸€ä¸ªä½ç½®çš„æ•°ï¼Œå…¶å¯ä»¥å‡å°‘è‹¥å¹²å€çš„2nn!âˆ’12 ^ n n! - 12nn!âˆ’1(è½¬åŒ–ä¸€å‘¨)ï¼Œ ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åæ‰€æœ‰å¡ç‰Œè½¬ä¸ºä¸ºç¬¬ä¸€ä¸ªä½ç½®çš„æ—¶å€™ï¼Œç­”æ¡ˆå¯ä»¥è¡¨ç¤ºä¸ºï¼Œ v=R+âˆ‘i=1nbixiâˆ’y(2nn!âˆ’1)v = R + \\sum_{i = 1} ^ n b_i x_i - y (2 ^ n n! - 1) v=R+i=1âˆ‘nâ€‹biâ€‹xiâ€‹âˆ’y(2nn!âˆ’1) è£´èœ€å®šç†è§£å‡ºå³å¯ï¼Œ ç„¶åè€ƒè™‘åˆ°æ•°æ®èŒƒå›´ï¼Œéœ€è¦ä½¿ç”¨æ ¹å·åˆ†æ²»ï¼Œå½“d&lt;2nn!d &lt; \\sqrt {2 ^ n n !}d&lt;2nn!â€‹æ—¶ï¼Œç›´æ¥æš´åŠ›æšä¸¾ï¼Œdâ‰¤2nn!d \\le \\sqrt {2 ^n n!}dâ‰¤2nn!â€‹æ—¶ï¼Œæ ¹æ®è½¬ç§»ï¼Œå¯ä»¥è·‘åŒä½™æœ€çŸ­è·¯ï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚ Test 3 T1 èŠ±ç¯ å“ˆå¸Œè§£å†³å³å¯ã€‚ T2 æœ€çŸ­æœ€é•¿æœ€çŸ­è·¯ å¯ä»¥æ ¹æ®ç«èµ›å›¾ä¸€ä¸ªç‚¹åˆ°å…¶ä»–ç‚¹çš„è·ç¦»ä¸è¶…è¿‡222çš„æ€§è´¨ï¼Œç›´æ¥å¾—å‡ºç­”æ¡ˆã€‚ T3 èŠ±ç¯ åŒºé—´dpè½¬ç§»å³å¯ã€‚ T4 äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é… æ ¹æ®æ›¼å“ˆé¡¿è·ç¦»çš„æ€§è´¨ï¼Œç›´æ¥å»ºå›¾å³å¯ã€‚ Test 4 T1 sequence KKKæ®µæ±‚å’Œçš„ gcdâ¡\\gcdgcd ç­‰äºKKKæ®µå³ç«¯ç‚¹å‰ç¼€å’Œçš„ gcdâ¡\\gcdgcd ä¹Ÿå°±æ˜¯æ±‚æœ€å¤§çš„æ•° xxx ä½¿å¾— xâˆ£sumNx|sum_Nxâˆ£sumNâ€‹ï¼Œä¸”æœ‰ Kâˆ’1Kâˆ’1Kâˆ’1 ä¸ª pppæ»¡è¶³ xâˆ£sumpx|sum_pxâˆ£sumpâ€‹ å¯ä»¥ O(N+Ïƒ1V)O(N+Ïƒ1V)O(N+Ïƒ1V) æ±‚å‡ºã€‚ T2 xor ç¬›å¡å°”æ ‘åˆ†æ²»è¿‡ç¨‹ä¸­0âˆ’10-10âˆ’1 trieå¯å‘å¼åˆå¹¶å³å¯ã€‚ T3 dawn çº¦ç‘Ÿå¤«ç¯ä¸Šçš„nimæ¸¸æˆã€‚ T4 nogirlfriend åç¼€æ•°ç»„åŠ å¹³è¡¡æ ‘ç»´æŠ¤ã€‚ Test 5 T1 brime ç›´æ¥ç­›ç´ æ•°ï¼Œæšä¸¾å³å¯ï¼Œå¤æ‚åº¦klnâ¡nk \\ln nklnnï¼Œkkkä¸ºè´¨æ•°ä¸ªæ•°ã€‚ T2 sequence dpçŸ©é˜µä¼˜åŒ–è½¬ç§»ã€‚ T3 iiidx çº¿æ®µæ ‘ç»´æŠ¤æœŸæœ›å€¼å³å¯ã€‚ T4 inception å¯¹äºæ¯æ¬¡è¯¢é—®å»ºè™šæ ‘ç„¶åï¼Œå¤§åŠ›åˆ†ç±»è®¨è®ºï¼Œå³å¯ã€‚ 2022-11-3 Test 1 T1 æ­£æ–¹å½¢ å¯ä»¥å…ˆå°†æ‰€æœ‰è¯¢é—®ä¸‹æ¥ï¼Œ ç„¶åé¢„å¤„ç†å‡ºä»¥æ¯ä¸ªç‚¹ä¸ºå³ä¸‹è§’çš„æœ€å¤§è¾¹é•¿ï¼Œæ’åºåï¼Œä»å¤§åˆ°å°ï¼Œä¾æ¬¡åŠ ç‚¹ç”¨å¹¶æŸ¥é›†ç»´æŠ¤è¿é€šæ€§å³å¯ã€‚ T2 è®¡æ•° å¯ä»¥ç”¨èŒƒå¾·è’™å¾·å·ç§¯ã€‚ 2022-11-10 Test 1 T1 GCDå’ŒLCM æ±‚çš„æŸ¿å­ä¸ºï¼Œ ans=âˆ‘i=1nâˆ‘j=1mlcm(i,j)[gcdâ¡(i,j)â‰¤k]=âˆ‘t=1kâˆ‘i=1nâˆ‘j=1mlcm(i,j)[gcdâ¡(i,j)=t]=âˆ‘t=1kâˆ‘i=1nâˆ‘j=1mijgcdâ¡(i,j)[gcdâ¡(i,j)=t]=âˆ‘t=1ktâˆ‘i=1âŒŠntâŒ‹âˆ‘j=1âŒŠmtâŒ‹ij[gcdâ¡(i,j)=1]=âˆ‘t=1ktâˆ‘i=1âŒŠntâŒ‹âˆ‘j=1âŒŠmtâŒ‹ijâˆ‘dâˆ£gcdâ¡(i,j)Î¼(d)=âˆ‘t=1ktâˆ‘d=1Î¼(d)d2âˆ‘i=1âŒŠntdâŒ‹âˆ‘j=1âŒŠmtdâŒ‹ij\\begin{aligned} \\\\ ans &amp;= \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m lcm(i,j) [\\gcd(i,j) \\le k]\\\\ &amp; = \\sum_{t = 1} ^k \\sum_{i = 1} ^ n\\sum_{j = 1} ^ m lcm(i, j) [\\gcd(i, j) = t] \\\\ &amp;= \\sum_{t = 1} ^ k \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\frac{ij}{\\gcd(i, j)}[\\gcd(i, j) = t] \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor} \\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} ij [\\gcd(i, j) = 1] \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor} \\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} ij \\sum_{d | \\gcd(i, j)} \\mu(d) \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{d = 1} \\mu(d) d^2 \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} ij \\\\ \\end{aligned} \\\\ ansâ€‹=i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹lcm(i,j)[gcd(i,j)â‰¤k]=t=1âˆ‘kâ€‹i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹lcm(i,j)[gcd(i,j)=t]=t=1âˆ‘kâ€‹i=1âˆ‘nâ€‹j=1âˆ‘mâ€‹gcd(i,j)ijâ€‹[gcd(i,j)=t]=t=1âˆ‘kâ€‹ti=1âˆ‘âŒŠtnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtmâ€‹âŒ‹â€‹ij[gcd(i,j)=1]=t=1âˆ‘kâ€‹ti=1âˆ‘âŒŠtnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtmâ€‹âŒ‹â€‹ijdâˆ£gcd(i,j)âˆ‘â€‹Î¼(d)=t=1âˆ‘kâ€‹td=1âˆ‘â€‹Î¼(d)d2i=1âˆ‘âŒŠtdnâ€‹âŒ‹â€‹j=1âˆ‘âŒŠtdmâ€‹âŒ‹â€‹ijâ€‹ è§‚å¯Ÿæ•°æ®èŒƒå›´ï¼Œéœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œè€ƒè™‘æšä¸¾tdtdtdï¼Œå¹¶å°†åé¢çš„æ±‚å’Œè®¾ä¸ºS(x)S(x)S(x)ï¼Œ ans=âˆ‘p=1S(âŒŠnpâŒ‹)S(âŒŠmpâŒ‹)âˆ‘1â‰¤dâ‰¤k,dâˆ£pp2dÎ¼(pd)ans = \\sum_{p = 1} S(\\lfloor \\frac{n}{p} \\rfloor) S(\\lfloor \\frac{m}{p} \\rfloor) \\sum_{1 \\le d \\le k, d|p} \\frac{p^2}{d} \\mu(\\frac{p}{d}) \\\\ ans=p=1âˆ‘â€‹S(âŒŠpnâ€‹âŒ‹)S(âŒŠpmâ€‹âŒ‹)1â‰¤dâ‰¤k,dâˆ£pâˆ‘â€‹dp2â€‹Î¼(dpâ€‹) ç„¶åå°†æ•°æ®ç¦»çº¿ä¸‹æ¥ï¼ŒæŒ‰ç…§kkkæ’åºåï¼Œæ¯æ¬¡ç§»åŠ¨ä¸Šç•Œç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å¯¹äºæ¯ä¸ªpppä¸‹çš„âˆ‘1â‰¤dâ‰¤k,dâˆ£pp2dÎ¼(pd)\\sum_{1 \\le d \\le k, d|p} \\frac{p^2}{d} \\mu(\\frac{p}{d})âˆ‘1â‰¤dâ‰¤k,dâˆ£pâ€‹dp2â€‹Î¼(dpâ€‹)ï¼Œæ¯ä¸ªç­”æ¡ˆæ±‚å’Œå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(qnlogâ¡n+nlogâ¡2n)O(q\\sqrt n \\log n + n \\log^2 n)O(qnâ€‹logn+nlog2n)ã€‚ T2 å¹³é¢å›¾ ç›´æ¥å¹³é¢å›¾è½¬å¯¹å¶å›¾ï¼Œå¯å‘å¼åˆ†è£‚å®Œäº‹äº†ã€‚ 2022-11-11 Test 1 T1 åºåˆ— ç›´æ¥è·‘DAGä¸Šçš„dpå³å¯ã€‚ T2 ç›´æ¥çŒœç»“è®ºï¼Œéšä¾¿è¯ä¸€è¯å°±å¯ä»¥å‘ç°ï¼Œå¯ä»¥å…ˆæŠŠæ ‘å¤„ç†å‡ºæ¥ï¼Œå¯¹äºéæ ‘è¾¹ä¸Šçš„æƒå€¼ï¼Œè¿›è¡Œæ ‘ä¸Šè·¯å¾„çš„æœ€å°å€¼è¦†ç›–å³å¯ã€‚ T3 é¦–å…ˆè§‚å¯Ÿåˆ°è´¨å› å­æ•°ä¼šå¾ˆå°‘ï¼Œç›´æ¥çŠ¶å‹DPå³å¯ã€‚ T4 è€ƒè™‘åŒ–ç®€æŸ¿å­ä¸ºï¼Œ maxâ¡{ai,iâˆˆ[l,r]}âˆ’minâ¡{ai,iâˆˆ[l,r]}â‰¤râˆ’l+k\\max\\{ a_i, i \\in [l, r] \\} - \\min\\{ a_i, i \\in [l, r] \\} \\le r - l + k max{aiâ€‹,iâˆˆ[l,r]}âˆ’min{aiâ€‹,iâˆˆ[l,r]}â‰¤râˆ’l+k æ¢ä¸€ä¸‹æŸ¿å­ç»´æŠ¤å³å¯ã€‚","link":"/2022/07/18/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/"},{"title":"ç‹„åˆ©å…‹é›·å·ç§¯ä¸è«æ¯”ä¹Œæ–¯åæ¼”","text":"ç‹„åˆ©å…‹é›·å·ç§¯ä¸è«æ¯”ä¹Œæ–¯åæ¼”è¯¦è§£ ç‹„åˆ©å…‹é›·å·ç§¯ä¸è«æ¯”ä¹Œæ–¯åæ¼” ç‹„åˆ©å…‹é›·å·ç§¯ å‰è¨€ ç‹„åˆ©å…‹é›·å·ç§¯(Dirichlet Convolution)ï¼Œåœ¨æ•°è®ºä¸­æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„å·¥å…·ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„ç”¨æ¥æ¨å‡ºè«æ¯”ä¹Œæ–¯åæ¼”(Mobius Inversion)çš„å…¬å¼ä»¥åŠé—®é¢˜ ğŸ¤” æ­£æ–‡ å®šä¹‰ ç‹„åˆ©å…‹é›·å·ç§¯æ˜¯å®šä¹‰åœ¨æ•°è®ºå‡½æ•°é—´çš„äºŒå…ƒè¿ç®—ã€‚ æ•°è®ºå‡½æ•°ï¼Œæ˜¯æŒ‡å®šä¹‰åŸŸä¸º N\\mathbb{N}N ï¼Œå€¼åŸŸä¸º C\\mathbb{C}C ï¼Œ çš„ä¸€ç±»å‡½æ•°ï¼Œæ¯ä¸ªæ•°è®ºå‡½æ•°å¯ä»¥è§†ä¸ºä¸€ä¸ªå¤æ•°çš„åºåˆ—ã€‚ å®šä¹‰å¼ä¸ºï¼š (fâˆ—g)(n)=âˆ‘dâˆ£nf(d)g(nd)(dâˆˆN)\\bigg(f \\ast g\\bigg) (n) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d}) (d \\in \\mathbb{N}) \\\\ (fâˆ—g)(n)=dâˆ£nâˆ‘â€‹f(d)g(dnâ€‹)(dâˆˆN) ä¹Ÿå¯ä»¥å†™ä¸º ï¼š (fâˆ—g)(n)=âˆ‘dâˆ£nf(nd)g(d)(dâˆˆN)\\bigg(f \\ast g\\bigg) (n) = \\sum_{d \\mid n} f(\\frac{n}{d})g(d) (d \\in \\mathbb{N}) (fâˆ—g)(n)=dâˆ£nâˆ‘â€‹f(dnâ€‹)g(d)(dâˆˆN) åŒæ—¶ç”±äºå¯¹ç§°æ€§ï¼Œåˆå¯ä»¥å†™ä¸º ï¼š (fâˆ—g)(n)=âˆ‘xy=nf(x)g(y)(x,yâˆˆN)\\bigg(f \\ast g\\bigg) (n) = \\sum_{xy=n} f(x)g(y) (x,y \\in \\mathbb{N}) (fâˆ—g)(n)=xy=nâˆ‘â€‹f(x)g(y)(x,yâˆˆN) â€œ+â€ å®šä¹‰ä¸ºäº†æ•°è®ºå‡½æ•°ç›´æ¥çš„ç›´æ¥ç›¸åŠ ï¼Œ &quot; âˆ—\\astâˆ— &quot;ï¼Œå…¶å®å°±æ˜¯ä¹˜ å¸¸è§çš„æ•°è®ºå‡½æ•° å•ä½å‡½æ•° Îµ(n)=[n=1]\\varepsilon (n) = \\left[ n=1 \\right] Îµ(n)=[n=1] å¹‚å‡½æ•° Idk(n)=nkId_k(n) = n^k Idkâ€‹(n)=nk çº¦æ•°å‡½æ•° Ïƒ(n)=âˆ‘dâˆ£ndk(dâˆˆN)\\sigma(n) = \\sum_{d \\mid n} d^k (d \\in \\mathbb{N}) Ïƒ(n)=dâˆ£nâˆ‘â€‹dk(dâˆˆN) æ¬§æ‹‰å‡½æ•° Ï†(n)\\varphi(n)Ï†(n) è¡¨ç¤º1 n1 ~ n1 nä¸­ä¸ nnn äº’è´¨çš„æ•´æ•°çš„ä¸ªæ•°æœ‰å¤šå°‘ä¸ª Ï†(n)=nâˆpâˆ£n(1âˆ’1p)(pâˆˆP)\\varphi (n) = n \\prod_{p|n}(1-\\frac{1}{p}) (p \\in \\mathbb{P}) Ï†(n)=npâˆ£nâˆâ€‹(1âˆ’p1â€‹)(pâˆˆP) ï¼ˆå®¹æ–¥å¯è¯ï¼‰ æœ‰è¶£çš„æ˜¯ä¸Šé¢æ‰€å†™çš„å‡½æ•°å‡ä¸ºç§¯æ€§å‡½æ•°ï¼Œå…¶ä¸­å•ä½å‡½æ•°å’Œå¹‚å‡½æ•°ä¸ºå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚ ç›¸å…³å®šç† è‹¥ fff ï¼Œ ggg ä¸ºç§¯æ€§å‡½æ•°ï¼Œåˆ™ fâˆ—gf \\ast gfâˆ—g ä¹Ÿä¸ºç§¯æ€§å‡½æ•° è¯æ˜ï¼š è®¾gcd(a,b)=1âˆ´(fâˆ—g)(a)â‹…(fâˆ—g)(b)=âˆ‘iâˆ£af(i)g(ai)â‹…âˆ‘jâˆ£bf(j)g(bj)=âˆ‘iâˆ£aâˆ‘jâˆ£bf(i)g(ai)â‹…f(j)g(bj)=âˆ‘dâˆ£abf(d)g(abd)=(fâˆ—g)(ab)ç”¨åˆ°äº†ç§¯æ€§å‡½æ•°çš„æ€§è´¨è®¾ gcd(a,b) =1 \\\\ \\begin{aligned} \\therefore \\bigg(f \\ast g\\bigg)(a) \\cdot (f \\ast g) (b) &amp;= \\sum_{i \\mid a} f(i) g(\\frac{a}{i}) \\cdot \\sum_{j \\mid b} f(j) g(\\frac{b}{j}) \\\\ &amp;= \\sum_{i \\mid a} \\sum_{j \\mid b} f(i) g(\\frac{a}{i}) \\cdot f(j) g(\\frac{b}{j}) \\\\ &amp;= \\sum_{d \\mid ab} f(d)g(\\frac{ab}{d}) \\\\ &amp;= (f \\ast g) (ab) \\\\ \\end{aligned}\\\\ ç”¨åˆ°äº†ç§¯æ€§å‡½æ•°çš„æ€§è´¨\\\\ è®¾gcd(a,b)=1âˆ´(fâˆ—g)(a)â‹…(fâˆ—g)(b)â€‹=iâˆ£aâˆ‘â€‹f(i)g(iaâ€‹)â‹…jâˆ£bâˆ‘â€‹f(j)g(jbâ€‹)=iâˆ£aâˆ‘â€‹jâˆ£bâˆ‘â€‹f(i)g(iaâ€‹)â‹…f(j)g(jbâ€‹)=dâˆ£abâˆ‘â€‹f(d)g(dabâ€‹)=(fâˆ—g)(ab)â€‹ç”¨åˆ°äº†ç§¯æ€§å‡½æ•°çš„æ€§è´¨ fâˆ—g=gâˆ—ff \\ast g = g \\ast f \\\\fâˆ—g=gâˆ—f è¯æ˜ ï¼š (fâˆ—g)(n)=âˆ‘ij=nf(i)g(j)=âˆ‘ji=nf(j)g(i)=(gâˆ—j)(n)\\begin{aligned} \\bigg(f \\ast g\\bigg)(n) &amp;= \\sum_{ij=n} f(i)g(j) \\\\ &amp;= \\sum_{ji=n} f(j)g(i) \\\\ &amp;= (g \\ast j) (n) \\end{aligned} (fâˆ—g)(n)â€‹=ij=nâˆ‘â€‹f(i)g(j)=ji=nâˆ‘â€‹f(j)g(i)=(gâˆ—j)(n)â€‹ å¯¹ç§°æ€§ã€‚ (fâˆ—g)âˆ—h=fâˆ—(gâˆ—h)(f \\ast g ) \\ast h = f \\ast (g \\ast h)(fâˆ—g)âˆ—h=fâˆ—(gâˆ—h) åˆ©ç”¨å¯¹ç§°æ€§çš„å¼å­å»æ‹†å¼€å³å¯å¾—è¯ã€‚ fâˆ—(g+h)=fâˆ—g+fâˆ—hf \\ast (g+h) = f \\ast g + f \\ast hfâˆ—(g+h)=fâˆ—g+fâˆ—h è¯æ˜ï¼š (fâˆ—(g+h))(n)=âˆ‘ij=nf(i)(g+h)(j)=âˆ‘ij=nf(i)[g(j)+h(j)]=âˆ‘ij=nf(i)g(j)+f(i)h(j)=âˆ‘ij=nf(i)g(j)+âˆ‘ij=nf(i)h(j)=(fâˆ—g+fâˆ—h)(n)\\begin{aligned} \\bigg(f \\ast (g + h )\\bigg) (n) &amp;= \\sum_{ij=n} f(i)\\bigg( g + h \\bigg)(j) \\\\ &amp;= \\sum_{ij=n} f(i)\\bigg[ g(j) + h(j) \\bigg] \\\\ &amp;= \\sum_{ij=n} f(i)g(j) + f(i)h(j) \\\\ &amp;= \\sum_{ij=n} f(i)g(j) + \\sum_{ij=n} f(i)h(j) \\\\ &amp;= \\bigg(f \\ast g + f \\ast h\\bigg) (n) \\end{aligned} (fâˆ—(g+h))(n)â€‹=ij=nâˆ‘â€‹f(i)(g+h)(j)=ij=nâˆ‘â€‹f(i)[g(j)+h(j)]=ij=nâˆ‘â€‹f(i)g(j)+f(i)h(j)=ij=nâˆ‘â€‹f(i)g(j)+ij=nâˆ‘â€‹f(i)h(j)=(fâˆ—g+fâˆ—h)(n)â€‹ ç‰¹æ®Šçš„å·ç§¯ Idkâˆ—1=Ïƒk Id_k \\ast 1 = \\sigma_k \\\\ Idkâ€‹âˆ—1=Ïƒkâ€‹ è¯æ˜ï¼š (Idkâˆ—1)(n)=âˆ‘dâˆ£nIdk(d)1(nd)=âˆ‘dâˆ£nIdk(d)=âˆ‘dâˆ£ndk=Ïƒ(n)\\begin{aligned} \\bigg( Id_k \\ast 1\\bigg) (n) &amp;= \\sum_{d \\mid n} Id_k (d) 1 (\\frac{n}{d}) \\\\ &amp;= \\sum_{d \\mid n} Id_k (d) \\\\ &amp;= \\sum_{d \\mid n} d^k \\\\ &amp;= \\sigma (n) \\end{aligned} (Idkâ€‹âˆ—1)(n)â€‹=dâˆ£nâˆ‘â€‹Idkâ€‹(d)1(dnâ€‹)=dâˆ£nâˆ‘â€‹Idkâ€‹(d)=dâˆ£nâˆ‘â€‹dk=Ïƒ(n)â€‹ åŒæ—¶å¯ä»¥å¾—åˆ°ä¸€ä¸ªåº”ç”¨å¹¿æ³›çš„å¼å­ ï¼š (fâˆ—1)(n)=âˆ‘dâˆ£nf(d)\\bigg( f \\ast 1 \\bigg) (n) = \\sum_{d \\mid n} f(d) (fâˆ—1)(n)=dâˆ£nâˆ‘â€‹f(d) Ï†âˆ—1=Id \\varphi \\ast 1 = Id Ï†âˆ—1=Id è¯æ˜ ï¼š âˆµ(Ï†âˆ—1)(n)=âˆ‘dâˆ£nÏ†(d)å°†næ‹†åˆ†ä¸ºâˆpkâˆ´(Ï†âˆ—1)(n)=(Ï†âˆ—1)(âˆpk)=âˆ(Ï†âˆ—1)(piki)=âˆâˆ‘j=1kiÏ†(pij)=âˆpiki=nâˆ´Ï†âˆ—1=Id\\because \\bigg( \\varphi \\ast 1 \\bigg)(n) = \\sum_{d \\mid n} \\varphi (d) \\\\ å°† n æ‹†åˆ†ä¸º \\prod p^k \\\\ \\begin{aligned} \\therefore \\bigg( \\varphi \\ast 1 \\bigg)(n) &amp;= \\bigg( \\varphi \\ast 1 \\bigg)(\\prod p^k) \\\\ &amp;= \\prod \\bigg( \\varphi \\ast 1 \\bigg)( p_i^{k_i}) \\\\ &amp;= \\prod \\sum_{j=1}^{k_i}\\varphi(p_i^j) \\\\ &amp;= \\prod p_i^{k_i} \\\\ &amp;= n \\\\ \\end{aligned}\\\\ \\therefore \\varphi \\ast 1 =Id âˆµ(Ï†âˆ—1)(n)=dâˆ£nâˆ‘â€‹Ï†(d)å°†næ‹†åˆ†ä¸ºâˆpkâˆ´(Ï†âˆ—1)(n)â€‹=(Ï†âˆ—1)(âˆpk)=âˆ(Ï†âˆ—1)(pikiâ€‹â€‹)=âˆj=1âˆ‘kiâ€‹â€‹Ï†(pijâ€‹)=âˆpikiâ€‹â€‹=nâ€‹âˆ´Ï†âˆ—1=Id 1âˆ—1=d1 \\ast 1 = d 1âˆ—1=d è¯æ˜ ï¼š (1âˆ—1)(n)=âˆ‘dâˆ£n1(d)1(nd)=âˆ‘dâˆ£n1=d(n)\\begin{aligned} \\bigg( 1 \\ast 1 \\bigg)(n) &amp;= \\sum_{d \\mid n} 1(d) 1(\\frac{n}{d}) \\\\ &amp;= \\sum_{d \\mid n} 1 \\\\ &amp;= d(n) \\end{aligned} (1âˆ—1)(n)â€‹=dâˆ£nâˆ‘â€‹1(d)1(dnâ€‹)=dâˆ£nâˆ‘â€‹1=d(n)â€‹ ä¸Šè¿°çš„è¿ç®—åŠ ä»¥ç»“åˆå¯ä»¥å¾—åˆ°æ›´å¤šç»“è®º ã€‚ ç‹„åˆ©å…‹é›·å·ç§¯é€† éœ€è¦ç”¨åˆ°å•ä½å…ƒï¼Œæœ‰ ï¼š (fâˆ—Îµ)(n)=âˆ‘dâˆ£nÎµ(d)f(nd)=f(n)\\bigg(f \\ast \\varepsilon \\bigg)(n) = \\sum_{d \\mid n} \\varepsilon(d)f(\\frac{n}{d}) =f (n) (fâˆ—Îµ)(n)=dâˆ£nâˆ‘â€‹Îµ(d)f(dnâ€‹)=f(n) å®šä¹‰ ï¼š fâˆ—fâˆ’1=Ïµf \\ast f^{-1} = \\epsilon fâˆ—fâˆ’1=Ïµ å³ä¸ºç‹„åˆ©å…‹é›·å·ç§¯é€† å…³äºè¿›ä¸€æ­¥çš„æ¨å¯¼ï¼Œå ä¸ªå‘ğŸ™ƒ ğŸ™ƒ ğŸ™ƒ ç§¯æ€§å‡½æ•°ä¸€å®šæœ‰ç‹„åˆ©å…‹é›·é€†ï¼Œä¸”å®ƒä¹Ÿæ˜¯ç§¯æ€§å‡½æ•° è«æ¯”ä¹Œæ–¯åæ¼” å‰ç½®çŸ¥è¯† ç‹„åˆ©å…‹é›·å·ç§¯ ä»‹ç» è«æ¯”ä¹Œæ–¯å‡½æ•° å®šä¹‰è«æ¯”ä¹Œæ–¯å‡½æ•°ä¸ºï¼š Î¼(x)={1x=1(âˆ’1)kâˆi=1kqi=10maxâ¡{qi}&gt;1\\mu (x) = \\left\\{ \\begin{aligned} &amp;1 &amp;x=1 \\\\ &amp;(-1)^k &amp;\\prod_{i=1}^k q_i=1 \\\\ &amp;0&amp;\\max\\left\\{ q_i \\right\\} &gt; 1 \\end{aligned} \\right. Î¼(x)=â©âªâªâªâªâ¨âªâªâªâªâ§â€‹â€‹1(âˆ’1)k0â€‹x=1i=1âˆkâ€‹qiâ€‹=1max{qiâ€‹}&gt;1â€‹ æ¨å¯¼ g=fâˆ—1 âŸº f=gâˆ—Î¼g=f \\ast 1 \\iff f= g \\ast \\mu g=fâˆ—1âŸºf=gâˆ—Î¼ ä¹Ÿå°±æ˜¯ ï¼š f(n)=âˆ‘dâˆ£ng(d) âŸº g(n)=âˆ‘dâˆ£nÎ¼(d)f(nd)f(n) = \\sum_{d \\mid n} g(d) \\iff g(n) = \\sum_{d \\mid n} \\mu(d) f( \\frac{n}{d}) f(n)=dâˆ£nâˆ‘â€‹g(d)âŸºg(n)=dâˆ£nâˆ‘â€‹Î¼(d)f(dnâ€‹) è«æ¯”ä¹Œæ–¯å‡½æ•°çš„æ€§è´¨ï¼š âˆ‘dâˆ£nnÎ¼(d)=[n=1]\\sum_{d \\mid n} ^n \\mu(d) = [n=1] dâˆ£nâˆ‘nâ€‹Î¼(d)=[n=1] æ¥ä¸‹æ¥è¯æ˜è«æ¯”ä¹Œæ–¯åæ¼”å®šç† ï¼š f(n)=âˆ‘dâˆ£ng(d)=âˆ‘dâˆ£ng(nd)âˆ‘dâˆ£nÎ¼(d)f(nd)=âˆ‘dâˆ£nÎ¼(d)âˆ‘d1âˆ£ndg(d1)âˆ‘dâˆ£nâˆ‘d1âˆ£ndÎ¼(d)g(d1)=âˆ‘d1âˆ£nâˆ‘dâˆ£nd1Î¼(d)g(d1)=âˆ‘d1âˆ£ng(d1)âˆ‘dâˆ£nd1Î¼(d)=g(n)\\begin{aligned} &amp;f(n)=\\sum_{d \\mid n}g(d)=\\sum_{d \\mid n}g(\\frac{n}{d})\\\\ &amp;\\sum_{d \\mid n} \\mu(d)f(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d) \\sum_{d_1 \\mid \\frac{n}{d}}g(d_1) \\\\ &amp;\\sum_{d \\mid n}\\sum_{d_1 \\mid \\frac{n}{d}} \\mu(d)g(d_1) \\\\ &amp;= \\sum_{d_1 \\mid n} \\sum_{d \\mid \\frac{n}{d_1}}\\mu(d)g(d_1) \\\\ &amp;= \\sum_{d_1 \\mid n} g(d_1) \\sum_{d \\mid \\frac{n}{d_1}} \\mu(d) \\\\ &amp;=g(n) \\\\ \\end{aligned} â€‹f(n)=dâˆ£nâˆ‘â€‹g(d)=dâˆ£nâˆ‘â€‹g(dnâ€‹)dâˆ£nâˆ‘â€‹Î¼(d)f(dnâ€‹)=dâˆ£nâˆ‘â€‹Î¼(d)d1â€‹âˆ£dnâ€‹âˆ‘â€‹g(d1â€‹)dâˆ£nâˆ‘â€‹d1â€‹âˆ£dnâ€‹âˆ‘â€‹Î¼(d)g(d1â€‹)=d1â€‹âˆ£nâˆ‘â€‹dâˆ£d1â€‹nâ€‹âˆ‘â€‹Î¼(d)g(d1â€‹)=d1â€‹âˆ£nâˆ‘â€‹g(d1â€‹)dâˆ£d1â€‹nâ€‹âˆ‘â€‹Î¼(d)=g(n)â€‹ ä¸Šè¿°ä»…ä¸ºå……åˆ†æ€§è¯æ˜ï¼Œå¿…è¦æ€§è¯æ˜é€†æ¨å³å¯ã€‚ é—®é¢˜ å‘ã€‚","link":"/2022/07/20/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"title":"ç”Ÿæˆå‡½æ•°å­¦ä¹ ç¬”è®°","text":"åˆæ¢ç”Ÿæˆå‡½æ•° ç”Ÿæˆå‡½æ•° æ™®é€šç”Ÿæˆå‡½æ•°(OGF) å®šä¹‰åºåˆ—aaaçš„ç”Ÿæˆå‡½æ•°ä¸º F(x)=âˆ‘i=0âˆaixiF(x) = \\sum_{i = 0} ^ {\\infty} a_ix^i F(x)=i=0âˆ‘âˆâ€‹aiâ€‹xi è¿ç®— å…¶åŠ æ³•è¿ç®—ä¸º F(x)Â±G(x)=âˆ‘i=0âˆ(aiÂ±bi)xiF(x) \\pm G(x) = \\sum_{i = 0} ^ {\\infty} (a_i \\pm b_i) x^ i F(x)Â±G(x)=i=0âˆ‘âˆâ€‹(aiâ€‹Â±biâ€‹)xi ä¹˜æ³•è¿ç®—ï¼Œä¹Ÿå°±æ˜¯å·ç§¯ä¸º F(x)âˆ—G(x)=âˆ‘i=0âˆ(âˆ‘j=0iajbiâˆ’j)xiF(x) \\ast G(x) = \\sum_{i = 0} ^ {\\infty} \\bigg( \\sum_{j = 0} ^ i a_jb_{i - j} \\bigg)x^i F(x)âˆ—G(x)=i=0âˆ‘âˆâ€‹(j=0âˆ‘iâ€‹ajâ€‹biâˆ’jâ€‹)xi å…¶ä¸ºåºåˆ—âˆ‘i=0naibnâˆ’i\\sum_ {i = 0}^n a_i b_{n - i}âˆ‘i=0nâ€‹aiâ€‹bnâˆ’iâ€‹çš„ç”Ÿæˆå‡½æ•°ã€‚ å°é—­å½¢å¼ æ ¹æ®ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼å¯å¾— F(x)=âˆ‘i=0âˆaixi=a0Ã—1âˆ’xâˆ1âˆ’x=a01âˆ’xF(x) = \\sum_{i = 0} ^ {\\infty} a_i x^i = a_0 \\times \\frac{1 - x ^ {\\infty}}{1 - x} = \\frac{a_0}{1 - x} F(x)=i=0âˆ‘âˆâ€‹aiâ€‹xi=a0â€‹Ã—1âˆ’x1âˆ’xâˆâ€‹=1âˆ’xa0â€‹â€‹ ç‰›é¡¿äºŒé¡¹å¼å®šç† å®šä¹‰ç»„åˆæ•°ä¸º (nm)=nmâ€¾m!,nâˆˆC,mâˆˆN\\dbinom{n}{m} = \\frac{n ^ {\\underline{m}}}{m!}, n \\in \\mathbb{C}, m \\in \\mathbb{N} (mnâ€‹)=m!nmâ€‹â€‹,nâˆˆC,mâˆˆN æŒ‡æ•°å‹ç”Ÿæˆå‡½æ•°(EGF) å®šä¹‰åºåˆ—aaaçš„æŒ‡æ•°å‹ç”Ÿæˆå‡½æ•°ä¸º F(x)=âˆ‘i=0âˆaixii!F(x) = \\sum_{i = 0} ^ {\\infty} a_i \\frac{x^i}{i !} F(x)=i=0âˆ‘âˆâ€‹aiâ€‹i!xiâ€‹ æ˜¾ç„¶æœ‰ ex=âˆ‘i=1âˆe0xii!=âˆ‘i=1âˆxii!ex+eâˆ’x2=âˆ‘i=0âˆx2i(2i)!exâˆ’eâˆ’x2=âˆ‘i=0âˆx2i+1(2i+1)!e^x = \\sum_{i = 1}^{\\infty} \\frac{e^0 x^i}{i!} = \\sum_{i = 1}^{\\infty}\\frac{x^i}{i!} \\\\ \\frac{e^x + e^{-x}}{2} = \\sum_{i = 0}^{\\infty} \\frac{x^{2i}}{(2i)!} \\\\ \\frac{e^x - e ^ {-x}}{2} =\\sum_{i = 0}^{\\infty} \\frac{x ^ {2i + 1}}{(2i+1)!} ex=i=1âˆ‘âˆâ€‹i!e0xiâ€‹=i=1âˆ‘âˆâ€‹i!xiâ€‹2ex+eâˆ’xâ€‹=i=0âˆ‘âˆâ€‹(2i)!x2iâ€‹2exâˆ’eâˆ’xâ€‹=i=0âˆ‘âˆâ€‹(2i+1)!x2i+1â€‹ å¯ä»¥åº”ç”¨åˆ°ç»„åˆæ•°å­¦ä¸­ã€‚","link":"/2022/09/30/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"çŸ©é˜µæ ‘å®šç†","text":"çŸ©é˜µæ ‘å®šç†è®²è§£ çŸ©é˜µæ ‘å®šç† å‰ç½®çŸ¥è¯†-è¡Œåˆ—å¼ å®šä¹‰ å¯¹äºä¸€ä¸ªnÃ—nn \\times nnÃ—nçš„çŸ©é˜µï¼Œå…¶è¡Œåˆ—å¼ä¸ºï¼Œ detâ¡(A)=âˆ‘P(âˆ’1)Î¼(P)âˆi=1nA(i,pi)\\det(A) = \\sum_{P}(-1)^{\\mu(P)}\\prod_{i = 1} ^ n A(i, p_i) det(A)=Pâˆ‘â€‹(âˆ’1)Î¼(P)i=1âˆnâ€‹A(i,piâ€‹) å…¶ä¸­PPPä¸º1âˆ’n1 - n1âˆ’nçš„ä¸€ä¸ªæ’åˆ—ï¼Œ Î¼(P)\\mu(P)Î¼(P)ä¸ºæ’åˆ—PPPçš„é€†åºå¯¹ä¸ªæ•°ã€‚ æ€§è´¨ å•ä½çŸ©é˜µIIIçš„è¡Œåˆ—å¼ä¸º111ï¼Œ ä¸Šä¸‰è§’çŸ©é˜µå’Œä¸‹ä¸‰è§’çŸ©é˜µçš„è¡Œåˆ—å¼éƒ½æ˜¯å¯¹è§’çº¿ä¹˜ç§¯ã€‚ äº¤æ¢çŸ©é˜µçš„ä¸¤è¡Œï¼Œè¡Œåˆ—å¼å˜å·ï¼ˆæ”¹å˜äº†å¥‡æ•°ä¸ªé€†åºå¯¹ï¼‰ã€‚ è‹¥æŸä¸€è¡Œä¹˜ä»¥kkkï¼Œè¡Œåˆ—å¼ä¹˜ä»¥kkkã€‚ è¡Œçš„çº¿æ€§æ€§ã€‚ âˆ£a+aâ€²b+bâ€²cdâˆ£=âˆ£abcdâˆ£+âˆ£aâ€²bâ€²cdâˆ£\\begin{vmatrix} a + a'&amp; b+ b' \\\\ c &amp; d\\end{vmatrix} = \\begin{vmatrix} a &amp; b \\\\ c &amp; d\\end{vmatrix} + \\begin{vmatrix} a'&amp; b' \\\\ c &amp; d\\end{vmatrix} âˆ£âˆ£âˆ£âˆ£â€‹a+aâ€²câ€‹b+bâ€²dâ€‹âˆ£âˆ£âˆ£âˆ£â€‹=âˆ£âˆ£âˆ£âˆ£â€‹acâ€‹bdâ€‹âˆ£âˆ£âˆ£âˆ£â€‹+âˆ£âˆ£âˆ£âˆ£â€‹aâ€²câ€‹bâ€²dâ€‹âˆ£âˆ£âˆ£âˆ£â€‹ æœ‰æŸä¸¤è¡Œä¸€æ ·çš„çŸ©é˜µï¼Œè¡Œåˆ—å¼ä¸º000ã€‚ ç²—ç•¥çš„è¯æ˜ï¼šæ ¹æ®1ï¼Œå‡è®¾æˆ‘ä»¬äº¤æ¢ç›¸åŒçš„ä¸¤è¡Œï¼Œä¼šä½¿è¡Œåˆ—å¼å˜å·ï¼Œ ä½†æ˜¯äº¤æ¢åï¼Œè¡Œåˆ—å¼å¹¶æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼Œä¹Ÿå°±æ˜¯è¡Œåˆ—å¼åªèƒ½ç­‰äº000 ç”¨çŸ©é˜µçš„ä¸Šä¸€è¡ŒåŠ ä¸Šå¦ä¸€è¡Œçš„å€æ•°ï¼Œ è¡Œåˆ—å¼ä¸å˜ã€‚ è¯æ˜ï¼š âˆµâˆ£abcâ‹¯abcâˆ£=0=âˆ£abcâ‹¯kakbkcâˆ£=0âˆ´âˆ£abcâ‹¯d+kae+kbf+kcâˆ£=âˆ£abcâ‹¯kakbkcâˆ£+âˆ£abcâ‹¯defâˆ£=âˆ£abcâ‹¯defâˆ£\\because \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ a &amp; b &amp; c\\end{vmatrix} = 0 =\\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ ka &amp; kb &amp; kc\\end{vmatrix} = 0 \\\\ \\therefore \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d + ka &amp; e + kb &amp;f + kc\\end{vmatrix} = \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ ka &amp; kb &amp; kc\\end{vmatrix} + \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d &amp; e &amp; f\\end{vmatrix} = \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d &amp; e &amp; f\\end{vmatrix} âˆµâˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹aaâ€‹bâ‹¯bâ€‹ccâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹=0=âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹akaâ€‹bâ‹¯kbâ€‹ckcâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹=0âˆ´âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ad+kaâ€‹bâ‹¯e+kbâ€‹cf+kcâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹=âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹akaâ€‹bâ‹¯kbâ€‹ckcâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹+âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹adâ€‹bâ‹¯eâ€‹cfâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹=âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹adâ€‹bâ‹¯eâ€‹cfâ€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ æ¶ˆå…ƒæ³•æ±‚è¡Œåˆ—å¼ é¦–å…ˆé«˜æ–¯æ¶ˆå…ƒçš„è¿‡ç¨‹ä¸­æˆ‘ä»¬ç”¨åˆ°çš„æ˜¯äº¤æ¢ä¸¤è¡Œï¼Œè¡Œåˆ—å¼çš„å€¼å˜å·ï¼Œ æŸä¸€è¡Œä¹˜ä¸Šä¸€ä¸ªæ•°ï¼Œè¡Œåˆ—å¼ä¹˜ä¸Šå¯¹åº”å€¼ï¼Œä¸€è¡ŒåŠ ä¸Šå¦ä¸€è¡Œçš„å€æ•°ï¼Œè¡Œåˆ—å¼ä¸å˜ï¼Œæœ€åå¾—åˆ°ä¸Šä¸‰è§’çŸ©é˜µåï¼ŒæŠŠå½±å“é€†å›å»å³å¯ã€‚ P7112 è¡Œåˆ—å¼æ±‚å€¼ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 610;int a[N][N];int n, p;signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]); int ans = 1, f = 1; for(int i = 1; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(a[i][i]) { int div = a[j][i] / a[i][i]; for(int k = i; k &lt;= n; k++) a[j][k] = (a[j][k] - div * a[i][k] % p + p) % p; swap(a[i], a[j]); f = - f; } swap(a[i], a[j]); f = -f; } } for(int i = 1; i &lt;= n; i++) ans = (ans * a[i][i]) % p; ans = f * ans; printf(&quot;%lld&quot;, (ans + p) % p); return 0;} æ¦‚å¿µ çŸ©é˜µæ ‘å®šç†(Matrix-tree Theorem) æ˜¯æŠŠå›¾çš„ç”Ÿæˆæ ‘ä¸ªæ•°å’ŒçŸ©é˜µè¡Œåˆ—å¼è”ç³»èµ·æ¥çš„å®šç†ã€‚ï¼ˆæœ‰å¾ˆå¤§çš„ç”¨å¤„ï¼ï¼‰ å®šä¹‰ é¦–å…ˆè®¾æœ‰æ— å‘å›¾G=(V,E)G = (V, E)G=(V,E)ï¼Œ æœ‰pppä¸ªé¡¶ï¼Œ qqqæ¡è¾¹ã€‚ ç„¶åæˆ‘ä»¬æŠŠGGGçš„æ¯æ¡è¾¹ä»»æ„æŒ‡å®šä¸€ä¸ªæ–¹å‘ï¼Œ è¿™æ ·å°±å¯ä»¥å®šä¹‰GGGçš„å…³è”çŸ©é˜µ(Incidence Matrix)M(G)M(G)M(G), ä¸ºä¸€ä¸ªpÃ—qp \\times qpÃ—qçš„çŸ©é˜µï¼Œ Mi,j={âˆ’1vi is the start of ej1vi is the end of ej0ortherwiseM_{i,j} = \\left\\{ \\begin{aligned} &amp; -1 &amp; v_i \\ is \\ the \\ start\\ of \\ e_j \\\\ &amp; 1 &amp; v_i \\ is \\ the \\ end \\ of \\ e_j \\\\ &amp; 0 &amp; ortherwise \\end{aligned} \\right. Mi,jâ€‹=â©âªâ¨âªâ§â€‹â€‹âˆ’110â€‹viâ€‹ is the start of ejâ€‹viâ€‹ is the end of ejâ€‹ortherwiseâ€‹ æ¥ç€å®šä¹‰GGGçš„æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ(Laplacian Matrix)L(G)L(G)L(G)ï¼Œ ä¸ºä¸€ä¸ªpÃ—pp \\times ppÃ—pçš„çŸ©é˜µï¼Œ Li,j={âˆ’mi,ji=Ì¸j ,mi,j edge between vi,vjdeg(vi)i=jL_{i, j} = \\left\\{ \\begin{aligned} &amp; -m_{i, j} &amp;i \\not = j \\ ,m_{i,j} \\ edge \\ between \\ v_i, v_j \\\\ &amp; deg(v_i) &amp;i = j \\end{aligned} \\right. Li,jâ€‹={â€‹âˆ’mi,jâ€‹deg(viâ€‹)â€‹iî€ â€‹=j ,mi,jâ€‹ edge between viâ€‹,vjâ€‹i=jâ€‹ æ³¨æ„åˆ°MMMä¸GGGæŒ‡å®šçš„æ–¹å‘æœ‰å…³ï¼Œ å¯¹LLLæ²¡æœ‰å½±å“ï¼Œä¸¾ä¸€ä¸ªä¾‹å­ï¼š å¯¹åº”çš„å…³è”çŸ©é˜µMMMä¸º âˆ£100âˆ’1âˆ’1âˆ’1âˆ’1âˆ’1000011001001âˆ£\\begin{vmatrix}1&amp;0&amp;0&amp;-1&amp;-1\\\\-1&amp;-1&amp;-1&amp;0&amp;0\\\\0&amp;0&amp;1&amp;1&amp;0\\\\0&amp;1&amp;0&amp;0&amp;1\\end{vmatrix} âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹1âˆ’100â€‹0âˆ’101â€‹0âˆ’110â€‹âˆ’1010â€‹âˆ’1001â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ å¯¹åº”çš„æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µLLLä¸º âˆ£3âˆ’1âˆ’1âˆ’1âˆ’13âˆ’1âˆ’1âˆ’1âˆ’120âˆ’1âˆ’102âˆ£\\begin{vmatrix} 3 &amp; -1 &amp; -1 &amp; -1 \\\\ -1 &amp; 3 &amp; -1 &amp; -1\\\\ -1 &amp; -1 &amp; 2 &amp; 0\\\\ -1 &amp; -1 &amp; 0 &amp; 2 \\end{vmatrix} âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹3âˆ’1âˆ’1âˆ’1â€‹âˆ’13âˆ’1âˆ’1â€‹âˆ’1âˆ’120â€‹âˆ’1âˆ’102â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ å¦å¤–LLLçš„éä¸»å¯¹è§’çº¿ä¸Šçš„å…ƒç´ ä¸ä¸€å®šæ˜¯âˆ’1-1âˆ’1 ï¼Œ GGGä¸­å…è®¸é‡è¾¹å­˜åœ¨ã€‚ å¼•ç† Lemma 1 MMT=LM M ^T = LMMT=L,å…¶ä¸­MTM^TMTè¡¨ç¤ºMMMçš„è½¬ç½® è¯æ˜ï¼šç”±å®šä¹‰æ˜“å¾—ï¼š(MMT)i,j=âˆ‘ekâˆˆEMi,kMk,jT=âˆ‘ekâˆˆEMi,kMj,k(MM^T)_{i,j} = \\sum_{e_k \\in E} M_{i,k} M ^T_{k,j} = \\sum_{e_k \\in E} M_{i,k}M_{j,k}(MMT)i,jâ€‹=âˆ‘ekâ€‹âˆˆEâ€‹Mi,kâ€‹Mk,jTâ€‹=âˆ‘ekâ€‹âˆˆEâ€‹Mi,kâ€‹Mj,kâ€‹ï¼Œi=ji = ji=jæ—¶å°±ç›¸å½“äºè¿äº†å‡ æ¡è¾¹ä¹Ÿå°±æ˜¯å…¥åº¦ï¼Œi=Ì¸ji \\not = jiî€ â€‹=jæ—¶ä¸¤ç‚¹ä¹‹é—´æœ‰è¿è¾¹çš„è¯å…¶ä¸­å¿…å®šæ˜¯ä¸€ä¸ªç»ˆç‚¹å’Œä¸€ä¸ªèµ·ç‚¹ï¼Œä¹Ÿå°±æ˜¯å¯¹åº”çš„âˆ’mi,j-m_{i,j}âˆ’mi,jâ€‹ï¼Œå¾—è¯ã€‚ æ¥ä¸‹æ¥å¼•å…¥ä¸€äº›MMMçš„å­çŸ©é˜µï¼Œç§°ä¸ºReduce Incidence Matrixï¼ŒM0M_0M0â€‹æ˜¯å»æ‰MMMæœ€åä¸€è¡Œå¾—åˆ°çš„(pâˆ’1)Ã—q(p - 1) \\times q(pâˆ’1)Ã—qçŸ©é˜µã€‚ å®šä¹‰ä¸€ä¸ª(pâˆ’1)Ã—(pâˆ’1)(p - 1) \\times (p - 1)(pâˆ’1)Ã—(pâˆ’1)çš„çŸ©é˜µM0[S]M_0[S]M0â€‹[S],å…¶ä¸­é›†åˆS={i1,i2,â‹¯ ,ipâˆ’1}âˆˆ{1,2,â‹¯ ,q}S = \\{i _ 1, i_2, \\cdots ,i_{p-1}\\} \\in \\{1, 2, \\cdots , q\\}S={i1â€‹,i2â€‹,â‹¯,ipâˆ’1â€‹}âˆˆ{1,2,â‹¯,q}qå…¶å®å°±æ˜¯æŠ½å‡ºM0M_0M0â€‹ä¸­pâˆ’1p - 1pâˆ’1åˆ—ï¼Œå¾—åˆ°çš„ä¸€ä¸ªæ–°çš„çŸ©é˜µã€‚ Lemma 2 ä»¤SSSæ˜¯è¾¹é›†EEEçš„ä¸€ä¸ªå¤§å°ä¸ºpâˆ’1p - 1pâˆ’1çš„å­é›†ï¼Œè‹¥Gâ€²=(V,S)G' = (V,S)Gâ€²=(V,S)ä¸æ„æˆç”Ÿæˆæ ‘ï¼Œåˆ™detâ¡M0[S]=0\\det M_0[S] = 0detM0â€‹[S]=0ï¼Œè‹¥Gâ€²G'Gâ€²æ„æˆç”Ÿæˆæ ‘ï¼Œåˆ™detâ¡M0[S]=Â±1\\det M_0[S] = \\pm 1detM0â€‹[S]=Â±1ï¼Œå…¶ä¸­detâ¡\\detdetè¡¨ç¤ºçŸ©é˜µçš„è¡Œåˆ—å¼ Lemma 3 Binet-Cauchy Theorem è®¾A=(ai,j)A = (a_{i,j})A=(ai,jâ€‹)æ˜¯ä¸€ä¸ªmÃ—nm \\times nmÃ—nçŸ©é˜µï¼Œ B=(bi,j)B = (b_{i,j})B=(bi,jâ€‹)æ˜¯ä¸€ä¸ªnÃ—mn \\times mnÃ—mçŸ©é˜µï¼Œåˆ™æœ‰detâ¡(AB)=âˆ‘S(detâ¡A[s])(detâ¡B[s])\\det (AB) = \\sum_{S} (\\det A[s])(\\det B[s])det(AB)=âˆ‘Sâ€‹(detA[s])(detB[s])ï¼Œ å…¶ä¸­SSSå¤§å°ä¸ºmmmï¼Œä¸”æ˜¯{1,2,â‹¯ ,n}\\{ 1, 2, \\cdots , n\\}{1,2,â‹¯,n}çš„å­é›†ã€‚ Lemma 4 Matrix-tree Theorem è®¾å›¾G=(V,E)G = (V, E)G=(V,E), æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µLLL, åˆ™GGGçš„ç”Ÿæˆæ ‘çš„ä¸ªæ•°ç­‰äºdetâ¡L0\\det L_0detL0â€‹ï¼Œ å…¶ä¸­L0L_0L0â€‹æ˜¯å»æ‰LLLç¬¬iiiåˆ—ç¬¬iiiè¡Œå¾—åˆ°çš„å­çŸ©é˜µ æ‹“å±• æ— å‘å›¾ è®¾GGGæ˜¯ä¸€ä¸ªæœ‰nnnä¸ªé¡¶ç‚¹çš„æ— å‘å›¾ï¼Œå®šä¹‰å…¶åº¦æ•°çŸ©é˜µä¸º Di,i(G)=deg(i), Di,j(G)=0, i!=jD_{i,i}(G) = deg(i), \\ D_{i, j}(G) = 0, \\ i != j Di,iâ€‹(G)=deg(i), Di,jâ€‹(G)=0, i!=j å…¶é‚»æ¥çŸ©é˜µä¸º Ai,j(G)=Aj,i(G)=e(i,j),i=Ì¸jA_{i, j}(G) = A_{j , i}(G) = e(i, j), i \\not= j Ai,jâ€‹(G)=Aj,iâ€‹(G)=e(i,j),iî€ â€‹=j å…¶æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µä¸º L(G)=D(G)âˆ’A(G)L(G) = D(G) - A(G) L(G)=D(G)âˆ’A(G) æœ‰å‘å›¾ è®¾GGGæ˜¯ä¸€ä¸ªæœ‰nnnä¸ªé¡¶ç‚¹çš„æœ‰å‘å›¾ï¼Œ å®šä¹‰å…¶å‡ºåº¦çŸ©é˜µä¸º Diiout(G)=degout(i),Dijout=0,iâ‰ jD^{out}_{ii}(G) = \\mathrm{deg^{out}}(i), D^{out}_{ij} = 0, i\\neq j Diioutâ€‹(G)=degout(i),Dijoutâ€‹=0,iî€ â€‹=j ç±»ä¼¼çš„å…¥åº¦çŸ©é˜µä¹Ÿè¿™æ ·å®šä¹‰ å®šä¹‰å…¶é‚»æ¥çŸ©é˜µä¸º Ai,j=e(i,j), i=Ì¸jA_{i,j} = e(i, j), \\ i \\not = j Ai,jâ€‹=e(i,j), iî€ â€‹=j å…¶æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µLoutL^{out}Loutä¸º Lout(G)=Dout(G)âˆ’A(G)L^{out}(G) = D^{out}(G) - A(G) Lout(G)=Dout(G)âˆ’A(G) LinL^{in}Linä¸º Lin(G)=Din(G)âˆ’A(G)L^{in}(G) = D^{in}(G) - A(G) Lin(G)=Din(G)âˆ’A(G) å¸¦æƒ-ä¹˜ç§¯ä¹‹å’Œ å¯¹äºå¸¦æƒæ— å‘å›¾ï¼Œè‹¥å­˜åœ¨è¾¹uâ†’vu\\rightarrow vuâ†’vï¼Œè¾¹æƒä¸ºcccï¼Œ åˆ™Dx,x+c,Dy,y+c,Ax,y+c,Ay,x+cD_{x, x} + c, D_{y,y} + c, A_{x, y} + c, A_{y, x} + cDx,xâ€‹+c,Dy,yâ€‹+c,Ax,yâ€‹+c,Ay,xâ€‹+cã€‚åˆ å»ä»»æ„ä¸€è¡Œå’Œä»»æ„ä¸€åˆ—ï¼Œæ±‚å‰©ä¸‹çš„çŸ©é˜µè¡Œåˆ—å¼å³å¯ã€‚ å¯¹äºå¸¦æƒæœ‰å‘å›¾ï¼Œè‹¥å­˜åœ¨è¾¹uâ†’vu \\rightarrow vuâ†’vï¼Œè¾¹æƒä¸ºcccï¼Œå¤–å‘æ ‘ä¸­Dy,y+cD_{y, y} + cDy,yâ€‹+cï¼Œ å†…å‘æ ‘ä¸­Dx,x+cD_{x, x} + cDx,xâ€‹+cï¼Œ å†…å‘æ ‘å’Œå¤–å‘æ ‘ä¸­Ax,y+cA_{x, y} + cAx,yâ€‹+cã€‚åˆ å»æŒ‡å®šçš„æ ¹æ‰€åœ¨çš„è¡Œå’Œåˆ—ï¼Œæ±‚å‰©ä¸‹çš„çŸ©é˜µè¡Œåˆ—å¼å³å¯ã€‚ P6178Matrix-Tree å®šç† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 310;const int mod = 1e9 + 7;ll D[N][N], A[N][N], L[N][N];int n, m, t;void add(int u, int v, int c, int type){ if(t == 0) { (D[u][u] += c) %= mod; (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; (A[v][u] += c) %= mod; } else { (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; }}ll ans;void gauss(){ ll f = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(L[i][i]) { ll div = L[j][i] / L[i][i]; for(int k = i; k &lt;= n; k++) L[j][k] = ((L[j][k] - L[i][k] * div % mod) % mod + mod) % mod; swap(L[i], L[j]); f = -f; } f = -f; swap(L[i], L[j]); } } ans = f; for(int i = 2; i &lt;= n; i++) ans = (ans % mod * (L[i][i] + mod) % mod + mod) % mod;}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z, t); } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) L[i][j] = (D[i][j] - A[i][j] + mod) % mod; gauss(); printf(&quot;%lld&quot;, ans); return 0;} å¸¦æƒ-æƒå€¼ä¹‹å’Œ ä¸Šé¢çš„æ„é€ æ–¹å¼åªæ˜¯æ±‚äº†æ¯ä¸ªç”Ÿæˆæ ‘è¾¹æƒä¹˜ç§¯çš„å’Œï¼Œ æ¥ä¸‹æ¥éœ€è¦è§£å†³ï¼Œæ¯ä¸ªç”Ÿæˆæ ‘è¾¹æƒä¹‹å’Œçš„å’Œï¼Œå¯¹äºä¸€æ¡è¾¹æƒä¸ºwwwçš„è¾¹ï¼Œåªéœ€è¦å°†è¾¹æƒè®¾ä¸ºå…³äºxxxçš„å¤šé¡¹å¼wx+1wx + 1wx+1ï¼Œæ¶ˆå…ƒåæœ€åçš„è¡Œåˆ—å¼çš„å€¼çš„ä¸€æ¬¡é¡¹ç³»æ•°å°±æ˜¯ç­”æ¡ˆï¼Œ å¯¹åº”çš„ä¹˜æ³•æ”¹ä¸º(a+bx)(c+dx)=ac+(ad+bc)x(a + bx) (c + dx) = ac + (ad + bc)x(a+bx)(c+dx)=ac+(ad+bc)xï¼Œé™¤æ³•ä¸ºa+bxc+dx=ac+bcâˆ’adc2x\\frac{a + bx} {c + dx} = \\frac{a}{c} + \\frac{bc - ad}{c ^ 2}xc+dxa+bxâ€‹=caâ€‹+c2bcâˆ’adâ€‹xï¼Œæ¥ä¸‹æ¥è¯æ˜ä¸€ä¸‹æ„é€ æ–¹å¼çš„æ­£ç¡®æ€§ï¼Œæˆ‘ä»¬éœ€è¦æ±‚çš„ç­”æ¡ˆå…¶å®å¯ä»¥è¡¨ç¤ºä¸ºæ¯ä¸ªè¾¹æƒÃ—\\timesÃ—å«æœ‰è¿™æ¡è¾¹æƒçš„ç”Ÿæˆæ ‘çš„ä¸ªæ•°ï¼Œå°±å¯ä»¥æ„é€ ä¸€ä¸ªå¤šé¡¹å¼æ¥æ±‚è§£ï¼Œï¼ˆè€å¥—è·¯äº†ï¼‰ï¼Œé¦–å…ˆä¹˜æ³•çš„å®šä¹‰å¾ˆå¥½ç†è§£ï¼Œè¯´ä¸€ä¸‹é™¤æ³•çš„ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦æ±‚çš„æ˜¯C+Dx=1c+dxC + Dx = \\frac{1}{c + dx}C+Dx=c+dx1â€‹ï¼Œå³(C+Dx)(c+dx)=1 mod x2(C + Dx)(c + dx) = 1 \\bmod x^2(C+Dx)(c+dx)=1modx2ï¼Œå±•å¼€å³å¯å¾—åˆ°C=1c,D=âˆ’dc2C = \\frac{1}{c}, D = -\\frac{d}{c^2}C=c1â€‹,D=âˆ’c2dâ€‹ï¼Œç„¶åå†ä¹˜ä¸Ša+bxa + bxa+bxï¼Œå°±å¯ä»¥å¾—åˆ°æ–°çš„å¼å­ä¸ºac+bcâˆ’adc2x\\frac{a}{c} + \\frac{bc - ad}{c^2}xcaâ€‹+c2bcâˆ’adâ€‹xã€‚ P6624 ä½œä¸šé¢˜ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 310;const int mod = 1e9 + 7;ll D[N][N], A[N][N], L[N][N];int n, m, t;void add(int u, int v, int c, int type){ if(t == 0) { (D[u][u] += c) %= mod; (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; (A[v][u] += c) %= mod; } else { (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; }}ll ans;void gauss(){ ll f = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(L[i][i]) { ll div = L[j][i] / L[i][i]; for(int k = i; k &lt;= n; k++) { L[j][k] = ((L[j][k] - L[i][k] * div % mod) % mod + mod) % mod; } swap(L[i], L[j]); f = -f; } f = -f; swap(L[i], L[j]); } } ans = f; for(int i = 2; i &lt;= n; i++) ans = (ans % mod * (L[i][i] + mod) % mod + mod) % mod;}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z, t); } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) L[i][j] = (D[i][j] - A[i][j] + mod) % mod; gauss(); printf(&quot;%lld&quot;, ans); return 0;} åè®° è¯æ˜ä»¥åå†è¡¥å§ï¼ˆé€ƒ","link":"/2022/09/18/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"title":"ç¬›å¡å°”æ ‘","text":"ç”¨çš„æœ‰ç‚¹å°‘çš„æ•°æ®ç»“æ„ ç¬›å¡å°”æ ‘ å‰ç½®çŸ¥è¯† å•è°ƒæ ˆ æ­£æ–‡ æ€§è´¨ ç¬›å¡å°”æ ‘ï¼Œæ˜¯ä¸€ç§ä¸å¸¸ç”¨çš„æ•°æ®ç»“æ„å§ï¼Œå…¶åŒæ—¶æ»¡è¶³äºŒå‰æœç´¢æ ‘å’Œå°æ ¹å †çš„æ€§è´¨ å‡è®¾ä»¬æœ‰ä¸€ä¸ªæ•°ç»„aia_iaiâ€‹ï¼Œå°†å…¶æ•°ç»„çš„ä¸‹æ ‡è®°ä¸ºkkk,å…¶æƒå€¼è®°ä¸ºwwwï¼Œé‚£ä¹ˆå»ºæˆçš„ç¬›å¡å°”æ ‘æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š kkkå€¼æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œlsk&lt;k&lt;rskls_k&lt;k&lt;rs_klskâ€‹&lt;k&lt;rskâ€‹ wwwå€¼æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ï¼Œlsw&lt;w,rsw&lt;wls_w&lt;w,rs_w&lt;wlswâ€‹&lt;w,rswâ€‹&lt;w å»ºæ ‘ é¦–å…ˆåŠ å…¥ç¬¬iiiä¸ªæ•°æ—¶ï¼Œiiiè‚¯å®šåœ¨[1ï¼Œiâˆ’1][1ï¼Œi-1][1ï¼Œiâˆ’1]æ„æˆçš„æ ‘å³é“¾çš„æœ«å°¾èŠ‚ç‚¹ï¼Œæ­¤æ—¶å…ˆæ’å…¥iiiï¼Œå°†å…¶æ’åˆ°å³é“¾æœ«å°¾èŠ‚ç‚¹ï¼Œä½†æ­¤æ—¶è¿™é¢—æ ‘ä¸ä¸€å®šæ»¡è¶³ç¬¬äºŒä¸ªæ€§è´¨ï¼Œéœ€è¦å¯¹å…¶è¿›è¡Œè°ƒæ•´ï¼Œè‹¥æ­¤æ—¶iiiçš„çˆ¶èŠ‚ç‚¹çš„wwwå€¼æ¯”iiiå¤§ï¼Œä¸€ç›´æ‰¾åˆ°å³é“¾ä¸Šwwwå€¼æ¯”iiiå°çš„ç„¶åï¼Œå…ˆå°†iiièŠ‚ç‚¹çš„å·¦å„¿å­è®¾ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å³å„¿å­ï¼Œå†å°†è¿™ä¸ªèŠ‚ç‚¹çš„å³å„¿å­è®¾ä¸ºiii,å°†nnnä¸ªç‚¹æ’å…¥åï¼Œå³å¯å¾—åˆ°ä¸€æ£µç¬›å¡å°”æ ‘ã€‚ 123456789101112void build(){ int top=0,st[maxn]; memset(st,0,sizeof(st)); for(int i=1;i&lt;=n;i++) { while(top&amp;&amp;a[st[top]]&gt;a[i])top--; if(!top)ls[i]=st[top+1]; else ls[i]=rs[st[top]],rs[st[top]]=i; st[++top]=i; }} é—®é¢˜ æˆ‘ä¹Ÿä¸çŸ¥é“èƒ½å¹²å•¥ ğŸ™ƒ","link":"/2022/07/24/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"title":"ç±»æ¬§å‡ é‡Œå¾·","text":"å¾ˆä¸é”™çš„ç®—æ³•å‘¢ï¼Œå°±æ˜¯å¼å­æœ‰ç‚¹é•¿ï¼Œä½†è¿˜æ˜¯ä¸éš¾æ¨çš„( Â´ï½¥ï½¥)ï¾‰(._.`) ç±»æ¬§å‡ é‡Œå¾—ç®—æ³• å‰ç½®çŸ¥è¯† æ•°å­¦æŠ€å·§ é¡¶åº•å‡½æ•° å‰è¨€ ç±»æ¬§å‡ é‡Œå¾·ç®—æ³•æ˜¯ç”±æ´ªåæ•¦åœ¨ 2016 å¹´å†¬ä»¤è¥è¥å‘˜äº¤æµä¸­æå‡ºçš„å†…å®¹ï¼Œå…¶æœ¬è´¨å¯ä»¥ç†è§£ä¸ºï¼Œä½¿ç”¨ä¸€ä¸ªç±»ä¼¼è¾—è½¬ç›¸é™¤æ³•æ¥åšå‡½æ•°æ±‚å’Œçš„è¿‡ç¨‹ã€‚ ä¸»è¦è¿˜æ˜¯æ¨å¼å­ğŸ¤” æ­£æ–‡ é—®é¢˜1 è®¾ f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹(1,1)\\tag{1,1} f(a,b,c,n)= \\sum_{i=0}^n \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor f(a,b,c,n)=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹(1,1) å…¶ä¸­a,b,c,nâˆˆZa,b,c,n \\in \\mathbb{Z}a,b,c,nâˆˆZã€‚ ä¸€çœ¼ä¸å¯åšï¼Œä¼¼ä¹åƒæ•°è®ºåˆ†å—ï¼Œä½†åˆå¥½åƒä¸å¤ªè¡Œçš„æ ·å­ã€‚ a,b,c,na,b,c,na,b,c,nä¹‹é—´çš„å…³ç³»ä¹Ÿæ²¡ç»™ï¼Œé‚£å°±åˆ†æƒ…å†µå§ é¦–å…ˆè€ƒè™‘ç¬¬ä¸€ç§æƒ…å†µaâ‰¥c,bâ‰¥ca \\ge c,b \\ge caâ‰¥c,bâ‰¥cï¼Œï¼ˆä¹Ÿæ˜¯æœ€ç®€å•çš„ä¸€ç§æƒ…å†µï¼‰ æ­¤æ—¶å¼å­å¯ä»¥è¿›ä¸€æ­¥åŒ–ç®€ä¸º ï¼š f(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹=âˆ‘i=0nâŒŠ(âŒŠacâŒ‹Ã—c+a mod c)i+âŒŠbcâŒ‹Ã—c+b mod ccâŒ‹=âˆ‘i=0n(âŒŠacâŒ‹i+âŒŠbcâŒ‹+âŒŠ(a mod c)i+b mod ccâŒ‹)=âˆ‘i=0nâŒŠacâŒ‹i+âˆ‘i=0nâŒŠbcâŒ‹+âˆ‘i=0nâŒŠ(a mod c)i+b mod ccâŒ‹=n(n+1)2âŒŠacâŒ‹+(n+1)âŒŠbcâŒ‹+f(a mod c,b mod c,c,n)(1,2)\\tag{1,2} \\begin{aligned} f(a,b,c,n) &amp;= \\sum_{i=0}^n \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n \\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg) \\\\ &amp;=\\sum_{i=0}^n \\lfloor \\frac{a}{c} \\rfloor i+\\sum_{i=0}^n \\lfloor \\frac{b}{c}\\rfloor +\\sum_{i=0}^n \\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\frac{n(n+1)}{2} \\lfloor \\frac{a}{c} \\rfloor+(n+1)\\lfloor \\frac{b}{c}\\rfloor + f(a \\bmod c,b\\bmod c,c,n) \\end{aligned} f(a,b,c,n)â€‹=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹=i=0âˆ‘nâ€‹âŒŠc(âŒŠcaâ€‹âŒ‹Ã—c+amodc)i+âŒŠcbâ€‹âŒ‹Ã—c+bmodcâ€‹âŒ‹=i=0âˆ‘nâ€‹(âŒŠcaâ€‹âŒ‹i+âŒŠcbâ€‹âŒ‹+âŒŠc(amodc)i+bmodcâ€‹âŒ‹)=i=0âˆ‘nâ€‹âŒŠcaâ€‹âŒ‹i+i=0âˆ‘nâ€‹âŒŠcbâ€‹âŒ‹+i=0âˆ‘nâ€‹âŒŠc(amodc)i+bmodcâ€‹âŒ‹=2n(n+1)â€‹âŒŠcaâ€‹âŒ‹+(n+1)âŒŠcbâ€‹âŒ‹+f(amodc,bmodc,c,n)â€‹(1,2) æ­¤æ—¶æˆ‘ä»¬æŠŠå¼å­åŒ–ä¸ºäº†ä¸€ä¸ªå«æœ‰fffçš„é€’å½’å¼ï¼Œæ¥ä¸‹æ¥a,ba,ba,bå¿…å®šä¼šå˜å¾—å°äºcccï¼Œè¿˜éœ€è®¨è®ºå¦ä¸€ç§æƒ…å†µ a&lt;c,b&lt;ca &lt; c,b&lt; ca&lt;c,b&lt;cæ—¶ï¼Œè¿™æ—¶å€™ä¹Ÿä¸èƒ½ç”¨ä¸Šé¢çš„æ–¹æ³•ï¼ŒğŸ¤” åˆ©ç”¨æšä¸¾è´¡çŒ®çš„æ–¹æ³•ï¼Œå°†å¼å­åŒ–ä¸º ï¼š f(a,b,c,n)=âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’11(1,3)\\tag{1,3} f(a,b,c,n)=\\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} 1 f(a,b,c,n)=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹1(1,3) ä¼¼ä¹ä»€ä¹ˆéƒ½æ²¡æœ‰åšçš„æ ·å­ã€‚ã€‚ éœ€è¦è¿›ä¸€æ­¥åŒ–ç®€ï¼š âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’11=âˆ‘i=0nâˆ‘j=0âŒŠan+bcâŒ‹âˆ’1[j&lt;âŒŠai+bcâŒ‹](1,4)\\tag{1,4} \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} 1 = \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\bigg[j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\bigg] i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹1=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹[j&lt;âŒŠcai+bâ€‹âŒ‹](1,4) æ”¹äº†ç¬¬äºŒå±‚æ±‚å’Œçš„ä¸Šç•Œï¼Œå¥½åƒæœ‰ç‚¹å¤´ç»ªäº† ç°åœ¨é™åˆ¶æˆ‘ä»¬çš„å°±æ˜¯åé¢çš„æ¡ä»¶è¡¨è¾¾å¼äº†ï¼Œä¹Ÿè®¸å¯ä»¥å°†è½¬åŒ–ä¸ºæŸç§æ–¹ä¾¿è®¡ç®—çš„å½¢å¼: âˆµj&lt;âŒŠai+bcâŒ‹âˆ´jâ‰¤ai+bcâˆ’1âˆ´jcâ‰¤ai+bâˆ’câˆ´jc&lt;ai+bâˆ’c+1âˆ´i&gt;jc+câˆ’bâˆ’1aâˆ´i&gt;âŒŠjc+câˆ’bâˆ’1aâŒ‹(1,5)\\tag{1,5} \\because j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\\\ \\therefore j\\le \\frac{ai+b}{c} -1 \\\\ \\therefore jc\\le ai+b-c \\\\ \\therefore jc &lt; ai+b-c+1\\\\ \\therefore i&gt;\\frac{jc+c-b-1}{a} \\\\ \\therefore i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor âˆµj&lt;âŒŠcai+bâ€‹âŒ‹âˆ´jâ‰¤cai+bâ€‹âˆ’1âˆ´jcâ‰¤ai+bâˆ’câˆ´jc&lt;ai+bâˆ’c+1âˆ´i&gt;ajc+câˆ’bâˆ’1â€‹âˆ´i&gt;âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹(1,5) è¿™æ ·çš„è¯åŸæ¥çš„å¼å­å°±å˜ä¸ºäº†ï¼š f(a,b,c,n)=âˆ‘i=0nâˆ‘j=0âŒŠan+bcâŒ‹âˆ’1[i&gt;âŒŠjc+câˆ’bâˆ’1aâŒ‹]=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âˆ‘i=0n[i&gt;âŒŠjc+câˆ’bâˆ’1aâŒ‹]=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âˆ‘i=âŒŠjc+câˆ’bâˆ’1aâŒ‹+1n1=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1(nâˆ’âŒŠjc+câˆ’bâˆ’1aâŒ‹)=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1nâˆ’âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âŒŠjc+câˆ’bâˆ’1aâŒ‹=âŒŠan+bcâŒ‹nâˆ’f(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1)(1,6)\\tag{1,6} \\begin{aligned} f(a,b,c,n) &amp;= \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor+1}^n1 \\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} (n-\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor) \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1}n- \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1}\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\\\ &amp;= \\lfloor\\frac{an+b}{c} \\rfloor n-f(c,c-b-1,a,\\lfloor\\frac{an+b}{c} \\rfloor-1) \\end{aligned} f(a,b,c,n)â€‹=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹[i&gt;âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹]=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i=0âˆ‘nâ€‹[i&gt;âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹]=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i=âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹+1âˆ‘nâ€‹1=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹(nâˆ’âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹)=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹nâˆ’j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹=âŒŠcan+bâ€‹âŒ‹nâˆ’f(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1)â€‹(1,6) å°†âŒŠan+bcâŒ‹\\lfloor\\frac{an+b}{c} \\rfloorâŒŠcan+bâ€‹âŒ‹è®¾ä¸ºmmmå†æ•´ç†ä¸€ä¸‹ï¼Œåˆå¾—åˆ°ä¸€ä¸ªé€’å½’å¼ï¼š f(a,b,c,n)=mnâˆ’f(c,câˆ’bâˆ’1,a,mâˆ’1)(1,7)\\tag{1,7} f(a,b,c,n)=mn-f(c,c-b-1,a,m-1) f(a,b,c,n)=mnâˆ’f(c,câˆ’bâˆ’1,a,mâˆ’1)(1,7) ç»¼ä¸Šï¼ˆ1,2ï¼‰ï¼ˆ1,6ï¼‰ï¼š f(a,b,c,n)={n(n+1)2âŒŠacâŒ‹+(n+1)âŒŠbcâŒ‹+f(a mod c,b mod c,c,n)aâ‰¥câˆ¨bâ‰¥câŒŠan+bcâŒ‹nâˆ’f(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1)a&lt;câˆ§b&lt;c(1,8)\\tag{1,8} f(a,b,c,n)= \\left\\{ \\begin{aligned} &amp; \\frac{n(n+1)}{2} \\lfloor \\frac{a}{c} \\rfloor+(n+1)\\lfloor \\frac{b}{c}\\rfloor + f(a \\bmod c,b\\bmod c,c,n) &amp;a\\ge c\\vee b \\ge c\\\\ &amp;\\lfloor\\frac{an+b}{c} \\rfloor n-f(c,c-b-1,a,\\lfloor\\frac{an+b}{c} \\rfloor-1) &amp;a&lt;c\\land b&lt;c \\end{aligned} \\right. f(a,b,c,n)=â©âªâªâ¨âªâªâ§â€‹â€‹2n(n+1)â€‹âŒŠcaâ€‹âŒ‹+(n+1)âŒŠcbâ€‹âŒ‹+f(amodc,bmodc,c,n)âŒŠcan+bâ€‹âŒ‹nâˆ’f(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1)â€‹aâ‰¥câˆ¨bâ‰¥ca&lt;câˆ§b&lt;câ€‹(1,8) å¯ä»¥åœ¨O(logâ¡n)O(\\log n)O(logn)æ—¶é—´å†…æ±‚å‡ºã€‚ é—®é¢˜2 è®¾ g(a,b,c,n)=âˆ‘i=0niâŒŠai+bcâŒ‹(2,1)\\tag{2,1} g(a,b,c,n)= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor g(a,b,c,n)=i=0âˆ‘nâ€‹iâŒŠcai+bâ€‹âŒ‹(2,1) å…¶ä¸­a,b,c,nâˆˆZa,b,c,n \\in \\mathbb{Z}a,b,c,nâˆˆZã€‚ ä¸Šä¸ªé—®é¢˜çš„å‡çº§ç‰ˆï¼Œï¼ˆä¸å°±æ˜¯å¤šäº†ä¸ªiiiå˜›ï¼Œåˆ«éª‚äº†åˆ«éª‚äº†) æ¥ç€åˆ†æƒ…å†µï¼Œaâ‰¥c,bâ‰¥ca\\ge c,b\\ge caâ‰¥c,bâ‰¥cæ—¶ï¼š g(a,b,c,n)=âˆ‘i=0niâŒŠai+bcâŒ‹=âˆ‘i=0niâŒŠ(âŒŠacâŒ‹Ã—c+a mod c)i+âŒŠbcâŒ‹Ã—c+b mod ccâŒ‹=âˆ‘i=0ni(âŒŠacâŒ‹i+âŒŠbcâŒ‹+âŒŠ(a mod c)i+b mod ccâŒ‹)=âˆ‘i=0nâŒŠacâŒ‹i2+âˆ‘i=0nâŒŠbcâŒ‹i+âˆ‘i=0nâŒŠ(a mod c)i+b mod ccâŒ‹i=n(n+1)(2n+1)6âŒŠacâŒ‹+n(n+1)2âŒŠbcâŒ‹+g(a mod c,b mod c,c,n)(2,2)\\tag{2,2} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n i \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg) \\\\ &amp;=\\sum_{i=0}^n \\lfloor \\frac{a}{c} \\rfloor i^2+\\sum_{i=0}^n \\lfloor \\frac{b}{c}\\rfloor i +\\sum_{i=0}^n \\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor i \\\\ &amp;= \\frac{n(n+1)(2n+1)}{6} \\lfloor \\frac{a}{c} \\rfloor+ \\frac{n(n+1)}{2} \\lfloor \\frac{b}{c}\\rfloor+g(a\\bmod c,b\\bmod c,c,n) \\end{aligned} g(a,b,c,n)â€‹=i=0âˆ‘nâ€‹iâŒŠcai+bâ€‹âŒ‹=i=0âˆ‘nâ€‹iâŒŠc(âŒŠcaâ€‹âŒ‹Ã—c+amodc)i+âŒŠcbâ€‹âŒ‹Ã—c+bmodcâ€‹âŒ‹=i=0âˆ‘nâ€‹i(âŒŠcaâ€‹âŒ‹i+âŒŠcbâ€‹âŒ‹+âŒŠc(amodc)i+bmodcâ€‹âŒ‹)=i=0âˆ‘nâ€‹âŒŠcaâ€‹âŒ‹i2+i=0âˆ‘nâ€‹âŒŠcbâ€‹âŒ‹i+i=0âˆ‘nâ€‹âŒŠc(amodc)i+bmodcâ€‹âŒ‹i=6n(n+1)(2n+1)â€‹âŒŠcaâ€‹âŒ‹+2n(n+1)â€‹âŒŠcbâ€‹âŒ‹+g(amodc,bmodc,c,n)â€‹(2,2) çœ‹æ¥æˆ‘ä»¬å®Œæˆäº†ä¸€åŠäº†ï¼ˆä¼¼ä¹ä¸æ˜¯ï¼‰ a&lt;c,b&lt;ca&lt;c,b&lt;ca&lt;c,b&lt;c æ—¶ï¼Œæšä¸¾è´¡çŒ®å°†å¼å­åŒ–ä¸ºï¼š g(a,b,c,n)=âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’1i(2,3)\\tag{2,3} g(a,b,c,n)=\\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} i g(a,b,c,n)=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹i(2,3) æ”¹å˜ä¸Šç•Œï¼š âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’1i=âˆ‘i=0nâˆ‘j=0âŒŠan+bcâŒ‹âˆ’1i[j&lt;âŒŠai+bcâŒ‹](2,4)\\tag{2,4} \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} i = \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} i \\bigg[j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\bigg] i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹i=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i[j&lt;âŒŠcai+bâ€‹âŒ‹](2,4) è½¬åŒ–æ¡ä»¶è¡¨è¾¾å¼ï¼š g(a,b,c,n)=âˆ‘i=0nâˆ‘j=0âŒŠan+bcâŒ‹âˆ’1i[i&gt;âŒŠjc+câˆ’bâˆ’1aâŒ‹]=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âˆ‘i=0ni[i&gt;âŒŠjc+câˆ’bâˆ’1aâŒ‹]=âˆ‘j=0âŒŠan+bcâŒ‹âˆ’1âˆ‘i=âŒŠjc+câˆ’bâˆ’1aâŒ‹+1ni(2,5)\\tag{2,5} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} i \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n i \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor+1}^n i \\\\ \\end{aligned} g(a,b,c,n)â€‹=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i[i&gt;âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹]=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i=0âˆ‘nâ€‹i[i&gt;âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹]=j=0âˆ‘âŒŠcan+bâ€‹âŒ‹âˆ’1â€‹i=âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹+1âˆ‘nâ€‹iâ€‹(2,5) è®¾k=âŒŠjc+câˆ’bâˆ’1aâŒ‹,m=âŒŠan+bcâŒ‹k=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor,m=\\lfloor \\frac{an+b}{c}\\rfloork=âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹,m=âŒŠcan+bâ€‹âŒ‹ï¼Œæ¥ç€åŒ–ç®€ï¼š g(a,b,c,n)=âˆ‘i=0mâˆ’1âˆ‘k+1ni=âˆ‘i=0mâˆ’1(nâˆ’k)(n+k+1)2=âˆ‘i=0mâˆ’1n2+nâˆ’k2âˆ’k2=12(mn2+mnâˆ’âˆ‘j=0mâˆ’1(âŒŠjc+câˆ’bâˆ’1aâŒ‹)2âˆ’âˆ‘i=0mâˆ’1âŒŠjc+câˆ’bâˆ’1aâŒ‹)(2,6)\\tag{2,6} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^{m-1}\\sum_{k+1}^ni \\\\ &amp;= \\sum_{i=0}^{m-1}\\frac{(n-k)(n+k+1)}{2} \\\\ &amp;= \\sum_{i=0}^{m-1}\\frac{n^2+n-k^2-k}{2} \\\\ &amp;= \\frac{1}{2}\\bigg(mn^2+mn-\\sum_{j=0}^{m-1}(\\lfloor\\frac{jc+c-b-1}{a}\\rfloor)^2-\\sum_{i=0}^{m-1}\\lfloor\\frac{jc+c-b-1}{a}\\rfloor\\bigg) \\end{aligned} g(a,b,c,n)â€‹=i=0âˆ‘mâˆ’1â€‹k+1âˆ‘nâ€‹i=i=0âˆ‘mâˆ’1â€‹2(nâˆ’k)(n+k+1)â€‹=i=0âˆ‘mâˆ’1â€‹2n2+nâˆ’k2âˆ’kâ€‹=21â€‹(mn2+mnâˆ’j=0âˆ‘mâˆ’1â€‹(âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹)2âˆ’i=0âˆ‘mâˆ’1â€‹âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹)â€‹(2,6) ã€‚ã€‚ã€‚å¥½åƒåŒ–çš„æ²¡é—®é¢˜å•Šï¼Œå‡ºç°äº†ä¸€ä¸ªæ²¡è§è¿‡çš„å¹³æ–¹ï¼ŒğŸ‘€ï¼Œå…ˆå®šä¹‰ä¸ºh(a,b,c,n)h(a,b,c,n)h(a,b,c,n)å§ï¼Œæ•´ç†ä¸€ä¸‹å¾—ï¼š g(a,b,c,n)={n(n+1)(2n+1)6âŒŠacâŒ‹+n(n+1)2âŒŠbcâŒ‹+g(a mod c,b mod c,c,n)aâ‰¥câˆ¨bâ‰¥c12(âŒŠan+bcâŒ‹n(n+1)âˆ’h(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1)âˆ’f(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1))a&lt;câˆ§b&lt;c(2,7)\\tag{2,7} g(a,b,c,n)= \\left\\{ \\begin{aligned} &amp; \\frac{n(n+1)(2n+1)}{6} \\lfloor \\frac{a}{c} \\rfloor+ \\frac{n(n+1)}{2} \\lfloor \\frac{b}{c}\\rfloor+g(a\\bmod c,b\\bmod c,c,n) &amp; a\\ge c\\vee b\\ge c \\\\ &amp; \\frac{1}{2}\\bigg( \\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor n(n+1) - h(c,c-b-1,a,\\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor-1)-f(c,c-b-1,a,\\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor-1)\\bigg) &amp; a&lt;c \\land b&lt;c \\end{aligned} \\right. g(a,b,c,n)=â©âªâªâ¨âªâªâ§â€‹â€‹6n(n+1)(2n+1)â€‹âŒŠcaâ€‹âŒ‹+2n(n+1)â€‹âŒŠcbâ€‹âŒ‹+g(amodc,bmodc,c,n)21â€‹(âŒŠcan+bâ€‹âŒ‹n(n+1)âˆ’h(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1)âˆ’f(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1))â€‹aâ‰¥câˆ¨bâ‰¥ca&lt;câˆ§b&lt;câ€‹(2,7) æ¥ä¸‹æ¥è§£å†³å¸¦å¹³æ–¹çš„é—®é¢˜ã€‚ é—®é¢˜3 è®¾ h(a,b,c,n)=âˆ‘i=0n(âŒŠai+bcâŒ‹)2(3,1)\\tag{3,1} h(a,b,c,n)=\\sum_{i=0}^n \\bigg(\\bigg\\lfloor \\frac{ai+b}{c}\\bigg\\rfloor \\bigg)^2 h(a,b,c,n)=i=0âˆ‘nâ€‹(âŒŠcai+bâ€‹âŒ‹)2(3,1) å…¶ä¸­a,b,c,nâˆˆZa,b,c,n \\in \\mathbb{Z}a,b,c,nâˆˆZã€‚ ä¸Šä¸ªé—®é¢˜è¿˜æ²¡æœ‰å®Œå…¨è§£å†³ï¼Œéœ€è¦è§£å‡ºh(a,b,c,n)h(a,b,c,n)h(a,b,c,n)ï¼Œï¼ˆä¸å°±å¤šäº†ä¸ªå¹³æ–¹å˜›ï¼Œè½»è½¦ç†Ÿè·¯äº†ï¼Œåˆ«æ‰“äº†åˆ«æ‰“äº†ï¼‰ h(a,b,c,n)=âˆ‘i=0n(âŒŠai+bcâŒ‹)2=âˆ‘i=0n(âŒŠ(âŒŠacâŒ‹Ã—c+a mod c)i+âŒŠbcâŒ‹Ã—c+b mod ccâŒ‹)2=âˆ‘i=0n(âŒŠacâŒ‹i+âŒŠbcâŒ‹+âŒŠ(a mod c)i+b mod ccâŒ‹)2(3,2)\\tag{3,2} \\begin{aligned} h(a,b,c,n) &amp;= \\sum_{i=0}^n \\bigg(\\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor\\bigg)^2\\\\ &amp;= \\sum_{i=0}^n \\bigg(\\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\bigg)^2\\\\ &amp;= \\sum_{i=0}^n \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg)^2 \\\\ \\end{aligned} h(a,b,c,n)â€‹=i=0âˆ‘nâ€‹(âŒŠcai+bâ€‹âŒ‹)2=i=0âˆ‘nâ€‹(âŒŠc(âŒŠcaâ€‹âŒ‹Ã—c+amodc)i+âŒŠcbâ€‹âŒ‹Ã—c+bmodcâ€‹âŒ‹)2=i=0âˆ‘nâ€‹(âŒŠcaâ€‹âŒ‹i+âŒŠcbâ€‹âŒ‹+âŒŠc(amodc)i+bmodcâ€‹âŒ‹)2â€‹(3,2) æ‰‹åŠ¨å¤šé¡¹å¼ä¹˜æ³•ï¼ åŸå¼å˜ä¸ºï¼š h(a,b,c,n)=h(a mod c,b mod c,c,n)+2âŒŠbcâŒ‹f(a mod c,b mod c,c,n)+2âŒŠacâŒ‹g(a mod c,b mod c,c,n)+âŒŠacâŒ‹2n(n+1)(2n+1)6+âŒŠbcâŒ‹2(n+1)+âŒŠacâŒ‹âŒŠbcâŒ‹n(n+1)(3,3)\\tag{3,3} h(a,b,c,n) =h(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{b}{c}\\right\\rfloor f(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{a}{c}\\right\\rfloor g(a\\bmod c,b\\bmod c,c,n) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2(n+1) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor n(n+1) h(a,b,c,n)=h(amodc,bmodc,c,n)+2âŒŠcbâ€‹âŒ‹f(amodc,bmodc,c,n)+2âŒŠcaâ€‹âŒ‹g(amodc,bmodc,c,n)+âŒŠcaâ€‹âŒ‹26n(n+1)(2n+1)â€‹+âŒŠcbâ€‹âŒ‹2(n+1)+âŒŠcaâ€‹âŒ‹âŒŠcbâ€‹âŒ‹n(n+1)(3,3) æ¥ç€è€ƒè™‘a&lt;c,b&lt;ca&lt;c,b&lt;ca&lt;c,b&lt;cçš„æƒ…å†µï¼Œè®¾k=âŒŠjc+câˆ’bâˆ’1aâŒ‹,m=âŒŠan+bcâŒ‹k=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor,m=\\lfloor \\frac{an+b}{c}\\rfloork=âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹,m=âŒŠcan+bâ€‹âŒ‹ï¼Œ å¹³æ–¹å¯ä»¥æ‹†æˆï¼š n2=2n(n+1)2âˆ’n=(2âˆ‘i=0ni)âˆ’n(3,3)\\tag{3,3} n^2=2\\frac{n(n+1)}{2}-n=\\bigg( 2\\sum_{i=0}^n i\\bigg) -n n2=22n(n+1)â€‹âˆ’n=(2i=0âˆ‘nâ€‹i)âˆ’n(3,3) é¿å…äº†å‡ºç°âˆ‘Ã—âˆ‘\\sum \\times \\sumâˆ‘Ã—âˆ‘ï¼Œç¥ä¸€æ ·çš„æ•°å­¦æŠ€å·§ h(a,b,c,n)=âˆ‘i=0nâŒŠai+bcâŒ‹2=âˆ‘i=0n[(2âˆ‘j=1âŒŠai+bcâŒ‹j)âˆ’âŒŠai+bcâŒ‹]=(2âˆ‘i=0nâˆ‘j=1âŒŠai+bcâŒ‹j)âˆ’f(a,b,c,n)(3,4)\\tag{3,4} \\begin{aligned} h(a,b,c,n) &amp;=\\sum_{i=0}^n\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor^2 \\\\ &amp;=\\sum_{i=0}^n\\left[\\left(2\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j \\right)-\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\right]\\\\ &amp;=\\left(2\\sum_{i=0}^n\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j\\right) -f(a,b,c,n)\\\\ \\end{aligned} h(a,b,c,n)â€‹=i=0âˆ‘nâ€‹âŒŠcai+bâ€‹âŒ‹2=i=0âˆ‘nâ€‹â£â¢â¡â€‹ââœâ›â€‹2j=1âˆ‘âŒŠcai+bâ€‹âŒ‹â€‹jâ âŸââ€‹âˆ’âŒŠcai+bâ€‹âŒ‹â¦â¥â¤â€‹=ââœâ›â€‹2i=0âˆ‘nâ€‹j=1âˆ‘âŒŠcai+bâ€‹âŒ‹â€‹jâ âŸââ€‹âˆ’f(a,b,c,n)â€‹(3,4) æ¥ç€åŒ–ç®€å‰é¢çš„éƒ¨åˆ†ï¼š âˆ‘i=0nâˆ‘j=1âŒŠai+bcâŒ‹j=âˆ‘i=0nâˆ‘j=0âŒŠai+bcâŒ‹âˆ’1(j+1)=âˆ‘j=0mâˆ’1(j+1)âˆ‘i=0n[j&lt;âŒŠai+bcâŒ‹]=âˆ‘j=0mâˆ’1(j+1)âˆ‘i=0n[i&gt;k]=âˆ‘j=0mâˆ’1(j+1)(nâˆ’k)=12nm(m+1)âˆ’âˆ‘j=0mâˆ’1(j+1)âŒŠjc+câˆ’bâˆ’1aâŒ‹=12nm(m+1)âˆ’g(c,câˆ’bâˆ’1,a,mâˆ’1)âˆ’f(c,câˆ’bâˆ’1,a,mâˆ’1)(3,5)\\tag{3,5} \\begin{aligned} \\sum_{i=0}^n\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1}(j+1)\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^n\\left[j&lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^n[i&gt;k]\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)(n-k)\\\\ &amp;=\\frac{1}{2}nm(m+1)-\\sum_{j=0}^{m-1}(j+1)\\left\\lfloor \\frac{jc+c-b-1}{a} \\right\\rfloor\\\\ &amp;=\\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1) \\end{aligned} i=0âˆ‘nâ€‹j=1âˆ‘âŒŠcai+bâ€‹âŒ‹â€‹jâ€‹=i=0âˆ‘nâ€‹j=0âˆ‘âŒŠcai+bâ€‹âŒ‹âˆ’1â€‹(j+1)=j=0âˆ‘mâˆ’1â€‹(j+1)i=0âˆ‘nâ€‹[j&lt;âŒŠcai+bâ€‹âŒ‹]=j=0âˆ‘mâˆ’1â€‹(j+1)i=0âˆ‘nâ€‹[i&gt;k]=j=0âˆ‘mâˆ’1â€‹(j+1)(nâˆ’k)=21â€‹nm(m+1)âˆ’j=0âˆ‘mâˆ’1â€‹(j+1)âŒŠajc+câˆ’bâˆ’1â€‹âŒ‹=21â€‹nm(m+1)âˆ’g(c,câˆ’bâˆ’1,a,mâˆ’1)âˆ’f(c,câˆ’bâˆ’1,a,mâˆ’1)â€‹(3,5) æ•´ç†ä¸€ä¸‹ï¼š h(a,b,c,n)={h(a mod c,b mod c,c,n)+2âŒŠbcâŒ‹f(a mod c,b mod c,c,n)+2âŒŠacâŒ‹g(a mod c,b mod c,c,n)+âŒŠacâŒ‹2n(n+1)(2n+1)6+âŒŠbcâŒ‹2(n+1)+âŒŠacâŒ‹âŒŠbcâŒ‹n(n+1)aâ‰¥câˆ¨bâ‰¥cnâŒŠan+bcâŒ‹(âŒŠan+bcâŒ‹+1)âˆ’2g(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1)âˆ’2f(c,câˆ’bâˆ’1,a,âŒŠan+bcâŒ‹âˆ’1)âˆ’f(a,b,c,n)a&lt;câˆ§b&lt;c(3,6)\\tag{3,6} h(a,b,c,n)= \\left\\{ \\begin{aligned} &amp;h(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{b}{c}\\right\\rfloor f(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{a}{c}\\right\\rfloor g(a\\bmod c,b\\bmod c,c,n) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2(n+1) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor n(n+1) &amp; a\\ge c \\vee b\\ge c \\\\ &amp; n\\lfloor \\frac{an+b}{c}\\rfloor(\\lfloor \\frac{an+b}{c}\\rfloor+1)-2g(c,c-b-1,a,\\lfloor \\frac{an+b}{c}\\rfloor-1)-2f(c,c-b-1,a,\\lfloor \\frac{an+b}{c}\\rfloor-1)-f(a,b,c,n) &amp; a&lt;c \\land b&lt;c \\end{aligned} \\right. h(a,b,c,n)=â©âªâªâ¨âªâªâ§â€‹â€‹h(amodc,bmodc,c,n)+2âŒŠcbâ€‹âŒ‹f(amodc,bmodc,c,n)+2âŒŠcaâ€‹âŒ‹g(amodc,bmodc,c,n)+âŒŠcaâ€‹âŒ‹26n(n+1)(2n+1)â€‹+âŒŠcbâ€‹âŒ‹2(n+1)+âŒŠcaâ€‹âŒ‹âŒŠcbâ€‹âŒ‹n(n+1)nâŒŠcan+bâ€‹âŒ‹(âŒŠcan+bâ€‹âŒ‹+1)âˆ’2g(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1)âˆ’2f(c,câˆ’bâˆ’1,a,âŒŠcan+bâ€‹âŒ‹âˆ’1)âˆ’f(a,b,c,n)â€‹aâ‰¥câˆ¨bâ‰¥ca&lt;câˆ§b&lt;câ€‹(3,6) æ—¶é—´å¤æ‚åº¦å‡ä¸ºO(logâ¡n)O(\\log n)O(logn)ï¼ åå¯„ æ¨å®Œåäººå‚»äº†ğŸ˜±ğŸ˜±ğŸ˜±ï¼Œæ¨hhhååŠéƒ¨åˆ†çš„æ—¶å€™ç…§ç€OIWikiæ‰“çš„ï¼Œæˆ‘å¤ªèœäº†ï¼Œå‘œå‘œå‘œ~ã€‚","link":"/2022/07/24/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"},{"title":"è™šæ ‘","text":"è™šæ ‘è®²è§£ è™šæ ‘ å‰è¨€ åœ¨ä¸€äº›æ ‘å½¢dpçš„é¢˜ç›®ä¸­ï¼Œæœ‰çš„é¢˜ç›®ä¼šå‡ºç°å…³é”®ç‚¹çš„è¦æ±‚ï¼Œæ­¤æ—¶æ•°æ®èŒƒå›´ä¼šå’Œè¯¢é—®çš„æ€»ä¸ªæ•°æœ‰å…³ï¼Œè¿™ç±»é—®é¢˜æ¯æ¬¡è·‘ä¸€è¾¹æ ‘å½¢dpå¤æ‚åº¦ä¸ä¼˜ï¼Œè™šæ ‘å¯ä»¥å°†å¤æ‚åº¦é™è‡³O(âˆ‘ki)O(\\sum k_i)O(âˆ‘kiâ€‹)ï¼Œæ¥è§£å†³é—®é¢˜ã€‚ æ­£æ–‡ è™šæ ‘ è™šæ ‘å…¶å®å°±æ˜¯å¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œåªä¿ç•™äº†æœ‰ç”¨çš„å…³é”®èŠ‚ç‚¹å»ºå‡ºæ¥çš„æ ‘å½¢ç»“æ„ï¼Œå¯ä»¥æœ‰æ•ˆçš„é™ä½æ—¶é—´å¤æ‚åº¦ã€‚ è™šæ ‘çš„æ„å»º å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰kkkä¸ªå…³é”®ç‚¹ï¼Œå¯¹å…¶å»ºæˆä¸€æ£µè™šæ ‘çš„æ“ä½œå¦‚ä¸‹ã€‚ å°†å…³é”®ç‚¹æŒ‰dfsåºæ’åº éå†ä¸€éï¼Œæ±‚å‡ºç›¸é‚»ä¸¤ä¸ªå…³é”®ç‚¹çš„LCA æ ¹æ®åŸæ ‘ä¸­çš„èŠ‚ç‚¹å…³ç³»å»ºæ ‘ è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ä½¿ç”¨å•è°ƒæ ˆæ¥å®ç°ã€‚ é¦–å…ˆå°†æ ¹èŠ‚ç‚¹åŠ å…¥å•è°ƒæ ˆä¸­ï¼ŒæŒ‰dfsåºæ’åºåé€ä¸ªåŠ å…¥å½“å‰è¯¢é—®ä¸­çš„å…³é”®ç‚¹ï¼Œå‡è®¾å½“å‰åŠ å…¥çš„ç‚¹ä¸ºkik_ikiâ€‹ï¼Œå…ˆæ±‚å‡ºkik_ikiâ€‹å’Œå½“å‰æ ˆé¡¶çš„LCAï¼Œå¦‚æœå½“å‰çš„æ ˆé¡¶å…ƒç´ å’Œæ±‚å‡ºçš„LCAä¸åŒï¼Œè¯´æ˜æ–°åŠ å…¥çš„å…ƒç´ ä¸åœ¨å½“å‰çš„å­æ ‘ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æŒ‰dfsåºæ‰¾åˆ°LCAåœ¨æ ˆä¸­çš„ä½ç½®ï¼Œå°†dfsåºå¤§äºLCAçš„å¼¹å‡ºæ ˆåŒæ—¶è¿›è¡Œè¿è¾¹æ“ä½œã€‚å¦‚æœLCAä¸åœ¨æ ˆä¸­éœ€è¦å°†å…¶åŠ å…¥æ ˆä¸­ï¼Œæœ€ååŠ å…¥å½“å‰èŠ‚ç‚¹ï¼Œå¤„ç†å®Œåï¼Œè¿˜éœ€è¦å°†æœ€åæ ˆä¸­å­˜ä¸‹çš„èŠ‚ç‚¹ä¹‹é—´å»ºå¥½è¾¹ã€‚ é€šè¿‡ä¸Šè¿°è¿‡ç¨‹ï¼Œä¸éš¾çœ‹å‡ºæ ˆä¸­ç»´æŠ¤çš„æ˜¯ä¸€æ¡åˆ°æ ˆé¡¶å…ƒç´ çš„é“¾ï¼Œå»ºå¥½è™šæ ‘åï¼Œå°±å¯ä»¥åœ¨ä¸Šé¢dpäº†ï¼Œæ—¶é—´å¤æ‚åº¦O(âˆ‘(klogâ¡k+klogâ¡n))O(\\sum(k \\log k + k \\log n))O(âˆ‘(klogk+klogn))ã€‚ ä»£ç å¦‚ä¸‹ï¼Œ 1234567891011121314151617181920212223242526272829bool cmp(int x, int y){ return dfn[x] &lt; dfn[y];}void insert(int x){ if(st[top] == x)return; int lca = LCA(x, st[top]); if(lca != st[top]) { while(dfn[lca] &lt; dfn[st[top - 1]]) add(st[top - 1], st[top]), top--; if(dfn[lca] &gt; dfn[st[top - 1]]) add(lca, st[top]), st[top] = lca; else add(lca, st[top--]); } st[++top] = x;}void build(int n){ sort(k + 1, k + n + 1, cmp); st[++top] = 1; for(int i = 1; i &lt;= n; i++) insert(k[i]); for(int i = 1; i &lt; top; i++) add(st[i], st[i + 1]);} è¯´å®è¯æˆ‘ä¸ä¼šäº”è¡Œå»ºè™šæ ‘ã€‚ åº”ç”¨ P2495 æ¶ˆè€—æˆ˜ é¦–å…ˆè€ƒè™‘è½¬ç§»æ–¹ç¨‹ä¸éš¾å¾—åˆ°ï¼Œè®¾fxf_xfxâ€‹è¡¨ç¤ºä½¿xxxä¸ä¸å…¶å­æ ‘ä¸­ä»»æ„ä¸€ä¸ªå…³é”®ç‚¹è¿é€šçš„æœ€å°ä»£ä»·ï¼Œæšä¸¾å…¶å­èŠ‚ç‚¹ï¼Œ è‹¥vvvæ˜¯å…³é”®ç‚¹ï¼Œfx=fx+w(x,v)f_x = f_x + w(x, v)fxâ€‹=fxâ€‹+w(x,v) è‹¥vvvä¸æ˜¯å…³é”®ç‚¹ï¼Œfx=fx+minâ¡{fv,w(x,v)}f_x = f_x + \\min\\{f_v, w(x, v)\\}fxâ€‹=fxâ€‹+min{fvâ€‹,w(x,v)} è¿™æ ·æ¯æ¬¡è·‘ä¸€éæ˜¯O(nq)O(nq)O(nq)çš„ï¼Œè€ƒè™‘æ¯æ¬¡å»ºå‡ºè™šæ ‘æ¥ç›´æ¥åœ¨è™šæ ‘ä¸Šè½¬ç§»å³å¯ä¼˜åŒ–å¤æ‚åº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2.5e5 + 10;const int M = 5e5 + 10;const int INF = 1e15;int n, m;int cnt, head[N];struct edge{ int to, nxt, cost; edge(int _v = 0, int _n = 0, int _c = 0): to(_v), nxt(_n), cost(_c) {}}e[M &lt;&lt; 1];void add(int u, int v, int c){ e[++cnt] = edge(v, head[u], c); head[u] = cnt;}int tot;int siz[N], fa[N], top[N], son[N], depth[N], id[N];int Min[N];void dfs1(int x, int father){ siz[x] = 1; fa[x] = father; depth[x] = depth[father] + 1; int maxs = -1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; int c = e[i].cost; if(v == father)continue; Min[v] = min(Min[x], c); dfs1(v, x); siz[x] += siz[v]; if(siz[v] &gt; maxs) maxs = siz[v], son[x] = v; }}void dfs2(int x, int topfather){ id[x] = ++tot; top[x] = topfather; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x])continue; dfs2(v, v); }}int LCA(int x, int y){ while(top[x] != top[y]) { if(depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } if(depth[x] &gt; depth[y])swap(x, y); return x;}int st[N];vector&lt;int&gt; v[N];void calc(int x){ if(tot == 1) { st[++tot] = x; return; } int lca = LCA(x, st[tot]); if(lca == st[tot])return; while(tot &gt; 1 &amp;&amp; id[st[tot-1]] &gt;= id[lca]) { v[st[tot-1]].push_back(st[tot]); tot--; } if(st[tot] != lca) { v[lca].push_back(st[tot]); st[tot] = lca; } st[++tot] = x;}int dp(int x){ if(!v[x].size())return Min[x]; int sum = 0; for(int i = 0; i &lt; v[x].size(); i++) sum += dp(v[x][i]); v[x].clear(); return min(Min[x], sum);}int a[N];bool cmp(int x, int y){ return id[x] &lt; id[y];}signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y, z; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); } Min[1] = INF; dfs1(1, 0); dfs2(1, 1); int T; tot = 0; scanf(&quot;%lld&quot;, &amp;T); while(T--) { int m; scanf(&quot;%lld&quot;, &amp;m); for(int i = 1; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a+1, a+m+1, cmp); st[++tot] = 1; for(int i = 1; i &lt;= m; i++)calc(a[i]); while(tot) { v[st[tot-1]].push_back(st[tot]); tot--; } printf(&quot;%lld\\n&quot;, dp(1)); } return 0;} CF613D Kingdom and its Cities é¦–å…ˆè€ƒè™‘å¦‚ä½•è½¬ç§»ï¼Œæ˜¾ç„¶å°±æ˜¯åˆ†ä¸€ä¸‹æƒ…å†µè®¾fxf_xfxâ€‹è¡¨ç¤ºè®©ä»¥xxxçš„å­æ ‘ä¸­è¯¢é—®ç‚¹ä¸è¿é€šçš„æœ€å°‘èŠ±è´¹ï¼Œgxg_xgxâ€‹è¡¨ç¤ºå½“å‰å­æ ‘ä¸­è¿˜æœ‰å¤šå°‘ä¸ªéœ€è¦æ–­å¼€çš„è¯¢é—®ç‚¹ å½“å‰ç‚¹æ˜¯è¯¢é—®ç‚¹æ—¶ï¼Œfx=fx+gx,gx=1f_x = f_x + g_x, g_x = 1fxâ€‹=fxâ€‹+gxâ€‹,gxâ€‹=1 å½“å‰ç‚¹ä¸æ˜¯è¯¢é—®ç‚¹æ—¶ï¼Œfx=fx+1,gx=0f_x = f_x + 1, g_x = 0fxâ€‹=fxâ€‹+1,gxâ€‹=0 ç„¶åå»ºå‡ºè™šæ ‘è½¬ç§»å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, q;int k[N], b[N];int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int tim, dfn[N];int depth[N], top[N], son[N], siz[N], fa[N];void dfs1(int x, int father){ dfn[x] = ++tim; fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[v] &gt; siz[son[x]]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}int LCA(int x, int y){ while(top[x] != top[y]) { if(depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } if(depth[x] &gt; depth[y]) swap(x, y); return x;}int st[N], t;int f[N], h[N], c[N];vector &lt;int&gt; g[N];void link(int x, int y){ g[x].push_back(y);}void clear(int x){ f[x] = h[x] = c[x] = 0; g[x].clear();}void insert(int x){ if(st[t] == x)return; int lca = LCA(st[t], x); if(lca != st[t]) { while(dfn[lca] &lt; dfn[st[t - 1]]) link(st[t - 1], st[t]), t--; if(dfn[lca] &gt; dfn[st[t - 1]]) clear(lca), link(lca, st[t]), st[t] = lca; else link(lca, st[t--]); } st[++t] = x; clear(x);}bool cmp(int x, int y){ return dfn[x] &lt; dfn[y];}void build(int n){ sort(k + 1, k + n + 1, cmp); t = 0; st[++t] = 1; clear(1); for(int i = 1; i &lt;= n; i++) insert(k[i]); for(int i = 1; i &lt; t; i++) link(st[i], st[i + 1]);}void dp(int x, int fa){ for(auto v : g[x]) { dp(v, x); f[x] += f[v]; h[x] += h[v]; } if(f[x] == -1)return; if(b[x])f[x] += h[x], h[x] = 1; else if(h[x] &gt; 1)f[x]++, h[x] = 0;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 0); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; i++) { int m; scanf(&quot;%d&quot;, &amp;m); for(int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;k[j]), b[k[j]] = 1; bool flag = true; for(int j = 1; j &lt;= m; j++) { if(b[fa[k[j]]] &amp;&amp; k[j] != 1) { printf(&quot;-1\\n&quot;); flag = false; break; } } if(flag){build(m); dp(1, 0); printf(&quot;%d\\n&quot;, f[1]);} for(int j = 1; j &lt;= m; j++) b[k[j]] = 0; } return 0;} åè®° ä¸ç®—éš¾ï¼Œï¼ˆéš¾çš„æ˜¯çœŸçš„éš¾ã€‚","link":"/2022/11/07/%E8%99%9A%E6%A0%91/"},{"title":"è®¡ç®—å‡ ä½•","text":"çœŸçš„æ˜¯è¶…è¯¦ç»†çš„è®¡ç®—å‡ ä½•å…¨å®¶æ¡¶å“¦ï¼ãƒ¾(â‰§â–½â‰¦*)o updï¼š2022-7-25 åˆè¿›è¡Œäº†ä¸€äº›ä¿®ä¿®è¡¥è¡¥ï¼Œå†…å®¹æ›´å¤šäº†ï¼Œä½†æˆ‘è¿˜æ˜¯è’Ÿè’»ã€‚ å¦å¤–è¿™ç¯‡æ–‡ç« çš„ä»£ç è¿‡äºæ¶è‡­ï¼Œè¯·è§è°…ã€‚ è®¡ç®—å‡ ä½• å‰ç½®çŸ¥è¯† å¯ä»¥åœ¨äºŒç»´ç”Ÿç‰©å’Œä¸‰ç»´ç”Ÿç‰©ä¹‹é—´è‡ªç”±è½¬æ¢ å‰è¨€ è®¡ç®—å‡ ä½•çš„è¯ä¼°è®¡å¾ˆä¹…å°±å·²ç»ä¸è€ƒäº†å§ï¼Œä½†å­¦ä¸€å­¦çš„è¯ï¼Œä¼¼ä¹ä¹Ÿæ˜¯æ— æ‰€è°“æœ‰ä¹Ÿæ— æ‰€è°“æ— çš„å§å¾ˆæœ‰å¥½å¤„çš„ï¼Œï¼ˆæ¯•ç«Ÿå¯ä»¥æ°´é¢˜ï¼‰ã€‚ è®¡ç®—å‡ ä½• å®šä¹‰ï¼šå¯¹å‡ ä½•å¤–å½¢ä¿¡æ¯çš„è®¡ç®—æœºè¡¨ç¤ºåˆ†æã€‚ï¼ˆå…¶å®å°±æ˜¯åˆ©ç”¨è®¡ç®—æœºå»ºç«‹æ•°å­¦æ¨¡å‹è§£å†³å‡ ä½•é—®é¢˜ã€‚ï¼‰ è®¡ç®—å‡ ä½•ç ”ç©¶çš„å¯¹è±¡æ˜¯å‡ ä½•å›¾å½¢ã€‚æ—©æœŸäººä»¬å¯¹äºå›¾åƒçš„ç ”ç©¶ä¸€èˆ¬éƒ½æ˜¯å…ˆå»ºç«‹åæ ‡ç³»ï¼ŒæŠŠå›¾å½¢è½¬æ¢æˆå‡½æ•°ï¼Œç„¶åç”¨æ’å€¼å’Œé€¼è¿‘çš„æ•°å­¦æ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯ç”¨æ ·æ¡å‡½æ•°ä½œä¸ºå·¥å…·æ¥åˆ†æå›¾å½¢ï¼Œå–å¾—äº†å¯å–œçš„æˆåŠŸã€‚ç„¶è€Œï¼Œè¿™äº›æ–¹æ³•è¿‡å¤šåœ°ä¾èµ–äºåæ ‡ç³»çš„é€‰å–ï¼Œç¼ºä¹å‡ ä½•ä¸å˜æ€§ï¼Œç‰¹åˆ«æ˜¯ç”¨æ¥è§£å†³æŸäº›å¤§æŒ åº¦æ›²çº¿åŠæ›²çº¿çš„å¥‡å¼‚ç‚¹ç­‰é—®é¢˜æ—¶ï¼Œæœ‰ä¸€å®šçš„å±€é™æ€§ã€‚ äºŒç»´è®¡ç®—å‡ ä½•åŸºç¡€ å¹³é¢ç›´è§’åæ ‡ç³» å¹³é¢ç›´è§’åæ ‡ç³»å…¶å®å°±æ˜¯ç¬›å¡å°”åæ ‡ç³»ï¼Œåœ¨è®¡ç®—å‡ ä½•ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šç”¨åˆ°åæ ‡è¡¨ç¤ºï¼Œç‚¹å’Œå‘é‡éƒ½æ˜¯é€šè¿‡åæ ‡æ¥ä¿å­˜çš„ã€‚ æåæ ‡ç³» æè§’åæ ‡ç³»ï¼Œæ˜¯æŒ‡åœ¨å¹³é¢å†…ç”±æç‚¹ï¼Œæè½´å’Œæå¾„ç»„æˆçš„åæ ‡ç³»ã€‚ å…¶å®æç‚¹å°±æ˜¯å¯¹åº”å¹³é¢ç›´è§’åæ ‡ç³»ä¸­çš„åŸç‚¹ï¼Œæè½´å¯¹åº”çš„å°±æ˜¯xxxæ­£åŠè½´ï¼ˆä¼¼ä¹ä¸å¤ªä¸¥è°¨ï¼‰ï¼Œåˆ©ç”¨ä¸€ä¸ªæœ‰åºç‚¹å¯¹P(d,Î¸)P(d,\\theta)P(d,Î¸)æ¥è¡¨ç¤ºä¸€ä¸ªç‚¹ï¼Œdddå°±æ˜¯å¯¹åº”çš„æå¾„ï¼ŒÎ¸\\thetaÎ¸ä¸ºä¸æè½´çš„å¤¹è§’ï¼Œï¼ˆå…¶å®å’Œå¹³é¢ç›´è§’åæ ‡ç³»æ²¡å•¥åŒºåˆ«ï¼‰ å‘é‡åŠå…¶è¿ç®— å‘é‡çš„åŸºç¡€çŸ¥è¯† å‘é‡ï¼ˆä¹Ÿç§°ä¸ºæ¬§å‡ é‡Œå¾—å‘é‡ã€å‡ ä½•å‘é‡ã€çŸ¢é‡ï¼‰ï¼šæ—¢æœ‰å¤§å°åˆæœ‰æ–¹å‘çš„é‡ç§°ä¸ºå‘é‡ã€‚åœ¨æ•°å­¦ä¸­ç ”ç©¶çš„å‘é‡ä¸ºè‡ªç”±å‘é‡ï¼Œå³åªè¦ä¸æ”¹å˜å®ƒçš„å¤§å°å’Œæ–¹å‘ï¼Œèµ·ç‚¹å’Œç»ˆç‚¹å¯ä»¥ä»»æ„å¹³è¡Œç§»åŠ¨çš„å‘é‡ã€‚è®°aâƒ—\\vec{a}aæˆ–aã€‚ æœ‰å‘çº¿æ®µï¼šå¸¦æœ‰æ–¹å‘çš„çº¿æ®µç§°ä¸ºæœ‰å‘çº¿æ®µã€‚æœ‰å‘çº¿æ®µä¸‰è¦ç´ ï¼šèµ·ç‚¹ï¼Œæ–¹å‘ï¼Œé•¿åº¦ï¼Œæœ‰äº†ä¸‰è¦ç´ ï¼Œç»ˆç‚¹å°±å”¯ä¸€ç¡®å®šã€‚æˆ‘ä»¬ç”¨æœ‰å‘çº¿æ®µè¡¨ç¤ºå‘é‡ã€‚ å‘é‡çš„æ¨¡ï¼šæœ‰å‘çº¿æ®µABâ†’\\overrightarrow{AB}ABçš„é•¿åº¦ç§°ä¸ºå‘é‡çš„æ¨¡ï¼Œå…¶å®å°±æ˜¯å‘é‡çš„å¤§å°ã€‚å³ä¸ºâˆ£ABâ†’âˆ£|\\overrightarrow{AB}|âˆ£ABâˆ£æˆ–âˆ£aâƒ—âˆ£|\\vec{a}|âˆ£aâˆ£ã€‚ é›¶å‘é‡ï¼šæ¨¡ä¸ºé›¶çš„å‘é‡ã€‚é›¶å‘é‡çš„æ–¹å‘ä»»æ„ã€‚ å•ä½å‘é‡ï¼šæ¨¡ä¸º 1 çš„å‘é‡ç§°ä¸ºè¯¥æ–¹å‘ä¸Šçš„å•ä½å‘é‡ã€‚ å¹³è¡Œå‘é‡ï¼šæ–¹å‘ç›¸åŒæˆ–ç›¸åçš„ä¸¤ä¸ªéé›¶å‘é‡ã€‚è®°ä½œaâˆ¥ba\\parallel baâˆ¥bã€‚å¯¹äºå¤šä¸ªäº’ç›¸å¹³è¡Œçš„å‘é‡ï¼Œå¯ä»¥ä»»ä½œä¸€æ¡ç›´çº¿ä¸è¿™äº›å‘é‡å¹³è¡Œï¼Œé‚£ä¹ˆä»»ä¸€ç»„å¹³è¡Œå‘é‡éƒ½å¯ä»¥å¹³ç§»åˆ°åŒä¸€ç›´çº¿ä¸Šï¼Œæ‰€ä»¥å¹³è¡Œå‘é‡åˆå«å…±çº¿å‘é‡ã€‚ æ»‘åŠ¨å‘é‡ï¼šæ²¿ç€ç›´çº¿ä½œç”¨çš„å‘é‡ç§°ä¸ºæ»‘åŠ¨å‘é‡ã€‚ å›ºå®šå‘é‡ï¼šä½œç”¨äºä¸€ç‚¹çš„å‘é‡ç§°ä¸ºå›ºå®šå‘é‡ã€‚ ç›¸ç­‰å‘é‡ï¼šæ¨¡ç›¸ç­‰ä¸”æ–¹å‘ç›¸åŒçš„å‘é‡ã€‚ ç›¸åå‘é‡ï¼šæ¨¡ç›¸ç­‰ä¸”æ–¹å‘ç›¸åçš„å‘é‡ã€‚ å‘é‡çš„å¤¹è§’ï¼šå·²çŸ¥ä¸¤ä¸ªéé›¶å‘é‡ aâƒ—,bâƒ—\\vec{a},\\vec{b}a,b, ä½œOAâ†’=aâƒ—,OBâ†’=bâƒ—\\overrightarrow{OA}=\\vec{a},\\overrightarrow{OB}=\\vec{b}OA=a,OB=bï¼Œ é‚£ä¹ˆå‘é‡ aâƒ—\\vec{a}aä¸å‘é‡ bâƒ—\\vec{b}b çš„å¤¹è§’ã€‚è®°ä½œï¼šâŸ¨a,bâŸ©\\left\\langle a,b \\right\\rangleâŸ¨a,bâŸ©ï¼Œæ˜¾ç„¶å½“ Î¸=0\\theta=0Î¸=0 æ—¶ï¼Œä¸¤å‘é‡åŒå‘ï¼Œ Î¸=Ï€\\theta= \\piÎ¸=Ï€ æ—¶ä¸¤å‘é‡åå‘ï¼ŒÎ¸=Ï€2\\theta = \\frac{\\pi}{2}Î¸=2Ï€â€‹ æ—¶ï¼Œä¸¤å‘é‡å‚ç›´ï¼Œè®°ä½œ aâƒ—âŠ¥bâƒ—\\vec{a} \\perp \\vec{b}aâŠ¥b ã€‚å¹¶ä¸”æˆ‘ä»¬è§„å®š Î¸âˆˆ[0,Ï€]\\theta \\in [0,\\pi]Î¸âˆˆ[0,Ï€] ã€‚ æ³¨æ„ï¼šå¹³é¢å‘é‡å…·æœ‰æ–¹å‘æ€§ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½æ¯”è¾ƒä¸¤ä¸ªå‘é‡çš„å¤§å°ï¼ˆä½†å¯ä»¥æ¯”è¾ƒä¸¤å‘é‡çš„æ¨¡é•¿ï¼‰ã€‚ä½†æ˜¯ä¸¤ä¸ªå‘é‡å¯ä»¥ç›¸ç­‰ã€‚ å‘é‡çš„è¿ç®— è®¾aâƒ—=(x1,y1)\\vec{a}=(x_1,y_1)a=(x1â€‹,y1â€‹),bâƒ—=(x2,y2)\\vec{b}=(x_2,y_2)b=(x2â€‹,y2â€‹)ã€‚ åŠ å‡æ³• æ—¢ç„¶å‘é‡å…·æœ‰å¹³ç§»ä¸å˜æ€§ï¼Œé‚£ä¹ˆaâƒ—+bâƒ—\\vec{a}+\\vec{b}a+bå°±æ˜¯å°†ä¸¤æ¡æœ‰å‘çº¿æ®µç›¸è¿ï¼Œå³:aâƒ—+bâƒ—=(x1+x2,y1+y2)\\vec{a}+\\vec{b}=(x_1+x_2,y_1+y_2)a+b=(x1â€‹+x2â€‹,y1â€‹+y2â€‹)ã€‚ é‚£å‘é‡çš„å‡æ³•aâƒ—âˆ’bâƒ—\\vec{a}-\\vec{b}aâˆ’bï¼Œå…¶å®å°±æ˜¯aâƒ—+(âˆ’bâƒ—)\\vec{a}+(-\\vec{b})a+(âˆ’b),å³aâƒ—âˆ’bâƒ—=(x1âˆ’x2,y1âˆ’y2)\\vec{a}-\\vec{b}=(x_1-x_2,y_1-y_2)aâˆ’b=(x1â€‹âˆ’x2â€‹,y1â€‹âˆ’y2â€‹)ã€‚ å‘é‡çš„åŠ å‡æ³•æ˜¯æ»¡è¶³ä»¥ä¸‹æ³•åˆ™çš„ï¼š ä¸‰è§’å½¢æ³•åˆ™ï¼šè‹¥è¦æ±‚å’Œçš„å‘é‡é¦–å°¾é¡ºæ¬¡ç›¸è¿ï¼Œé‚£ä¹ˆè¿™äº›å‘é‡çš„å’Œä¸ºç¬¬ä¸€ä¸ªå‘é‡çš„èµ·ç‚¹æŒ‡å‘æœ€åä¸€ä¸ªå‘é‡çš„ç»ˆç‚¹ï¼› å¹³è¡Œå››è¾¹å½¢æ³•åˆ™ï¼šè‹¥è¦æ±‚å’Œçš„ä¸¤ä¸ªå‘é‡å…±èµ·ç‚¹ï¼Œé‚£ä¹ˆå®ƒä»¬çš„å’Œå‘é‡ä¸ºä»¥è¿™ä¸¤ä¸ªå‘é‡ä¸ºé‚»è¾¹çš„å¹³è¡Œå››è¾¹å½¢çš„å¯¹è§’çº¿ï¼Œèµ·ç‚¹ä¸ºä¸¤ä¸ªå‘é‡å…±æœ‰çš„èµ·ç‚¹ï¼Œæ–¹å‘æ²¿å¹³è¡Œå››è¾¹å½¢å¯¹è§’çº¿æ–¹å‘ã€‚ æ‰€ä»¥è¯´å‘é‡çš„åŠ å‡æ³•å°±æœ‰äº†å‡ ä½•æ„ä¹‰ï¼Œå¹¶ä¸”æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ã€‚ æ•°ä¹˜ è§„å®šâŒˆå®æ•°Î»ä¸å‘é‡aâƒ—çš„ç§¯âŒ‹\\left\\lceil å®æ•°\\lambdaä¸å‘é‡\\vec{a}çš„ç§¯ \\right\\rfloorâŒˆå®æ•°Î»ä¸å‘é‡açš„ç§¯âŒ‹ä¸ºä¸€ä¸ªå‘é‡ï¼Œè¿™ç§è¿ç®—å°±æ˜¯æ•°ä¹˜ã€‚è®°ä½œÎ»aâƒ—\\lambda\\vec{a}Î»a,å¹¶ä¸”æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š âˆ£Î»aâƒ—âˆ£=âˆ£Î»âˆ£âˆ£aâƒ—âˆ£|\\lambda\\vec{a}|=|\\lambda||\\vec{a}|âˆ£Î»aâˆ£=âˆ£Î»âˆ£âˆ£aâˆ£ï¼› å½“Î»&gt;0\\lambda&gt;0Î»&gt;0æ—¶ï¼ŒÎ»aâƒ—\\lambda\\vec{a}Î»aä¸aâƒ—\\vec{a}aåŒå‘ï¼Œå½“Î»=0\\lambda=0Î»=0æ—¶ï¼ŒÎ»aâƒ—=0\\lambda\\vec{a}=0Î»a=0ï¼Œå½“Î»&lt;0\\lambda&lt;0Î»&lt;0æ—¶ï¼ŒÎ»aâƒ—\\lambda\\vec{a}Î»aä¸aâƒ—\\vec{a}aæ–¹å‘ç›¸åã€‚ Î»(Î¼aâƒ—)=(Î»Î¼)aâƒ—(Î»+Î¼)aâƒ—=Î»aâƒ—+Î¼aâƒ—Î»(aâƒ—+bâƒ—)=Î»aâƒ—+Î»bâƒ—(âˆ’Î»)aâƒ—=âˆ’(Î»aâƒ—)=âˆ’Î»(aâƒ—)Î»(aâƒ—âˆ’bâƒ—)=Î»aâƒ—âˆ’Î»bâƒ—\\lambda(\\mu\\vec{a})=(\\lambda\\mu)\\vec{a} \\\\ (\\lambda+\\mu)\\vec{a}=\\lambda\\vec{a}+\\mu\\vec{a} \\\\ \\lambda(\\vec{a}+\\vec{b})=\\lambda\\vec{a}+\\lambda\\vec{b} \\\\ (-\\lambda)\\vec{a}=-(\\lambda\\vec{a})=-\\lambda(\\vec{a}) \\\\ \\lambda(\\vec{a}-\\vec{b})=\\lambda\\vec{a}-\\lambda\\vec{b} Î»(Î¼a)=(Î»Î¼)a(Î»+Î¼)a=Î»a+Î¼aÎ»(a+b)=Î»a+Î»b(âˆ’Î»)a=âˆ’(Î»a)=âˆ’Î»(a)Î»(aâˆ’b)=Î»aâˆ’Î»b ï¼ˆå‘é‡çš„æ•°ä¹˜å…¶å®å°±æ˜¯å¯¹å‘é‡è¿›è¡Œæ”¾ç¼©ï¼‰ ç‚¹ç§¯ å‘é‡çš„ç‚¹ç§¯ä¹Ÿå«æ•°é‡ç§¯ã€å†…ç§¯ï¼Œå‘é‡çš„ç‚¹ç§¯è¡¨ç¤ºä¸ºaâƒ—â‹…bâƒ—\\vec{a}Â·\\vec{b}aâ‹…b,æ˜¯ä¸€ä¸ªå®æ•°ã€‚è®¡ç®—å¼ä¸ºï¼š aâƒ—â‹…bâƒ—=âˆ£aâƒ—âˆ£âˆ£bâƒ—âˆ£cosÎ¸(Î¸=âŸ¨aâƒ—,bâƒ—âŸ©)(Î¸è¡¨ç¤ºaâƒ—,bâƒ—çš„å¤¹è§’)\\vec{a}Â·\\vec{b}=|\\vec{a}||\\vec{b}|cos\\theta(\\theta=\\left\\langle \\vec{a},\\vec{b} \\right\\rangle)(\\thetaè¡¨ç¤º\\vec{a},\\vec{b}çš„å¤¹è§’) aâ‹…b=âˆ£aâˆ£âˆ£bâˆ£cosÎ¸(Î¸=âŸ¨a,bâŸ©)(Î¸è¡¨ç¤ºa,bçš„å¤¹è§’) ä¸‰è§’å½¢æ’ç­‰å˜æ¢çš„æ¨å¯¼ï¼š âˆµaâƒ—â‹…bâƒ—=âˆ£aâƒ—âˆ£âˆ£bâƒ—âˆ£cosÎ¸âˆ´aâƒ—â‹…bâƒ—=(x1)2+(y1)2â‹…(x2)2+(y2)2â‹…cosÎ¸âˆµcosÎ¸=cos(Î±âˆ’Î²)=cosÎ±cosÎ²+sinÎ±sinÎ²âˆµcosÎ±=x1(x1)2+(y1)2,sinÎ±=x1(y1)2+(y1)2cosÎ²=x2(x2)2+(y2)2,sinÎ²=y2(x2)2+(y2)2âˆ´æ•´ç†ä»£å…¥å¾—ï¼šaâƒ—â‹…bâƒ—=x1x2+y1y2\\because \\vec{a}Â·\\vec{b}=|\\vec{a}||\\vec{b}|cos\\theta\\\\ \\therefore \\vec{a}Â·\\vec{b}=\\sqrt{(x_1)^2+(y_1)^2}Â·\\sqrt{(x_2)^2+(y_2)^2}Â·cos\\theta\\\\ \\because cos\\theta=cos(\\alpha-\\beta)=cos\\alpha cos\\beta + sin\\alpha sin\\beta\\\\ \\because cos\\alpha=\\dfrac{x_1}{\\sqrt{(x_1)^2+(y_1)^2}},sin\\alpha=\\dfrac{x_1}{\\sqrt{(y_1)^2+(y_1)^2}}\\\\ cos\\beta=\\dfrac{x_2}{\\sqrt{(x_2)^2+(y_2)^2}},sin\\beta=\\dfrac{y_2}{\\sqrt{(x_2)^2+(y_2)^2}}\\\\ \\therefore æ•´ç†ä»£å…¥å¾—ï¼š\\vec{a}Â·\\vec{b}=x_1x_2+y_1y_2 âˆµaâ‹…b=âˆ£aâˆ£âˆ£bâˆ£cosÎ¸âˆ´aâ‹…b=(x1â€‹)2+(y1â€‹)2â€‹â‹…(x2â€‹)2+(y2â€‹)2â€‹â‹…cosÎ¸âˆµcosÎ¸=cos(Î±âˆ’Î²)=cosÎ±cosÎ²+sinÎ±sinÎ²âˆµcosÎ±=(x1â€‹)2+(y1â€‹)2â€‹x1â€‹â€‹,sinÎ±=(y1â€‹)2+(y1â€‹)2â€‹x1â€‹â€‹cosÎ²=(x2â€‹)2+(y2â€‹)2â€‹x2â€‹â€‹,sinÎ²=(x2â€‹)2+(y2â€‹)2â€‹y2â€‹â€‹âˆ´æ•´ç†ä»£å…¥å¾—ï¼šaâ‹…b=x1â€‹x2â€‹+y1â€‹y2â€‹ åŒæ—¶ç‚¹ç§¯æ˜¯æ»¡è¶³äº¤æ¢å¾‹ï¼Œç»“åˆå¾‹å’Œåˆ†é…å¾‹çš„ã€‚ å‰ç§¯ ä¹Ÿå«çŸ¢é‡ç§¯ï¼Œå¤–ç§¯ã€‚å‡ ä½•æ„ä¹‰æ˜¯ä¸¤å‘é‡ç”±å¹³è¡Œå››è¾¹å½¢æ³•åˆ™å›´æˆçš„é¢ç§¯ã€‚å‰ç§¯æ˜¯ä¸€ä¸ªå‘é‡ï¼Œå‚ç›´äºåŸæ¥ä¸¤ä¸ªå‘é‡æ‰€åœ¨çš„å¹³é¢ã€‚ï¼ˆæ ¹æ®å‰ä¹˜çš„æ¨¡æ˜¯å¹³è¡Œå››è¾¹å½¢çš„é¢ç§¯æˆ‘ä»¬å¯ä»¥æƒ³è±¡ï¼Œå‰ä¹˜çš„ç»“æœæ˜¯ä¸€ä¸ªæœ‰æ–¹å‘çš„é¢ï¼Œè€Œé¢çš„æ–¹å‘å¹³è¡Œäºé¢çš„æ³•çº¿ï¼Œæ‰€ä»¥é¢çš„æ–¹å‘å‚ç›´äºé¢ä¸Šä»»ä½•ä¸€ä¸ªå‘é‡ï¼‰ï¼Œå³ï¼š âˆ£aâƒ—Ã—bâƒ—âˆ£=âˆ£aâƒ—âˆ£âˆ£bâƒ—âˆ£sinâŸ¨a,bâŸ©|\\vec{a} Ã— \\vec{b}|=|\\vec{a}||\\vec{b}|sin\\left\\langle a,b \\right\\rangle âˆ£aÃ—bâˆ£=âˆ£aâˆ£âˆ£bâˆ£sinâŸ¨a,bâŸ© ï¼ˆupdï¼šè¿™é‡Œçš„å‰ç§¯å®šä¹‰æ„Ÿè§‰ä¸å¤ªä¸¥è°¨ï¼Œæ¯•ç«Ÿåœ¨æ•°å­¦ä¸­ä¸€èˆ¬å®šä¹‰âŸ¨a,bâŸ©âˆˆ[0,Ï€]\\left\\langle a,b \\right\\rangle \\in [0,\\pi]âŸ¨a,bâŸ©âˆˆ[0,Ï€],è¿™é‡Œæ˜¾ç„¶âˆˆ[0,2Ï€]\\in[0,2 \\pi]âˆˆ[0,2Ï€]ï¼Œä½†è¿™å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ¨å‡ºåæ ‡è¡¨ç¤ºä¸‹çš„å…¬å¼ï¼‰ å¹¶ä¸”ï¼Œaâƒ—Ã—bâƒ—=(x1y2âˆ’x2y2)\\vec{a}Ã—\\vec{b}=(x_1y_2-x_2y_2)aÃ—b=(x1â€‹y2â€‹âˆ’x2â€‹y2â€‹)ã€‚ å‰ç§¯æ˜¯ä¸€ä¸ªæœ‰å‘é¢ç§¯ï¼š aâƒ—Ã—bâƒ—=0\\vec{a}Ã—\\vec{b}=0aÃ—b=0ï¼Œç­‰ä»·äºaâƒ—,bâƒ—\\vec{a},\\vec{b}a,bï¼Œå…±çº¿ï¼ˆå¯ä»¥åå‘ï¼‰ï¼› aâƒ—Ã—bâƒ—&gt;0\\vec{a}Ã—\\vec{b}&gt;0aÃ—b&gt;0ï¼Œbâƒ—\\vec{b}båœ¨aâƒ—\\vec{a}aå·¦ä¾§ï¼› aâƒ—Ã—bâƒ—&lt;0\\vec{a}Ã—\\vec{b}&lt;0aÃ—b&lt;0ï¼Œbâƒ—\\vec{b}båœ¨aâƒ—\\vec{a}aå³ä¾§ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯aâƒ—Ã—bâƒ—â‰ bâƒ—Ã—aâƒ—\\vec{a} \\times \\vec{b} \\ne \\vec{b} \\times \\vec{a}aÃ—bî€ â€‹=bÃ—aï¼Œåªæ˜¯ç»å¯¹å€¼ç›¸ç­‰ã€‚ åˆ¤æ–­ä¸¤å‘é‡å…±çº¿ ä¸¤ä¸ªéé›¶å‘é‡aâƒ—\\vec{a}aä¸bâƒ—\\vec{b}bå…±çº¿ âŸº \\iffâŸºæœ‰å”¯ä¸€å®æ•°Î»\\lambdaÎ»ï¼Œä½¿å¾—bâƒ—=Î»aâƒ—\\vec{b}=\\lambda\\vec{a}b=Î»aã€‚ç”±å‘é‡çš„æ•°ä¹˜å³å¯å¾—è¯ã€‚ æ¨è®ºï¼šå¦‚æœlllä¸ºå·²ç»è¿‡ç‚¹ A ä¸”å¹³è¡Œäºå·²çŸ¥éé›¶å‘é‡aâƒ—\\vec{a}açš„ç›´çº¿ï¼Œé‚£ä¹ˆå¯¹ç©ºé—´ä»»ä¸€ç‚¹ Oï¼Œç‚¹ P åœ¨ç›´çº¿lllä¸Šçš„å……è¦æ¡ä»¶æ˜¯å­˜åœ¨å®æ•°tttï¼Œæ»¡è¶³ç­‰å¼ï¼šOPâƒ—=OAâƒ—+taâƒ—\\vec{OP}=\\vec{OA}+t\\vec{a}OP=OA+taã€‚ å…¶ä¸­å‘é‡aâƒ—\\vec{a}aå«åšç›´çº¿lllçš„æ–¹å‘å‘é‡ã€‚ åŸºæœ¬å®šç†å’Œåæ ‡è¡¨ç¤º å¹³é¢å‘é‡åŸºæœ¬å®šç† å¹³é¢å‘é‡åŸºæœ¬å®šç†ï¼šä¸¤ä¸ªå‘é‡aâƒ—\\vec{a}aå’Œbâƒ—\\vec{b}bä¸å…±çº¿çš„å……è¦æ¡ä»¶æ˜¯ï¼Œå¯¹äºå’Œå‘é‡aâƒ—\\vec{a}aï¼Œbâƒ—\\vec{b}bå…±é¢çš„ä»»æ„å‘é‡pâƒ—\\vec{p}pâ€‹ï¼Œæœ‰å”¯ä¸€å®æ•°å¯¹(x,y)(x,y)(x,y)æ»¡è¶³pâƒ—=xaâƒ—+ybâƒ—\\vec{p}=x\\vec{a}+y\\vec{b}pâ€‹=xa+ybã€‚ è¯æ˜(éå¸¸ç®€å•): å¯¹äºå¹³é¢ä¸Šçš„ä»»æ„å‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘è¢«åˆ†è§£ä¸ºä»»æ„ä¸¤ä¸ªå‘é‡ï¼Œå¹³é¢ä¸Šçš„ä»»æ„ä¸¤ä¸ªå‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘åˆæˆä»»æ„æŒ‡å®šå‘é‡ã€‚å¯¹äºæœ‰å”¯ä¸€å®æ•°å¯¹æˆ‘ä»¬å¯ä»¥ç”¨åè¯æ³•:å‡è®¾æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šçš„å®æ•°å¯¹æ»¡è¶³è¦æ±‚ä¸º(m,n)âˆ´xaâƒ—+ybâƒ—=maâƒ—+nbâƒ—âˆ´(xâˆ’m)aâƒ—=(nâˆ’y)bâƒ—âˆµaâƒ—å’Œbâƒ—ä¸å…±çº¿âˆ´x=m,n=yä¸å‡è®¾çŸ›ç›¾æ‰€ä»¥ç»“è®ºæˆç«‹è¯æ¯•å¯¹äºå¹³é¢ä¸Šçš„ä»»æ„å‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘è¢«åˆ†è§£ä¸ºä»»æ„ä¸¤ä¸ªå‘é‡ï¼Œ\\\\ å¹³é¢ä¸Šçš„ä»»æ„ä¸¤ä¸ªå‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘åˆæˆä»»æ„æŒ‡å®šå‘é‡ã€‚\\\\ å¯¹äºæœ‰å”¯ä¸€å®æ•°å¯¹æˆ‘ä»¬å¯ä»¥ç”¨åè¯æ³•:\\\\ å‡è®¾æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šçš„å®æ•°å¯¹æ»¡è¶³è¦æ±‚ä¸º(m,n)\\\\ \\therefore x\\vec{a}+y\\vec{b}=m\\vec{a}+n\\vec{b}\\\\ \\therefore (x-m)\\vec{a}=(n-y)\\vec{b}\\\\ \\because \\vec{a}å’Œ\\vec{b}ä¸å…±çº¿\\\\ \\therefore x=m,n=y\\\\ ä¸å‡è®¾çŸ›ç›¾æ‰€ä»¥ç»“è®ºæˆç«‹\\\\è¯æ¯• å¯¹äºå¹³é¢ä¸Šçš„ä»»æ„å‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘è¢«åˆ†è§£ä¸ºä»»æ„ä¸¤ä¸ªå‘é‡ï¼Œå¹³é¢ä¸Šçš„ä»»æ„ä¸¤ä¸ªå‘é‡å¯ä»¥æ²¿æŒ‡å®šæ–¹å‘åˆæˆä»»æ„æŒ‡å®šå‘é‡ã€‚å¯¹äºæœ‰å”¯ä¸€å®æ•°å¯¹æˆ‘ä»¬å¯ä»¥ç”¨åè¯æ³•:å‡è®¾æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šçš„å®æ•°å¯¹æ»¡è¶³è¦æ±‚ä¸º(m,n)âˆ´xa+yb=ma+nbâˆ´(xâˆ’m)a=(nâˆ’y)bâˆµaå’Œbä¸å…±çº¿âˆ´x=m,n=yä¸å‡è®¾çŸ›ç›¾æ‰€ä»¥ç»“è®ºæˆç«‹è¯æ¯• åœ¨åŒä¸€å¹³é¢å†…çš„ä¸¤ä¸ªä¸å…±çº¿çš„å‘é‡ç§°ä¸ºåŸºåº•ã€‚ å¦‚æœåŸºåº•ç›¸äº’å‚ç›´ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨åˆ†è§£çš„æ—¶å€™å°±æ˜¯å¯¹å‘é‡æ­£äº¤åˆ†è§£ã€‚ å¹³é¢å‘é‡çš„åæ ‡è¡¨ç¤º å¦‚æœå–ä¸æ¨ªè½´ä¸çºµè½´æ–¹å‘ç›¸åŒçš„å•ä½å‘é‡i,ji,ji,jä½œä¸ºä¸€ç»„åŸºåº•ï¼Œæ ¹æ®å¹³é¢å‘é‡åŸºæœ¬å®šç†ï¼Œå¹³é¢ä¸Šçš„æ‰€æœ‰å‘é‡ä¸æœ‰åºå®æ•°å¯¹(x,y)(x,y)(x,y)ä¸€ä¸€å¯¹åº”ã€‚ è€Œæœ‰åºæ•°å¯¹(x,y)(x,y)(x,y)ä¸å¹³é¢ç›´è§’åæ ‡ç³»ä¸Šçš„ç‚¹ä¸€ä¸€å¯¹åº”ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½œOPâƒ—=pâƒ—\\vec{OP}=\\vec{p}OP=pâ€‹ï¼Œé‚£ä¹ˆç»ˆç‚¹P(x,y)P(x,y)P(x,y)ä¹Ÿæ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚ç”±äºæˆ‘ä»¬ç ”ç©¶çš„éƒ½æ˜¯è‡ªç”±å‘é‡ï¼Œå¯ä»¥è‡ªç”±å¹³ç§»èµ·ç‚¹ï¼Œè¿™æ ·ï¼Œåœ¨å¹³é¢ç›´è§’åæ ‡ç³»é‡Œï¼Œæ¯ä¸€ä¸ªå‘é‡éƒ½å¯ä»¥ç”¨æœ‰åºå®æ•°å¯¹å”¯ä¸€è¡¨ç¤ºã€‚ åæ ‡è¿ç®— å¹³é¢å‘é‡çº¿æ€§è¿ç®— ç”±å¹³é¢å‘é‡çš„çº¿æ€§è¿ç®—ï¼Œæˆ‘ä»¬å¯ä»¥æ¨å¯¼å…¶åæ ‡è¿ç®—ï¼Œä¸»è¦æ–¹æ³•æ˜¯å°†åæ ‡å…¨éƒ¨åŒ–ä¸ºç”¨åŸºåº•è¡¨ç¤ºï¼Œç„¶ååˆ©ç”¨è¿ç®—å¾‹è¿›è¡Œåˆå¹¶ï¼Œä¹‹åè¡¨ç¤ºå‡ºè¿ç®—ç»“æœçš„åæ ‡å½¢å¼ã€‚ å¯¹äºå‘é‡aâƒ—=(m,n)\\vec{a}=(m,n)a=(m,n)å’Œå‘é‡bâƒ—=(p,q)\\vec{b}=(p,q)b=(p,q)ï¼Œåˆ™æœ‰ï¼š aâƒ—+bâƒ—=(m+n,n+q)aâƒ—âˆ’bâƒ—=(mâˆ’n,nâˆ’q)kaâƒ—=(km,kn),kbâƒ—=(kq,kq)\\vec{a}+\\vec{b}=(m+n,n+q)\\\\ \\vec{a}-\\vec{b}=(m-n,n-q)\\\\ k\\vec{a}=(km,kn),k\\vec{b}=(kq,kq) a+b=(m+n,n+q)aâˆ’b=(mâˆ’n,nâˆ’q)ka=(km,kn),kb=(kq,kq) å‘é‡çš„åæ ‡è¡¨ç¤º å·²çŸ¥ä¸¤ç‚¹A(a,b),B(c,d)A(a,b),B(c,d)A(a,b),B(c,d),åˆ™ABâƒ—=(câˆ’a,dâˆ’b)\\vec{AB}=(c-a,d-b)AB=(câˆ’a,dâˆ’b)ã€‚ å¹³ç§»ä¸€ç‚¹ å°†ä¸€ç‚¹PPPæ²¿ä¸€å®šæ–¹å‘å¹³ç§»æŸå•ä½é•¿åº¦ï¼Œåªéœ€è¦å°†è¦å¹³ç§»çš„æ–¹å‘å’Œè·ç¦»ç»„åˆæˆä¸€ä¸ªå‘é‡ï¼Œåˆ©ç”¨ä¸‰è§’å½¢æ³•åˆ™ï¼Œç”¨OPâƒ—\\vec{OP}OPåŠ ä¸Šè¿™ä¸ªå‘é‡å³å¯ï¼Œå¾—åˆ°çš„å‘é‡ç»ˆç‚¹å³ä¸ºå¹³ç§»åçš„ç‚¹ã€‚ ä¸‰ç‚¹å…±çº¿çš„åˆ¤å®š åœ¨å¹³é¢ä¸ŠA,B,CA,B,CA,B,Cä¸‰ç‚¹å…±çº¿çš„å……è¦æ¡ä»¶æ˜¯ï¼šOCâƒ—=Î»OBâƒ—+(1âˆ’Î»)OAâƒ—,(Oä¸ºå¹³é¢å†…ä¸ä¸ç›´çº¿ACå…±çº¿ä»»æ„ä¸€ç‚¹)\\vec{OC}=\\lambda\\vec{OB}+(1-\\lambda)\\vec{OA},(Oä¸ºå¹³é¢å†…ä¸ä¸ç›´çº¿ACå…±çº¿ä»»æ„ä¸€ç‚¹)OC=Î»OB+(1âˆ’Î»)OA,(Oä¸ºå¹³é¢å†…ä¸ä¸ç›´çº¿ACå…±çº¿ä»»æ„ä¸€ç‚¹)ã€‚ è¯æ˜ï¼š è‹¥ç‚¹Bä¸ACå…±çº¿ï¼Œç”±å…±çº¿å‘é‡å®šç†å¯çŸ¥ï¼šACâƒ—=Î»ABâƒ—âˆ´ACâƒ—=Î»ABâƒ— âŸº OCâƒ—âˆ’OAâƒ—=Î»(OBâƒ—âˆ’OAâƒ—) âŸº OCâƒ—=(1âˆ’Î»)OAâƒ—+Î»OBâƒ—è¯æ¯•è‹¥ç‚¹Bä¸ACå…±çº¿ï¼Œç”±å…±çº¿å‘é‡å®šç†å¯çŸ¥ï¼š\\vec{AC}=\\lambda\\vec{AB}\\\\ \\therefore \\vec{AC}=\\lambda\\vec{AB}\\iff\\vec{OC}-\\vec{OA}=\\lambda(\\vec{OB}-\\vec{OA})\\iff\\vec{OC}=(1-\\lambda)\\vec{OA}+\\lambda\\vec{OB}\\\\ è¯æ¯• è‹¥ç‚¹Bä¸ACå…±çº¿ï¼Œç”±å…±çº¿å‘é‡å®šç†å¯çŸ¥ï¼šAC=Î»ABâˆ´AC=Î»ABâŸºOCâˆ’OA=Î»(OBâˆ’OA)âŸºOC=(1âˆ’Î»)OA+Î»OBè¯æ¯• ä¸‰ç»´è®¡ç®—å‡ ä½•åŸºç¡€ åæ ‡è¡¨ç¤º å’Œå¹³é¢ç›´è§’åæ ‡ç³»å·®ä¸å¤šï¼Œå°±æ˜¯å˜æˆäº†ç©ºé—´ç›´è§’åæ ‡ç³»ï¼ŒåŠ äº†æ¡zzzè½´ï¼Œå¤šäº†ä¸ªå³æ‰‹å®šåˆ™å’Œå·¦æ‰‹å®šåˆ™ï¼ˆä¹Ÿä¸å¸¸ç”¨ï¼‰ï¼Œè¡¨ç¤ºç©ºé—´ä¸­çš„ä¸€ä¸ªç‚¹çš„æ—¶å€™ï¼Œç”¨ä¸€ä¸ªæœ‰åºæ•°å¯¹(x,y,z)(x,y,z)(x,y,z)å³å¯ã€‚ å‘é‡aâƒ—(x,y,z)\\vec{a}(x,y,z)a(x,y,z)çš„æ¨¡é•¿ä¸ºï¼š âˆ£aâƒ—âˆ£=x2+y2+z2|\\vec{a}|=\\sqrt{x^2+y^2+z^2} âˆ£aâˆ£=x2+y2+z2â€‹ å‘é‡è¿ç®— æ•°ä¹˜ å¹¶æ²¡æœ‰å¤ªå¤§çš„å˜åŒ–ï¼Œåªä¸è¿‡æ˜¯å˜æˆäº†ä¸‰ç»´åæ ‡ï¼Œè®¾ aâƒ—=(x,y,z)\\vec{a}=(x,y,z)a=(x,y,z),æœ‰ kaâƒ—=(kx,ky,kz)k \\vec{a} = (kx,ky,kz) ka=(kx,ky,kz) ç‚¹ç§¯ è®¾aâƒ—=(x1,y1,z1),bâƒ—=(x2,y2,z2)\\vec{a}=(x_1,y_1,z_1),\\vec{b}= (x_2,y_2,z_2)a=(x1â€‹,y1â€‹,z1â€‹),b=(x2â€‹,y2â€‹,z2â€‹)ï¼Œåˆ™ aâƒ—â‹…bâƒ—=âˆ£aâƒ—âˆ£âˆ£bâƒ—âˆ£cosâ¡âŸ¨aâƒ—,bâƒ—âŸ©\\vec{a} \\cdot \\vec{b}=|\\vec{a}| |\\vec{b}|\\cos \\left\\langle \\vec{a},\\vec{b} \\right\\rangle aâ‹…b=âˆ£aâˆ£âˆ£bâˆ£cosâŸ¨a,bâŸ© åˆå¯ä»¥è¡¨ç¤ºä¸ºï¼š aâƒ—â‹…bâƒ—=x1x2+y1y2+z1z2\\vec{a} \\cdot \\vec{b} = x_1x_2+y_1y_2+z_1z_2 aâ‹…b=x1â€‹x2â€‹+y1â€‹y2â€‹+z1â€‹z2â€‹ æ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚ å‰ç§¯ ç©ºé—´ç›´è§’åæ ‡ç³»ä¸­å‘é‡aâƒ—\\vec{a}aå’Œå‘é‡bâƒ—\\vec{b}bçš„å‰ç§¯ä¸ºï¼š aâƒ—Ã—bâƒ—=(y1z2âˆ’y2z1,x2z1âˆ’x1z2,x1y2âˆ’x2y1)\\vec{a} \\times \\vec{b} = (y_1z_2-y_2z_1,x_2z_1-x_1z_2,x_1y_2-x_2y_1) aÃ—b=(y1â€‹z2â€‹âˆ’y2â€‹z1â€‹,x2â€‹z1â€‹âˆ’x1â€‹z2â€‹,x1â€‹y2â€‹âˆ’x2â€‹y1â€‹) ç»“æœæ˜¯ä¸€ä¸ªå‘é‡ï¼Œå¦å¤–å¯ä»¥ç”¨è¡Œåˆ—å¼è¡¨ç¤ºï¼Œ è®¾ câƒ—=aâƒ—Ã—bâƒ—,câƒ—=(x3,y3,z3)\\vec{c} = \\vec{a} \\times \\vec{b},\\vec{c} = (x_3,y_3,z_3)c=aÃ—b,c=(x3â€‹,y3â€‹,z3â€‹),å‰ç§¯ç»“æœä¸ºï¼š âˆ£x3y3z3x1y1z1x2y2z2âˆ£\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹x3â€‹x1â€‹x2â€‹â€‹y3â€‹y1â€‹y2â€‹â€‹z3â€‹z1â€‹z2â€‹â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ å°†å…¶å±•å¼€å³ä¸º ï¼š x3(y1z2âˆ’y2z1)+y3(x2z1âˆ’x1z2)+z3(x1y2âˆ’x2y1)x_3(y_1z_2-y_2z_1)+y_3(x_2z_1-x_1z_2)+z_3(x_1y_2-x_2y_1) x3â€‹(y1â€‹z2â€‹âˆ’y2â€‹z1â€‹)+y3â€‹(x2â€‹z1â€‹âˆ’x1â€‹z2â€‹)+z3â€‹(x1â€‹y2â€‹âˆ’x2â€‹y1â€‹) å‰ç§¯ç»“æœå³ä¸º(y1z2âˆ’y2z1,x2z1âˆ’x1z2,x1y2âˆ’x2y1)(y_1z_2-y_2z_1,x_2z_1-x_1z_2,x_1y_2-x_2y_1)(y1â€‹z2â€‹âˆ’y2â€‹z1â€‹,x2â€‹z1â€‹âˆ’x1â€‹z2â€‹,x1â€‹y2â€‹âˆ’x2â€‹y1â€‹)ï¼Œ å¦å¤–æ ¹æ®å‰ç§¯çš„å®šä¹‰ï¼Œåœ¨ç©ºé—´ç›´è§’åæ ‡ç³»ä¸­å‰ç§¯æ‰€ä»£è¡¨çš„å‘é‡ä¸ºä¸¤ä¸ªè¿›è¡Œå‰ç§¯å‘é‡æ‰€åœ¨å¹³é¢çš„æ³•å‘é‡ã€‚ tips:ä¸‰é˜¶è¡Œåˆ—å¼çš„å±•å¼€ æ¯”å¦‚ä¸Šé¢çš„ âˆ£x3y3z3x1y1z1x2y2z2âˆ£\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹x3â€‹x1â€‹x2â€‹â€‹y3â€‹y1â€‹y2â€‹â€‹z3â€‹z1â€‹z2â€‹â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ å°†å…¶ç¬¬ä¸€ï¼ŒäºŒåˆ— copy åˆ°ç¬¬ä¸‰åˆ—å³è¾¹ï¼š âˆ£x3y3z3x1y1z1x2y2z2âˆ£âˆ£x3y3x1y1x2y2âˆ£\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} \\begin{vmatrix} x_3&amp;y_3 \\\\ x_1&amp;y_1 \\\\ x_2&amp;y_2 \\end{vmatrix} âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹x3â€‹x1â€‹x2â€‹â€‹y3â€‹y1â€‹y2â€‹â€‹z3â€‹z1â€‹z2â€‹â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹x3â€‹x1â€‹x2â€‹â€‹y3â€‹y1â€‹y2â€‹â€‹âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£â€‹ ç”¨ç¬¬ 1,2,3 åˆ—çš„å¯¹è§’çº¿çš„ä¹˜ç§¯å’Œå‡å»ç¬¬ 3,4,5 åˆ—çš„ä¹˜ç§¯å’Œï¼š (x3y1z2+y3z1x2+z3x1y2)âˆ’(y3x1z2+x3z1y2+z3y1x2)(x_3y_1z_2+y_3z_1x_2+z_3x_1y_2)-(y_3x_1z_2+x_3z_1y_2+z_3y_1x_2) (x3â€‹y1â€‹z2â€‹+y3â€‹z1â€‹x2â€‹+z3â€‹x1â€‹y2â€‹)âˆ’(y3â€‹x1â€‹z2â€‹+x3â€‹z1â€‹y2â€‹+z3â€‹y1â€‹x2â€‹) åŒ–ç®€å³ä¸Šè¿°ç»“æœï¼Œï¼ˆç®—é”™å¯å°±å¯„äº†ï¼‰ å¹³é¢çš„è¡¨ç¤º æˆ‘ä»¬å¯ä»¥ç”¨å¹³é¢ä¸Šçš„ä¸€ç‚¹P(x,y,z)P(x,y,z)P(x,y,z)å’Œè¯¥å¹³é¢çš„æ³•å‘é‡nâƒ—(a,b,c)\\vec{n}(a,b,c)n(a,b,c)æ¥è¡¨ç¤ºä¸€ä¸ªå¹³é¢ï¼Œæ»¡è¶³Pâ‹…nâƒ—=0P \\cdot \\vec{n}=0Pâ‹…n=0çš„ç‚¹é›†å³ä¸ºè¯¥å¹³é¢ï¼Œå¯ä»¥æ¨å‡ºï¼Œ Ax+By+Cz+D=0Ax+By+Cz+D=0 Ax+By+Cz+D=0 ä¸ºå¹³é¢çš„ä¸€èˆ¬å¼ã€‚ ä¸‰ç»´è®¡ç®—å‡ ä½•å…¶å®ä¹Ÿæ²¡å•¥ï¼Œå°±æ˜¯å‡ç»´æ‰“å‡»ã€‚ å‡¸åŒ… äºŒç»´å‡¸åŒ… å‡¸å¤šè¾¹å½¢ å‡¸å¤šè¾¹å½¢æ˜¯æŒ‡æ‰€æœ‰å†…è§’åœ¨[0,Ï€]\\left[ 0,\\pi \\right][0,Ï€]èŒƒå›´å†…çš„ç®€å•å¤šè¾¹å½¢ã€‚ å‡¸åŒ… å¯¹äºåœ¨å¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹é›†ï¼Œå‡¸åŒ…æ˜¯èƒ½åŒ…å«æ‰€æœ‰ç‚¹çš„æœ€å°å‡¸å¤šè¾¹å½¢ã€‚ å…¶å®šä¹‰ä¸ºï¼šå¯¹äºç»™å®šé›†åˆDDDï¼Œæ‰€æœ‰åŒ…å«DDDçš„å‡¸é›†çš„äº¤é›†SSSè¢«ç§°ä¸ºDDDçš„å‡¸åŒ…ã€‚ å¦‚ï¼š å‡¸åŒ…æ±‚æ³• å¯¹äºå¹³é¢ä¸Šçš„ä¸€ä¸ªç‚¹é›†ï¼Œå…¶å‡¸åŒ…å¯ä»¥ç”¨åˆ†æ²»ï¼ŒGrahamâˆ’ScanGraham-ScanGrahamâˆ’Scanï¼Œå’Œ AndrewAndrewAndrewã€‚ åˆ†æ²» å¯¹äºåˆ†æ²»ç®—æ³•è§£å†³å‡¸åŒ…é—®é¢˜ï¼Œé€’å½’æ±‚è§£ï¼Œæ‰¾åˆ°å­é—®é¢˜çš„å‡¸åŒ…ï¼Œè®²å·¦å³ä¸¤ä¸ªå­é›†çš„å‡¸åŒ…è¿›è¿›è¡Œåˆå¹¶å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦(nlogâ¡n)(n \\log n)(nlogn)ã€‚ AndrewAndrewAndrew å¯¹äºAndrewAndrewAndrewç®—æ³•ï¼Œä¸»è¦æµç¨‹ï¼š é¦–å…ˆå°†æ‰€æœ‰ç‚¹ä»¥æ¨ªåæ ‡ä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œçºµåæ ‡ä¸ºç¬¬äºŒå…³é”®å­—è¿›è¡Œæ’åºï¼› æ˜¾ç„¶æ’åºåæœ€å°çš„å…ƒç´ å’Œæœ€å¤§çš„å…ƒç´ ä¸€å®šåœ¨å‡¸åŒ…ä¸Šï¼Œç„¶åç”¨å•è°ƒæ ˆç»´æŠ¤ä¸Šä¸‹å‡¸å£³ï¼› å› ä¸ºä¸Šä¸‹å‡¸å£³æ‰€æ—‹è½¬çš„æ–¹å‘ä¸åŒï¼Œæˆ‘ä»¬é¦–å…ˆå‡åºæšä¸¾ä¸‹å‡¸å£³ï¼Œç„¶åé™åºæšä¸¾ä¸Šå‡¸å£³ã€‚ æ—¶é—´å¤æ‚åº¦(nlogâ¡n)(n \\log n)(nlogn)ã€‚ Grahamâˆ’ScanGraham-ScanGrahamâˆ’Scan ä¸»è¦ä»‹ç»è¿™ç§ç®—æ³•ï¼Œæ›´å¥½å†™ä¸€äº›ï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆæ‰¾å‡ºåœ¨æœ€å³ä¸‹è§’çš„ç‚¹ï¼Œæ­¤æ—¶è¿™ä¸ªç‚¹ä¸€å®šåœ¨å‡¸åŒ…ä¸Šï¼Œç„¶åæˆ‘ä»¬ä»è¿™ä¸ªç‚¹å¼€å§‹é€†æ—¶é’ˆæ—‹è½¬ï¼ŒåŒæ—¶ç”¨å•è°ƒæ ˆç»´æŠ¤å‡¸åŒ…ä¸Šçš„ç‚¹ï¼Œæ¯åŠ å…¥ä¸€ä¸ªæ–°ç‚¹æ˜¯åˆ¤æ–­æ”¹ç‚¹æ˜¯å¦ä¼šå‡ºç°ï¼Œè¯¥è¾¹åœ¨ä¸Šä¸€æ¡è¾¹çš„â€œå³è¾¹â€ï¼Œå¦‚æœå‡ºç°åˆ™åˆ é™¤ä¸Šä¸€ä¸ªç‚¹ã€‚ ã€æ¨¡æ¿ã€‘äºŒç»´å‡¸åŒ… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int n,top;double ans;struct geometric{ double x,y,dss; friend geometric operator + (const geometric a,const geometric b){return (geometric){a.x+b.x,a.y+b.y};} friend geometric operator - (const geometric a,const geometric b){return (geometric){a.x-b.x,a.y-b.y};} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);}};geometric origin,data[maxn],st[maxn];bool vis[maxn];bool cmp(geometric a,geometric b){ geometric opt; double tamp=opt.cross(data[1],a,data[1],b); if(tamp&gt;0)return true; if(tamp==0&amp;&amp;opt.dis(data[1],a)&lt;=opt.dis(data[1],b))return true; return false;}geometric opt;int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lf%lf&quot;,&amp;data[i].x,&amp;data[i].y); if(i!=1&amp;&amp;data[i].y&lt;data[1].y) { double tmp; swap(data[1].y,data[i].y); swap(data[1].x,data[i].x); } if(i!=1&amp;&amp;data[i].y==data[1].y&amp;&amp;data[i].x&gt;data[1].x) swap(data[1].x,data[i].x); } sort(data+2,data+n+1,cmp); st[++top]=data[1]; for(int i=2;i&lt;=n;i++) { while(top&gt;1&amp;&amp;opt.cross(st[top-1],st[top],st[top],data[i])&lt;=0)top--; st[++top]=data[i]; } st[++top]=data[1]; for(int i=1;i&lt;top;i++)ans+=opt.dis(st[i],st[i+1]); printf(&quot;%.2lf&quot;,ans); return 0;} åŠ¨æ€å‡¸åŒ… é¦–å…ˆæˆ‘ä»¬è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š ä¸¤ç§æ“ä½œï¼š å‘ç‚¹é›†ä¸­æ·»åŠ ä¸€ä¸ªç‚¹(x,y)(x,y)(x,y); è¯¢é—®ç‚¹æ˜¯å¦åœ¨å‡¸åŒ…ä¸­ã€‚ é¦–å…ˆæˆ‘ä»¬å¯¹äºä¸€ä¸ªåŠ¨æ€çš„å‡¸åŒ…ï¼Œå¾ˆæ˜æ˜¾åœ¨æ¯æ¬¡åŠ å…¥æ–°ç‚¹æ—¶ä¸èƒ½å†è¿›è¡Œä¸€æ¬¡Grahamâˆ’ScanGraham-ScanGrahamâˆ’Scanï¼Œå¦åˆ™æ—¶é—´å¤æ‚åº¦ä¸ä¼˜ã€‚ é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç”¨ä¸€ä¸‹æ–¹æ³•ï¼š é¦–å…ˆå»ºä¸€æ£µå¹³è¡¡æ ‘ï¼ŒæŒ‰æè§’æ’åºï¼› è¯¢é—®æ˜¯æ‰¾åˆ°è¯¥ç‚¹çš„å‰é©±åç»§ï¼Œç”¨å‰ç§¯åˆ¤æ–­å³å¯ï¼Œå¦åˆ™æ‰§è¡Œæ’å…¥æ“ä½œï¼› æ’å…¥æ—¶ï¼Œå…ˆå°†ç‚¹æ’å…¥å¹³è¡¡æ ‘å†…ç„¶åæ‰¾è¯¥ç‚¹çš„å‰é©±åç»§ï¼ŒåŒæ—¶ä¸æ–­å»æ—‹è½¬å°†åœ¨å‡¸åŒ…å†…çš„ç‚¹åˆ å»ã€‚ å¯¹äºå¹³è¡¡æ ‘æˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨STLSTLSTLé‡Œçš„setsetset å»å®ç°ï¼Œéœ€è¦ç”¨åˆ°è¿­ä»£å™¨ã€‚ Professorâ€™s task 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define it set&lt;geometric&gt;::iterator#define eps 1e-8using namespace std;const int maxn=1e5+10;int Sure(double x){return fabs(x)&lt;eps?0:(x&lt;0?-1:1);}struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);} geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));}}opt,d[maxn],origin;bool operator &lt; (geometric a,geometric b){ a=a-origin;b=b-origin; double ang1=atan2(a.y,a.x),ang2=atan2(b.y,b.x); double l1=sqrt(a.x*a.x+a.y*a.y),l2=sqrt(b.x*b.x+b.y*b.y); if(Sure(ang1-ang2)!=0)return Sure(ang1-ang2)&lt;0; else return Sure(l1-l2)&lt;0;}int q,cnt;set&lt;geometric&gt; S;it Pre(it pos){if(pos==S.begin())pos=S.end();return --pos;}it Nxt(it pos){++pos; return pos==S.end() ? S.begin():pos;}bool Query(geometric key){ it pos=S.lower_bound(key); if(pos==S.end())pos=S.begin(); return Sure(opt.cross(*(Pre(pos)),key,*(Pre(pos)),*(pos)))&lt;=0;}void Insert(geometric key){ if(Query(key))return; S.insert(key); it pos=Nxt(S.find(key)); while(S.size()&gt;3&amp;&amp;Sure(opt.cross(*(Nxt(pos)),*(pos),*(Nxt(pos)),key))&gt;=0) { S.erase(pos);pos=Nxt(S.find(key)); } pos=Pre(S.find(key)); while(S.size()&gt;3&amp;&amp;Sure(opt.cross(*(Pre(pos)),*(pos),*(Pre(pos)),key))&lt;=0) { S.erase(pos);pos=Pre(S.find(key)); }}int main(){ scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=3;i++) { int opt;double x,y;scanf(&quot;%d%lf%lf&quot;,&amp;opt,&amp;x,&amp;y); d[++cnt]=geometric(x,y);origin.x+=x;origin.y+=y; } origin=origin/3.0; for(int i=1;i&lt;=3;i++)S.insert(d[i]); for(int i=4;i&lt;=q;i++) { int opt;double x,y; scanf(&quot;%d%lf%lf&quot;,&amp;opt,&amp;x,&amp;y); d[++cnt]=geometric(x,y); if(opt==1)Insert(d[cnt]); else { if(Query(d[cnt]))printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } return 0;} æ³¨æ„ä½¿ç”¨è¿­ä»£å™¨æ—¶ä¸è¦è¶Šç•Œï¼Œè¦å’Œç”¨æŒ‡é’ˆä¸€æ ·å°å¿ƒï¼ ä¸‰ç»´å‡¸åŒ… å¯¹äº aâƒ—(x1,y1)\\vec{a}(x_1,y_1)a(x1â€‹,y1â€‹) å’Œ bâƒ—(x2,y2)\\vec{b}(x_2,y_2)b(x2â€‹,y2â€‹) ä¸‰ç»´å‡¸åŒ…çš„è¯ï¼Œä¸»è¦æ˜¯ç©ºé—´å‡ ä½•åæ ‡ç³»ä¸­ç‚¹ç§¯ä¸ºï¼š aâƒ—â‹…bâƒ—=x1x2+y1y2+z1z2 \\vec{a} Â· \\vec{b} = x_1x_2+y_1y_2+z_1z_2 aâ‹…b=x1â€‹x2â€‹+y1â€‹y2â€‹+z1â€‹z2â€‹ å‰ç§¯ä¸ºå‘é‡ï¼ˆæ³•å‘é‡ï¼‰ï¼š aâƒ—Ã—bâƒ—=(y1z2âˆ’y2z1,x2z1âˆ’z2x1,x1y2âˆ’x2y1) \\vec{a} \\times \\vec{b} =(y_1z_2 - y_2z_1, x_2z_1-z_2x_1, x_1y_2 -x_2y_1) aÃ—b=(y1â€‹z2â€‹âˆ’y2â€‹z1â€‹,x2â€‹z1â€‹âˆ’z2â€‹x1â€‹,x1â€‹y2â€‹âˆ’x2â€‹y1â€‹) å¯¹äºä¸‰ç»´å‡¸åŒ…çš„è§£æ³•æœ‰å¾ˆå¤šç§ï¼Œä»‹ç»å‡ ç§æ¯”è¾ƒå¸¸ç”¨çš„å§ã€‚ å¢é‡æ³• ä¸»è¦æ˜¯è€ƒè™‘åŠ å…¥ä¸€ä¸ªç‚¹æ—¶å¦‚ä½•ç»´æŠ¤å‡¸åŒ…,æ¯åŠ å…¥ä¸€ä¸ªç‚¹ï¼Œä»è¿™ä¸ªç‚¹â€œèƒ½çœ‹è§çš„é¢â€éƒ½ä¸ä¼šæ˜¯æœ€ç»ˆå‡¸åŒ…çš„é¢ï¼Œå°†è¿™äº›ä¸ä¼šæˆä¸ºç­”æ¡ˆçš„é¢åˆ å»å°±å¥½äº†ã€‚ å¦å¤–å¦‚æœæ–°åŠ å…¥çš„ç‚¹åœ¨å·²ç»åŠ å…¥çš„é¢ä¸Šï¼Œä¸ç”¨åˆ é™¤è¿™ä¸ªé¢ã€‚ é¦–å…ˆå…ˆé€‰å–å››ä¸ªé¡¶ç‚¹ï¼Œæ„æˆä¸€ä¸ªå››é¢ä½“ï¼Œä½œä¸ºåˆå§‹å‡¸åŒ…ï¼Œæ¯åŠ å…¥ä¸€ä¸ªç‚¹å»åœ¨å·²ç»åŠ å…¥é¢ä¸­å»æ‰¾ï¼Œä»è¿™ä¸ªç‚¹èƒ½çœ‹åˆ°çš„é¢ï¼Œå°†å…¶åˆ é™¤ï¼Œ å…³äºå­˜é¢çš„æ—¶å€™ï¼ŒåŒä¸€æ¡è¾¹ä¼šè¢«ä½¿ç”¨ä¸¤æ¬¡ï¼Œè¢«é¡ºæ—¶é’ˆä½¿ç”¨ä¸€æ¬¡ï¼Œé€†æ—¶é’ˆä½¿ç”¨ä¸€æ¬¡ï¼Œå¯ä»¥å¯¹æ¯æ¡è¾¹æ‰“ä¸Šæ ‡è®°ï¼Œåˆ æ‰ä¸éœ€è¦çš„é¢åå¯¹äºåªä½¿ç”¨è¿‡ä¸€æ¬¡çš„è¾¹æŒ‰ç…§å…¶ä½¿ç”¨æ–¹å‘ä¸æ–°ç‚¹å»ºé¢ï¼Œ å­˜é¢çš„æ—¶å€™åªéœ€ç”¨åˆ°ä¸‰ä¸ªç‚¹å°±å¯ä»¥äº†ï¼Œå¯¹äºå¤šä¸ªç‚¹å…±é¢çš„æƒ…å†µï¼Œå› ä¸ºæˆ‘ä»¬ç”¨çš„æ˜¯ä¸‰ä¸ªç‚¹æ¥å­˜é¢ï¼Œæœ€åçš„å‡¸å¤šè¾¹å½¢ï¼Œæœ‰å¯èƒ½ä¼šå‡ºç°å¤šä¸ªç‚¹å…±é¢çš„æƒ…å†µï¼Œå¯¼è‡´å°†è¿™ä¸ªé¢åˆ†æˆå¤šä¸ªå°ä¸‰è§’å½¢ï¼Œä¸ºäº†å…å»å»é‡çš„ä¸€äº›æ“ä½œï¼Œæ›´å¥½å†™ä¸€äº›ï¼Œå¯ä»¥å¯¹ç‚¹è¿›è¡Œæ‰°åŠ¨ï¼ŒåŠ ä¸€ä¸ªä¸ç®—å¤§çš„è¯¯å·®ã€‚ æ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2)è€Œä¸”æ”¯æŒåœ¨çº¿ã€‚ ã€æ¨¡æ¿ã€‘ä¸‰ç»´å‡¸åŒ… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define eps 1e-10#define double long doubleusing namespace std;const int maxn=2010;double randeps(){return (rand()/(double)RAND_MAX-0.5)*eps;}struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} void shake(){x+=randeps(),y+=randeps(),z+=randeps();} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// å‘é‡çš„å››åˆ™è¿ç®— double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // å‘é‡æ¨¡é•¿ double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// ç‚¹ç§¯ geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a=a2-a1,b=b2-b1;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // å‰ç§¯}opt,origin,p[maxn];struct plane{ int v[3]; plane(){v[0]=v[1]=v[2]=0;} plane(int A,int B,int C){v[0]=A,v[1]=B,v[2]=C;} geometric normal(){return opt.cross(p[v[0]],p[v[1]],p[v[0]],p[v[2]]);} double area(){return fabs(opt.dis(normal(),origin))/2.0;}}con[maxn&lt;&lt;1],h[maxn&lt;&lt;1];// å­˜å‚¨é¢ä»å¤–é¢çœ‹é€†æ—¶é’ˆå­˜int check(plane alpha,geometric vec){return opt.dot(origin,alpha.normal(),p[alpha.v[0]],vec)&gt;0;}int n,cnt,indx,l,vis[maxn][maxn];double S;int main(){ srand(time(0)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { double x,y,z; scanf(&quot;%Lf%Lf%Lf&quot;,&amp;x,&amp;y,&amp;z); p[++cnt]=geometric(x,y,z); p[i].shake(); } con[++indx]=plane(1,2,3); con[++indx]=plane(3,2,1); for(int i=4;i&lt;=cnt;i++) { for(int j=1,res;j&lt;=indx;j++) { res=check(con[j],p[i]); if(!res)h[++l]=con[j];//ä¿å­˜ä¸éœ€è¦åˆ é™¤çš„é¢ for(int k=0;k&lt;3;k++) { vis[con[j].v[k]][con[j].v[(k+1)%3]]=res;// æ ‡è®°è¾¹ // åˆ é™¤çš„æ ‡è®°ä¸ºtrueä¸åˆ é™¤çš„æ ‡è®°ä¸ºfalse } } for(int j=1;j&lt;=indx;j++) { for(int k=0;k&lt;3;k++) { int x=con[j].v[k],y=con[j].v[(k+1)%3]; if(vis[x][y]&amp;&amp;!vis[y][x])h[++l]=plane(x,y,i); // è¾¹ç¼˜ // ä½¿ç”¨è¿‡çš„è¢«åˆ äº†ï¼Œå»ºé¢ç”¨ä½¿ç”¨è¿‡çš„é¡ºåº } } for(int j=1;j&lt;=l;j++)con[j]=h[j]; indx=l,l=0; } for(int i=1;i&lt;=indx;i++)S+=con[i].area(); printf(&quot;%0.3Lf&quot;,S); return 0;} å·åŒ…è£¹æ³• å…¶å®å°±åƒæ˜¯ç”¨ä¸€å¼ çº¸å»æ—‹è½¬åŒ…ä½å‡¸åŒ…ï¼Œç¢°åˆ°çš„ç¬¬ä¸€ä¸ªç‚¹ä½œä¸ºå‡¸åŒ…é¡¶ç‚¹ï¼Œé¢ä¸å¤ªä¼šå†™ã€‚ æ—¶é—´å¤æ‚åº¦O(nh)O(nh)O(nh)ï¼Œhhhä¸ºå‡¸åŒ…ç‚¹æ•°ï¼Œéšæœºæ•°æ®ä¸‹èƒ½è·‘æˆO(n)O(\\sqrt n)O(nâ€‹)ï¼Ÿ QuickHull ä¸ä¼šï¼ŒæŒ–å‘ã€‚ï¼ˆä¹Ÿè®¸ä¸ä¼šè¡¥ï¼Œæ¯”ç«Ÿéš¾å†™ï¼Œåˆä¸ç”¨ï¼‰ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn)å¥½åƒæ˜¯æœ€å¿«çš„ã€‚ ä¸€äº›ä¾‹é¢˜ï¼š [SHOI2012]ä¿¡ç”¨å¡å‡¸åŒ… [HAOI2011]é˜²çº¿ä¿®å»º [HNOI2008]æ°´å¹³å¯è§ç›´çº¿ [SDOI2013]ä¿æŠ¤å‡ºé¢˜äºº æ—‹è½¬å¡å£³ è¯»æ³• ï¼ˆå…¶å®æˆ‘ä¹Ÿä¸çŸ¥é“è¯¥æ€ä¹ˆè¯»ï¼Œæœ‰ 16 ç§è¯»æ³•ï¼‰ å‡¸å¤šè¾¹å½¢çš„åˆ‡çº¿ å¦‚æœä¸€æ¡ç›´çº¿ä¸å‡¸å¤šè¾¹å½¢æœ‰äº¤ç‚¹ï¼Œå¹¶ä¸”æ•´ä¸ªå‡¸å¤šè¾¹å½¢éƒ½åœ¨è¿™æ¡ç›´çº¿çš„ä¸€ä¾§ï¼Œé‚£ä¹ˆè¿™æ¡ç›´çº¿å°±æ˜¯è¯¥å‡¸å¤šè¾¹å½¢çš„ä¸€æ¡åˆ‡çº¿ã€‚ å¯¹è¸µç‚¹ å¦‚æœè¿‡å‡¸å¤šè¾¹å½¢ä¸Šä¸¤ç‚¹ä½œä¸€å¯¹å¹³è¡Œçº¿ï¼Œä½¿å¾—æ•´ä¸ªå¤šè¾¹å½¢éƒ½åœ¨è¿™ä¸¤æ¡çº¿ä¹‹é—´ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹è¢«ç§°ä¸ºä¸€å¯¹å¯¹è¸µç‚¹ã€‚ å‡¸å¤šè¾¹å½¢çš„ç›´å¾„ å³å‡¸å¤šè¾¹å½¢ä¸Šä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´è·ç¦»çš„æœ€å¤§å€¼ã€‚ç›´å¾„ä¸€å®šä¼šåœ¨å¯¹è¸µç‚¹ä¸­äº§ç”Ÿï¼Œå¦‚æœä¸¤ä¸ªç‚¹ä¸æ˜¯å¯¹è¸µç‚¹ï¼Œé‚£ä¹ˆä¸¤ä¸ªç‚¹ä¸­ä¸€å®šå¯ä»¥è®©ä¸€ä¸ªç‚¹å‘å¦ä¸€ä¸ªç‚¹çš„å¯¹è¸µç‚¹æ–¹å‘ç§»åŠ¨ä½¿å¾—è·ç¦»æ›´å¤§ã€‚å¹¶ä¸”ç‚¹ä¸ç‚¹ä¹‹é—´çš„è·ç¦»å¯ä»¥ä½“ç°ä¸ºçº¿ä¸çº¿ä¹‹é—´çš„è·ç¦»ï¼Œåœ¨éå¯¹è¸µç‚¹ä¹‹é—´æ„é€ å¹³è¡Œçº¿ï¼Œä¸€å®šæ²¡æœ‰åœ¨å¯¹è¸µç‚¹æ„é€ å¹³è¡Œçº¿ä¼˜ï¼Œè¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡å¹³ç§»çœ‹å‡ºã€‚ æ—‹è½¬å¡å£³ å…ˆä¸Šä¸€å¼ æ¯”è¾ƒæ ‡è‡´çš„å›¾ï¼Œæ¥å¯¹æ—‹è½¬å¡å£³æœ‰ä¸€ä¸ªåˆæ­¥çš„äº†è§£ï¼š å¯¹äºå®ç°æ—‹è½¬å¡å£³ï¼Œæˆ‘ä»¬é¦–å…ˆå¯ä»¥å…ˆå»æ±‚å‡ºå‡¸åŒ…ï¼Œç„¶åå»æšä¸¾æ¯ä¸€æ¡è¾¹ï¼Œå»æ‰¾å¯¹è¸µç‚¹ï¼Œå³å¯æ‰¾å‡ºå‡¸åŒ…ç›´å¾„ã€‚æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn) åœ¨æ—‹è½¬çš„æ—¶å€™ç”¨å‰ç§¯å¯¹åº”çš„é¢ç§¯ï¼Œæ¥æ‰¾å¯¹è¸µç‚¹å°±å¥½äº†ï¼Œå› ä¸ºåœ¨å‡¸åŒ…ä¸Šæœ‰ä¸€ä¸ªå•è°ƒæ€§ï¼Œåœ¨æ‰¾å¯¹è¸µç‚¹çš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯O(n)O(n)O(n)çš„ï¼Œå»ºè®®å¥½å¥½æ€è€ƒä¸€ä¸‹ã€‚ æ³¨æ„ï¼Œåœ¨æ—‹è½¬æ—¶ä¸ºä¸€ä¸ªç¯ï¼Œéœ€è¦æ³¨æ„è¾¹ç•Œé—®é¢˜ï¼Œè¦ä¸è¦ä¼šæ”¶è·è¡€ä¸æ³ªçš„æ•™è®­ ï¼ˆåˆ«é—®æˆ‘æ€ä¹ˆçŸ¥é“çš„ï¼‰ ã€æ¨¡æ¿ã€‘æ—‹è½¬å¡å£³ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;struct geometric{ double x,y,dss; friend geometric operator + (const geometric a,const geometric b){return (geometric){a.x+b.x,a.y+b.y};} friend geometric operator - (const geometric a,const geometric b){return (geometric){a.x-b.x,a.y-b.y};} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));}};int n,top;double ans;geometric d[maxn],opt,st[maxn];bool cmp(geometric a,geometric b){ double tamp=opt.cross(d[1],a,d[1],b); if(tamp&gt;0)return true; if(tamp==0&amp;&amp;opt.dis(d[1],a)&lt;opt.dis(d[1],b))return true; return false;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lf%lf&quot;,&amp;d[i].x,&amp;d[i].y); if(i!=1&amp;&amp;d[i].y&lt;d[1].y) { swap(d[1].y,d[i].y); swap(d[1].x,d[i].x); } if(i!=1&amp;&amp;d[i].y==d[1].y&amp;&amp;d[i].x&gt;d[1].x) swap(d[1].x,d[i].x); } sort(d+2,d+n+1,cmp); st[++top]=d[1]; for(int i=2;i&lt;=n;i++) { while(top&gt;1&amp;&amp;opt.cross(st[top-1],st[top],st[top],d[i])&lt;=0)top--; st[++top]=d[i]; } st[++top]=d[1]; for(int i=2,j=3;i&lt;=top;i++) { while(opt.cross(st[i-1],st[i],st[i-1],st[j])&lt;opt.cross(st[i-1],st[i],st[i-1],st[j+1]))j==top-1?j=1:j++;// ï¼ï¼ï¼ï¼ ans=max(ans,max(opt.dis(st[i],st[j]),opt.dis(st[i-1],st[j]))); } printf(&quot;%d&quot;,int(ans*ans)); return 0;} ä¸€äº›ä¾‹é¢˜ [HNOI2007]æœ€å°çŸ©å½¢è¦†ç›– [SCOI2007]æœ€å¤§åœŸåœ°é¢ç§¯ [HNOI2008]æ°´å¹³å¯è§ç›´çº¿ [ZJOI2008]ç­æœ›å¡” éƒ¨åˆ†èµ„æ–™å‚è€ƒè‡ªæ´›è°·æ—¥æŠ¥ åŠå¹³é¢äº¤ åŠå¹³é¢ å¹³é¢å†…çš„ä¸€æ¡ç›´çº¿æŠŠè¿™ä¸ªå¹³é¢åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œæ¯ä¸€éƒ¨åˆ†å¯¹è¿™ä¸ªå¹³é¢æ¥è¯´ï¼Œéƒ½å«åšåŠå¹³é¢ã€‚åŒ…æ‹¬è¿™æ¡ç›´çº¿çš„åŠå¹³é¢å«åšé—­åŠå¹³é¢ï¼Œå¦åˆ™å«åšå¼€åŠå¹³é¢ã€‚ è§£æå¼ä¸º Ax+By+C&gt;=0Ax + By +C &gt;=0Ax+By+C&gt;=0æˆ–Ax+By+C&lt;=0Ax + By +C &lt;=0Ax+By+C&lt;=0ã€‚ åœ¨è®¡ç®—å‡ ä½•ä¸­ç”¨å‘é‡è¡¨ç¤ºï¼Œæ•´ä¸ªé¢˜ç»Ÿä¸€ä»¥å‘é‡çš„å·¦ä¾§æˆ–å³ä¾§ä¸ºåŠå¹³é¢ã€‚ åŠå¹³é¢äº¤ åŠå¹³é¢äº¤å°±æ˜¯å¤šä¸ªåŠå¹³é¢çš„äº¤é›†ã€‚åŠå¹³é¢äº¤æ˜¯ä¸€ä¸ªç‚¹é›†ã€‚ å®ƒå¯ä»¥ç†è§£ä¸ºå‘é‡é›†ä¸­æ¯ä¸€ä¸ªå‘é‡çš„å³ä¾§çš„äº¤ï¼Œæˆ–è€…æ˜¯ä¸‹é¢æ–¹ç¨‹ç»„çš„è§£ã€‚ {A1x+B1y+C1â‰¥0A2x+B2y+C2â‰¥0 \\left\\{ \\begin{aligned} A_1x+B_1y+C_1 \\ge 0\\\\ A_2x+B_2y+C_2 \\ge 0 \\end{aligned} \\right. {A1â€‹x+B1â€‹y+C1â€‹â‰¥0A2â€‹x+B2â€‹y+C2â€‹â‰¥0â€‹ å¤šè¾¹å½¢çš„æ ¸ å¦‚æœä¸€ä¸ªç‚¹é›†ä¸­çš„ç‚¹ä¸å¤šè¾¹å½¢ä¸Šä»»æ„ä¸€ç‚¹çš„è¿çº¿ä¸å¤šè¾¹å½¢æ²¡æœ‰å…¶ä»–äº¤ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹é›†è¢«ç§°ä¸ºå¤šè¾¹å½¢çš„æ ¸ã€‚ æŠŠå¤šè¾¹å½¢çš„æ¯æ¡è¾¹çœ‹æˆæ˜¯é¦–å°¾ç›¸è¿çš„å‘é‡ï¼Œé‚£ä¹ˆè¿™äº›å‘é‡åœ¨å¤šè¾¹å½¢å†…éƒ¨æ–¹å‘çš„åŠå¹³é¢äº¤å°±æ˜¯å¤šè¾¹å½¢çš„æ ¸ã€‚ æ±‚æ³• D&amp;C ç®—æ³• è¯¥ç®—æ³•æ˜¯åŸºäºåˆ†æ²»æ€æƒ³çš„ï¼š å°†nnnä¸ªåŠå¹³é¢åˆ†æˆä¸¤ä¸ªn/2n/2n/2çš„é›†åˆ; å¯¹ä¸¤ä¸ªå­é›†å’Œé€’å½’æ±‚è§£åŠå¹³é¢äº¤; å°†å‰ä¸€æ­¥ç®—å‡ºæ¥çš„ä¸¤ä¸ªäº¤åˆ©ç”¨å¹³é¢æ‰«ææ³•æ±‚è§£ã€‚ æ—¶é—´å¤æ‚åº¦(nlogâ¡n)(n \\log n)(nlogn)è¿™ä¸ªç®—æ³•å¹¶ä¸å¸¸ç”¨ï¼Œä¸»è¦ä»‹ç»çš„æ˜¯ä¸‹é¢è¿™ä¸ªã€‚ S&amp;I ç®—æ³• è¯¥ç®—æ³•æ˜¯åœ¨ 2006 å¹´æœ‰ä¸­å›½é˜Ÿé˜Ÿå‘˜æœ±æ³½å›­æå‡ºæ¥çš„â€œæ’åºå¢é‡æ³•â€ã€‚ å‡è®¾ç»™å‡ºnnnæ¡ç›´çº¿ï¼Œæ±‚è¿™nnnæ¡ç›´çº¿çš„å·¦æ–¹åŠå¹³é¢çš„äº¤é›†ï¼š é¦–å…ˆå¯¹è¿™nnnæ¡ç›´çº¿æŒ‰æè§’æ’åºï¼› ç”¨ä¸€ä¸ªé˜Ÿåˆ—å»ç»´æŠ¤åŠå¹³é¢çš„äº¤é›†ï¼Œå’Œç›¸é‚»ä¸¤æ¡ç›´çº¿çš„äº¤ç‚¹ï¼› æ¯æ¬¡åŠ å…¥æ–°çš„ç›´çº¿æ—¶åˆ¤æ–­æ˜¯å¦æœ‰äº¤ç‚¹åœ¨è¯¥ç›´çº¿çš„å³é¢ï¼Œå¦‚æœæ˜¯åˆ™å¼¹å‡ºç›´çº¿ï¼Œå…ˆåˆ¤é˜Ÿå°¾å†åˆ¤é˜Ÿé¦–ï¼Œæ³¨æ„åˆ¤æ–­å¹³è¡Œæƒ…å†µï¼› æœ€åé˜Ÿåˆ—ä¸­çš„äº¤é›†å³ä¸ºåŠå¹³é¢äº¤ã€‚ æ³¨æ„äº‹é¡¹ï¼ï¼ï¼ åœ¨å¼¹å‡ºä¸éœ€è¦çš„äº¤ç‚¹æ—¶ä¸€å®šè¦å…ˆå¤„ç†é˜Ÿå°¾å†å¤„ç†é˜Ÿé¦–ï¼Œå› ä¸ºåœ¨æ’å…¥å‘é‡æ—¶ï¼Œæœ‰å¯èƒ½æ˜¯ä¼šæŠŠé˜Ÿé¦–å‘é‡å¼¹å‡ºçš„ï¼Œæ­¤æ—¶å¦‚æœå…ˆå¼¹é˜Ÿé¦–æ²¡å›å‡ºç°è¯¯åˆ ï¼Œ ï¼ˆABâƒ—\\vec{AB}ABå…ˆå…¥é˜Ÿï¼‰ æ­¤æ—¶æˆ‘ä»¬æ’å…¥EFâƒ—\\vec{EF}EFï¼ŒGGGç‚¹è‚¯å®šæ˜¯è¦åˆ å»ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬å…ˆå¼¹é˜Ÿé¦–å°±ä¼šæŠŠå¯èƒ½ä¼šæˆä¸ºç­”æ¡ˆçš„ABâƒ—\\vec{AB}ABåˆ å»ï¼Œå› ä¸ºæŒ‰é€†æ—¶é’ˆæ’åºï¼Œæ‰€ä»¥åæ’å…¥çš„CDâƒ—\\vec{CD}CDå½±å“ä¼šæ›´å¤§ä¸€äº›ï¼Œåº”å…ˆå¤„ç†é˜Ÿå°¾ã€‚ ã€æ¨¡æ¿ã€‘åŠå¹³é¢äº¤ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;const int maxn=1010;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);}}opt;int n,m,tot,head=1,tail=1;double ans;geometric data[maxn],origin,T[maxn];struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }}q[maxn],p[maxn],take;int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;m); for(int j=1;j&lt;=m;j++) scanf(&quot;%lf%lf&quot;,&amp;data[j].x,&amp;data[j].y); for(int j=1;j&lt;=m;j++) { if(j==m)p[++tot]=line(data[j],data[1]-data[j]); else p[++tot]=line(data[j],data[j+1]-data[j]); } } sort(p+1,p+tot+1); q[head]=p[head]; for(int i=2;i&lt;=tot;i++) { while(head&lt;tail&amp;&amp;opt.cross(origin,p[i].B,p[i].A,T[tail-1])&lt;=eps)tail--; while(head&lt;tail&amp;&amp;opt.cross(origin,p[i].B,p[i].A,T[head])&lt;=eps)head++; q[++tail]=p[i]; if(fabs(opt.cross(origin,q[tail].B,origin,q[tail-1].B))&lt;=eps) { tail--; if(opt.cross(origin,q[tail].B,q[tail].A,p[i].A)&gt;eps)q[tail]=p[i]; } if(head&lt;tail)T[tail-1]=take.sdot(q[tail-1],q[tail]); } while(head&lt;tail&amp;&amp;opt.cross(origin,q[head].B,q[head].A,T[tail-1])&lt;=eps)tail--; if(tail-head&gt;1) T[tail]=take.sdot(q[head],q[tail]); for(int i=head;i&lt;=tail;i++) { if(i==tail)ans+=opt.cross(origin,T[i],origin,T[head]); else ans+=opt.cross(origin,T[i],origin,T[i+1]); } printf(&quot;%.3lf&quot;,ans/2); return 0;} ä¸€äº›ä¾‹é¢˜ [ZJOI2008]ç­æœ›å¡” [HNOI2008]æ°´å¹³å¯è§ç›´çº¿ [JLOI2013]èµ›è½¦ [HNOI2012]å°„ç®­ éšæœºå¢é‡ éšæœºå¢é‡æ³• éšæœºå¢é‡æ³•å¯ä»¥ç”¨æ¥è§£å†³æœ€å°åœ†è¦†ç›–ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆæ€è€ƒä¸€ä¸‹è¿™ä¸ªé—®é¢˜ï¼š ç»™å®šå¹³é¢ä¸Šnnnä¸ªç‚¹ï¼Œæ±‚ä¸€ä¸ªåŠå¾„æœ€å°çš„åœ†å»è¦†ç›–è¿™nnnä¸ªç‚¹ã€‚ æˆ‘ä»¬å¯ä»¥å…ˆè®¾ç‚¹é›†AAAçš„æœ€å°åœ†è¦†ç›–ä¸ºc(A)c(A)c(A)ï¼Œå¯¹äºä¸€ä¸ªæœ€å°è¦†ç›–åœ†ï¼Œå®ƒè‚¯å®šæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š c(A)c(A)c(A) æ˜¯å”¯ä¸€çš„; åœ†ä¸Šæœ‰ä¸‰ä¸ªï¼ˆæˆ–ä»¥ä¸Šï¼‰AAAä¸­çš„ç‚¹; åœ†ä¸Šæœ‰ä¸¤ä¸ªç‚¹ä¸ºä¸€æ¡ç›´å¾„çš„ä¸¤ç«¯. å…¶ä¸­ç¬¬äºŒæ¡å’Œç¬¬ä¸‰æ¡å¿…é¡»æ»¡è¶³å…¶ä¸­ä¹‹ä¸€ã€‚ æˆ‘ä»¬å…ˆå‡è®¾ç›®å‰å·²ç»æ±‚å‡ºäº†iâˆ’1i-1iâˆ’1ä¸ªç‚¹çš„æœ€å°è¦†ç›–åœ†ï¼Œåœ¨åŠ å…¥ç¬¬iiiä¸ªç‚¹åï¼Œæœ€å°è¦†ç›–åœ†ä¸€å®šæ˜¯: å‰iâˆ’1i-1iâˆ’1ä¸ªç‚¹ä¸­çš„ä¸¤ä¸ªç‚¹ä¸ç¬¬iiiä¸ªç‚¹ä¸‰ç‚¹ç¡®å®šçš„åœ†; å‰iâˆ’1i-1iâˆ’1ä¸ªç‚¹ä¸­çš„ä¸€ä¸ªç‚¹ä¸ç¬¬iiiä¸ªç‚¹ä¸ºç›´å¾„ä½œçš„åœ†. é¢ã€‚ã€‚æ˜“è¯ï¼ ä¸»è¦çš„ä»£ç éƒ¨åˆ†ï¼š 12345678910111213141516171819202122for(int i=2;i&lt;=n;i++) { if(check(center,r,d[i]))continue; geometric now;double nr=0; for(int j=1;j&lt;i;j++) { if(check(now,nr,d[j]))continue; now=(d[i]+d[j])/2.0; nr=opt.dis(d[i],d[j])/2.0; // å…ˆä»¥ä¸€æ¡ç›´å¾„ä½œåœ† for(int k=1;k&lt;j;k++) { if(check(now,nr,d[k]))continue; now=Center(d[i],d[j],d[k]); nr=opt.dis(now,d[i]); // æ‰¾ç¬¬ä¸‰ä¸ªç‚¹ä½œåœ† } } center=now;r=nr; } ç„¶åæˆ‘ä»¬å‘ç°ï¼Œæˆ‘ä»¬ä¼¼ä¹å†™äº†ä¸€ä¸ªO(n3)O(n^3)O(n3)çš„æš´åŠ›ã€‚ã€‚å…¶å®ä¸ç„¶ã€‚ æ—¶é—´å¤æ‚åº¦çš„è¯æ˜ ç”±äºnnnä¸ªç‚¹æœ€å¤šç”±ä¸‰ä¸ªç‚¹ç¡®å®šçš„æœ€å°è¦†ç›–åœ†ï¼Œå› æ­¤æ¯ä¸ªç‚¹å‚ä¸ç¡®å®šæœ€ä¸‹è¦†ç›–åœ†çš„æ¦‚ç‡ä¸å¤§äº3n\\frac{3}{n}n3â€‹ã€‚ æ‰€ä»¥æ¯ä¸€å±‚åœ¨ç¬¬iiiä¸ªç‚¹å¤„è°ƒç”¨ä¸‹ä¸€å±‚çš„æ¦‚ç‡ä¸å¤§äº3i\\frac{3}{i}i3â€‹ã€‚ è®¾ä¸‰ä¸ªå¾ªç¯çš„æ—¶é—´å¤æ‚åº¦ä¸ºT1,T2,T3T_1,T_2,T_3T1â€‹,T2â€‹,T3â€‹: T1(n)=O(n)+âˆ‘i=1n3iT2(i)T2(n)=O(n)+âˆ‘i=1n3iT3(i)T3(n)=O(n)\\begin{aligned}T_1(n) &amp; = O(n) + \\sum_{i=1}^{n}{\\frac{3}{i}T_2(i)}\\\\ T_2(n) &amp; = O(n) + \\sum_{i=1}^{n}{\\frac{3}{i}T_3(i)}\\\\ T_3(n) &amp; = O(n)\\end{aligned} T1â€‹(n)T2â€‹(n)T3â€‹(n)â€‹=O(n)+i=1âˆ‘nâ€‹i3â€‹T2â€‹(i)=O(n)+i=1âˆ‘nâ€‹i3â€‹T3â€‹(i)=O(n)â€‹ å¯ä»¥è§£å¾—T1=T2=T3=O(n)T_1=T_2=T_3=O(n)T1â€‹=T2â€‹=T3â€‹=O(n)ã€‚ è¯æ¯•ã€‚ ä½†æ˜¯è¿™åªæ˜¯åœ¨æ•°æ®éšæœºçš„æƒ…å†µä¸‹ï¼Œä½†æ˜¯å‡ºé¢˜äººå¾€å¾€ä¸è¿™ä¹ˆåšï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨random_shuffleå‡½æ•°è¿›è¡Œæ‰°åŠ¨å°±å¾ˆå¥½äº†ã€‚ æœ€ån3n^3n3è¿‡ç™¾ä¸‡ï¼ï¼ï¼ˆè¿«çœŸï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;const int maxn=1e5+10;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);} geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));}}opt,origin,d[maxn],st[maxn];int n,top;double S=0,rx,ry;int Sure(double x){return fabs(x)&lt;eps?0:(x&lt;0?-1:1);}bool check(geometric a,double r,geometric b){return Sure(r-opt.dis(a,b))&gt;=0;}geometric Center(geometric a,geometric b,geometric c){ geometric mid1,mid2,cen; double k1=0,k2=0,b1=0,b2=0; if(a.y!=b.y)k1=-(a.x-b.x)/(a.y-b.y); if(b.y!=c.y)k2=-(b.x-c.x)/(b.y-c.y); mid1=(a+b)/2.0;mid2=(b+c)/2.0; b1=mid1.y-mid1.x*k1;b2=mid2.y-mid2.x*k2; if(k1==k2) cen=(a+c)/2.0; else { cen.x=(b2-b1)/(k1-k2); cen.y=k1*cen.x+b1; } return cen;}int main(){ srand(time(0)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;d[i].x,&amp;d[i].y); random_shuffle(d+1,d+n+1); geometric center=d[1];double r=0; for(int i=2;i&lt;=n;i++) { if(check(center,r,d[i]))continue; geometric now;double nr=0; for(int j=1;j&lt;i;j++) { if(check(now,nr,d[j]))continue; now=(d[i]+d[j])/2.0; nr=opt.dis(d[i],d[j])/2.0; for(int k=1;k&lt;j;k++) { if(check(now,nr,d[k]))continue; now=Center(d[i],d[j],d[k]); nr=opt.dis(now,d[i]); } } center=now;r=nr; } printf(&quot;%0.10lf\\n%0.10lf %0.10lf&quot;,r,center.x,center.y); return 0;} ä¸€äº›ä¾‹é¢˜ æœ€å°åœ†è¦†ç›– [AHOI2012]ä¿¡å·å¡” é—µå¯å¤«æ–¯åŸºå’Œ é—µå¯å¤«æ–¯åŸºå’Œ é—µå¯å¤«æ–¯åŸºå’Œï¼Œåˆç§°ä½œé—µå¯å¤«æ–¯åŸºåŠ æ³•ï¼Œæ˜¯ä¸¤ä¸ªæ¬§å‡ é‡Œå¾—ç©ºé—´çš„ç‚¹é›†çš„å’Œï¼Œä»¥å¾·å›½æ•°å­¦å®¶é—µå¯å¤«æ–¯åŸºå‘½åã€‚ï¼ˆå°çŸ¥è¯†ï¼šé—µå¯å¤«æ–¯åŸºæ›¾ç»åšè¿‡çˆ±å› æ–¯å¦çš„è€å¸ˆã€‚ï¼‰ é—µå¯å¤«æ–¯åŸºå’Œæ˜¯ä¸¤ä¸ªæ¬§å‡ é‡Œå¾—ç©ºé—´çš„ç‚¹é›†çš„å’Œï¼Œä¹Ÿç§°ä¸ºè¿™ä¸¤ä¸ªç©ºé—´çš„è†¨èƒ€é›†ï¼Œè¢«å®šä¹‰ä¸º A+B={a+bâˆ£aâˆˆA,bâˆˆB} A + B=\\{a+b|a \\in A, b \\in B \\} A+B={a+bâˆ£aâˆˆA,bâˆˆB} æ ¹æ®é—µå¯å¤«æ–¯åŸºå’Œçš„å®šä¹‰ï¼Œè‹¥é›†åˆå…ƒç´ æ‰€å¤„ä»£æ•°ç³»ç»Ÿæ»¡è¶³é˜¿è´å°”ç¾¤ï¼ˆåŠ æ³•å¯äº¤æ¢ï¼‰ï¼Œåˆ™é—µå¯å¤«æ–¯åŸºå’Œæœ¬èº«ä¹Ÿæ»¡è¶³äº¤æ¢å¾‹ï¼š A+B=B+A A+B=B+A A+B=B+A ï¼ˆä»¥ä¸Šå‚è€ƒè‡ª Baidu) å…¶å®å¯¹äºé—µå¯å¤«æ–¯åŸºå’Œï¼Œå¯ä»¥é€šä¿—çš„ç†è§£ä¸ºï¼Œå¯¹äºä¸€ä¸ªå‡¸åŒ…AAAç»•ç€å‡¸åŒ…BBBè½¬ä¸€åœˆï¼š ç®—æ³•å®ç° å¯¹äºæ±‚ä¸¤ä¸ªç‚¹é›†çš„é—µå¯å¤«æ–¯åŸºå’Œï¼Œé€šè¿‡è‚‰çœ¼è§‚å¯Ÿï¼Œå’Œç†æ€§åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºè¿™ä¹ˆä¸€ä¸ªç»“è®ºï¼šä¸¤ä¸ªå‡¸åŒ…AAAå’ŒBBBä¸Šçš„è¾¹ä¸€å®šåœ¨é—µå¯å¤«æ–¯åŸºå’Œä¸­å‡ºç°ã€‚ ç„¶åæˆ‘ä»¬å°±å¯ä»¥å…ˆæ±‚å‡ºä¸¤ä¸ªç‚¹é›†çš„å‡¸åŒ…ï¼Œç„¶åæŒ‰æè§’æ’åºåæ±‚é—µå¯å¤«æ–¯åŸºå’Œã€‚ æ±‚å‡¸åŒ…ï¼š 123456789101112131415161718192021222324int Convexhull(geometric *p,ll l){ for(int i=2;i&lt;=l;i++) { if(p[i].y&lt;p[1].y)swap(p[1],p[i]); if(p[i].y==p[1].y&amp;&amp;p[i].x&lt;p[1].x) swap(p[i],p[1]); } geometric k=p[1]; for(int i=1;i&lt;=l;i++)p[i]=p[i]-k; sort(p+2,p+l+1,cmp); int top=0; geometric st[maxn]; st[++top]=p[1]; for(int i=2;i&lt;=l;i++) { while(top&gt;1&amp;&amp;cross(st[top-1],st[top],st[top],p[i])&lt;0) top--; st[++top]=p[i]; } for(int i=1;i&lt;=top;i++)p[i]=st[i]+k; p[top+1]=p[1]; return top;} æ±‚é—µå¯å¤«æ–¯åŸºå’Œï¼š 123456789101112131415161718192021222324void Minkowski(){ for(int i=1;i&lt;=n;i++)s1[i]=p1[i+1]-p1[i]; for(int i=1;i&lt;=m;i++)s2[i]=p2[i+1]-p2[i]; S[++cnt]=p1[1]+p2[1]; int i=1,j=1; while(i&lt;=n&amp;&amp;j&lt;=m) { cnt++; if(cross(origin,s1[i],origin,s2[j])&gt;=0) S[cnt]=S[cnt-1]+s1[i++]; else S[cnt]=S[cnt-1]+s2[j++]; } while(i&lt;=n) { cnt++; S[cnt]=S[cnt-1]+s1[i++]; } while(j&lt;=m) { cnt++; S[cnt]=S[cnt-1]+s2[j++]; }} ä¸€äº›ä¾‹é¢˜ [JSOI2018]æˆ˜äº‰ Pick å®šç† ç»™å®šé¡¶ç‚¹å‡ä¸ºæ•´ç‚¹çš„å¤šè¾¹å½¢ï¼Œå…¶é¢ç§¯SSSå’Œå†…éƒ¨æ ¼ç‚¹æ•°ç›®iiiï¼Œè¾¹ä¸Šæ ¼ç‚¹æ•°ç›®bbbçš„å…³ç³»ä¸ºï¼š S=i+b2âˆ’1S=i+\\frac{b}{2}-1 S=i+2bâ€‹âˆ’1 å…¶ä¸æ¬§æ‹‰å…¬å¼ï¼Œ Vâˆ’E+F=2V-E+F=2 Vâˆ’E+F=2 æ˜¯ç­‰ä»·çš„ï¼ˆFFFä¸ºé¢æ•°ï¼ŒVVVä¸ºé¡¶ç‚¹æ•°ï¼ŒEEEä¸ºè¾¹æ•°ï¼‰ ï¼ˆå¥½åƒå¯ä»¥è¯æ˜ä¸ºä»€ä¹ˆåªæœ‰äº”ç§æ­£å¤šé¢ä½“ğŸ¤”ï¼‰ æ‰«æçº¿ æ‰«æçº¿æ˜¯ç”¨æ¥è§£å†³äºŒç»´å¹³é¢å†…çš„çŸ©å½¢é¢ç§¯å¹¶çš„ï¼Œ ä¸»è¦è¿˜æ˜¯ç”¨åˆ°äº†çº¿æ®µæ ‘å’Œåæ ‡ç¦»æ•£åŒ–ã€‚ ç”¨çº¿æ®µæ ‘ç»´æŠ¤å½“å‰ä½ç½®ä¸Šæ˜¯å¦æœ‰çŸ©å½¢å³å¯ï¼Œ é¢˜ç›® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ll long long#define lson(p) (p&lt;&lt;1)#define rson(p) (p&lt;&lt;1|1)using namespace std;const int maxn=1e5+10;ll n,num[4*maxn],tot,cnt,ans;struct segment{ ll Lx,Ly,Rx,Ry,v; segment(int x1=0,int y1=0,int x2=0,int y2=0,int V=0):Lx(x1),Ly(y1),Rx(x2),Ry(y2),v(V) {} friend bool operator &lt; (const segment x,const segment y){ if(x.Ly==y.Ly)return x.Lx&lt;y.Lx; return x.Ly&lt;y.Ly; } ll len(segment x,segment y){return Rx-Lx;}}line[maxn*2];struct Segmentree{ ll val,ls,rs,cnt;}t[maxn&lt;&lt;4];int len(int p){return num[t[p].rs]-num[t[p].ls-1];}ll read(){ ll x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}void LSH(){ sort(num+1,num+tot+1); tot=unique(num+1,num+tot+1)-num-1; sort(line+1,line+cnt+1);}void push_up(int p){ if(t[p].cnt)t[p].val=len(p); else t[p].val=t[lson(p)].val+t[rson(p)].val;}void build(int l,int r,int p){ t[p].ls=l;t[p].rs=r; if(l==r)return; int mid=(l+r)&gt;&gt;1; build(l,mid,lson(p)); build(mid+1,r,rson(p));}void change(int l,int r,int p,int x,int y,int k){ if(x&lt;=l&amp;&amp;r&lt;=y) { t[p].cnt+=k; push_up(p); return ; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(l,mid,lson(p),x,y,k); if(mid&lt;y)change(mid+1,r,rson(p),x,y,k); push_up(p);}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { ll x1,x2,y1,y2; x1=read();y1=read();x2=read();y2=read(); line[++cnt]=segment(x1,y1,x2,y1,1); line[++cnt]=segment(x1,y2,x2,y2,-1); num[++tot]=x1;num[++tot]=x2; } LSH(); build(1,tot,1); for(int i=1;i&lt;=cnt;i++) { int x=lower_bound(num+1,num+tot+1,line[i].Lx)-num; int y=lower_bound(num+1,num+tot+1,line[i].Rx)-num; if(line[i].Ly!=line[i-1].Ly&amp;&amp;i!=1) ans+=(line[i].Ly-line[i-1].Ly)*t[1].val; change(1,tot,1,x+1,y,line[i].v); } printf(&quot;%lld&quot;,ans); return 0;} çª—å£çš„æ˜Ÿæ˜Ÿ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å…ˆå›ºå®šä½çŸ©å½¢çš„å³ä¸Šè§’ä½¿å…¶åœ¨ä¸€å®šçš„èŒƒå›´å†…å¯ä»¥è¦†ç›–åˆ°æ˜Ÿæ˜Ÿï¼Œè¿™æ—¶è¿™ä¸ªèŒƒå›´å°±æ˜¯ç¬¬ä¸€ä¸ªä»¥è¯¥æ˜Ÿæ˜Ÿä¸ºæœ€ä¸‹è§’çš„ä¸€ä¸ªçŸ©é˜µï¼Œæƒå€¼å³ä¸ºè¿™ä¸ªæ˜Ÿæ˜Ÿçš„äº®åº¦ï¼Œè½¬åŒ–ä¸ºåŒºé—´æœ€å€¼é—®é¢˜ã€‚ ååºé—®é¢˜ äºŒç»´ååº ç»™å®šnnnä¸ªäºŒå…ƒç»„(x,y)(x,y)(x,y)ï¼Œæ±‚æ»¡è¶³æ¡ä»¶çš„äºŒå…ƒç»„å¯¹æ•°ã€‚ æ¯”å¦‚é€†åºå¯¹ï¼Œè¿™é‡Œç»™å‡ºæƒå€¼çº¿æ®µæ ‘çš„æ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define lson(p) (p&lt;&lt;1)#define rson(p) (p&lt;&lt;1|1)using namespace std;const int maxn=5e5+10;int n,a[maxn],h[maxn],size;int k[maxn],indx[maxn];long long ans;struct Segment{ int ls,rs,val;}t[maxn&lt;&lt;2];void push_up(int p){ t[p].val=t[lson(p)].val+t[rson(p)].val;}void update(int l,int r,int p,int x){ if(l==r) { t[p].val++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) { ans+=t[rson(p)].val; update(l,mid,lson(p),x); } else update(mid+1,r,rson(p),x); push_up(p);}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),h[i]=a[i]; sort(h+1,h+n+1); size=unique(h+1,h+n+1)-h-1; for(int i=1;i&lt;=n;i++) { indx[i]=lower_bound(h+1,h+size+1,a[i])-h; update(1,size,1,indx[i]); } printf(&quot;%lld\\n&quot;,ans); return 0;} ä¸‰ç»´ååº ç»™å®šnnnä¸ªä¸‰å…ƒç»„(x,y,z)(x,y,z)(x,y,z)ï¼Œæ±‚æ»¡è¶³æ¡ä»¶çš„å¯¹æ•°ã€‚ å…ˆå¯¹xxxæ’åºï¼Œå°†å…¶è½¬åŒ–ä¸ºäºŒç»´ååºï¼Œç„¶åç”¨ CDQ åˆ†æ²»ï¼Œå°†yyyæ’åºï¼Œç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤zzz é™Œä¸ŠèŠ±å¼€ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;const int maxn=1e5+10;using namespace std;int n,cnt=1,Max,Ans[maxn];struct node{ int a,b,c,t,val;}d[maxn];struct Segmentree{ int ls,rs,val;}t[maxn&lt;&lt;3];void push_up(int p){ t[p].val=t[t[p].ls].val+t[t[p].rs].val;}bool cmp1(node x,node y){ if(x.a==y.a) { if(x.b==y.b) return x.c&lt;y.c; else return x.b&lt;y.b; } else return x.a&lt;y.a;}bool cmp2(node x,node y){ if(x.b==y.b) return x.c&lt;y.c; else return x.b&lt;y.b;}int Insert(int l,int r,int p,int x,int k,int&amp; sum){ if(p==0)p=++cnt; if(l==r) { sum+=t[p].val; t[p].val+=k; return p; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) t[p].ls=Insert(l,mid,t[p].ls,x,k,sum); else { sum+=t[t[p].ls].val; t[p].rs=Insert(mid+1,r,t[p].rs,x,k,sum); } push_up(p); return p;}void cdq(int l,int r){ if(l==r)return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); cdq(mid+1,r); sort(d+l,d+mid+1,cmp2); sort(d+mid+1,d+r+1,cmp2); cnt=1; int sum,j=l; for(int i=mid+1;i&lt;=r;i++) { while(d[i].b&gt;=d[j].b&amp;&amp;j&lt;=mid) { Insert(1,Max,1,d[j].c,d[j].t,sum); j++; } sum=0; Insert(1,Max,1,d[i].c,0,sum); d[i].val+=sum; } for(int i=1;i&lt;=cnt;i++) t[i].ls=t[i].rs=t[i].val=0;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;Max); int N=n; for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;d[i].a,&amp;d[i].b,&amp;d[i].c); sort(d+1,d+n+1,cmp1); int tot=0; for(int i=1,len=1;i&lt;=n;i++) { if(d[i].a!=d[i+1].a||d[i].b!=d[i+1].b||d[i].c!=d[i+1].c) { tot++; d[tot]=d[i]; d[tot].t=len; len=1; } else len++; } n=tot; cdq(1,n); for(int i=1;i&lt;=n;i++) Ans[d[i].val+d[i].t-1]+=d[i].t; for(int i=0;i&lt;N;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0;} n ç»´ååº å››ç»´çš„è¯å¯ä»¥è€ƒè™‘ CDQ å¥— CDQï¼Œæ›´é«˜çš„è¯ç›´æ¥ KD-treeã€‚ æ•°å€¼ç§¯åˆ† ä¸ä¼šï¼ŒæŒ–å‘ï¼Œè€ƒè™‘ä¸€ä¸‹åœ¨è¡¥ï¼Œå¯ä»¥å¾ˆé«˜æ•ˆçš„å¤„ç†ç²¾åº¦é—®é¢˜å’Œä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„é—®é¢˜ã€‚ upd(2022/8/16):åœ¨å¦ä¸€å¤„è¡¥å¥½åŠ›ï¼ã€‚ è®¡ç®—å‡ ä½•æ‚é¡¹ æœ¬æ¥æƒ³å†™åˆ°å‰é¢çš„ï¼Œç»“æœå†™åˆ°è¿™é‡Œäº† åˆ¤æ–­ç²¾åº¦ ç²¾åº¦é—®é¢˜æ˜¯è®¡ç®—å‡ ä½•éå¸¸æ¶å¿ƒçš„ä¸€ä¸ªåœ°æ–¹ï¼Œæœ‰æ—¶å€™ä¸€ä¸ªéå¸¸åˆé€‚çš„ç²¾åº¦å¯ä»¥å†³å®šä½ æ˜¯å¦èƒ½ A æ‰è¿™ä¸ªé¢˜ 12345const double eps=1e-10;int sure(double x){ return fabs(x)&lt;eps?0:x&lt;0?-1:1;} ç‚¹ 123struct Point{ double x,y;}; å‘é‡ è®°å½•èµ·ç‚¹å’Œç»ˆç‚¹ 123struct Vector{ Point a,b;}; å››åˆ™è¿ç®— 1234friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// å‘é‡çš„å››åˆ™è¿ç®— è·ç¦» 1double dis(Point a,Point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} ç‚¹ç§¯ 1double dot(Point a1,Point a2,Point b1,Point b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} å‰ç§¯ 1double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} å‘é‡å¤¹è§’ 1double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} ä¸¤å‘é‡å›´æˆçš„å››è¾¹å½¢é¢ç§¯ 1double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} æè§’ 1double angle(geometric a){return atan2(a.y,a.x);} é€†æ—¶é’ˆæ—‹è½¬ 1geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} é¡ºæ—¶é’ˆæ—‹è½¬ 1geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} ç›´çº¿ ç‚¹åŠ æ–¹å‘å‘é‡ 1234567891011struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }};// æŒ‰æè§’æ’åºå·²ç»æ±‚ä¸¤ç›´çº¿çš„äº¤ç‚¹ ä¸‰ç»´è®¡ç®—å‡ ä½• 1234567891011struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// å‘é‡çš„å››åˆ™è¿ç®— double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // å‘é‡æ¨¡é•¿ double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// ç‚¹ç§¯ geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a,b;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // å‰ç§¯}; å¹³é¢ 123456truct plane{ geometric a,b,c; plane(geometric A=origin,geometric B=origin,geometric C=origin):a(A),b(B),c(C) {} geometric normal(){return opt.cross(p[v[0]],p[v[1]],p[v[0]],p[v[2]]);} double area(){return fabs(opt.dis(origin,opt.cross(a,b,a,c)))/2.0;}};// é¢ç§¯ï¼Œé€†æ—¶é’ˆå­˜ç‚¹,æ³•å‘é‡ æœ€åæ¨èä¸¤ä¸ªç”»å›¾å·¥å…·desmoså’ŒGeogebra! ç›®å‰æˆ‘æ•´ç†çš„è¿˜åªæœ‰è¿™äº›ï¼Œè¿‡æ®µæ—¶é—´è¿˜ä¼šå†ä½œè¡¥å……ï¼Œæ„Ÿè°¢è§‚çœ‹ï¼ï¼ï¼","link":"/2022/06/11/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95All-in-All/"},{"title":"è®¡ç®—å‡ ä½•å°è½¦å¤´","text":"ä¸€äº›è®¡ç®—å‡ ä½•å¸¸ç”¨çš„ä¸œè¥¿å§ã€‚ (upd:2022/8/17 å†™äº†ä¸€ä¸ªæ–°ç‰ˆçš„æ¿å­ï¼Œåœ¨åé¢) ä¸€äº›è®¡ç®—å‡ ä½•å¸¸ç”¨çš„ä¸œè¥¿å§ã€‚ (upd:2022/8/17 å†™äº†ä¸€ä¸ªæ–°ç‰ˆçš„æ¿å­ï¼Œåœ¨åé¢) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// å‘é‡çš„å››åˆ™è¿ç®— double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} // å‘é‡æ¨¡é•¿ double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);}// ç‚¹ç§¯ double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} // å‰ç§¯ double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a2,b1,b2)/(dis(a1,a2)*dis(b1,b2));}// å‘é‡å¤¹è§’ double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));}// ä¸¤å‘é‡å›´æˆçš„å››è¾¹å½¢é¢ç§¯ double angle(geometric a){return atan2(a.y,a.x);}// æè§’ geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} // å‘é‡é€†æ—¶é’ˆæ—‹è½¬ geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} // å‘é‡é¡ºæ—¶é’ˆæ—‹è½¬}opt;struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }};// äºŒç»´è®¡ç®—å‡ ä½•struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// å‘é‡çš„å››åˆ™è¿ç®— double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // å‘é‡æ¨¡é•¿ double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// ç‚¹ç§¯ geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a,b;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // å‰ç§¯}opt;struct plane{ geometric a,b,c; plane(geometric A=origin,geometric B=origin,geometric C=origin):a(A),b(B),c(C) {} double area(){return fabs(opt.dis(origin,opt.cross(a,b,a,c)))/2.0;}};// å¹³é¢// ä¸‰ç»´è®¡ç®—å‡ ä½•/*æ–°çš„æ¿å­ï¼ï¼ï¼*/struct Point{ double x, y; Point(double _x = 0, double _y = 0):x(_x), y(_y) {} friend Point operator + (Point a, Point b){return Point(a.x+b.x, a.y+b.y);} friend Point operator - (Point a, Point b){return Point(a.x-b.x, a.y-b.y);} friend Point operator * (Point a, double b){return Point(a.x*b, a.y*b);} friend Point operator / (Point a, double b){return Point(a.x/b, a.y/b);}}origin;struct Vector{ Point a, b; Vector(Point _a = 0, Point _b = 0):a(_a), b(_b) {} double calx(){return b.x - a.x;} double caly(){return b.y - a.y;}};double dis(Point a, Point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double len(Vector v){ return dis(v.a, v.b);}double dot(Vector v1, Vector v2){ return v1.calx()*v2.calx() + v1.caly()*v2.caly();}double cross(Vector v1, Vector v2){ return v1.calx()*v2.caly() - v2.calx()*v1.caly();}double corner(Vector v1, Vector v2){ return dot(v1, v2)/(len(v1)*len(v2));}double area(Vector v1, Vector v2){ return cross(v1, v2)/2.0;}double angle(Vector v){ return atan2(v.caly(), v.calx());}Vector rotate_counterclockwise(Vector v, double theta){ double x = v.calx(); double y = v.caly(); return Vector(x*cos(theta) - y*sin(theta), x*sin(theta) + y*cos(theta));}Vector rotate_clockwise(Vector v, double theta){ double x = v.calx(); double y = v.caly(); return Vector(x*cos(theta) + y*sin(theta), y*cos(theta) - x*sin(theta));}struct line{ Point A, B; double An; line(Point a = 0, Point b = 0):A(a), B(b) {An = atan2(B.y, B.x);} bool operator &lt; (const line &amp;a)const{return An &lt; a.An;}};Point sdot(line a, line b){ Point c = a.A - b.A; double k = cross(Vector(origin, b.B), Vector(origin, c)) / cross(Vector(origin, a.B), Vector(origin, b.B)); return a.A + a.B*k;}","link":"/2022/06/14/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%B0%8F%E8%BD%A6%E5%A4%B4/"},{"title":"è®¡ç®—å‡ ä½•é€‰åš","text":"è®¡ç®—å‡ ä½•å¤§æ°´é¢˜ï¼ï¼ï¼ è®¡ç®—å‡ ä½•é€‰åš [SCOI2016]å¦–æ€ª è¿˜æŒºç®€å•çš„ä¸€é“é¢˜ï¼Œä¸éš¾çœ‹å‡ºç­”æ¡ˆæ˜¯å…·æœ‰å•è°ƒæ€§çš„è€Œä¸”ï¼Œæ±‚æœ€å¤§æ”»å‡»åŠ›æœ€å°ï¼Œå¾ˆå®¹æ˜“å°±ä¼šæƒ³åˆ°äºŒåˆ†ã€‚ å‡è®¾æˆ‘ä»¬å½“å‰äºŒåˆ†çš„å€¼ä¸ºmidmidmidï¼Œç°åœ¨éœ€è¦å»è§£å†³çš„æ˜¯å¦‚ä½•å»checkcheckcheckå½“å‰çš„ç­”æ¡ˆåˆä¸åˆæ³•ï¼Œå…¶å®å°±æ˜¯è§£ä¸€ä¸ªå½¢å¦‚ï¼š atki+dnfi+atkiba+dnfiabâ‰¤midatk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b} \\le mid atkiâ€‹+dnfiâ€‹+atkiâ€‹abâ€‹+dnfiâ€‹baâ€‹â‰¤mid çš„ä¸€ä¸ªä¸ç­‰å¼ï¼Œä¸Šè¿°å¼å­ä¸­è¯´æ˜äº†æ¯ä¸ªå¦–ç²¾çš„æˆ˜æ–—åŠ›å¾ˆæ˜¾ç„¶æ˜¯atki+dnfi+atkiba+dnfiabatk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b}atkiâ€‹+dnfiâ€‹+atkiâ€‹abâ€‹+dnfiâ€‹baâ€‹ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥å¯¹å¼å­è¿›è¡Œå˜å½¢ï¼š atki+dnfi+atkiba+dnfiabâˆ’midâ‰¤0atk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b}- mid \\le 0 atkiâ€‹+dnfiâ€‹+atkiâ€‹abâ€‹+dnfiâ€‹baâ€‹âˆ’midâ‰¤0 è®¾A=atki,B=atki+dnfiâˆ’mid,C=dnfiA = atk_i,B = atk_i + dnf_i-mid,C = dnf_iA=atkiâ€‹,B=atkiâ€‹+dnfiâ€‹âˆ’mid,C=dnfiâ€‹å†å°†ba\\frac{b}{a}abâ€‹è®¾ä¸ºxxxï¼Œå¼å­å˜ä¸ºï¼š Ax+B+C1xâ‰¤0Ax+B+C\\frac{1}{x} \\le 0 Ax+B+Cx1â€‹â‰¤0 ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥xxxå¾—ï¼š Ax2+Bx+Câ‰¤0Ax^2+Bx+C \\le 0 Ax2+Bx+Câ‰¤0 checkcheckcheckæ—¶åˆ¤æ–­èŒƒå›´äºŒæ¬¡å‡½æ•°è§£é›†æ˜¯å¦æœ‰äº¤å³å¯ï¼Œè¿˜æœ‰æ³¨æ„è§£æ˜¯è¦å¤§äº0çš„ã€‚ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n \\log n)O(nlogn) çª—å£çš„æ˜Ÿæ˜Ÿ å…ˆåªè€ƒè™‘ç»™å®šçª—å£çš„å·¦ä¸Šè§’å“ªäº›ä½ç½®å¯ä»¥åœˆåˆ°ä¸€é¢—æ˜Ÿæ˜Ÿï¼Œä¸éš¾å‘ç°ä¸‹å›¾ï¼š å³ä¸‹è§’ä¸ºæˆ‘ä»¬éœ€è¦åœˆåˆ°çš„æ˜Ÿæ˜Ÿï¼Œæ•´ä¸ªè™šçº¿åŒºåŸŸå°±æ˜¯å¯ä»¥ä½¿æˆ‘ä»¬æ‰€ç”¨çš„çª—å£çš„å·¦ä¸Šè§’æ»¡è¶³æ¡ä»¶çš„è§£é›†ï¼ˆä¸åŒ…æ‹¬è¾¹ç•Œï¼‰ï¼Œå°†è¿™ä¸ªçŸ©å½¢çš„æƒå€¼è®¾ä¸ºè¿™é¢—æ˜Ÿæ˜Ÿçš„äº®åº¦ï¼Œå¯¹äºæ¯ä¸€é¢—æ˜Ÿæ˜Ÿéƒ½æœ‰å¯¹åº”çš„ä¸€ä¸ªè¿™æ ·çš„çŸ©å½¢ï¼Œè½¬åŒ–ä¸ºé‡åˆçš„åŒºåŸŸæœ€å¤§æƒå€¼ä¸ºå¤šå°‘ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨æ‰«æçº¿è½¬åŒ–ä¸ºåŒºé—´æœ€å€¼é—®é¢˜ã€‚ å¤„ç†è¾¹ç•Œçš„è¯å¯ä»¥å°†æ‰€æœ‰æ˜Ÿæ˜Ÿçš„åæ ‡åç§»0.5ï¼Œå°±å¯ä»¥å¾ˆå¥½çš„å¤„ç†è¾¹ç•Œé—®é¢˜ã€‚ [HNOI2007]æœ€å°çŸ©å½¢è¦†ç›– é¢˜æ„å¾ˆç®€å•ï¼Œæ±‚å¯¹å¹³é¢ä¸Šç‚¹çš„æœ€å°çŸ©å½¢è¦†ç›–ã€‚ ä¸éš¾æƒ³åˆ°ï¼Œæ—‹è½¬å¡å£³å¯ä»¥è½»æ¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯¹äºæœ€å°çŸ©å½¢è¦†ç›–ï¼Œå…¶æœ€å°çŸ©å½¢çš„ä¸€æ¡è¾¹å¿…å®šåœ¨è¿™nnä¸ªç‚¹çš„å‡¸åŒ…ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬å°±å…ˆæ±‚å‡ºå‡¸åŒ…å†ä½¿ç”¨æ—‹è½¬å¡å£³ï¼Œæ‰¾åˆ°åœ¨ä»¥å½“å‰è¾¹ä¸ºçŸ©å½¢çš„ä¸€æ¡è¾¹æ—¶ï¼Œåœ¨æœ€å·¦è¾¹ï¼Œæœ€å³è¾¹ï¼Œæœ€ä¸Šè¾¹çš„ç‚¹ï¼Œç„¶åç”¨å‘é‡åŠ å‡çš„æ–¹æ³•æ±‚å‡ºçŸ©å½¢çš„é«˜å’Œå®½ï¼Œå†è¿›ä¸€æ­¥æ±‚é¢ç§¯å°±å¥½äº†ã€‚ ï¼ˆæ³¨æ„æ˜¯å¦æœ‰æ— è§£çš„æƒ…å†µï¼‰ ç„¶åè¿˜æœ‰ä¸€é“ç±»ä¼¼çš„é¢˜ç›®ï¼Œå°±æ˜¯æ•°æ®ä¸å¤ªä¸€æ ·ã€‚ UVA11178 Morleyâ€™s Theorem æ— éå°±æ˜¯å‘é‡çš„æ—‹è½¬å’Œç›´çº¿çš„æ±‚äº¤ç‚¹è€Œå·²ã€‚ [USACO15FEB]Fencing the Herd G é¢˜æ„å¤§æ¦‚å°±æ˜¯æœ‰mmmç§æ“ä½œï¼š æ’å…¥ä¸€ä¸ªç‚¹ è¯¢é—®Ax+By=CAx+By=CAx+By=Cè¿™æ¡ç›´çº¿æ˜¯å¦å’Œå½“å‰æ’å…¥çš„ç‚¹ç»„æˆçš„å‡¸åŒ…æœ‰äº¤ æ—¢ç„¶ä¸å¼ºåˆ¶åœ¨çº¿ï¼Œå°±å¯ä»¥ç¦»çº¿ä¸‹æ¥åˆ©ç”¨CDQåˆ†æ²»çš„æ€æƒ³ï¼Œå»å¤„ç†æ¯ä¸ªè¯¢é—®ä¹‹å‰çš„ä¿®æ”¹æ“ä½œå¯¹è¯¢é—®çš„å½±å“ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è€ƒè™‘å¦‚ä½•è®¡ç®—å½±å“ã€‚ ç»™å‡ºçš„é™åˆ¶æ¡ä»¶å…¶å®å°±æ˜¯åˆ¤æ–­å½“å‰å·²ç»æ’å…¥çš„æ‰€æœ‰ç‚¹ï¼Œå¸¦å…¥å¼å­åæ˜¯å¦åŒå·ï¼Œå…¶å®å°±æ˜¯åˆ¤æ–­æ˜¯å¦éƒ½åœ¨åŒä¸€ä¸ªåŠå¹³é¢ï¼Œè¿›ä¸€æ­¥è½¬åŒ–é—®é¢˜ä¸ºï¼Œå‡¸åŒ…çš„ä¸Šä¸‹ä¸¤ä¸ªç‚¹çš„å€¼çš„åˆ¤æ–­ï¼Œå¯ä»¥çœ‹ä¸€ä¸ªå›¾ï¼ˆæˆ‘æ¬çš„ï¼‰ åˆ¤æ–­æ—¶ï¼Œåªéœ€è¦è®¡ç®—Ax+ByAx + ByAx+Byæ¥ä½œä¸ºå€¼å»åˆ¤æ–­ï¼Œå‡è®¾è®¡ç®—å‡ºæ¥çš„æœ€å¤§å€¼ä¸ºCmaxC_{max}Cmaxâ€‹æœ€å°å€¼ä¸ºCminC_{min}Cminâ€‹ï¼Œå½“Cmin&lt;C&lt;CmaxC_{min} &lt; C &lt;C_{max}Cminâ€‹&lt;C&lt;Cmaxâ€‹æ—¶å¾ˆæ˜æ˜¾å°±æ˜¯ä¸å‡¸åŒ…æœ‰äº¤ã€‚ ç»´æŠ¤æ—¶éœ€è¦ç»´æŠ¤ä¸€ä¸ªä¸Šå‡¸åŒ…å’Œä¸€ä¸ªä¸‹å‡¸åŒ…ï¼Œåˆ©ç”¨å‡¸åŒ…å•è°ƒæ€§ï¼Œå»æ—‹è½¬åˆ¤æ–­ï¼Œè®°å½•æ¯æ¡ç›´çº¿çš„CminC_{min}Cminâ€‹å’ŒCmaxC_{max}Cmaxâ€‹æœ€åç»Ÿä¸€åˆ¤æ–­å³å¯ã€‚ æ—¶é—´å¤æ‚åº¦O(nlogâ¡n)O(n\\log n)O(nlogn) [IOI1998] [USACO5.5] çŸ©å½¢å‘¨é•¿Picture é¢˜æ„å°±æ˜¯æ±‚å¹³é¢å†…çŸ©å½¢çš„å‘¨é•¿å¹¶ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹å›¾ å›¾å¾ˆå½¢è±¡å§ï¼Œå¾ˆæ˜æ˜¾æ‰«æçº¿å¯ä»¥è½»æ˜“çš„è§£å†³è¿™é“é¢˜ï¼Œï¼ˆä½†æ˜¯æ•°æ®èŒƒå›´å¤ªå°ï¼Œè¿n2n^2n2éƒ½èƒ½æš´ç¢¾è¿‡å»ï¼Œè€Œä¸”ä¼¼ä¹è·‘çš„æ¯”æ‰«æçº¿è¿˜å¿«ï¼‰ã€‚ é¦–å…ˆå’Œæ±‚é¢ç§¯å¹¶ä¸€æ ·çš„æ–¹æ³•å»ç»´æŠ¤ï¼ŒåŒæ—¶æ•°æ®è§„æ¨¡ä¹Ÿä¸éœ€è¦æˆ‘ä»¬å»ç¦»æ•£åŒ–ï¼Œç°åœ¨è€ƒè™‘å¦‚ä½•å»ç»Ÿè®¡ç­”æ¡ˆï¼Œ æ¯æ¬¡åŠ å…¥ä¸€æ¡çº¿æ®µæ—¶ï¼Œå¯¹æ•´æ£µçº¿æ®µæ ‘ï¼Œä¸­ç»´æŠ¤çš„åŒºé—´è¦†ç›–çš„ä¸ªæ•°çš„æ”¹å˜å…¶å®å°±æ˜¯æˆ‘ä»¬éœ€è¦ç´¯åŠ çš„ç­”æ¡ˆï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ä¸æ˜¯å—ï¼Ÿ ä½†æ˜¯ä¸€æ¬¡æ‰«æè¿˜ä¸å¤Ÿï¼Œè¦æ‰«ä¸¤æ¬¡ï¼Œå…ˆæ‰«ä¸€éxxxè½´å†æ‰«ä¸€éyyyè½´å³å¯ï¼Œä¸è¿‡ä¹Ÿå¯ä»¥åœ¨æ‰«xxxä¸ªè½´çš„æ—¶å€™åŒæ—¶è®¡ç®—yyyè½´çš„ç­”æ¡ˆï¼Œæ‰«ä¸€éä¹Ÿèƒ½è§£å†³é—®é¢˜ï¼Œå°±æ˜¯éœ€è¦æ³¨æ„ä¸€äº›å°ç»†èŠ‚ã€‚ é¦–å…ˆéœ€è¦æ³¨æ„ï¼Œæƒå€¼çº¿æ®µæ ‘çš„å€¼åŸŸä¸º[âˆ’1e5,1e5][-1e5, 1e5][âˆ’1e5,1e5]ï¼Œç„¶åéå¸¸é‡è¦çš„ä¸€ç‚¹å°±æ˜¯ï¼Œåœ¨çº¿æ®µæ ‘ä¸Šä¸€æ®µåŒºé—´çš„é•¿åº¦ä¸ºrâˆ’l+1r-l+1râˆ’l+1ï¼Œä½†åœ¨è®¡ç®—è¾¹é•¿çš„æ—¶å€™å¯¹äºåæ ‡ç³»ä¸­çš„ä¸€æ¡çº¿æ®µï¼Œå…¶é•¿ä¸ºrâˆ’lr-lrâˆ’lï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åœ¨ä¿®æ”¹çº¿æ®µæ—¶éœ€è¦å¯¹å³ç«¯ç‚¹-1ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„ç‚¹ï¼Œé‚£å°±æ˜¯ï¼Œåœ¨æ’åºæ—¶å¦‚æœä¸¤ä¸ªçº¿æ®µåœ¨åŒä¸€ç›´çº¿ä¸Šéœ€è¦è®©æ‰§è¡ŒåŠ å…¥çº¿æ®µæ“ä½œçš„åœ¨å‰ï¼Œæ¯”å¦‚ï¼š 123456input:20 0 4 40 4 4 8output:24 è¿™ç»„æ•°æ®ï¼Œå¯¹åº”è¿‡æ¥å°±æ˜¯ å¦‚è¿‡æˆ‘ä»¬åœ¨è®¡ç®—xxxè½´æ—¶å…ˆåˆ å»äº†BCBCBCå†æ‰§è¡Œæ’å…¥å°±ä¼šç®—äº†ä¸¤éè´¡çŒ®ï¼Œyyyè½´ä¸Šä¹ŸåŒç†ï¼Œæ’åºçš„æ—¶å€™éœ€è¦æ³¨æ„ä¸€ä¸‹ã€‚ [JSOI2010]å†·å†»æ³¢ å¾ˆæ¸…æ™°çš„é¢˜æ„å¯¹å§ï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆè€ƒè™‘æ²¡æœ‰æ ‘æœ¨é˜»æŒ¡çš„æƒ…å†µï¼Œæ±‚æœ€å°æ—¶é—´ï¼Œä¸€ç§åšæ³•å°±æ˜¯äºŒåˆ†åŠ ç½‘ç»œæµï¼ŒäºŒåˆ†æšä¸¾æœ€å°æ—¶é—´ï¼Œç„¶åå»ºå›¾çš„è¯å°±æ˜¯å¯¹äºæ¯ä¸ªå·«å¦–å‘å®ƒèƒ½ä»¥æ”»å‡»åˆ°çš„ç²¾çµè¿ä¸€æ¡æƒå€¼ä¸º1çš„è¾¹ï¼Œç„¶åä»æºç‚¹å‘æ¯ä¸ªå·«å¦–è¿ä¸€æ¡æƒå€¼ä¸ºåœ¨é™åˆ¶çš„æ—¶é—´å†…èƒ½ä»¥æ”»å‡»çš„æœ€å¤šæ¬¡æ•°çš„è¾¹ï¼Œæ¯ä¸ªç²¾çµå‘æ±‡ç‚¹è¿ä¸€æ¡æƒå€¼ä¸º1çš„è¾¹ï¼Œæœ€åè·‘æœ€å¤§æµå³å¯ã€‚ ç°åœ¨åŠ å…¥æ ‘æœ¨ï¼Œæ ‘æœ¨èƒ½ä»¥å½±å“ä¸¤ä¸ªç‚¹çš„è¯å°±æ˜¯åˆ¤æ–­ï¼Œåœ†ä¸çº¿æ®µæ˜¯å¦æœ‰äº¤ç‚¹ï¼Œå¦‚ä¸‹ï¼š çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹éƒ½åœ¨åœ†å†…ï¼Œæ— äº¤ç‚¹ã€‚ çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹ä¸€ä¸ªåœ¨å›­å†…ä¸€ä¸ªåœ¨åœ†å¤–ï¼Œæœ‰äº¤ç‚¹ã€‚ çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹å‡åœ¨åœ†å¤–ï¼Œåˆ¤æ–­æ–¹æ³•å°±æ˜¯ä»åœ†å¿ƒå‘çº¿æ®µæ‰€åœ¨çš„ç›´çº¿ä½œå‚çº¿ï¼Œé•¿åº¦è®°ä¸ºdddå¦‚æœd&gt;rd &gt; rd&gt;råˆ™æ— äº¤ç‚¹ï¼Œå¦‚æœdâ‰¤rd \\le rdâ‰¤réœ€è¦å»åˆ¤æ–­åœ†å¿ƒä¸ç«¯ç‚¹çš„è¿çº¿ä¸çº¿æ®µæ‰€æˆçš„è§’æ˜¯å¦ä¸ºé”è§’ã€‚ ï¼ˆè¯´å®è¯ï¼Œè¿™é¢˜æ•°æ®æŒºæ°´çš„)ï¼Œé¦–å…ˆn3n^3n3æšä¸¾å¤„ç†å‡ºæ¯ä¸ªå·«å¦–æ‰€èƒ½æ‰“åˆ°çš„ç²¾çµï¼Œç„¶åäºŒåˆ†è·‘ç½‘ç»œæµå³å¯ã€‚ ç»™ä¸€ä¸ªæ¯”è¾ƒæ¸…æ™°çš„å›¾å§ã€‚ [JLOI2016]åœ†çš„å¼‚æˆ–å¹¶ é¢˜æ„å°±æ˜¯æ±‚åœ†çš„å¼‚æˆ–å¹¶ï¼Œçœ‹åˆ°nâ‰¤2Ã—105n \\le 2\\times 10^5nâ‰¤2Ã—105ï¼Œè‚¯å®šæ˜¯ä¸èƒ½ä¹±æè¿‡å»çš„ï¼Œä½†æ˜¯æ³¨æ„åˆ°é¢˜ç›®ä¸­çš„å·²çŸ¥è¿™äº›åœ†ä¸¤ä¸¤æ²¡æœ‰äº¤ç‚¹ï¼Œå³ä¸¤åœ†çš„å…³ç³»åªå­˜åœ¨ç›¸ç¦»å’ŒåŒ…å«ï¼Œå°±ä¼šä¸éš¾å¾—å‡ºä¸€ä¸ªæ€§è´¨ï¼šå¦‚æœå°†æ¯ä¸ªåœ†æŒ‰xxxåæ ‡æ’åºåï¼Œå‡è®¾æœ‰ä¸€æ¡å‚ç›´äºxxxè½´çš„æ‰«æçº¿ï¼Œä»å·¦å¾€å³æ‰«ï¼Œä¸€ä¸ªåœ†è‚¯å®šæ˜¯æ¯”å®ƒåŒ…å«çš„åœ†å…ˆå‡ºç°ï¼Œåæ¶ˆå¤±çš„ã€‚ æ˜¾ç„¶æ‰«æçº¿å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œç°åœ¨éœ€è¦çŸ¥é“å¦‚ä½•å»åˆ¤æ–­å¥‡å¶æ€§ï¼Œæ¯æ¬¡æ‰«æçº¿å‘å³ç§»åŠ¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬è‚¯å®šä¸èƒ½æ’å…¥ä¸€ä¸ªåœ†ï¼Œæ¥è®¡ç®—ä¸æ‰«æçº¿çš„äº¤ç‚¹ï¼Œä½†æ˜¯æˆ‘ä»¬ç”¨setç»´æŠ¤ï¼Œåˆ†åˆ«æ’å…¥ä¸€ä¸ªåœ†çš„ä¸Šåœ†å¼§å’Œä¸‹åœ†å¼§ï¼ŒæŒ‰ä¸æ‰«æçº¿çš„äº¤ç‚¹æ’åºæ¥åˆ¤æ–­ä»¥ä¸‹æƒ…å†µï¼š æ’å…¥çš„åœ†å¼§æ˜¯setä¸­çš„å”¯ä¸€ä¸€æ®µåœ†å¼§ï¼Œä¸ºå¥‡é¢ç§¯ã€‚ æ’å…¥åœ†å¼§çš„å‰é©±ä¸ºä¸Šåœ†å¼§ï¼Œè¯¥åœ†çš„å¥‡å¶æ€§ä¸å…¶ç›¸åŒï¼ˆå› ä¸ºæ‰«æçº¿ä»å·¦åˆ°å³ç§»åŠ¨æ—¶ï¼Œç”±äºåœ†ä¸¤ä¸¤ä¹‹é—´æ²¡æœ‰äº¤ç‚¹ï¼Œå‰é©±ä¸ºä¸Šåœ†å¼§æ—¶è‚¯å®šä¸åŒ…å«è¯¥åœ†ï¼‰ æ’å…¥åœ†å¼§çš„å‰é©±ä¸ºä¸‹åœ†å¼§æ—¶ï¼Œè¯¥åœ†çš„å¥‡å¶æ€§ä¸å…¶ç›¸åï¼ˆè¯¥åœ†è¢«å‰é©±çš„åœ†åŒ…å«ï¼‰ æœ€åansåŠ ä¸Šå¥‡é¢ç§¯å‡å»å¶é¢ç§¯å°±å¯ä»¥äº† éœ€è¦æ³¨æ„çš„å‡ ä¸ªç‚¹ï¼š seté‡è½½å°äºå·æ—¶è¦é‡è½½æˆä¸¥æ ¼å°äºï¼Œsetå…·æœ‰ä¸å¯é‡æ€§ï¼Œåªéœ€è¦è®¡ç®—ä¸æ‰«æçº¿äº¤ç‚¹æ—¶åŠ ä¸Šä¸€ä¸ªepsepsepså°±è¡Œäº† ç»Ÿè®¡ç­”æ¡ˆæ—¶å¼€long long UVA1298 Triathlon æ ¹æ®é¢˜æ„åˆ—å‡ºå¼å­ï¼Œè®¾ä¸‰æ®µè·ç¦»åˆ†åˆ«ä¸ºx,y,zx, y, zx,y,zå¯¹äºç¬¬iiiä¸ªäººå’Œç¬¬jjjä¸ªäººï¼Œiiiå¯ä»¥å¾—åˆ°å† å†›ï¼Œå½“ä¸”ä»…å½“ï¼š xvi,1+yvi,2+zvi,3&lt;xvj,1+yvj,2+zvj,3\\frac{x}{v_{i,1}} + \\frac{y}{v_{i,2}} + \\frac{z}{v_{i,3}} &lt; \\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{z}{v_{j,3}} vi,1â€‹xâ€‹+vi,2â€‹yâ€‹+vi,3â€‹zâ€‹&lt;vj,1â€‹xâ€‹+vj,2â€‹yâ€‹+vj,3â€‹zâ€‹ å‘ç°æœ‰ä¸‰ä¸ªæœªçŸ¥æ•°ï¼Œä½†å› ä¸ºæ€»è·¯ç¨‹æ˜¯ä¸€æ ·çš„å¯ä»¥å‡è®¾æ€»è·¯ç¨‹ä¸ºâ€œ1â€ï¼Œè¿™æ ·å°±æœ‰ï¼š xvi,1+yvi,2+1âˆ’xâˆ’yvi,3&lt;xvj,1+yvj,2+1âˆ’xâˆ’yvj,3\\frac{x}{v_{i,1}} + \\frac{y}{v_{i,2}} + \\frac{1-x-y}{v_{i,3}} &lt; \\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{1-x-y}{v_{j,3}} vi,1â€‹xâ€‹+vi,2â€‹yâ€‹+vi,3â€‹1âˆ’xâˆ’yâ€‹&lt;vj,1â€‹xâ€‹+vj,2â€‹yâ€‹+vj,3â€‹1âˆ’xâˆ’yâ€‹ è€ƒè™‘åŒ–æˆAx+By+C&gt;0Ax + By +C &gt; 0Ax+By+C&gt;0çš„å½¢å¼ï¼š xvj,1+yvj,2+1âˆ’xâˆ’yvj,3âˆ’xvi,1âˆ’yvi,2âˆ’1âˆ’xâˆ’yvi,3&gt;0\\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{1-x-y}{v_{j,3}} - \\frac{x}{v_{i,1}} - \\frac{y}{v_{i,2}} - \\frac{1-x-y}{v_{i,3}} &gt; 0 vj,1â€‹xâ€‹+vj,2â€‹yâ€‹+vj,3â€‹1âˆ’xâˆ’yâ€‹âˆ’vi,1â€‹xâ€‹âˆ’vi,2â€‹yâ€‹âˆ’vi,3â€‹1âˆ’xâˆ’yâ€‹&gt;0 è¿›ä¸€æ­¥æ•´ç†å¾—ï¼š (1vj,1âˆ’1vi,1+1vi,3âˆ’1vj,3)x+(1vj,2âˆ’1vi,2+1vi,3âˆ’1vj,3)y+1vj,3âˆ’1vi,3&gt;0(\\frac{1}{v_{j,1}} - \\frac{1}{v_{i,1}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}})x + (\\frac{1}{v_{j,2}} - \\frac{1}{v_{i,2}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}})y + \\frac{1}{v_{j,3}} - \\frac{1}{v_{i,3}} &gt; 0 (vj,1â€‹1â€‹âˆ’vi,1â€‹1â€‹+vi,3â€‹1â€‹âˆ’vj,3â€‹1â€‹)x+(vj,2â€‹1â€‹âˆ’vi,2â€‹1â€‹+vi,3â€‹1â€‹âˆ’vj,3â€‹1â€‹)y+vj,3â€‹1â€‹âˆ’vi,3â€‹1â€‹&gt;0 å…¶ä¸­A=1vj,1âˆ’1vi,1+1vi,3âˆ’1vj,3A = \\frac{1}{v_{j,1}} - \\frac{1}{v_{i,1}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}}A=vj,1â€‹1â€‹âˆ’vi,1â€‹1â€‹+vi,3â€‹1â€‹âˆ’vj,3â€‹1â€‹ï¼ŒB=1vj,2âˆ’1vi,2+1vi,3âˆ’1vj,3B = \\frac{1}{v_{j,2}} - \\frac{1}{v_{i,2}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}}B=vj,2â€‹1â€‹âˆ’vi,2â€‹1â€‹+vi,3â€‹1â€‹âˆ’vj,3â€‹1â€‹ï¼ŒC=1vj,3âˆ’1vi,3C = \\frac{1}{v_{j,3}} - \\frac{1}{v_{i,3}}C=vj,3â€‹1â€‹âˆ’vi,3â€‹1â€‹ï¼ŒåŠå¹³é¢äº¤æ±‚è§£å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2)ã€‚ éœ€è¦æ³¨æ„è®¡ç®—ç³»æ•°æ—¶ï¼Œåˆ†å¼çš„åˆ†å­ä¸º1å¾ˆæ˜æ˜¾ä¼šäº§ç”Ÿè¾ƒå¤§çš„è¯¯å·®ï¼Œ å¯ä»¥åœ¨å¼å­ä¸¤è¾¹åŒæ—¶ä¹˜ä»¥ä¸€ä¸ªè¾ƒå¤§çš„æ•°ï¼Œæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ›´éœ€è¦è¯´æ˜çš„æ˜¯æ ¹æ®æˆ‘ä»¬è®¾çš„x,yx,yx,yå¾ˆæ˜æ˜¾x+yâ‰¤1x+y \\le 1x+yâ‰¤1ï¼Œéœ€è¦å¯¹å…¶è¿›è¡Œé™åˆ¶ã€‚ å…³äºåŠå¹³é¢äº¤ è§£å†³è¿™ç±»é—®é¢˜å¾ˆæ˜æ˜¾æ˜¯åŠå¹³é¢äº¤çš„å¾ˆå¤§ç”¨å¤„ï¼Œæ¥åˆ¤æ–­å¤šå…ƒä¸€æ¬¡ä¸ç­‰å¼ç»„æ˜¯å¦æœ‰è§£ï¼Œåœ¨æ¨ç†å®Œå¼å­åï¼Œå¾€å¾€éœ€è¦æ’å…¥ç›´çº¿ï¼Œé€‰æ‹©ç›´çº¿ä¸Šçš„ä¸€ä¸ªç‚¹å’Œæ–¹å‘å‘é‡ï¼Œä¸€èˆ¬å»ºè®®åŒ–ç®€å¼å­ä¸ºAx+By+Câ‰¥0Ax + By +C \\ge 0Ax+By+Câ‰¥0çš„å½¢å¼ï¼ˆæˆ–ä¸å¸¦ç­‰ï¼‰ï¼Œå–ç›´çº¿çš„â€œå·¦ä¾§â€ï¼Œè¿™é‡Œçš„å·¦ä¾§æ˜¯ä¾ç…§é€‰å–çš„æ–¹å‘å‘é‡æ¥è¯´çš„ï¼Œå¯¹äºé€‰å–æ–¹å‘å‘é‡ï¼Œæˆ‘ä»¬éœ€è¦è®©å…¶æ»¡è¶³å¼å­ä¸­çš„æ¡ä»¶ï¼Œåˆéœ€è¦è®©å…¶æ»¡è¶³æ±‚å·¦ä¾§çš„äº¤ï¼Œæ˜¯ä¸èƒ½éšä¾¿é€‰ç›´çº¿ä¸Šçš„ä¸¤ä¸ªç‚¹æ¥ç¡®å®šçš„ï¼Œå…¶å®å¤šç”»å›¾å°±ä¸éš¾å‘ç°æ–¹å‘å‘é‡å–(B,âˆ’A)(B,-A)(B,âˆ’A)æ˜¯å¯ä»¥æ»¡è¶³è¦æ±‚çš„ï¼Œèµ·ç‚¹çš„è¯ï¼Œä¸€èˆ¬é€‰x=0x= 0x=0å¤„çš„å–å€¼ï¼Œä½†æ˜¯æœ‰æ—¶éœ€è¦è€ƒè™‘å€¼åŸŸã€‚åœ¨æ±‚äº¤çš„æ—¶å€™ï¼Œéœ€è¦é¢å¤–æ³¨æ„é¢˜ç›®ä¸­çš„å€¼åŸŸæ¡ä»¶ï¼Œåœ¨æ±‚äº¤çš„é›†åˆä¸­åŠ å…¥å¯¹åº”çš„ç›´çº¿ã€‚ [SCOI2015]å°å‡¸æƒ³è·‘æ­¥ é¦–å…ˆå‡è®¾PPPç‚¹ä¸º(x,y)(x,y)(x,y)ï¼Œé‚£ä¹ˆæ ¹æ®é¢˜æ„å°±æœ‰ï¼š (x0âˆ’x,y0âˆ’y)Ã—(x1âˆ’x,y1âˆ’y)&lt;(xiâˆ’1âˆ’x,yiâˆ’1âˆ’y)Ã—(xiâˆ’x,yiâˆ’y)(x_0-x, y_0-y) \\times (x_1-x, y_1-y) &lt; (x_{i-1}-x, y_{i-1}-y)\\times(x_i-x, y_i-y) (x0â€‹âˆ’x,y0â€‹âˆ’y)Ã—(x1â€‹âˆ’x,y1â€‹âˆ’y)&lt;(xiâˆ’1â€‹âˆ’x,yiâˆ’1â€‹âˆ’y)Ã—(xiâ€‹âˆ’x,yiâ€‹âˆ’y) è¿›ä¸€æ­¥åŒ–ç®€å¾—ï¼š (x0âˆ’x)(y1âˆ’y)âˆ’(x1âˆ’x)(y0âˆ’y)&lt;(xiâˆ’1âˆ’x)(yiâˆ’y)âˆ’(xiâˆ’x)(yiâˆ’1âˆ’y)(x_0-x)(y_1-y)-(x_1-x)(y_0-y) &lt; (x_{i-1}-x)(y_i-y)-(x_i-x)(y_{i-1}- y) (x0â€‹âˆ’x)(y1â€‹âˆ’y)âˆ’(x1â€‹âˆ’x)(y0â€‹âˆ’y)&lt;(xiâˆ’1â€‹âˆ’x)(yiâ€‹âˆ’y)âˆ’(xiâ€‹âˆ’x)(yiâˆ’1â€‹âˆ’y) æ‹†å¼€å¼å­ï¼Œ x0y1âˆ’x0yâˆ’xy1+xyâˆ’x1y0+x1y+xy0âˆ’xy&lt;xiâˆ’1yiâˆ’xiâˆ’1yâˆ’xyi+xyâˆ’xiyiâˆ’1+xiy+xyiâˆ’1âˆ’xyx_0y_1-x_0y-xy_1+xy-x_1y_0+x_1y+xy_0-xy &lt; x_{i-1}y_i-x_{i-1}y-xy_i+xy-x_iy_{i-1}+x_iy+xy_{i-1}-xy x0â€‹y1â€‹âˆ’x0â€‹yâˆ’xy1â€‹+xyâˆ’x1â€‹y0â€‹+x1â€‹y+xy0â€‹âˆ’xy&lt;xiâˆ’1â€‹yiâ€‹âˆ’xiâˆ’1â€‹yâˆ’xyiâ€‹+xyâˆ’xiâ€‹yiâˆ’1â€‹+xiâ€‹y+xyiâˆ’1â€‹âˆ’xy è½¬åŒ–ä¸ºAx+By+C&gt;0Ax+By +C &gt; 0Ax+By+C&gt;0çš„å½¢å¼ï¼Œ (âˆ’yi+yiâˆ’1+y1âˆ’y0)x+(âˆ’xiâˆ’1+xi+x0âˆ’x1)y+xiâˆ’1yiâˆ’xiyiâˆ’1âˆ’x0y1+x1y0&gt;0(-y_i + y_{i-1} + y_1-y_0)x + (-x_{i-1}+x_i+x_0-x_1)y+x_{i-1}y_i-x_iy_{i-1}-x_0y_1+x_1y_0 &gt; 0 (âˆ’yiâ€‹+yiâˆ’1â€‹+y1â€‹âˆ’y0â€‹)x+(âˆ’xiâˆ’1â€‹+xiâ€‹+x0â€‹âˆ’x1â€‹)y+xiâˆ’1â€‹yiâ€‹âˆ’xiâ€‹yiâˆ’1â€‹âˆ’x0â€‹y1â€‹+x1â€‹y0â€‹&gt;0 å…¶ä¸­A=âˆ’yi+yiâˆ’1+y1âˆ’y0,B=âˆ’xiâˆ’1+xi+x0âˆ’x1,C=xiâˆ’1yiâˆ’xiyiâˆ’1âˆ’x0y1+x1y0A =-y_i + y_{i-1} + y_1-y_0 ,B = -x_{i-1}+x_i+x_0-x_1,C = x_{i-1}y_i-x_iy_{i-1}-x_0y_1+x_1y_0A=âˆ’yiâ€‹+yiâˆ’1â€‹+y1â€‹âˆ’y0â€‹,B=âˆ’xiâˆ’1â€‹+xiâ€‹+x0â€‹âˆ’x1â€‹,C=xiâˆ’1â€‹yiâ€‹âˆ’xiâ€‹yiâˆ’1â€‹âˆ’x0â€‹y1â€‹+x1â€‹y0â€‹ï¼ŒåŠå¹³é¢äº¤æ±‚è§£å³å¯ï¼Œåˆ«å¿˜äº†æŠŠè§£é™åˆ¶åœ¨å‡¸å¤šè¾¹å½¢å†…ã€‚ [USACO22JAN] Multiple Choice Test P å…¶å®çœ‹åˆ°é¢˜ç›®å°±å¯ä»¥å‘ç°ï¼Œæœ€ç»ˆå‘é‡ä¹‹å’Œæœ€å¤§å…¶å®æ˜¯é—µå¯å¤«æ–¯åŸºå’Œä¸Šç¦»åŸç‚¹æœ€è¿œçš„ç‚¹ï¼Œå¯¹äºå¤šä¸ªå‡¸åŒ…çš„é—µå¯å¤«æ–¯åŸºå’Œï¼Œå¯ä»¥ç”¨å¯å‘å¼åˆå¹¶ï¼Œæ¯æ¬¡åˆå¹¶å°çš„ï¼Œ å¤æ‚åº¦O(nlogâ¡n)O(n\\log n)O(nlogn)ã€‚","link":"/2022/08/17/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E9%80%89%E5%81%9A/"},{"title":"é«˜æ–¯æ¶ˆå…ƒ","text":"é«˜æ–¯æ¶ˆå…ƒ é«˜æ–¯æ¶ˆå…ƒ å®šä¹‰ æ•°å­¦ä¸Šï¼Œé«˜æ–¯æ¶ˆå…ƒæ³•ï¼ˆæˆ–è¯‘ï¼šé«˜æ–¯æ¶ˆå»æ³•ï¼‰ï¼Œæ˜¯çº¿æ€§ä»£æ•°è§„åˆ’ä¸­çš„ä¸€ä¸ªç®—æ³•ï¼Œå¯ç”¨æ¥ä¸ºçº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ã€‚ä½†å…¶ç®—æ³•ååˆ†å¤æ‚ï¼Œä¸å¸¸ç”¨äºåŠ å‡æ¶ˆå…ƒæ³•ï¼Œæ±‚å‡ºçŸ©é˜µçš„ç§©ï¼Œä»¥åŠæ±‚å‡ºå¯é€†æ–¹é˜µçš„é€†çŸ©é˜µã€‚ä¸è¿‡ï¼Œå¦‚æœæœ‰è¿‡ç™¾ä¸‡æ¡ç­‰å¼æ—¶ï¼Œè¿™ä¸ªç®—æ³•ä¼šååˆ†çœæ—¶ã€‚ä¸€äº›æå¤§çš„æ–¹ç¨‹ç»„é€šå¸¸ä¼šç”¨è¿­ä»£æ³•ä»¥åŠèŠ±å¼æ¶ˆå…ƒæ¥è§£å†³ã€‚å½“ç”¨äºä¸€ä¸ªçŸ©é˜µæ—¶ï¼Œé«˜æ–¯æ¶ˆå…ƒæ³•ä¼šäº§ç”Ÿå‡ºä¸€ä¸ªâ€œè¡Œæ¢¯é˜µå¼â€ã€‚é«˜æ–¯æ¶ˆå…ƒæ³•å¯ä»¥ç”¨åœ¨ç”µè„‘ä¸­æ¥è§£å†³æ•°åƒæ¡ç­‰å¼åŠæœªçŸ¥æ•°ã€‚äº¦æœ‰ä¸€äº›æ–¹æ³•ç‰¹åœ°ç”¨æ¥è§£å†³ä¸€äº›æœ‰ç‰¹åˆ«æ’åˆ—çš„ç³»æ•°çš„æ–¹ç¨‹ç»„ã€‚ â€”â€”Baidu é«˜æ–¯æ¶ˆå…ƒæ³•ï¼ˆGaussâˆ’JordaneliminationGauss-Jordan eliminationGaussâˆ’Jordaneliminationï¼‰æ˜¯æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„çš„ç»å…¸ç®—æ³•ã€‚å¹¶ä¸”é«˜æ–¯æ¶ˆå…ƒè¿˜å¯ä»¥è®¡ç®—è¡Œåˆ—å¼ï¼Œæ±‚çŸ©é˜µçš„é€†ã€‚ æ¶ˆå…ƒæ³• æ¶ˆå…ƒæ³•ä¸»è¦ä¸ºåŠ å‡æ¶ˆå…ƒï¼ŒåŒæ—¶åŠ å‡æ¶ˆå…ƒä¹Ÿæ˜¯ä¸€ä¸ªæ¯”è¾ƒå¸¸ç”¨çš„æ–¹æ³•ï¼Œå¦‚ï¼š {4x+y=10âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’(1)xâˆ’y=5âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’(2)\\left\\{ \\begin{aligned} 4x+y=10 ------(1)\\\\ x-y=5 ------ (2) \\end{aligned} \\right. {4x+y=10âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’(1)xâˆ’y=5âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’(2)â€‹ (1)+(2)å¼å¯å¾—ï¼š 5x=155x=15 5x=15 è§£å¾—ï¼š x=3x=3 x=3 å°†x=3x=3x=3å¸¦å›(1)å’Œ(2)ä»»ä¸€å¼å­å¯å¾—ï¼š y=âˆ’2y=-2 y=âˆ’2 è¿™å°±æ˜¯æ¶ˆå…ƒæ³•ï¼Œé€šè¿‡ä½¿ä¸¤ä¸ªæ–¹ç¨‹ä¸­åŒä¸€æœªçŸ¥æ•°çš„ç³»æ•°ç›¸åŠ å‡æ¥æ¶ˆå»æœªçŸ¥æ•°ï¼Œå®Œæˆæ±‚è§£çš„ç›®çš„ã€‚ é«˜æ–¯æ¶ˆå…ƒæ³• å¯¹äºä¸€ä¸ªçº¿æ€§æ–¹ç¨‹ç»„æˆ‘ä»¬å¯ä»¥å°†å…¶åŒ–ä¸ºä¸€ä¸ªçŸ©é˜µï¼Œæ¯”å¦‚ä¸€ä¸ªmmmä¸ªnnnå…ƒä¸€æ¬¡æ–¹ç¨‹ç»„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶åŒ–ä¸ºä¸€ä¸ªmÃ—(n+1)m \\times (n+1)mÃ—(n+1)çš„ä¸€ä¸ªçŸ©é˜µï¼ŒçŸ©é˜µçš„æ¯è¡Œçš„å‰nnnä¸ªå…ƒç´ è¡¨ç¤ºä¸ºæ¯ä¸ªæœªçŸ¥æ•°çš„ç³»æ•°ï¼Œç¬¬n+1n+1n+1ä¸ªå…ƒç´ è¡¨ç¤ºä¸ºè¯¥æ–¹ç¨‹æ‰€ç­‰äºçš„å¸¸æ•°ï¼Œè¿™ä¸ªçŸ©é˜µå°±æ˜¯å¢å¹¿çŸ©é˜µã€‚ å¦‚: å¯¹äºä¸€ä¸ªä¸‰å…ƒä¸€æ¬¡æ–¹ç¨‹ç»„ï¼š x1+x2+x3=62x1âˆ’x2+x3=1x1+2x2âˆ’3x3=1x_1+x_2+x_3=6 \\\\ 2x_1-x_2+x_3=1 \\\\ x_1+2x_2-3x_3=1 x1â€‹+x2â€‹+x3â€‹=62x1â€‹âˆ’x2â€‹+x3â€‹=1x1â€‹+2x2â€‹âˆ’3x3â€‹=1 å…¶å¢å¹¿çŸ©é˜µä¸ºï¼š (111âˆ£62âˆ’11âˆ£112âˆ’3âˆ£1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\2&amp;-1&amp;1&amp;|&amp;1\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ââ›â€‹121â€‹1âˆ’12â€‹11âˆ’3â€‹âˆ£âˆ£âˆ£â€‹611â€‹â ââ€‹ æ¥ä¸‹æ¥ä¼šç»è¿‡ä»¥ä¸‹å˜åŒ–ï¼š (111âˆ£62âˆ’11âˆ£112âˆ’3âˆ£1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\2&amp;-1&amp;1&amp;|&amp;1\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ââ›â€‹121â€‹1âˆ’12â€‹11âˆ’3â€‹âˆ£âˆ£âˆ£â€‹611â€‹â ââ€‹ (111âˆ£60âˆ’3âˆ’1âˆ£âˆ’1112âˆ’3âˆ£1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ââ›â€‹101â€‹1âˆ’32â€‹1âˆ’1âˆ’3â€‹âˆ£âˆ£âˆ£â€‹6âˆ’111â€‹â ââ€‹ (111âˆ£60âˆ’3âˆ’1âˆ£âˆ’1101âˆ’4âˆ£âˆ’5)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\0&amp;1&amp;-4&amp;|&amp;-5\\end{pmatrix} ââ›â€‹100â€‹1âˆ’31â€‹1âˆ’1âˆ’4â€‹âˆ£âˆ£âˆ£â€‹6âˆ’11âˆ’5â€‹â ââ€‹ (111âˆ£60âˆ’3âˆ’1âˆ£âˆ’1100âˆ’13âˆ£âˆ’26)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\0&amp;0&amp;-13&amp;|&amp;-26\\end{pmatrix} ââ›â€‹100â€‹1âˆ’30â€‹1âˆ’1âˆ’13â€‹âˆ£âˆ£âˆ£â€‹6âˆ’11âˆ’26â€‹â ââ€‹ æ ¹æ®æœ€åä¸€ä¸ªå¼å­å³å¯å¾—ï¼š x3=2x_3=2 x3â€‹=2 æ¥ç€å›å¸¦ï¼š (100âˆ£1010âˆ£3001âˆ£2)\\begin{pmatrix}1&amp;0&amp;0&amp;|&amp;1\\\\0&amp;1&amp;0&amp;|&amp;3\\\\0&amp;0&amp;1&amp;|&amp;2\\end{pmatrix} ââ›â€‹100â€‹010â€‹001â€‹âˆ£âˆ£âˆ£â€‹132â€‹â ââ€‹ ä»¥ä¸Šçš„å‡ ç§å˜æ¢å«åšåˆç­‰è¡Œå˜æ¢ï¼ŒååŒ–ç®€åçš„å«åšé˜¶æ¢¯å‹çŸ©é˜µï¼Œæœ€ååŒ–ç®€åçš„çŸ©é˜µä¸ºç®€åŒ–é˜¶æ¢¯å‹çŸ©é˜µã€‚ åŒæ—¶å¦‚æœåŒ–ç®€åå‡ºç°è¿™ç§æƒ…å†µï¼š x1=6âˆ’x2x3=1x_1=6-x_2\\\\ x_3=1 x1â€‹=6âˆ’x2â€‹x3â€‹=1 è¿™æ—¶x2x_2x2â€‹å–ä»»ä½•ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªx1x_1x1â€‹ä¸ä¹‹å¯¹åº”ï¼Œåœ¨ä¸Šè¿°çš„æ–¹ç¨‹ä¸­ï¼Œåƒx1,x3x_1,x_3x1â€‹,x3â€‹ç§°ä¸ºä¸»å…ƒï¼Œx2x_2x2â€‹ç§°ä¸ºè‡ªç”±å…ƒã€‚ å¼•è®º æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œé«˜æ–¯æ¶ˆå…ƒåä¼šæœ‰ä¸‰ç§æƒ…å†µï¼š è‹¥å­˜åœ¨ç³»æ•°å…¨ä¸ºé›¶ï¼Œç„¶è€Œå¸¸æ•°ä¸ä¸ºé›¶æ—¶ï¼Œæ–¹ç¨‹æ— è§£ï¼› è‹¥ç³»æ•°ä¸å…¨ä¸ºé›¶çš„è¡Œæ•°å’ŒæœªçŸ¥æ•°çš„ä¸ªæ•°ç›¸ç­‰ï¼Œåˆ™æ–¹ç¨‹æœ‰å”¯ä¸€è§£ï¼› è‹¥ç³»æ•°ä¸å…¨ä¸ºé›¶çš„è¡Œæ•°å°äºæœªçŸ¥æ•°çš„ä¸ªæ•°ï¼Œåˆ™æ–¹ç¨‹æœ‰æ— æ•°ä¸ªè§£ã€‚ ä»£ç å®ç° é¦–å…ˆæˆ‘ä»¬æ•´ç†ä¸€ä¸‹é«˜æ–¯æ¶ˆå…ƒçš„æ­¥éª¤ï¼š å¢å¹¿çŸ©é˜µåˆç­‰è¡Œå˜æ¢ä¸ºæœ€ç®€é˜¶æ¢¯çŸ©é˜µï¼› è¿˜åŸçº¿æ€§æ–¹ç¨‹ç»„ï¼› æ±‚è§£ç¬¬ä¸€ä¸ªå˜é‡ï¼› è¡¥å……è‡ªç”±æœªçŸ¥é‡ï¼› åˆ—è¡¨ç¤ºæ–¹ç¨‹ç»„é€šè§£ã€‚ CODEï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;int n;double c[110][110];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) scanf(&quot;%lf&quot;,&amp;c[i][j]); for(int i=1;i&lt;=n;i++) { for(int j=i;j&lt;=n;j++) { if(fabs(c[j][i])&gt;eps)swap(c[i],c[j]); // æ‰¾åˆ°x[i]ç³»æ•°ä¸ä¸ºé›¶çš„æ–¹ç¨‹ } for(int j=1;j&lt;=n;j++) { if(i==j)continue; double rate=c[j][i]/c[i][i]; for(int k=i;k&lt;=n;k++) { c[j][k]-=c[i][k]*rate; if(fabs(c[j][k])&lt;eps)c[j][k]=0;// æµ®ç‚¹å‹ä¸å¯é¿å…çš„ç²¾åº¦è¯¯å·® }// æ¶ˆå…ƒ c[j][n+1]-=c[i][n+1]*rate; if(fabs(c[j][n+1])&lt;eps)c[j][n+1]=0;// æ”¹å˜å¸¸æ•° } } for(int i=1;i&lt;=n;i++) { int x=0; for(int j=1;j&lt;=n;j++) { if(c[i][j]==0)x++; } if(x==n) { printf(&quot;No Solution&quot;); return 0; }// åˆ¤æ–­æ˜¯å¦æ— è§£ } for(int i=1;i&lt;=n;i++)printf(&quot;%0.2lf\\n&quot;,c[i][n+1]/c[i][i]); return 0;} é™„ä¸Šæ¨¡æ¿é¢˜P3389 ã€æ¨¡æ¿ã€‘é«˜æ–¯æ¶ˆå…ƒæ³•ã€‚ ç»ƒä¹ é¢˜ï¼šP4035 [JSOI2008]çƒå½¢ç©ºé—´äº§ç”Ÿå™¨ã€‚ å®Œç»“æ’’èŠ±ï¼ˆ&gt;_&lt;)","link":"/2022/06/13/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"title":"é«˜çº§ä½œæˆ˜è®°å½•","text":"é«˜çº§ä½œæˆ˜è®°å½• ç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å— ç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—ç»ƒä¹  CSPåˆèµ›æ•´ç† çŸ¥è¯†ç‚¹ LaTeXå…¬å¼å¤§å…¨ æ—¶é—´å¤æ‚åº¦-åŠ¿èƒ½åˆ†ææµ…è°ˆ åšå¼ˆè®º è®¡ç®—å‡ ä½• æ´›è°·æ—¥æŠ¥-è®¡ç®—å‡ ä½• desmos ç¾¤è®º gayç®—å‡ ä½• Geogebra! å†·é—¨å‡½æ•° Emoji CSPåˆèµ›çŸ¥è¯†ç‚¹ DLX å¤šé¡¹å¼æ€»ç»“ æ”¯é…æ ‘è¯¦è§£ PollardRho æµ…è°ˆè™šæ ‘","link":"/2022/06/15/%E9%AB%98%E7%BA%A7%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95/"},{"title":"åšå¼ˆè®º","text":"æ•´ç†äº†ä¸€äº›åšå¼ˆè®ºæ¨¡å‹ï¼Œä½†å¤§éƒ¨åˆ†è¿˜æ˜¯å’•å’•å’•äº†(â—Ë‡âˆ€Ë‡â—) åšå¼ˆè®º ç»„åˆæ¸¸æˆ å‰è¨€ ç»„åˆæ¸¸æˆæ˜¯æŒ‡ä¸€ç§ä¸¤ä¸ªç©å®¶çš„æ¸¸æˆï¼Œæ¯ä¸ªç©å®¶éƒ½æ˜¯èªæ˜ç»é¡¶ä¸å­˜åœ¨éšæœºæ“ä½œï¼Œæ¯”å¦‚æ‰“ç‰Œä¸æ˜¯ï¼Œæ¸¸æˆçš„ç»“æœåªæœ‰èµ¢å’Œè¾“ã€‚ é€šå¸¸ç©å®¶ä¼šäº¤æ›¿ç§»åŠ¨ï¼Œç›´åˆ°æ¸¸æˆç»“æŸï¼Œå³è¾¾åˆ°ç»ˆæ­¢çŠ¶æ€ï¼Œä¸å­˜åœ¨ä»»ä½•ä¸€ç§å¯è¡Œçš„ç§»åŠ¨æ–¹å¼çš„çŠ¶æ€ã€‚ è¿™ç§æ¸¸æˆçš„ç»“æœåœ¨ä¸€å¼€å§‹å°±å·²ç»è¢«å†³å®šäº†ï¼Œç”±æ¸¸æˆçš„é›†åˆï¼Œæ¸¸æˆçš„åˆå§‹çŠ¶æ€å’Œç©å®¶çš„å…ˆåæ‰‹å®Œå…¨ç¡®å®šã€‚ ç»„åˆæ¸¸æˆçš„å½¢å¼æœ‰ä¸¤ç§åˆ†åˆ«æ˜¯Impartial Combinatorial Gameså’ŒPartizan Combinatorial Gamesï¼Œå‰è€…æ˜¯æŒ‡åœ¨æ¸¸æˆä¸­ä¸¤ä½ç©å®¶è¿›è¡Œçš„ç§»åŠ¨æ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œåè€…åˆ™ä¸ç›¸åŒæ¯”å¦‚å›½é™…è±¡æ£‹ï¼ˆNGNLï¼‰ï¼Œä¸»è¦è¿˜æ˜¯è®¨è®ºICGã€‚ å®šä¹‰ å½¢å¼åŒ–çš„å®šä¹‰ä¸€ä¸ªç»„åˆæ¸¸æˆï¼š ä¸¤ä¸ªç©å®¶ç»„æˆçš„æ¸¸æˆ æ¸¸æˆå­˜åœ¨ä¸€ä¸ªæœ‰é™çš„çŠ¶æ€é›†åˆ ä¸¤ä¸ªç©å®¶çš„æ“ä½œæ–¹å¼æ˜¯ç›¸åŒçš„ï¼Œæ²¡æœ‰åŒºåˆ« ç©å®¶äº¤æ›¿è¿›è¡Œ å½“ç©å®¶ç§»åŠ¨åˆ°ç»ˆæ­¢çŠ¶æ€æ—¶ï¼Œæ¸¸æˆç»“æŸ ä¸€èˆ¬çš„è¯éƒ½æ˜¯æœ€åä¸€ä¸ªç§»åŠ¨çš„ç©å®¶è·èƒœï¼Œè®¨è®ºèµ·æ¥è¿˜ç›¸å¯¹ç®€å•ï¼Œä¸è¿‡ä¹Ÿå­˜åœ¨æœ€åä¸€ä¸ªç§»åŠ¨çš„ç©å®¶å¤±è´¥çš„æ¸¸æˆï¼Œæ›´ä¸ºå¤æ‚ä¸€äº›ã€‚ ä¸è¿‡é‡è¦çš„æ˜¯ï¼Œæ— è®ºæ¸¸æˆæ€æ ·è¿›è¡Œï¼Œéƒ½ä¼šåœ¨æœ‰é™æ­¥æ•°å†…ç»“æŸã€‚ å¦å¤–ï¼Œä¸¤ä¸ªç©å®¶éƒ½æ˜¯è¶³å¤Ÿèªæ˜çš„ç©å®¶ï¼Œæ¯ä¸€æ­¥éƒ½ä¼šèµ°æœ€ä¼˜ç­–ç•¥ã€‚ çŠ¶æ€ ç”±äºæ¸¸æˆçš„ç»“æœåœ¨ä¸€å¼€å§‹å°±å¯ä»¥ç¡®å®šï¼Œæ‰€ä»¥å­˜åœ¨å…ˆæ‰‹å¿…èƒœå’Œåæ‰‹å¿…èƒœã€‚ å®šä¹‰P-positionä¸ºå…ˆæ‰‹å¿…èƒœï¼ŒN-position ä¸ºåæ‰‹å¿…èƒœã€‚ NIM æ¸¸æˆ å‰ç½®çŸ¥è¯† ä½è¿ç®— æ­£æ–‡ NIMæ¸¸æˆï¼Œå±äºç»„åˆæ¸¸æˆçš„ä¸€ç§ï¼Œèµ·æºå¯ä»¥è¿½æº¯åˆ°å¾ˆä¹…ä»¥å‰ï¼Œå…¶æ¸¸æˆå†…å®¹ä¸ºï¼š æœ‰nnnå †çŸ³å­Aliceå’ŒBobè½®æµä»ä¸­å–è‡³å°‘ä¸€ä¸ªè‡³å¤šä¸è¶…è¿‡ä¸€å †çŸ³å­ï¼Œè°å–èµ°æœ€åä¸€å †çŸ³å­ï¼Œè°å°±èƒœåˆ©ã€‚ æ˜¯å¦å­˜åœ¨ä¸€ç§å…ˆæ‰‹å¿…èƒœçš„ç­–ç•¥ï¼Ÿ è¿™ç§é—®é¢˜çš„è§£å†³æ–¹æ³•ï¼Œæ˜¯è®¾aia_iaiâ€‹ä¸ºæ¯å †çŸ³å­çš„æ•°é‡ï¼Œx=a1âŠ•a2âŠ•a3âŠ•â‹¯âŠ•anx=a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_nx=a1â€‹âŠ•a2â€‹âŠ•a3â€‹âŠ•â‹¯âŠ•anâ€‹ï¼Œè‹¥xâ‰ 0x\\ne 0xî€ â€‹=0åˆ™å…ˆæ‰‹å¿…èƒœï¼Œå¦åˆ™åæ‰‹å¿…èƒœã€‚ è¯æ˜ï¼š æ²¡æœ‰åç»§çŠ¶æ€çš„çŠ¶æ€ä¸ºå¿…è´¥çŠ¶æ€ï¼ˆTerminal Positionï¼‰ ä¾‹å¦‚å°†çŸ³å­å–å®Œåx=0âŠ•0âŠ•â‹¯âŠ•0=0x=0 \\oplus 0 \\oplus \\cdots \\oplus 0 = 0x=0âŠ•0âŠ•â‹¯âŠ•0=0ï¼Œæ­¤æ—¶ä¸ºN-positionï¼ˆæ­¤æ—¶å…ˆæ‰‹å·²ç»æ²¡æœ‰å¯ä»¥å–çš„çŸ³å­äº†ï¼‰ã€‚ å¯¹äºxâ‰ 0x\\ne 0xî€ â€‹=0 çš„å±€é¢ä¸€å®šå­˜åœ¨æŸç§ç§»åŠ¨ä½¿å¾— x=0x=0x=0ï¼Œå³P-positionä¸€å®šå¯ä»¥è½¬ç§»åˆ°N-position å‡è®¾a1âŠ•a2âŠ•a3âŠ•â‹¯âŠ•anâ‰ 0a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_n \\ne 0a1â€‹âŠ•a2â€‹âŠ•a3â€‹âŠ•â‹¯âŠ•anâ€‹î€ â€‹=0è®¾xxxä¸º1çš„æœ€é«˜ä½ä¸ºç¬¬kkkä½ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ä¸ªaia_iaiâ€‹çš„ç¬¬kkkä½ä¸º1ï¼Œæ­¤æ—¶xâŠ•ai=a1âŠ•a2âŠ•â‹¯âŠ•anx \\oplus a_i=a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_nxâŠ•aiâ€‹=a1â€‹âŠ•a2â€‹âŠ•â‹¯âŠ•anâ€‹ï¼ŒxâŠ•aix\\oplus a_ixâŠ•aiâ€‹ä¸€å®šå°äºaia_iaiâ€‹ï¼ˆå› ä¸ºxxxçš„ç¬¬kkkä½ä¸ä¸º0ï¼Œå¼‚æˆ–aia_iaiâ€‹åä¸º0è‚¯å®šå°äºaia_iaiâ€‹ï¼‰ï¼Œæˆ‘ä»¬ç§»èµ°aiâˆ’aiâŠ•xa_i-a_i \\oplus xaiâ€‹âˆ’aiâ€‹âŠ•xä¸ªçŸ³å­ï¼Œæ­¤æ—¶ç¬¬iiiå †è¿˜å‰©aiâˆ’(aiâˆ’aiâŠ•x)=aiâŠ•xa_i-(a_i-a_i\\oplus x)=a_i \\oplus xaiâ€‹âˆ’(aiâ€‹âˆ’aiâ€‹âŠ•x)=aiâ€‹âŠ•xä¸ªçŸ³å­ï¼Œæ­¤æ—¶a1âŠ•a2âŠ•â‹¯âŠ•aiâŠ•xâŠ•â‹¯âŠ•an=xâŠ•x=0a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_i \\oplus x \\oplus \\cdots\\oplus a_n=x\\oplus x=0a1â€‹âŠ•a2â€‹âŠ•â‹¯âŠ•aiâ€‹âŠ•xâŠ•â‹¯âŠ•anâ€‹=xâŠ•x=0ï¼Œå¾—è¯ã€‚ å¯¹äºx=0x =0x=0çš„å±€é¢ä¸€å®šä¸å­˜åœ¨æŸç§ç§»åŠ¨ä½¿å¾—x=0x=0x=0ï¼Œå³N-positionä¸€å®šä¸å¯è½¬ç§»åˆ°N-position è®¾å–èµ°ç¬¬iiiå †çš„çŸ³å­åaia_iaiâ€‹å˜ä¸ºäº†aiâ€²a_i'aiâ€²â€‹ï¼Œæ­¤æ—¶a1âŠ•a2âŠ•â‹¯âŠ•aiâ€²âŠ•â‹¯âŠ•an=0=a1âŠ•a2âŠ•â‹¯âŠ•aiâŠ•â‹¯âŠ•ana_1 \\oplus a_2 \\oplus \\cdots\\oplus a_i' \\oplus\\cdots \\oplus a_n = 0 =a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_i \\oplus \\cdots \\oplus a_na1â€‹âŠ•a2â€‹âŠ•â‹¯âŠ•aiâ€²â€‹âŠ•â‹¯âŠ•anâ€‹=0=a1â€‹âŠ•a2â€‹âŠ•â‹¯âŠ•aiâ€‹âŠ•â‹¯âŠ•anâ€‹å¾—ai=aiâ€²a_i = a_i'aiâ€‹=aiâ€²â€‹ä¸æˆç«‹ã€‚ è‡³äºå¼‚æˆ–ä¸ºä»€ä¹ˆèƒ½è¡¨ç¤ºçŠ¶æ€ä¹‹é—´çš„è½¬ç§»ä¸»è¦è¿˜æ˜¯å› ä¸ºï¼š ç»ˆæ­¢çŠ¶æ€æ—¶æ˜¾ç„¶æœ‰0âŠ•0âŠ•â‹¯âŠ•0=00 \\oplus 0 \\oplus \\cdots \\oplus 0 = 00âŠ•0âŠ•â‹¯âŠ•0=0 å–å‡ºç¬¬iiiå †çš„çŸ³å­çš„æ“ä½œå…¶å®ç­‰ä»·äºå°†è¿™å †çŸ³å­çš„æ•°ç›®å¼‚æˆ–ä¸Šä¸€ä¸ªæ•°å˜ä¸ºaiâ€²=aiâŠ•ka_i'= a_i \\oplus kaiâ€²â€‹=aiâ€‹âŠ•k æ¯ä¸ªçŠ¶æ€ä¹‹é—´çš„å¼‚æˆ–å…¶å®å°±ä½“ç°åœ¨ä¸Šè¿°è¯æ˜ä¸­çš„ç¬¬2ï¼Œ3æ¡å¼•ç†ï¼Œå¯¹æŸä¸ªçŠ¶æ€çš„å¼‚æˆ–å°±æ˜¯å¯¹æ•´ä½“ç»“æœçš„å¼‚æˆ– ç°åœ¨æˆ‘ä»¬å°†å–çŸ³å­çš„æ¸¸æˆè½¬åŒ–æˆäº†å¼‚æˆ–çš„æ¸¸æˆï¼ŒåŒæ—¶ä¹Ÿæ»¡è¶³å¯¹åº”çš„è§„åˆ™ï¼Œå¼‚æˆ–å’Œåœ¨x=0x=0x=0ä¸xâ‰ 0x \\ne 0xî€ â€‹=0çš„ä¸¤ä¸ªçŠ¶æ€é—´ä¸åœçš„è½¬æ¢ï¼Œå°±ä½“ç°äº†P-positionå’ŒN-positionä¹‹é—´çš„è½¬æ¢ã€‚ Anti NIM å‰ç½®çŸ¥è¯† NIM æ­£æ–‡ Anti NIMæ¸¸æˆï¼Œå°±æ˜¯ä¿®æ”¹NIMæ¸¸æˆçš„èƒœåˆ©åˆ¤å®šä¸ºæ‹¿èµ°æœ€åä¸€å †çŸ³å­çš„å¤±è´¥ï¼Œä¼šå˜å¾—æ›´å¤æ‚ä¸€ç‚¹ï¼ˆä½†ä¹Ÿä¸éš¾ï¼‰ å¼•ç†ï¼š å…ˆæ‰‹å¿…èƒœå½“ä¸”ä»…å½“ï¼š æ¯å †çš„ç‰©å“æ•°éƒ½ä¸º1ä¸”NIMå’Œä¸º0 æœ‰äº›å †çš„ç‰©å“æ•°å¤§äº1ä¸”NIMå’Œä¸ä¸º0 è¯æ˜ï¼š å½“æ‰€æœ‰å †çš„çŸ³å­å‡ä¸º1æ—¶ çŸ³å­NIMå’Œx=0x=0x=0ï¼Œæ­¤æ—¶æœ‰å¶æ•°å †ï¼Œå…ˆæ‰‹å¿…èƒœ xâ‰ 0x \\ne 0xî€ â€‹=0æ—¶ï¼Œæ­¤æ—¶æœ‰å¥‡æ•°å †ï¼Œå…ˆæ‰‹å¿…è´¥ å½“æœ‰ä¸€å †çŸ³å­æ•°&gt;1&gt;1&gt;1æ—¶ï¼Œæ­¤æ—¶xxxæ˜¾ç„¶â‰ 0\\ne 0î€ â€‹=0 è‹¥æœ‰å¥‡æ•°å †çŸ³å­ï¼Œæ­¤æ—¶æŠŠ&gt;1&gt;1&gt;1çš„é‚£å †çŸ³å­å–è‡³1ä¸ªçŸ³å­ï¼Œè½¬åŒ–ä¸º1ä¸­çš„2ï¼Œå…ˆæ‰‹å¿…èƒœ è‹¥æœ‰å¶æ•°å †çŸ³å­ï¼Œæ­¤æ—¶æŠŠ&gt;1&gt;1&gt;1çš„é‚£å †çŸ³å­å–å®Œï¼ŒåŒæ ·è½¬åŒ–ä¸º1ä¸­çš„2ï¼Œå…ˆæ‰‹å¿…èƒœ å½“æœ‰ä¸¤å †åŠä»¥ä¸ŠçŸ³å­æ•°&gt;1&gt;1&gt;1æ—¶ è‹¥x=0x=0x=0ï¼Œåˆå¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µ è½¬åŒ–ä¸ºè‡³å°‘ä¸¤å †çŸ³å­&gt;1&gt;1&gt;1ä¸”x!=0x!=0x!=0,è½¬åŒ–åˆ°3ä¸­çš„2 è½¬åŒ–ä¸ºä¸€å †çŸ³å­&gt;1&gt;1&gt;1ï¼Œç”±2å¯çŸ¥ï¼Œæ­¤æ—¶å…ˆæ‰‹å¿…èƒœ è‹¥xâ‰ 0x\\ne 0xî€ â€‹=0ï¼Œæ ¹æ®NIMæ¸¸æˆçš„è¯æ˜ï¼Œå¿…å®šæœ‰ä¸€ç§æ–¹æ³•è½¬åŒ–ä¸º3ä¸­çš„1ï¼Œæ­¤æ—¶å…ˆæ‰‹æ€»æ˜¯èƒ½è®©åæ‰‹å–è¿›è¡Œ3ä¸­çš„1ï¼Œåæ‰‹åªèƒ½ç»™å…ˆæ‰‹3ä¸­2ç›´è‡³å¿…èƒœçŠ¶æ€ï¼Œæ•…æ­¤æ—¶å…ˆæ‰‹å¿…èƒœ Staircase NIM å‰è¨€ Staircase NIMæ˜¯NIMæ¸¸æˆçš„åˆä¸€ç§å˜å½¢ï¼Œä¸è¿‡è¿˜æ˜¯éå¸¸ç®€å• æ­£æ–‡ è¿™æ¬¡Aliceå’ŒBobåˆæ¢äº†ç§ç©æ³•ï¼Œ æœ‰nnnå †çŸ³å­ï¼Œæ¯æ¬¡ç§»åŠ¨å¯ä»¥å°†ç¬¬iiiå±‚ä¸Šçš„è‡³å°‘ä¸€ä¸ªçŸ³å­ç§»åŠ¨åˆ°iâˆ’1i-1iâˆ’1å±‚ä¸Šï¼Œè°å–å®Œæœ€åä¸€å †çŸ³å­è°å°±èƒœåˆ©ã€‚ æ±‚æ˜¯å¦å­˜åœ¨ä¸€ç§å…ˆæ‰‹å¿…èƒœçš„ç­–ç•¥ã€‚ é¦–å…ˆè€ƒè™‘åªæœ‰å¶æ•°å±‚å­˜åœ¨çŸ³å­ä¹Ÿå°±æ˜¯è¯´ï¼Œå‡è®¾å¯¹æ–¹ä¸ºå…ˆæ‰‹ï¼Œé‚£ä¹ˆå¯¹æ–¹åªèƒ½å°†è‹¥å¹²ä¸ªçŸ³å­ç§»åŠ¨çš„å¥‡æ•°å±‚ï¼Œæ­¤æ—¶æˆ‘ä»¬å†è®²å…¶ç§»åŠ¨åˆ°å¶æ•°å±‚ï¼Œç›´åˆ°æœ€åå¶æ•°å±‚ä¸Šéƒ½æ²¡æœ‰çŸ³å­ï¼ˆéƒ½åˆ°ç¬¬0å±‚ä¸Šäº†ï¼‰ï¼Œæ­¤æ—¶åæ‰‹å¿…èƒœ ç„¶åè€ƒè™‘å¥‡æ•°å±‚çš„çŸ³å­ï¼Œå°†å¥‡æ•°å±‚ç§»åŠ¨åˆ°å¶æ•°å±‚ï¼Œå…¶å®å¯ä»¥ç›´æ¥å½“åšæŠŠå¥‡æ•°å±‚çš„çŸ³å­ç›´æ¥æ‹¿èµ°ï¼Œå¹¶ä¸ä¼šå½±å“ä¹‹å‰å¶æ•°å±‚ç­–ç•¥çš„å½±å“ï¼Œé‚£ä¹ˆå°±å°†é—®é¢˜è½¬åŒ–ä¸ºäº†å¥‡æ•°å±‚ä¹‹é—´çš„NIMåšå¼ˆï¼Œå¦‚æœå¯ä»¥åšåˆ°ç•™ç»™å¯¹æ–¹çš„åªæœ‰å¶æ•°å±‚çŸ³å­ï¼Œåˆ™å¯¹æ–¹å¿…è´¥ å…¶ä»–åšå¼ˆè®ºæ¸¸æˆ å ä¸ªå‘ ğŸ˜± åšå¼ˆé—®é¢˜ 1. A Funny Game é¦–å…ˆAliceä½œä¸ºå…ˆæ‰‹ï¼Œ æ‹¿ä¸€ä¸ªï¼Œç¯æ–­ä¸ºé•¿åº¦ä¸ºå¥‡æ•°çš„é“¾ï¼Œæ­¤æ—¶Bobå†æ‹¿ä¸€ä¸ªæŠŠé“¾çš„é•¿åº¦å˜ä¸ºå¶æ•°ï¼Œæ¥ä¸‹æ¥Aliceæ‹¿å‡ ä¸ªBobæ‹¿ç›¸åŒæ•°ç›®çš„ç¡¬å¸ï¼ŒBobå¿…èƒœ æ‹¿ä¸¤ä¸ªï¼Œç¯æ–­ä¸ºé•¿åº¦ä¸ºå¶æ•°çš„é“¾ï¼Œæ­¤æ—¶Bobå†æ‹¿ä¸¤ä¸ªé“¾çš„é•¿åº¦ä»ç„¶ä¸ºå¶æ•°ï¼Œæ¥ä¸‹æ¥é‡‡å–å’Œ1ç›¸åŒçš„ç­–ç•¥å³å¯ï¼ŒBobå¿…èƒœ ç»¼ä¸Šï¼Œå½“nâ‰¤2n \\le 2nâ‰¤2æ—¶Aliceå¿…èƒœï¼Œåæ­£Bobå¿…èƒœã€‚ï¼ˆå¥½åƒå«åšå¯¹ç§°åšå¼ˆï¼‰ 2.è°èƒ½èµ¢å‘¢ï¼Ÿ å¾ˆç®€å•ï¼Œå°±åƒå¤šç±³è¯ºéª¨ç‰Œå»è¦†ç›–æ£‹ç›˜ï¼Œnnnä¸ºå¥‡æ•°æ—¶éœ€è¦æŒ–æ‰å·¦ä¸Šå’Œå³ä¸‹æ‰èƒ½å®Œå…¨è¦†ç›–ï¼Œæ­¤æ—¶åæ‰‹å¿…èƒœï¼Œnnnä¸ºå¶æ•°æ—¶ç›´æ¥è¦†ç›–æ­¤æ—¶å…ˆæ‰‹å¿…èƒœã€‚ 3.å–çŸ³å­ é¦–å…ˆå¦‚æœä¸èƒ½åˆå¹¶ï¼Œé‚£ä¹ˆåªè¦çŸ³å­æ€»æ•°æ˜¯å¶æ•°ï¼ŒAliceå°±å¿…èƒœï¼Œæ‰€ä»¥ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆå¹¶æ“ä½œæ˜¯ç”¨æ¥è½¬æ¢çŠ¶æ€çš„ã€‚ è€ƒè™‘çŸ³å­ä¸ªæ•°$&gt;1ï¼Œæ­¤æ—¶è®¾1ï¼Œæ­¤æ—¶è®¾1ï¼Œæ­¤æ—¶è®¾mä¸ºçŸ³å­æ€»æ•°åŠ ä¸ŠçŸ³å­å †æ•°âˆ’1ï¼Œè‹¥ä¸ºçŸ³å­æ€»æ•°åŠ ä¸ŠçŸ³å­å †æ•°-1ï¼Œè‹¥ä¸ºçŸ³å­æ€»æ•°åŠ ä¸ŠçŸ³å­å †æ•°âˆ’1ï¼Œè‹¥m$ä¸ºå¥‡æ•°åˆ™å…ˆæ‰‹å¿…èƒœï¼Œå¦åˆ™åæ‰‹å¿…èƒœ â€‹ è¯æ˜ï¼š â€‹ mmmä¸ºå¥‡æ•°æ—¶ï¼Œä¸ç®¡åæ‰‹åšå“ªä¸€ä¸ªæ“ä½œå‡å¯å°†mmmå˜å›å¥‡æ•°ï¼Œæœ€ååˆå¹¶ä¸ºä¸€å †æ—¶å…ˆæ‰‹å¿…èƒœã€‚ â€‹ mmmä¸ºå¶æ•°æ—¶ï¼Œ å…ˆæ‰‹é€‰æ‹©åˆå¹¶ï¼Œmmmå˜ä¸ºå¥‡æ•°ï¼Œå˜æˆåæ‰‹çš„å¿…èƒœå±€é¢ å…ˆæ‰‹é€‰æ‹©å–&gt;2&gt; 2&gt;2çŸ³å­ï¼Œmmmå˜ä¸ºå¥‡æ•°ï¼Œå˜æˆåæ‰‹çš„å¿…èƒœå±€é¢ å…ˆæ‰‹é€‰æ‹©å–=2=2=2çŸ³å­ï¼Œmmmå˜ä¸ºå¥‡æ•°ï¼Œæ­¤æ—¶åæ‰‹å°†=1=1=1çš„çŸ³å­å †åˆå¹¶ï¼ˆå¦‚æœé€‰æ‹©å–çŸ³å­ï¼Œåˆ™å †æ•°-1ï¼ŒçŸ³å­æ•°-1ï¼Œmmmä¸ºå¥‡æ•°ï¼Œå…ˆæ‰‹å¿…èƒœï¼‰ è€ƒè™‘çŸ³å­ä¸ªæ•°=1=1=1ï¼Œä½¿ç”¨è®°å¿†åŒ–æœç´¢ï¼Œf[i][j]f[i][j]f[i][j]ä¸ºæœ‰iiiå †çŸ³å­ä¸º1ï¼Œjjjå †æ•°é‡ä¸ä¸º1çš„çŠ¶æ€ã€‚ 4.A New Stone Game è€ƒè™‘ä¸¤å †çŸ³å­æ•°é‡ç›¸åŒï¼Œè¿™æ—¶è‚¯å®šæ˜¯åæ‰‹å¿…èƒœï¼Œåªè¦åæ‰‹å’Œå…ˆæ‰‹ä¸€ç›´åšç›¸åŒçš„æ“ä½œå°±å¯ä»¥å¿…èƒœã€‚ å¦‚æœæœ‰çš„çŸ³å­æ•°é‡ä¸ç›¸åŒçš„è¯ï¼Œæ­¤æ—¶å¿…å®šå­˜åœ¨ä¸€ç§æ–¹æ¡ˆä½¿å¾—æ“ä½œåçŸ³å­æ•°é‡ç›¸åŒ è‹¥å½“å‰æœ‰å¥‡æ•°å †çŸ³å­çš„æ•°é‡ä¸èƒ½ä¸¤ä¸¤é…å¯¹ï¼Œåˆ™å°†å…¶ä¸­çš„ä¸€å †çŸ³å­å…¨éƒ¨å–èµ°ï¼Œåˆ†åˆ°å…¶ä»–å †çŸ³å­ï¼Œä½¿å…¶ä¸¤ä¸¤é…å¯¹ï¼Œæœ‰å¶æ•°å † è‹¥å½“å‰æœ‰å¶æ•°å †çŸ³å­çš„æ•°é‡ä¸èƒ½ä¸¤ä¸¤é…å¯¹ï¼Œåˆ™å°†å…¶ä¸­çš„ä¸€å †çŸ³å­ä¸å…¨éƒ¨å–èµ°ï¼Œåˆ†åˆ°å…¶ä»–çŸ³å­ï¼Œä»ä¸ºå¶æ•°å † æ‰€ä»¥æ­¤æ—¶åæ‰‹é¢å¯¹çš„æ˜¯å¿…è´¥çŠ¶æ€ï¼Œå…ˆæ‰‹å¿…èƒœã€‚ 5.å°çº¦ç¿°çš„æ¸¸æˆ Anti NIMæ¸¸æˆï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(n)O(n) 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { int n,sum=0,res=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res^=x; sum+=(x==1); } if(sum==n&amp;&amp;res==0) printf(&quot;John\\n&quot;); else if(sum!=n&amp;&amp;res!=0) printf(&quot;John\\n&quot;); else printf(&quot;Brother\\n&quot;); } return 0;} 6.NIMæ¸¸æˆ åˆ¤æ–­å¼‚æˆ–å’Œå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(n)O(n) 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int T;int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--) { int n,ans=0;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x;scanf(&quot;%d&quot;,&amp;x);ans^=x; } ans?printf(&quot;Yes\\n&quot;):printf(&quot;No\\n&quot;); } return 0;} å‘ã€‚ã€‚ã€‚","link":"/2022/07/23/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"title":"ğŸ˜…","text":"ğŸ˜…","link":"/2022/11/08/%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%BE%97%E4%BA%86/"},{"title":"test","text":"eiÏ€=cosâ¡Ï€+isinâ¡Ï€e^{i \\pi} = \\cos \\pi + i \\sin \\pi eiÏ€=cosÏ€+isinÏ€","link":"/2022/09/22/test/"}],"tags":[{"name":"é—²è¯","slug":"é—²è¯","link":"/tags/%E9%97%B2%E8%AF%9D/"},{"name":"æœç´¢","slug":"æœç´¢","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"å¯å‘å¼æœç´¢","slug":"å¯å‘å¼æœç´¢","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AtCoder Regular Contest","slug":"AtCoder-Regular-Contest","link":"/tags/AtCoder-Regular-Contest/"},{"name":"Record","slug":"Record","link":"/tags/Record/"},{"name":"æ‚é¡¹","slug":"æ‚é¡¹","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"æ•°è®º","slug":"æ•°è®º","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"BSGS","slug":"BSGS","link":"/tags/BSGS/"},{"name":"ç»„åˆæ•°å­¦","slug":"ç»„åˆæ•°å­¦","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"è®¡ç®—å‡ ä½•","slug":"è®¡ç®—å‡ ä½•","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"æ•°å­¦æœŸæœ›","slug":"æ•°å­¦æœŸæœ›","link":"/tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"},{"name":"Link Cut Tree","slug":"Link-Cut-Tree","link":"/tags/Link-Cut-Tree/"},{"name":"æ ‘é“¾å‰–åˆ†","slug":"æ ‘é“¾å‰–åˆ†","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"åŠ¨æ€æ ‘","slug":"åŠ¨æ€æ ‘","link":"/tags/%E5%8A%A8%E6%80%81%E6%A0%91/"},{"name":"åŸæ ¹","slug":"åŸæ ¹","link":"/tags/%E5%8E%9F%E6%A0%B9/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"NaCly_Fish&#39;s Math Contest","slug":"NaCly-Fish-s-Math-Contest","link":"/tags/NaCly-Fish-s-Math-Contest/"},{"name":"å‹¾è‚¡æ•°ç»„","slug":"å‹¾è‚¡æ•°ç»„","link":"/tags/%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84/"},{"name":"é«˜æ–¯æ•´æ•°","slug":"é«˜æ–¯æ•´æ•°","link":"/tags/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0/"},{"name":"é«˜æ–¯ç´ æ•°","slug":"é«˜æ–¯ç´ æ•°","link":"/tags/%E9%AB%98%E6%96%AF%E7%B4%A0%E6%95%B0/"},{"name":"è«æ¯”ä¹Œæ–¯åæ¼”","slug":"è«æ¯”ä¹Œæ–¯åæ¼”","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"æœæ•™ç­›","slug":"æœæ•™ç­›","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"æ¬§æ‹‰åæ¼”","slug":"æ¬§æ‹‰åæ¼”","link":"/tags/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"},{"name":"å¤šé¡¹å¼","slug":"å¤šé¡¹å¼","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(FFT)","slug":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢-FFT","link":"/tags/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT/"},{"name":"å›¾è®º","slug":"å›¾è®º","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Kruskalé‡æ„æ ‘","slug":"Kruskalé‡æ„æ ‘","link":"/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"ç”Ÿæˆå‡½æ•°","slug":"ç”Ÿæˆå‡½æ•°","link":"/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"æ—‹è½¬å¡å£³","slug":"æ—‹è½¬å¡å£³","link":"/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"},{"name":"ä¸‰è§’å‰–åˆ†","slug":"ä¸‰è§’å‰–åˆ†","link":"/tags/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Actions","slug":"Github-Actions","link":"/tags/Github-Actions/"},{"name":"åŠ¨æ€DP(DDP)","slug":"åŠ¨æ€DP-DDP","link":"/tags/%E5%8A%A8%E6%80%81DP-DDP/"},{"name":"å¿«é€Ÿæ•°è®ºå˜æ¢(NTT)","slug":"å¿«é€Ÿæ•°è®ºå˜æ¢-NTT","link":"/tags/%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2-NTT/"},{"name":"å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢(FWT)","slug":"å¿«é€Ÿæ²ƒå°”ä»€å˜æ¢-FWT","link":"/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"},{"name":"ä»»æ„æ¨¡æ•°NTT","slug":"ä»»æ„æ¨¡æ•°NTT","link":"/tags/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0NTT/"},{"name":"å¤šé¡¹å¼ä¹˜æ³•é€†","slug":"å¤šé¡¹å¼ä¹˜æ³•é€†","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86/"},{"name":"å¤šé¡¹å¼å¯¹æ•°å‡½æ•°(å¤šé¡¹å¼æ±‚ln)","slug":"å¤šé¡¹å¼å¯¹æ•°å‡½æ•°-å¤šé¡¹å¼æ±‚ln","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82ln/"},{"name":"å¤šé¡¹å¼æŒ‡æ•°å‡½æ•°(å¤šé¡¹å¼exp)","slug":"å¤šé¡¹å¼æŒ‡æ•°å‡½æ•°-å¤šé¡¹å¼exp","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp/"},{"name":"å¤šé¡¹å¼å¼€æ ¹","slug":"å¤šé¡¹å¼å¼€æ ¹","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BC%80%E6%A0%B9/"},{"name":"å¤šé¡¹å¼å¹‚å‡½æ•°","slug":"å¤šé¡¹å¼å¹‚å‡½æ•°","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B9%82%E5%87%BD%E6%95%B0/"},{"name":"åˆ†æ²»FFT&#x2F;NTT","slug":"åˆ†æ²»FFT-NTT","link":"/tags/%E5%88%86%E6%B2%BBFFT-NTT/"},{"name":"ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•","slug":"ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•","link":"/tags/%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/"},{"name":"å¤šé¡¹å¼é™¤æ³•","slug":"å¤šé¡¹å¼é™¤æ³•","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95/"},{"name":"å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼","slug":"å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/"},{"name":"å¤šé¡¹å¼å¤åˆå‡½æ•°","slug":"å¤šé¡¹å¼å¤åˆå‡½æ•°","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0/"},{"name":"å¤šé¡¹å¼å¤åˆé€†","slug":"å¤šé¡¹å¼å¤åˆé€†","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E9%80%86/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"åæ¼”å˜æ¢","slug":"åæ¼”å˜æ¢","link":"/tags/%E5%8F%8D%E6%BC%94%E5%8F%98%E6%8D%A2/"},{"name":"å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨","slug":"å¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨","link":"/tags/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"æ•°å€¼ç§¯åˆ†","slug":"æ•°å€¼ç§¯åˆ†","link":"/tags/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"},{"name":"æ¬§æ‹‰è·¯","slug":"æ¬§æ‹‰è·¯","link":"/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"name":"æ€»ç»“","slug":"æ€»ç»“","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"ç‹„åˆ©å…‹é›·å·ç§¯","slug":"ç‹„åˆ©å…‹é›·å·ç§¯","link":"/tags/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"name":"æ™®é€šç”Ÿæˆå‡½æ•°(OGF)","slug":"æ™®é€šç”Ÿæˆå‡½æ•°-OGF","link":"/tags/%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-OGF/"},{"name":"æŒ‡æ•°å‹ç”Ÿæˆå‡½æ•°(EGF)","slug":"æŒ‡æ•°å‹ç”Ÿæˆå‡½æ•°-EGF","link":"/tags/%E6%8C%87%E6%95%B0%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-EGF/"},{"name":"çŸ©é˜µæ ‘å®šç†","slug":"çŸ©é˜µæ ‘å®šç†","link":"/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"ç¬›å¡å°”æ ‘","slug":"ç¬›å¡å°”æ ‘","link":"/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"ç±»æ¬§å‡ é‡Œå¾·","slug":"ç±»æ¬§å‡ é‡Œå¾·","link":"/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"},{"name":"è™šæ ‘","slug":"è™šæ ‘","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"å‡¸åŒ…","slug":"å‡¸åŒ…","link":"/tags/%E5%87%B8%E5%8C%85/"},{"name":"åŠå¹³é¢äº¤","slug":"åŠå¹³é¢äº¤","link":"/tags/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/"},{"name":"éšæœºå¢é‡","slug":"éšæœºå¢é‡","link":"/tags/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F/"},{"name":"é—µå¯å¤«æ–¯åŸºå’Œ","slug":"é—µå¯å¤«æ–¯åŸºå’Œ","link":"/tags/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"},{"name":"æ‰«æçº¿","slug":"æ‰«æçº¿","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"ååºé—®é¢˜","slug":"ååºé—®é¢˜","link":"/tags/%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"name":"Pickå®šç†","slug":"Pickå®šç†","link":"/tags/Pick%E5%AE%9A%E7%90%86/"},{"name":"é«˜æ–¯æ¶ˆå…ƒ","slug":"é«˜æ–¯æ¶ˆå…ƒ","link":"/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"åšå¼ˆè®º","slug":"åšå¼ˆè®º","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"categories":[{"name":"é—²è¯","slug":"é—²è¯","link":"/categories/%E9%97%B2%E8%AF%9D/"},{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"åšé¢˜è®°å½•","slug":"åšé¢˜è®°å½•","link":"/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"æ¿å­","slug":"æ¿å­","link":"/categories/%E6%9D%BF%E5%AD%90/"},{"name":"æ€»ç»“","slug":"æ€»ç»“","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"æ‚é¡¹","slug":"æ‚é¡¹","link":"/categories/%E6%9D%82%E9%A1%B9/"}],"pages":[{"title":"Jekyll_Y","text":"About Hi there is JekyllğŸ‘‹, a OIerâ€™s blog. This is my blog, Welcome! Some of my Github Stats","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"ç•™è¨€","text":"ç•™ä¸‹ä½ æƒ³è¯´çš„è¯å§","link":"/comments/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"My Friends","text":"","link":"/friends/index.html"},{"title":"Archives","text":"","link":"/archives/index.html"}]}