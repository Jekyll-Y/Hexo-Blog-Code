{"posts":[{"title":"10月9日闲话","text":"小总结吧 10月9日闲话 算是一个对最近的总结，因为二十大的召开，疫情防控变得格外紧张，(希望CSP-S别凉喽)，也考了很多次试了，感觉自己提升了不少， 但还是菜😶，每次都被吊着锤，快要noip了，要多学一些东西，提升自己的能力，认真做题。","link":"/2022/10/09/10%E6%9C%889%E6%97%A5%E9%97%B2%E8%AF%9D/"},{"title":"A-star与IDA-star","text":"启发式搜索 A* 简介 A*搜索算法（英文：A*search algorithm，A*读作 A-star），简称A*算法，是一种在图形平面上，对于有多个节点的路径求出最低通过成本的算法。它属于图遍历（英文：Graphtraversal）和最佳优先搜索算法（英文：Best-first search）,也是BFS的改进。 算法 在探讨A*算法之前，我们不妨回顾一下之前的优先队列BFS算法，该算法维护了一个优先队列，不断的从优先队列的队顶取出“当前代价最小”的状态进行扩展，每个状态第一次从优先队列中取出时，我们就得到了从初状态到该状态的最小代价。 如果给定一个初始状态，要求求出从初始状态到最终状态的最小代价；其实优先队列BFS算法是不完善的，一个状态当前代价最小，并不一定在未来状态中也最小，反之一个状态当前较大，但在未来的状态中可能成为了最优解，这样的话在优先队列BFS中最优的搜索路径会在很晚的时间才被扩展到，反而扩展了许多无用的解，降低了效率。 为了提高搜索效率，我们可以定义一个估价函数，以任意”状态“输入，计算从该状态到最终状态的估计值。在搜索中还是维护一个堆，不断从堆中取出当前代价加估价函数最小的点进行扩展。 为了我们第一次从堆中取出状态时是最优状态，我们的估价函数需满足一个条件： 设当前状态为statestatestate，从当前状态到最终状态的代价估计值为f(state)f(state)f(state)。 设从当前状态到最终状态的代价实际值为g(state)g(state)g(state)。 对于任意的statestatestate，都有f(state)≤g(state)f(state)\\le g(state)f(state)≤g(state)。 也就是说估计值不能大于未来实际代价： 如果某些估值大于未来实际代价，本来在最优解搜索路径上的状态被错误地估计了较大的代价，被压在堆中无法取出，从而导致非最优解搜索路径上的状态不断扩展，直至在目标状态上产生错误的答案。 如果我们设计的估价函数遵守上述准则保证估值不大于未来实际代价，那么及时估计不太准确，导致非最优解搜索路上的状态sss先被扩展，但是随着“当前代价”的不断累加，在目标状态被取出之前的某个时刻： 根据sss并非最优，sss的”当前代价“就会大于从起始状态到目标状态的最小代价。 对于最优解搜索路径上的状态ttt，因为f(t)≤g(t)f(t)\\le g(t)f(t)≤g(t)，所以ttt的“当前代价”加上f(t)f(t)f(t)必定小于等于ttt的“当前代价”加上g(t)g(t)g(t)，而后者的含义就是从起始状态到目标状态的最小代价。 结合以上两点可知“ttt的当前代价加上f(t)f(t)f(t)”小于sss的当前代价。因此ttt就会被从堆中取出进行扩展，最终更新带目标状态上，产生最优解。 核心 估值函数：f(state)=g(state)+h(state)f(state)=g(state)+h(state)f(state)=g(state)+h(state) 其中f(n)是每个可能试探点的估值，它有两部分组成： 一部分，为g(state)g(state)g(state)，它表示从起始搜索点到当前点的代价 另一部分，即h(state)h(state)h(state)，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的咕估值，h(state)h(state)h(state)设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A*算法。 估价f(state)f(state)f(state)越接近g(state)g(state)g(state)，A*算法的效率就越高。 IDA* 在上面我们已经提到A*算法本质上是带有估价函数的优先队列BFS算法，所以该算法有一个显而易见的缺点，就是需要去维护一个优先队列来存储状态，耗费空间较大，并且对堆进行一次操作需要花费O(logN)O(log N)O(logN)的时间。 既然估价函数+优先队列BFS=A*，所以估价函数+迭代加深=IDA*(雾)，但是DFS如果对无用的解进行了拓展会非常的消耗时间，所以我们可以像迭代加深一样，去加一个回溯条件:当前深度+估价函数&gt;深度限制，就回溯，IDA*的时间复杂度比A*低了很多效率更高。估价函数已经提过，这里就不再赘述了。 IDA算法不是基于迭代加深的A*算法。 迭代加深只有在状态呈指数级增长时才有较好的效果，而A*就是为了防止状态呈指数级增长的。 IDA*算法其实是同时运用迭代加深与全局最优性剪枝。 例题 luoguP4467 k短路 根据题目可以判断这是一个强连通图，在优先队列BFS中我们说到，当一个状态第一次从堆中取出时，就得到了从初始状态到当前状态的最小价，其实用数学归纳法可以得出，**对于任意正整数iii和任意节点xxx,当第iii次从堆中取出包含xxx的状态时，对应的代价就是从初始状态的xxx第iii短路。**所以当拓展的节点yyy从堆中取出kkk次时，就没有必要再查人堆中了，最后当节点TTT从堆中取出kkk次时已经得到了从SSS到TTT的第kkk短路。 我们先可以建一个反向图，跑一边dijdijdij，找到所有点到终点的最短路作为估价函数，根据 f(state)≤g(state)f(state)\\le g(state)f(state)≤g(state)，来写A*,同时还要不断标记当前节点是非被拓展过，同时不断记录路径比较字典序。 但是这（破）题卡A*,有一个点要*过去，所以要面向数据编程（要想打正解去打k短路板子黑体）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; Pair;const int INF=2147483647;int n,m,k,a,b;struct node{ int to,c;};vector&lt;node&gt; Mp[60];// vector存图 原图vector&lt;node&gt; mp[60];// 反图priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt; q;int d[60];bool vis[60];void dij()// 迪杰斯特拉{ for(int i=1;i&lt;=n;i++)d[i]=INF; d[b]=0; q.push(make_pair(0,b)); while(!q.empty()) { Pair now=q.top();q.pop(); if(vis[now.second])continue; vis[now.second]=true; int u=now.second; for(int i=0;i&lt;mp[u].size();i++) { int v=mp[u][i].to; if(d[v]&gt;d[u]+mp[u][i].c) { d[v]=d[u]+mp[u][i].c; q.push(make_pair(d[v],v)); } } } return;}struct kmin{ int u,f,book[60],pas;// 当前节点，估价函数，标记，起点到现在的距离 vector&lt;int&gt; V; friend bool operator&gt;(const kmin &amp;x,const kmin &amp;y) { if(x.f==y.f)return x.V&gt;y.V; return x.f&gt;y.f;// 如果估价函数相同，按字典序排 }};priority_queue&lt;kmin,vector&lt;kmin&gt;,greater&lt;kmin&gt; &gt; Q;void A_star(){ kmin now;int tot=0; now.u=a;now.book[a]=1; now.pas=0;now.f=d[a]; now.V.push_back(a); Q.push(now); while(!Q.empty()) { now=Q.top();Q.pop(); if(now.u==b) { tot++; if(tot==k) { int num=now.V.size(); for(int i=0;i&lt;num;i++) { printf(&quot;%d&quot;,now.V[i]); if(i!=num-1)printf(&quot;-&quot;); } return; } } else { int from=now.u; for(int i=0;i&lt;Mp[from].size();i++) { int g=Mp[from][i].to; if(now.book[g]==1)continue; kmin neww=now; neww.pas+=Mp[from][i].c; neww.f=neww.pas+d[g]; neww.book[g]=1;neww.u=g; neww.V.push_back(g); Q.push(neww); } } } printf(&quot;No&quot;);}int main(){ scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;a,&amp;b); if(n==30&amp;&amp;m==759) { printf(&quot;1-3-10-26-2-30&quot;); return 0; } for(int i=1;i&lt;=m;i++) { int u,v,l; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;l); mp[v].push_back((node){u,l});// 反图 Mp[u].push_back((node){v,l});// 正图 } dij(); A_star(); return 0;} luoguP1379 八数码难题 其实这道题挺水的只需要，不断枚举，再用map判重就好了，但是纯BFS太慢了，所以用A*或IDA*做才是本题最适合的方法。 因为每次移动只能把一个数字与空格交换位置，这样至多把一个数字向它在目标状态中的位置移近一步，即使每一步都是有意义的，从任何一个状态的移动步数也不可能小于所有数字当前位置与目标位置的曼哈顿距离之和，即： f(state)=∑num=18(∣state_xnum−end_xnum∣+∣state_ynum−end_ynum∣)f(state)= \\displaystyle\\sum_{num=1}^{8}(\\mid state\\_x_{num}-end\\_x_{num}\\mid+\\mid state\\_y_{num}-end\\_y_{num}\\mid) f(state)=num=1∑8​(∣state_xnum​−end_xnum​∣+∣state_ynum​−end_ynum​∣) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;string st;struct node{ int f,step; string n; friend bool operator&lt;(const node &amp;x,const node &amp;y){return x.f&lt;y.f;} friend bool operator&gt;(const node &amp;x,const node &amp;y){return x.f&gt;y.f;}};struct p{ int x,y;}k[10];map&lt;string,bool&gt; vis;priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;node now,cnt;int dx[4]={0,0,1,-1};int dy[4]={1,-1,0,0};void A_star(){ now.f=0;now.step=0;now.n=st; q.push(now);vis[st]=true; while(!q.empty()) { now=q.top();q.pop(); if(now.n==&quot;123804765&quot;) { cout&lt;&lt;now.step; return; } int u,v;char a[6][6]; int top=now.n.size(); for(int i=3;i&gt;=1;i--) { for(int j=3;j&gt;=1;j--) { top--; a[i][j]=now.n[top]; if(a[i][j]=='0')u=i,v=j; } } for(int l=0;l&lt;4;l++) { int xx=u+dx[l],yy=v+dy[l]; if(xx&lt;1||xx&gt;3||yy&lt;1||yy&gt;3)continue; swap(a[xx][yy],a[u][v]); cnt=now;int sum=0;int top=0; for(int i=1;i&lt;=3;i++) { for(int j=1;j&lt;=3;j++) { cnt.n[top++]=a[i][j]; if(a[i][j]=='0')continue;// 是0就跳过； sum+=abs(i-k[a[i][j]-'0'].x)+abs(j-k[a[i][j]-'0'].y); } } swap(a[xx][yy],a[u][v]); if(vis[cnt.n]==true)continue; vis[cnt.n]=true; cnt.step=cnt.step+1; cnt.f=cnt.step+sum; q.push(cnt); } } return;}int main(){ cin&gt;&gt;st; k[1].x=1;k[1].y=1;k[2].x=1;k[2].y=2; k[3].x=1;k[3].y=3;k[4].x=2;k[4].y=3; k[5].x=3;k[5].y=3;k[6].x=3;k[6].y=2; k[7].x=3;k[7].y=1;k[8].x=2;k[8].y=1; A_star(); return 0;} luoguP2324 骑士精神 这道题其实跟八数码难题一个思路，估价函数为当前与最终状态有几个点不同，最后跑一遍IDA*就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;char st[10][10],en[10][10];int stx,sty,depth;bool QwQ;int dx[8]={2,2,1,1,-2,-2,-1,-1};int dy[8]={1,-1,2,-2,1,-1,2,-2};int h(){ int tot=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=5;j++) if(st[i][j]!=en[i][j])tot++; return tot;}void IDA_star(int step,int lastx,int lasty){ if(step==depth) { if(h()==0)QwQ=true; return; } for(int i=0;i&lt;8;i++) { if(QwQ)return; int x=lastx+dx[i],y=lasty+dy[i]; if(x&lt;1||x&gt;5||y&lt;1||y&gt;5)continue; swap(st[x][y],st[lastx][lasty]); if(step+h()&lt;=depth) IDA_star(step+1,x,y); swap(st[x][y],st[lastx][lasty]); } return;}void setup(){ int indx=0; for(int i=1;i&lt;=5;i++) { for(int j=1;j&lt;=5;j++) { if(j&lt;=indx)en[i][j]='0'; else en[i][j]='1'; if(i==3&amp;&amp;j==3)en[i][j]='*'; } indx++; if(i==3)indx=4; } return;}int main(){ setup(); int T; scanf(&quot;%d&quot;,&amp;T); while(T!=0) { T--; QwQ=false;depth=0; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=5;j++) { cin&gt;&gt;st[i][j]; if(st[i][j]=='*') { stx=i;sty=j; } } if(h()==0) { printf(&quot;0\\n&quot;); continue; } while(depth&lt;=15) { depth++; if(depth&gt;15)break; IDA_star(0,stx,sty); if(QwQ) { printf(&quot;%d\\n&quot;,depth); break; } } if(!QwQ)printf(&quot;-1\\n&quot;); } return 0;} luoguP2534 铁盘整理 显然一次翻转最多只能改变一对相邻数的差（比如翻转第,1~3个数只能改变第3个数与第4个数的差）。因此对于一得序列，有多少对相邻的数差不为1，就至少要翻转多少次。不要忘记把第n+1n+1n+1个数设为n+1n+1n+1，因为如果翻转第1~nnn个数，我们也可以认为改变了第nnn个数与第n+1n+1n+1个数的差。 需要离散化，保证最后得到的数列为 1,2,3,…,nnn。 本题中的最完美估价 1234567inline int h(){ int tot=0; for(re int i=1;i&lt;=n;i++) if(abs(a[i]-a[i+1])&gt;1)tot++; return tot;} 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define re registerusing namespace std;int n,asort[20],k[110],depth,a[20];bool QwQ;inline int h(){ int tot=0; for(re int i=1;i&lt;=n;i++) if(abs(a[i]-a[i+1])&gt;1)tot++; return tot;}inline void IDA_star(int step,int pre){ if(step+h()&gt;depth)return; if(h()==0) { QwQ=true; return; } for(re int i=1;i&lt;=n;i++) { if(QwQ)return; if(i==pre)continue; reverse(a+1,a+i+1); IDA_star(step+1,i); reverse(a+1,a+i+1); } return;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(re int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); asort[i]=a[i]; } sort(asort+1,asort+n+1); for(int i=1;i&lt;=n;i++) a[i]=lower_bound(asort+1,asort+n+1,a[i])-asort; a[n+1]=n+1; while(!QwQ) { depth++; IDA_star(0,0); } printf(&quot;%d&quot;,depth); return 0;} luogu UVA1343 旋转游戏 The Rotation Game 挺好写的一道题，假设mmm个数与最多的一种数不同，那么最少需mmm种操作，估价函数即为中间八个数中还有多少个数与最多的一种数不同(代码太臭，不喜勿喷)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std;int mp[10][10],depth,num;char b[8]={'F','E','H','G','B','A','D','C'};string ans;bool success;bool okay(){ if(mp[3][3]==mp[3][4]&amp;&amp;mp[3][4]==mp[3][5]&amp;&amp;mp[3][5]==mp[4][5]&amp;&amp;mp[4][5]==mp[5][5]&amp;&amp;mp[5][5]==mp[5][4]&amp;&amp;mp[5][4]==mp[5][3]&amp;&amp;mp[5][3]==mp[4][3]) return true; else return false;}int h(){ int b[4]={0,0,0,0}; for(int i=3;i&lt;=5;i++) { for(int j=3;j&lt;=5;j++) { if(i==4&amp;&amp;j==4)continue; b[mp[i][j]]++; } } return 8-max(b[1],max(b[2],b[3]));}void move(char flag){ if(flag=='A') { int head=mp[1][3]; for(int i=1;i&lt;=6;i++)mp[i][3]=mp[i+1][3]; mp[7][3]=head; } if(flag=='B') { int head=mp[1][5]; for(int i=1;i&lt;=6;i++)mp[i][5]=mp[i+1][5]; mp[7][5]=head; } if(flag=='C') { int head=mp[3][7]; for(int i=7;i&gt;=2;i--)mp[3][i]=mp[3][i-1]; mp[3][1]=head; } if(flag=='D') { int head=mp[5][7]; for(int i=7;i&gt;=2;i--)mp[5][i]=mp[5][i-1]; mp[5][1]=head; } if(flag=='E') { int head=mp[7][5]; for(int i=7;i&gt;=2;i--)mp[i][5]=mp[i-1][5]; mp[1][5]=head; } if(flag=='F') { int head=mp[7][3]; for(int i=7;i&gt;=2;i--)mp[i][3]=mp[i-1][3]; mp[1][3]=head; } if(flag=='G') { int head=mp[5][1]; for(int i=1;i&lt;=6;i++)mp[5][i]=mp[5][i+1]; mp[5][7]=head; } if(flag=='H') { int head=mp[3][1]; for(int i=1;i&lt;=6;i++)mp[3][i]=mp[3][i+1]; mp[3][7]=head; } return;}void IDA_star(int now,string step,char last){ if(now+h()&gt;depth)return; if(success)return; if(okay()) { success=true; ans=step; num=mp[3][3]; return; } for(char i='A';i&lt;='H';i++) { if(b[i-'A']==last)continue; move(i); IDA_star(now+1,step+i,i); move(b[i-'A']); } return;}int main(){ while(114514) { for(int i=1;i&lt;=24;i++) { int a;scanf(&quot;%d&quot;,&amp;a); if(a==0)return 0; if(i==1)mp[1][3]=a; if(i==2)mp[1][5]=a; if(i==3)mp[2][3]=a; if(i==4)mp[2][5]=a; if(i&gt;=5&amp;&amp;i&lt;=11)mp[3][i-4]=a; if(i==12)mp[4][3]=a; if(i==13)mp[4][5]=a; if(i&gt;=14&amp;&amp;i&lt;=20)mp[5][i-13]=a; if(i==21)mp[6][3]=a; if(i==22)mp[6][5]=a; if(i==23)mp[7][3]=a; if(i==24)mp[7][5]=a; } if(okay()) { printf(&quot;No moves needed\\n&quot;); printf(&quot;%d\\n&quot;,mp[3][3]); continue; } success=false;depth=1;ans=&quot;&quot;;num=0; while(!success) { IDA_star(0,&quot;&quot;,'0'); depth++; } cout&lt;&lt;ans&lt;&lt;endl; printf(&quot;%d\\n&quot;,num); } return 0;} 以上就是IDA*与A*的全部内容了，完结撒花~❤️","link":"/2022/06/13/A-star%E4%B8%8EIDA-star/"},{"title":"ARC做题记录","text":"Solve ARC Problems Record ARC做题记录 ARC058 C.Iroha’s Obsession Difficulty: 1147\\color{green} 11471147 分情况讨论即可，首先确定构造的数的第一位， 有三种情况，能填的数分别可以大于第一位， 等于第一位， 小于第一位，贪心考虑即可。 时间复杂度O(n)O(n)O(n)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;const int M = 12;int n, m;int d[M];bool vis[M];int num[N], len;void solve(int type){ if(type == 0) { int fir = 0; for(int i = 1; i &lt;= m; i++) { if(d[i] &gt;= num[len]) { fir = d[i]; break; } } if(fir &gt; num[len]) cout &lt;&lt; fir, solve(1); else solve(2); } else if(type == 1) { for(int i = len - 1; i &gt;= 1; i--) cout &lt;&lt; d[1]; } else if(type == 2) { int fir = 0; for(int i = 1; i &lt;= m; i++) { if(d[i] == num[len]) { fir = d[i]; break; } } int res = true; vector &lt;int&gt; v; for(int i = len - 1; i &gt;= 1; i--) { int x = -1; for(int j = 1; j &lt;= m; j++) { if(d[j] &gt;= num[i]) { x = d[j]; break; } } if(x == -1)res = false; v.push_back(x); } if(res &amp;&amp; fir != 0) { cout &lt;&lt; fir; for(auto x : v) cout &lt;&lt; x; } else solve(3); } else if(type == 3) { if(d[1] == 0)cout &lt;&lt; d[2]; else cout &lt;&lt; d[1]; for(int i = len; i &gt;= 1; i--) cout &lt;&lt; d[1]; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { int x; scanf(&quot;%d&quot;, &amp;x); vis[x] = true; } m = 0; for(int i = 0; i &lt; 10; i++) if(!vis[i])d[++m] = i; if(n == 0)num[++len] = 0; while(n != 0)num[++len] = n % 10, n /= 10; solve(0); return 0;} D.Iroha and a Grid Difficulty:1905\\color{blue} 19051905 首先没有限制的方案数显然是(n−1n+m−2)\\dbinom{n - 1}{n + m - 2}(n+m−2n−1​), 再考虑上限制，其实就是出现了一个分界线，我们可以强制其走到分界线上方，不走有限制的格子， 再让其走到右下角， 求方案数， 答案即为： ∑i=1m−b(b+i−1n−a+b+i−2)×(a−1a+m−b−i+1−2) \\sum_{ i = 1} ^ {m - b} \\dbinom{b + i - 1}{n - a + b + i - 2} \\times \\dbinom{a - 1}{a + m - b - i + 1 - 2} i=1∑m−b​(n−a+b+i−2b+i−1​)×(a+m−b−i+1−2a−1​) 时间复杂度O(n)O(n)O(n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 1e5 + 10;int n, m, a, b;int fac[N &lt;&lt; 1], ifac[N &lt;&lt; 1];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int C(int n, int m){ if(n &lt; m)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}signed main(){ scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;a, &amp;b); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n + m; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n + m; i++) ifac[i] = qpow(fac[i], mod - 2); int ans = 0; for(int i = 1; i &lt;= m - b; i++) (ans += C(n - a + b + i - 2, b + i - 1) % mod * C(a + m - b - i - 1, a - 1) % mod) %= mod; printf(&quot;%lld&quot;, ans); return 0;} E.Iroha and Haiku Difficulty: 2473\\color{orange} 24732473 首先我们可以将每个数分解，然后组合构造方案，但是会产生重复，而且很难计算，不妨换一个思路考虑总方案数-不合法的方案数， 接下来考虑如何计算不合法的方案数。 感觉是一道非常好的状压dp, 状压方式也很特殊，首先根据数据限制可以判断x+y+z≤17x + y + z \\le 17x+y+z≤17， 可以压成一个171717位的二进制数，将一个数kkk压成1&lt;&lt;k−11 &lt;&lt; k - 11&lt;&lt;k−1， 比如将444，压成100010001000，表示末尾的数，当加入一个数333时，其为100010010001001000100，同时也可以表示出其能表示出的数777，再举一个例子，比如100001000101000010001010000100010可以表示11,6,2,4,5,911,6,2,4,5,911,6,2,4,5,9，其实就是表示的一段连续区间的和，那么当状态的子集中有(1&lt;&lt;x−1)∣(1&lt;&lt;x+y−1)∣(1&lt;&lt;x+y+z−1)(1 &lt;&lt; x - 1) | (1 &lt;&lt; x + y - 1) | (1 &lt;&lt; x + y + z - 1)(1&lt;&lt;x−1)∣(1&lt;&lt;x+y−1)∣(1&lt;&lt;x+y+z−1)时，显然就满足要求，每次只考虑压的x+y+zx + y + zx+y+z即可，注意防止越位，时间复杂度O(n2x+y+z)O(n 2 ^ {x + y + z})O(n2x+y+z)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 45;const int M = 17;const int mod = 1e9 + 7;int n, X, Y, Z;int f[N][1 &lt;&lt; M];int ans;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}signed main(){ scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;X, &amp;Y, &amp;Z); int S = (1 &lt;&lt; X + Y + Z) - 1; int T = (1 &lt;&lt; X - 1) | (1 &lt;&lt; X + Y - 1) | (1 &lt;&lt; X + Y + Z - 1); f[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= S; j++) { for(int k = 1; k &lt;= 10; k++) { int s = ((j &lt;&lt; k) | (1 &lt;&lt; k - 1)) &amp; S; if((T &amp; s) == T)continue; f[i][s] = (f[i][s] + f[i - 1][j]) % mod; } } } ans = qpow(10, n); for(int i = 0; i &lt;= S; i++) ans = (ans - f[n][i] + mod) % mod; printf(&quot;%lld&quot;, ans); return 0;} F.Iroha Loves Strings Difficulty: 3678\\color{red} 36783678 就会写一个O(nm2)O(nm^2)O(nm2)的，不太会Z函数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2100;const int K = 1e4 + 10;int n, k;string s[N];string f[2][K];int main(){ cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; string str = &quot;&quot;; for(int i = 1; i &lt;= k; i++) str = str + &quot;|&quot;; for(int i = 1; i &lt;= k; i++) f[0][i] = str; f[0][0] = &quot;&quot;; for(int i = 1; i &lt;= n; i++) { int len = s[i].size(); for(int j = 0; j &lt;= k; j++) f[i &amp; 1][j] = f[!(i &amp; 1)][j]; for(int j = len; j &lt;= k ; j++) { if(f[!(i &amp; 1)][j - len] + s[i] &lt; f[i &amp; 1][j]) f[i &amp; 1][j] = f[!(i &amp; 1)][j - len] + s[i]; } } cout &lt;&lt; f[n &amp; 1][k]; return 0;} ARC059 C.Being Together Difficulty: 712\\color{brown} 712712 直接枚举即可，时间复杂度O(n2)O(n^2)O(n2) 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n;int a[N];int cost(int x, int y){ return (x - y) * (x - y);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int ans = 1e9; for(int i = -100; i &lt;= 100; i++) { int sum = 0; for(int j = 1; j &lt;= n; j++) sum += cost(a[j], i); ans = min(ans, sum); } printf(&quot;%d&quot;, ans); return 0;} D.Unbalanced Difficulty : 1374\\color{cyan} 13741374 其实手玩一下就可以发现出现相邻的相同的或间隔一个相同的就会满足要求，时间复杂度O(n)O(n)O(n) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;char s[N];int n;int main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); bool res = true; for(int i = 2; i &lt;= n; i++) { if(s[i] == s[i - 1]) { res = false; printf(&quot;%d %d&quot;, i - 1, i); break; } } if(res) { for(int i = 3; i &lt;= n; i++) { if(s[i] == s[i - 2]) { res = false; printf(&quot;%d %d&quot;, i - 2, i); break; } } } if(res)printf(&quot;-1 -1&quot;); return 0;} E.Children and Candies Difficulty: 2189\\color{yellow}21892189 一开始被一坨sigma搞不会了, 其实就是个dp, 设fi,jf_{i, j}fi,j​表示前iii个人， 分到了jjj个糖果的答案，可以得到转移 fi,j=∑k=0j(fi−1,j−k×∑x=aibixk) f_{i, j} = \\sum_{k = 0} ^ j \\bigg ( f_{i - 1, j - k} \\times \\sum_{x = a_i} ^ {b_i} x ^ k \\bigg) fi,j​=k=0∑j​(fi−1,j−k​×x=ai​∑bi​​xk) 表示当前选了kkk个，然后其对答案的贡献。 时间复杂度O(n3)O(n^3)O(n3) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 410;int n, m;int a[N], b[N];int f[N][N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int sum[N][N];signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt;= m; k++) for(int j = a[i]; j &lt;= b[i]; j++) sum[i][k] = (sum[i][k] + qpow(j, k)) % mod; f[0][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++) for(int k = 0; k &lt;= j; k++) f[i][j] = (f[i][j] + f[i - 1][j - k] * sum[i][k] % mod) % mod; printf(&quot;%lld&quot;, f[n][m]); return 0;} F.Unhappy Hacking Difficulty: 2427\\color{orange} 24272427 其实挺简单的，一开始想麻烦了，设fi,jf_{i, j}fi,j​表示当前使用了iii次操作，匹配到了jjj个字符，对于转移可以分为两种，首先是选填0,10, 10,1， fi,j=fi,j+fi−1,j−1f_{i, j} = f_{i, j} + f_{i - 1, j - 1} fi,j​=fi,j​+fi−1,j−1​ 如果选择删除操作， 其实就可以从上次操作的j+1j + 1j+1个位置转移过来，由于不限制0,10, 10,1， 要乘以222 fi,j=fi,j+2×fi−1,j+1f_{i, j} = f_{i, j} + 2 \\times f_{i - 1, j + 1} fi,j​=fi,j​+2×fi−1,j+1​ 注意为空时可以使用删除操作。 时间复杂度O(n2)O(n ^ 2)O(n2) 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5100;const int mod = 1e9 + 7;int n;char s[N];int f[N][N];signed main(){ scanf(&quot;%lld%s&quot;, &amp;n, s + 1); int m = strlen(s + 1); f[0][0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = 0; j &lt;= i; j++) { if(j &gt; 0)f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mod; else f[i][j] = (f[i][j] + f[i - 1][0]) % mod; f[i][j] = (f[i][j] + 2 * f[i - 1][j + 1]) % mod; } } printf(&quot;%lld&quot;, f[n][m]); return 0;} ARC060 C.Tak and Cards Difficulty: 1583\\color{cyan} 15831583 首先将每个数减去平均数，将问题转化为选出若干个数使其和为000的方案数， 可以使用折半搜索，时间复杂度O(nn2)O(n^{\\frac{n}{2}})O(n2n​)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;#define int long longconst int N = 60;int n, m;int a[N];unordered_map&lt;int, int&gt; vis;int ans;void dfs1(int x, int lim, int sum){ if(x &gt; lim) { vis[sum]++; return; } dfs1(x + 1, lim, sum); dfs1(x + 1, lim, sum + a[x]);}void dfs2(int x, int lim, int sum){ if(x &gt; lim) { ans += vis[-sum]; return; } dfs2(x + 1, lim, sum); dfs2(x + 1, lim, sum + a[x]);}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a + 1, a + n + 1); for(int i = 1; i &lt;= n; i++) a[i] -= m; int mid = n &gt;&gt; 1; dfs1(1, mid, 0); dfs2(mid + 1, n, 0); printf(&quot;%lld&quot;, ans - 1); return 0;} D.Digit Sum Difficulty: 2261\\color{yellow} 22612261 可以使用根号分治，当d≤nd \\le \\sqrt nd≤n​的时候，直接暴力枚举，d&gt;nd &gt; \\sqrt nd&gt;n​时，n=kb+x,s=k+xn = k b + x, s = k + xn=kb+x,s=k+x, n−sn - sn−s为b−1b - 1b−1的倍数，枚举约数即可，有一些特殊情况需要特判。 时间复杂度O(n)O(\\sqrt n)O(n​) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n, m;int f(int b, int n){ if(!n)return 0; return f(b, n / b) + n % b;}int ans = 1e18;signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); bool res = false; int mid = 1e6; for(int i = 2; i &lt;= mid; i++) { if(f(i, n) == m) { res = true; ans = i; break; } } if(!res) { for(int i = 1; i * i &lt;= n - m; i++) { if((n - m) % i)continue; if(f(i + 1, n) == m) { res = true; ans = i + 1; break; } if(f((n - m) / i + 1, n) == m) { ans = min(ans,(n - m) / i + 1); res = true; } } } if(!res) { for(int i = n;i &gt;= 2 &amp;&amp; i &lt;= n + 10; i++) if(f(i, n) == m) {ans = i, res = true; break;} } if(!res)ans = -1; printf(&quot;%lld&quot;, ans); return 0;} E.Tak and Hotels Difficulty: 2154\\color{yellow} 21542154 直接倍增处理即可时间复杂度O(qlog⁡n)O(q \\log n)O(qlogn) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, q;int pos[N];int f[N][26];int query(int a, int b){ int sum = 0, cur = a; for(int i = 25; i &gt;= 0; i--) { if(f[cur][i] &gt;= b)continue; cur = f[cur][i]; sum += (1 &lt;&lt; i); } sum++; return sum;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;pos[i]); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= n; i++) { int x = lower_bound(pos + 1, pos + n + 1, pos[i] + m + 1) - pos; f[i][0] = x - 1; } for(int j = 1; j &lt;= 25; j++) for(int i = 1; i &lt;= n; i++) { if(f[i][j - 1] &gt;= n)f[i][j] = n + 1; else f[i][j] = f[f[i][j - 1]][j - 1]; } scanf(&quot;%d&quot;, &amp;q); while(q--) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if(a &gt; b)swap(a, b); printf(&quot;%d\\n&quot;, query(a, b)); } return 0;} F.Best Representation Difficulty: 2804\\color{red} 28042804 诈骗题 一道诈骗题，模数根本就没用到， 也没特殊性质， 还以为是dp， 其实除了全是相同字母的字符串， 其他的要么为111，要么为222，很显然，然后kmp， 判循环节，统计方案就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5e5 + 10;const int mod = 1e9 + 7;int n;char s[N];bool check1(){ for(int i = 2; i &lt;= n; i++) if(s[i] != s[i - 1])return false; return true;}bool check2(int *f, int i){ if((f[i] &lt;&lt; 1) &lt; i) return true; else return i % (i - f[i]);}int fnxt[N], gnxt[N];signed main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); if(check1()) { printf(&quot;%d\\n1&quot;, n); return 0; } for(int i = 2, j = 0; i &lt;= n; i++) { while(j &amp;&amp; s[i] != s[j + 1]) j = fnxt[j]; if(s[i] == s[j + 1]) j++; fnxt[i] = j; } reverse(s + 1, s + n + 1); for(int i = 2, j = 0; i &lt;= n; i++) { while(j &amp;&amp; s[i] != s[j + 1]) j = gnxt[j]; if(s[i] == s[j + 1]) j++; gnxt[i] = j; } if(check2(fnxt, n)) { printf(&quot;1\\n1&quot;); return 0; } int ans = 0; for(int i = 1; i &lt; n; i++) { int x = i, y = n - i; if(check2(fnxt, x) &amp;&amp; check2(gnxt, y)) ans++; } printf(&quot;2\\n%d&quot;, ans); return 0;} ARC061 C.Many Formulas Difficulty: 1089\\color{green} 10891089 搜索即可，时间复杂度O(2n)O(2 ^ n)O(2n)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n;char s[15];int num[15][15];int ans = 0;bool vis[15];void dfs(int x){ if(x &gt;= n) { int sum = 0; int lst = 1; for(int i = 1; i &lt;= n; i++) { if(vis[i]) { sum += num[lst][i]; lst = i + 1; } } ans += sum; return; } dfs(x + 1); vis[x] = true; dfs(x + 1); vis[x] = false;}signed main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); for(int i = 1; i &lt;= n; i++) { int sum = 0; for(int j = i; j &lt;= n; j++) { sum = sum * 10 + s[j] - '0'; num[i][j] = sum; } } vis[n] = true; dfs(1); printf(&quot;%lld&quot;, ans); return 0;} D.Snuke’s Coloring Difficulty: 1682\\color{blue} 16821682 只考虑每个矩形的左上角，然后考虑每个黑点对每个矩形的贡献， 然后枚举即可，时间复杂度O(n)O(n)O(n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5 + 10;int n, h, w;struct node{ int x, y; node(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (node a, node b){return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}};map &lt;node, int&gt; id;int b[N * 100];int cnt;void paint(int x, int y){ for(int i = x - 2; i &lt;= x; i++) { for(int j = y - 2; j &lt;= y; j++) { if(i &lt; 1 || j &lt; 1 || i + 2 &gt; h || j + 2 &gt; w) continue; if(id[node(i, j)] == 0) id[node(i, j)] = ++cnt; b[id[node(i, j)]]++; } }}int ans[10];signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;h, &amp;w, &amp;n); for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); paint(x, y); } for(int i = 1; i &lt;= cnt; i++) ans[b[i]]++; int sum = 0; for(int i = 1; i &lt;= 9; i++) sum += ans[i]; ans[0] = max(0ll, (h - 2) * (w - 2) - sum); for(int i = 0; i &lt;= 9; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;} E.Snuke’s Subway Trip Difficulty: 2502\\color{orange} 25022502 首先可以想到新建虚点然后，在每个连通块中跑最短路， 但是这样建的边数是n2n^2n2级别的，我们可以换一种建边方式，将每个边拆成一个点，然后建边，这样的话其实就是将费用拆成了两个0.50.50.5最后需要，除以222，建边的复杂度为n+2×mn + 2 \\times mn+2×m级别的。 跑最短路即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e6 + 10;const int INF = 0x3f3f3f3f3f3f3f3f;int cnt, head[N];struct edge{ int to, nxt, cost; edge(int v = 0, int x = 0, int c = 0) : to(v), nxt(x), cost(c) {}};edge e[N &lt;&lt; 1];void add(int u, int v, int c){ e[++cnt] = edge(v, head[u], c); head[u] = cnt; e[++cnt] = edge(u, head[v], c); head[v] = cnt;}struct node{ int x, y; node(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (node a, node b){return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}};int n, m;int tot;map &lt;node, int&gt; f;map &lt;node, int&gt; g;int find(int x, int y){ if(f[node(x, y)])return f[node(x, y)]; else return f[node(x, y)] = ++tot;}bool check(int x, int y){ return g[node(x, y)] | g[node(y, x)];}int dis[N];bool vis[N];int bfs(){ memset(dis, INF, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[1] = 0; vis[1] = true; queue &lt;int&gt; q; q.push(1); while(!q.empty()) { int x = q.front(); q.pop(); vis[x] = false; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to, c = e[i].cost; if(dis[x] + c &lt; dis[v]) { dis[v] = dis[x] + c; if(!vis[v]) { vis[v] = true; q.push(v); } } } } return dis[n];}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); tot = n; for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z); int u = find(x, z); int v = find(y, z); if(!check(x, u))add(x, u, 1), g[node(x, u)] = g[node(u, x)] = 1; if(!check(y, v))add(y, v, 1), g[node(x, v)] = g[node(v, x)] = 1; add(u, v, 0); } int ans = bfs(); if(ans == INF)ans = -2; printf(&quot;%lld\\n&quot;, ans / 2); return 0;} F.Card Game for Three Difficulty: 3154\\color{red} 31543154 首先需要注意的是题目说的是3n+m+k3 ^ { n + m + k }3n+m+k 种情况也就是说，最后拿完后，不止对应的是一种情况，首先转化问题，将其转化为只有1,2,31, 2, 31,2,3的序列，假设我们枚举游戏结束时，此时选了不是111的个数为xxx，此时这段序列长度为x+nx + nx+n，且此时肯定会有nnn个111以及末尾一定是111， 也就是： (x+n−1x)∑y=0x(xy)[y≤m][x−y≤k]\\dbinom{x + n - 1}{x} \\sum_{y = 0}^x \\dbinom{x}{y} [y \\le m][x - y \\le k] (xx+n−1​)y=0∑x​(yx​)[y≤m][x−y≤k] 这个组合数的意义其实就是，在x+n−1x + n - 1x+n−1个可以随便选的位置中选xxx个位置填不是111的，然后再在这些位置中选填222还是333，接着将组合数求和转化为 S(x)=∑x−k≤y≤m(xy)=∑x−k≤y≤m(x−1y)+(x−1y−1)=∑x−k≤y≤m(x−1y)+∑x−k≤y≤m(x−1y−1)=2S(x−1)−(x−1x−k−1)−(x−1m)\\begin{aligned} S(x) &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x}{y} \\\\ &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y} + \\dbinom{x - 1}{y - 1} \\\\ &amp;= \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y} + \\sum_{x - k \\le y \\le m} \\dbinom{x - 1}{y - 1} \\\\ &amp;= 2S(x - 1) - \\dbinom{x - 1}{x - k - 1} - \\dbinom{x - 1}{m} \\end{aligned} S(x)​=x−k≤y≤m∑​(yx​)=x−k≤y≤m∑​(yx−1​)+(y−1x−1​)=x−k≤y≤m∑​(yx−1​)+x−k≤y≤m∑​(y−1x−1​)=2S(x−1)−(x−k−1x−1​)−(mx−1​)​ 这样就可以O(n)O(n)O(n)处理组合数求和，再考虑长度为xxx的序列对应的情况答案其实就是 ∑x=0m+k3m+k−x(x+n−1x)S(x)\\sum_{x = 0} ^ {m + k} 3 ^ {m + k - x} \\dbinom{x + n - 1}{x}S(x) x=0∑m+k​3m+k−x(xx+n−1​)S(x) O(n)O(n)O(n)计算即可。(tips: 取模意义下减法要加模数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;const int N = 1e6 + 10;int n, m, k;int S[N];int fac[N], ifac[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int C(int n, int m){ if(n &lt; m || n &lt; 0 || m &lt; 0)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k); n = n + m + k; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = inv(fac[i]); S[0] = 1; for(int i = 1; i &lt;= n; i++) S[i] = ((2 * S[i - 1] % mod - C(i - 1, i - k - 1) % mod - C(i - 1, m) % mod + mod) % mod + mod) % mod; int ans = 0; for(int i = 0; i &lt;= m + k; i++) ((ans += qpow(3, m + k - i) % mod * C(i + n - m - k - 1, i) % mod * S[i] % mod + mod) %= mod + mod) %= mod; printf(&quot;%lld&quot;, ans); return 0;} ARC104 F.Visibility Sequence Difficulty: 3213\\color{red} 32133213 考虑将所有的−1-1−1替换成000，根据题目中的要求，在iii和pip_ipi​之间连一条边，可以构造出一棵树，其满足以下性质： 一棵树对应唯一的一个排列PPP 这棵树以000为根 子树内的编号是连续的 对于一个节点的hih_ihi​，其满足hi≥max⁡{hsoni+1,hfriendi}h_i \\ge \\max \\{ h_{son_i} + 1, h_{friend_i} \\}hi​≥max{hsoni​​+1,hfriendi​​}。 证明不难，直接设fi,j,kf_{i, j, k}fi,j,k​表示区间[i,j][i, j][i,j]构造出来以iii为根的字数，且hi=kh_i = khi​=k的PPP的数量。 观察到题目中给的值域的范围，其实由于求的是PPP的个数，已经被我们转化为映射之间的关系，只和相对大小有关，所以其值域其实是nnn，然后就是考虑转移。 首先第一种情况就是，考虑区间[i,j][i, j][i,j]在末尾新添加一棵子树，如果子树太大会导致hih_ihi​变大： fi,j,k=∑p=i+1jfp,j,k−1∑t≤kfi,p−1,tf_{i, j, k} = \\sum_{p = i + 1} ^ j f_{p, j, k - 1} \\sum_{t \\le k}f_{i , p - 1, t} fi,j,k​=p=i+1∑j​fp,j,k−1​t≤k∑​fi,p−1,t​ 另一种情况就是新加入的子树hhh比较小，但是由于其friendfriendfriend的影响，而导致变大： fi,j,k=∑p=i+1jfi,p−1,k[xp≥k−1]∑t&lt;k−1fp,j,tf_{i, j, k} = \\sum_{p = i + 1} ^ j f_{i, p - 1, k}[x_p \\ge k - 1] \\sum_{t &lt; k - 1} f_{p, j, t} fi,j,k​=p=i+1∑j​fi,p−1,k​[xp​≥k−1]t&lt;k−1∑​fp,j,t​ 然后可以使用前缀和优化到O(n4)O(n^4)O(n4)。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 110;const int mod = 1e9 + 7;int n, x[N];int f[N][N][N];int g[N][N][N];signed main(){ scanf(&quot;%lld&quot;, &amp;n); x[1] = n + 1; n = n + 1; for(int i = 2; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;x[i]); for(int i = n; i &gt;= 1; i--) { f[i][i][1] = 1; for(int k = 1; k &lt;= n; k++) g[i][i][k] = (g[i][i][k - 1] + f[i][i][k]) % mod; for(int j = i + 1; j &lt;= n; j++) { for(int k = 2; k &lt;= n &amp;&amp; k &lt;= x[i]; k++) { for(int mid = i + 1; mid &lt;= j; mid++) { f[i][j][k] = (f[i][j][k] + g[i][mid - 1][k] * f[mid][j][k - 1] % mod + f[i][mid - 1][k] * g[mid][j][k - 2] % mod * (x[mid] &gt;= k - 1)) % mod; } g[i][j][k] = (g[i][j][k - 1] + f[i][j][k]) % mod; } } } printf(&quot;%lld&quot;, g[1][n][n]); return 0;} ARC062 C.AtCoDeer and Election Report Difficulty : 1346\\color{cyan} 13461346 直接按题意模拟即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e3 + 10;int n, a[N], b[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a; a = a * a; b &gt;&gt;= 1; } return t;}signed main(){ scanf(&quot;%lld&quot;, &amp;n); a[0] = b[0] = 1; for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); int k = max(a[i - 1] / x, b[i - 1] / y); a[i] = k * x; b[i] = k * y; while(a[i] &lt; a[i - 1] || b[i] &lt; b[i - 1]) a[i] += x, b[i] += y; } printf(&quot;%lld&quot;, a[n] + b[n]); return 0;} D.AtCoDeer and Rock-Paper Difficulty: 1256\\color{cyan} 12561256 贪心选择即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;char s[N];int main(){ scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); int x = 0, y = 0, ans = 0; for(int i = 1; i &lt;= n; i++) { if(s[i] == 'p') { if(y + 1 &lt;= x) { y++; } else x++, ans--; } else { if(y + 1 &lt;= x) { y++; ans++; } else x++; } } printf(&quot;%d&quot;, ans);} ARC063 C.1D Reversi Difficulty : 755\\color{brown}755755 判断有多少不同的段数。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;char s[N];int main(){ scanf(&quot;%s&quot;, s + 1); int n = strlen(s + 1); int ans = 0; for(int i = 2; i &lt;= n; i++) { if(s[i] != s[i - 1]) ans++; } printf(&quot;%d&quot;, ans); return 0;} D.An Invisible Hand Difficulty : 1376\\color{cyan} 13761376 逆序枚举选一遍最大的差，最后统计一下方案即可。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, m, a[N];int ans;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int Max = 0, k = 0; for(int i = n; i &gt;= 1; i--) { Max = max(Max, a[i]); k = max(k, Max - a[i]); } Max = 0; for(int i = n; i &gt;= 1; i--) { Max = max(Max, a[i]); if(Max - a[i]== k) ans++; } printf(&quot;%d&quot;, ans); return 0;} E.Integers on a Tree Difficulty : 2198\\color{yellow} 21982198 不难想到一种构造方式就是维护一下当前的点权最小值，然后让与其相连的点为其点权+1+1+1，最后check一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 0x3f3f3f3f;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int w[N];int res, check;int d[N], l[N], r[N];void dfs(int x, int fa){ d[x] = d[fa] ^ 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x); l[x] = max(l[x], l[v] - 1); r[x] = min(r[x], r[v] + 1); } if(l[x] &gt; r[x])check = 0; if(w[x] != -1) { if(w[x] &gt; r[x] || w[x] &lt; l[x]) check = 0; if(res == -1)res = (w[x] &amp; 1) ^ d[x]; else if(res != ((w[x] &amp; 1) ^ d[x])) check = 0; l[x] = r[x] = w[x]; }}void paint(int x, int fa){ if(fa != 0) { if(w[fa] - 1 &gt;= l[x] &amp;&amp; w[fa] - 1 &lt;= r[x]) w[x] = w[fa] - 1; else w[x] = w[fa] + 1; } else w[x] = l[x]; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; paint(v, x); }}void init(){ check = 1; memset(w, -1, sizeof(w)); memset(l, -INF, sizeof(l)); memset(r, INF, sizeof(r));}int main(){ init(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1, x, y; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } scanf(&quot;%d&quot;, &amp;m); for(int i = 1, v, x; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;v, &amp;x); w[v] = x; } res = -1; dfs(1, 0); if(!check) { printf(&quot;No\\n&quot;); } else { printf(&quot;Yes\\n&quot;); paint(1, 0); for(int i = 1; i &lt;= n; i++) printf(&quot;%d\\n&quot;, w[i]); } return 0;} F.Snuke’s Coloring 2 Difficulty : 3688\\color{red} 36883688 就是找一个矩形使点不在矩形内，求矩形的周长，首先很容易想到的就是答案至少为2max⁡(W,H)+22 \\max(W, H) + 22max(W,H)+2， 我们可以直接枚举中线，进行分治， 复杂度为O(nlog⁡n)O(n \\log n)O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 3e5 + 10;int n, W, H;struct Point{ int x, y; Point(int a = 0, int b = 0) : x(a), y(b) {} friend bool operator &lt; (Point a, Point b) { return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x; }};Point p[N];int ans, up[N], down[N];int m;int q[N], head, tail;void solve(int l, int r){ if(l == r)return; int mid = (l + r) &gt;&gt; 1; solve(l, mid); solve(mid + 1, r); int u = H, d = 0; for(int i = mid; i &gt;= l; i--) { up[i] = u; down[i] = d; if(p[i].y &lt;= m) d = max(d, p[i].y); else u = min(u, p[i].y); } u = H, d = 0; for(int i = mid + 1; i &lt;= r; i++) { up[i] = u, down[i] = d; if(p[i].y &lt;= m) d = max(d, p[i].y); else u = min(u, p[i].y); } int j = mid, s = W; head = 1, tail = 0; for(int i = mid + 1; i &lt;= r; i++) { while(j &gt;= l &amp;&amp; up[j] &gt;= up[i]) { while(head &lt;= tail &amp;&amp; p[q[tail]].x + down[q[tail]] &gt;= p[j].x + down[j]) tail--; q[++tail] = j; j--; } while(head &lt;= tail &amp;&amp; down[q[head]] &lt;= down[i]) { s = min(s, p[q[head]].x); head++; } ans = max(ans, p[i].x - s + up[i] - down[i]); if(head &lt;= tail) ans = max(ans, p[i].x + up[i] - (p[q[head]].x + down[q[head]])); }}void getans(){ sort(p + 1, p + n + 1); m = H &gt;&gt; 1; p[0] = Point(0, 0); p[n + 1] = Point(W, 0); solve(0, n + 1); reverse(p + 1, p + n + 1); for(int i = 1; i &lt;= n; i++) p[i].x = W - p[i].x; solve(0, n + 1);}signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;W, &amp;H, &amp;n); for(int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); p[i] = Point(x, y); } getans(); swap(W, H); for(int i = 1; i &lt;= n; i++) swap(p[i].x, p[i].y); getans(); printf(&quot;%lld&quot;, ans &lt;&lt; 1ll); return 0;} ARC119 A.119 × 2^23 + 1 Difficulty : 69\\color{cray} 6969 直接暴力枚举。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;int n;int ans = 1e18;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 63; i &gt;= 0; i--) { int x = 1ll &lt;&lt; i; ans = min(ans, n / x + n % x + i); } printf(&quot;%lld&quot;, ans); return 0;} B.Electric Board Difficulty : 1196\\color{green} 11961196 一个很显然的结论， 答案就是每个000的位置差不为000的和。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int n;char s[N];char t[N];int ans = 0;vector &lt;int&gt; a, b;int main(){ cin &gt;&gt; n &gt;&gt; s + 1 &gt;&gt; t + 1; for(int i = 1; i &lt;= n; i++) if(s[i] == '0')a.push_back(i); for(int i = 1; i &lt;= n; i++) if(t[i] == '0')b.push_back(i); if(a.size() != b.size()) ans = -1; else { for(int i = 0; i &lt; a.size(); i++) if(a[i] != b[i])ans++; } printf(&quot;%d&quot;, ans); return 0;} C.ARC Wrecker 2 Difficulty : 1354\\color{cyan} 13541354 其实就是统计偶数位置和奇数位置的和相加为000的个数。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 10;#define int long longint n, a[N];int f[N], g[N];int ans;map &lt;int, int&gt; sum;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) { if(i &amp; 1) f[i] = f[i - 1] + a[i], g[i] = g[i - 1]; else g[i] = g[i - 1] + a[i], f[i] = f[i - 1]; } for(int i = 0; i &lt;= n; i++) { ans += sum[f[i] - g[i]]; sum[f[i] - g[i]]++; } printf(&quot;%lld&quot;, ans); return 0;} D. Grid Repainting 3 Difficulty : 2713\\color{orange} 27132713 很经典的一个模型，可以根据行列分为左部点和右部点，建立二分图，然后分联通块统计答案即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;#define fir first#define sec second#define mpr make_pair#define int long longtypedef pair &lt;int, int&gt; Pair;const int N = 2e7 + 10;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int a[5010][5010];int fa[N];Pair w[N];int find(int x){ if(x == fa[x])return x; return fa[x] = find(fa[x]);}void merge(int x, int y){ if(find(x) == find(y)) return; x = find(x), y = find(y); fa[x] = y; w[y].fir += w[x].fir; w[y].sec += w[x].sec;}void init(){ for(int i = 1; i &lt;= n; i++) fa[i] = i, w[i] = mpr(1, 0); for(int i = 1; i &lt;= m; i++) fa[i + n] = i + n, w[i + n] = mpr(0, 1);}int f(int x, int y){ return x * m + y * n - x * y;}bool vis[N];vector &lt;pair &lt;Pair, int&gt; &gt; ans;void dfs(int x, int c){ vis[x] = true; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(vis[v])continue; if(!c)ans.push_back(mpr(mpr(x, v - n), 1)); else ans.push_back(mpr(mpr(v, x - n), 0)); dfs(v, c ^ 1); }}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { char c; cin &gt;&gt; c; a[i][j] = (c == 'R'); } } init(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i][j])add(i, j + n), merge(i, j + n); int tot = 0; Pair x(0, 0); for(int i = 1; i &lt;= n + m; i++) { if(find(i) == i &amp;&amp; w[i].fir + w[i].sec &gt; 1) tot++, x.fir += w[i].fir, x.sec += w[i].sec; } if(f(x.fir - tot, x.sec) &gt; f(x.fir, x.sec - tot)) { for(int i = 1; i &lt;= n; i++) if(!vis[i])dfs(i, 0); } else { for(int i = 1; i &lt;= m; i++) if(!vis[i + n])dfs(i + n, 1); } printf(&quot;%lld\\n&quot;, ans.size()); reverse(ans.begin(), ans.end()); for(auto i : ans) printf(&quot;%c %lld %lld\\n&quot;, (i.sec ? 'Y' : 'X'), i.fir.fir, i.fir.sec); return 0;} E.Pancakes Difficulty : 2502\\color{orange} 25022502 由于反转区间对中间的部分没有影响， 可以把绝对值拆开， 然后转化为一个二维偏序的形式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 3e5 + 10;const int INF = 2147483647;struct Point{ int x, y; bool operator &lt; (const Point &amp;a) const{return x &lt; a.x;}};Point p[N];int main(){ int n, lst; scanf(&quot;%d%d&quot;, &amp;n, &amp;lst); ll ans = 0; for (int i = 2; i &lt;= n; i++) { p[i - 1].x = lst; scanf(&quot;%d&quot;, &amp;lst); p[i - 1].y = lst; ans += abs(p[i - 1].x - lst); } int cur = 0; for (int i = 1; i &lt; n; i++) cur = max(cur, abs(p[i].x - p[i].y) - abs(p[n - 1].y - p[i].x)); for (int i = 1; i &lt; n; i++) cur = max(cur, abs(p[i].x - p[i].y) - abs(p[1].x - p[i].y)); sort(p + 1, p + n); for (int i = n - 1, x = INF; i &gt;= 1; i--) { if (p[i].y &lt;= p[i].x) { if (x &lt;= p[i].y) cur = max(cur, 2 * abs(p[i].x - p[i].y)); else if (x &lt;= p[i].x) cur = max(cur, 2 * abs(p[i].x - x)); x = min(x, p[i].y); } swap(p[i].x, p[i].y); } sort(p + 1, p + n); for (int i = n - 1, x = INF; i &gt;= 1; i--) { if (p[i].y &lt;= p[i].x) { if (x &lt;= p[i].y) cur = max(cur, 2 * abs(p[i].x - p[i].y)); else if (x &lt;= p[i].x) cur = max(cur, 2 * abs(p[i].x - x)); x = min(x, p[i].y); } } printf(&quot;%lld\\n&quot;, ans - cur); return 0;} ARC112 F.Die Siedler Difficulty : 3432\\color{red} 34323432 考虑转化问题，将每个位置的卡牌转移到第一个位置上来，首先对于这种转化方式容易得到其得到满足要求的序列所需的最小步数，是与原序列是等价的，同时对于每种卡包， 也用相同的转化方式，然后相加减的答案就是原序列的答案。 对于一个长度为nnn的序列，其转化即为 ∑i=1nai2i−1(i−1)!\\sum_{i = 1} ^n a_i 2 ^ {i - 1} (i - 1) ! i=1∑n​ai​2i−1(i−1)! 然后考虑已知这种表达方式如何求解，其实只要贪心即可，去倒着填，对于第一个位置的数，其可以减少若干倍的2nn!−12 ^ n n! - 12nn!−1(转化一周)， 也就是说，最后所有卡牌转为为第一个位置的时候，答案可以表示为， v=R+∑i=1nbixi−y(2nn!−1)v = R + \\sum_{i = 1} ^ n b_i x_i - y (2 ^ n n! - 1) v=R+i=1∑n​bi​xi​−y(2nn!−1) 裴蜀定理解出即可， 然后考虑到数据范围，需要使用根号分治，当d&lt;2nn!d &lt; \\sqrt {2 ^ n n !}d&lt;2nn!​时，直接暴力枚举，d≤2nn!d \\le \\sqrt {2 ^n n!}d≤2nn!​时，根据转移，可以跑同余最短路，然后问题就解决了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 18;const int M = 60;const int INF = 1e18;const int K = 1.5e6 + 10;int n, m;int a[N], s[M][N];int fac[N], t[N];int S[M];int lim;int b[N];void init(){ fac[0] = t[0] = 1; for(int i = 1; i &lt;= n; i++) t[i] = t[i - 1] * 2; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i;}int f(int *a){ int sum = 0; for(int i = 1; i &lt;= n; i++) sum += a[i] * t[i - 1] * fac[i - 1]; return sum;}int calc(int A){ int sum = A, s = 0; for(int i = n; i &gt;= 1; i--) { s += sum / (t[i - 1] * fac[i - 1]); sum %= (t[i - 1] * fac[i - 1]); } return s;}int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int dis[K];int d;int spfa(int T){ memset(dis, 0x3f3f3f3f, sizeof(dis)); queue &lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { int x = t[i - 1] * fac[i - 1] % d; dis[x] = 1; q.push(x); } while(!q.empty()) { int x = q.front();q.pop(); for(int i = 1; i &lt;= n; i++) { int v = (x + t[i - 1] * fac[i - 1]) % d; if(dis[x] + 1 &lt; dis[v]) { dis[v] = dis[x] + 1; q.push(v); } } } return dis[T];}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;s[i][j]); init(); for(int i = 1; i &lt;= m; i++) S[i] = f(s[i]); lim = t[n] * fac[n] - 1; d = lim; for(int i = 1; i &lt;= m; i++) d = gcd(S[i], d); int ans = INF; if(d &gt;= lim / d) { for(int i = f(a) % d; i &lt;= lim; i += d) if(i) ans = min(ans, calc(i)); } else { ans = INF; int A = f(a); ans = min(ans, spfa(A % d)); } printf(&quot;%lld&quot;, ans); return 0;} ARC116 A.Odd vs Even Difficulty : 155\\color{gray} 155155 分情况讨论一下，不难得出当nnn为奇数时，odd&gt;evenodd &gt; evenodd&gt;even， 当nnn不是444的倍数时此时odd=evenodd = evenodd=even， 否则odd&lt;evenodd &lt; evenodd&lt;even，其实质因数分解一下就可以看出来。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main(){ int T; scanf(&quot;%d&quot;, &amp;T); while(T--) { ll n; scanf(&quot;%lld&quot;, &amp;n); if(n &amp; 1) cout &lt;&lt; &quot;Odd&quot; &lt;&lt; endl; else if(n % 4 != 0) cout &lt;&lt; &quot;Same&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Even&quot; &lt;&lt; endl; } return 0;} B.Products of Min-Max Difficulty : 816\\color{green} 816816 可以考虑排序后固定最大值，然后统计贡献即可。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 + 10;const int mod = 998244353;const int INF = 1e9;int n, a[N];int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); sort(a + 1, a + n + 1); ll ans = 0, sum = 0; for(int i = 1; i &lt;= n; i++) { ans = (ans + a[i] * (sum + a[i]) % mod) % mod; sum = sum * 2ll % mod; sum = (sum + a[i]) % mod; } printf(&quot;%lld&quot;, ans); return 0;} C.Multiple Sequences Difficulty : 1468\\color{cyan} 14681468 首先注意到m≤2×105m \\le 2 \\times 10 ^ 5m≤2×105，分解后质因子数最多为666个，然后考虑枚举最后一个数为多少，将其质因数分解，然后先计算每个质因数指数分配的情况然后相乘，这时候等价于在nnn个相同的盒子中放mmm个不同的小球，方案数为(n+m−1n)\\dbinom{n +m - 1}{n}(nn+m−1​)，然后将每个质因数的答案乘起来就好了。时间复杂度O(nn)O(n \\sqrt n)O(nn​)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 + 10;const int mod = 998244353;int n, m;ll ans;ll qpow(ll a, ll b){ ll t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}ll inv(ll x){ return qpow(x, mod - 2);}ll fac[N + 100], ifac[N + 100];ll C(int n, int m){ if(n &lt; m)return 0; return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); fac[0] = ifac[0] = 1; for(ll i = 1; i &lt;= N + 99; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1;i &lt;= N + 99; i++) ifac[i] = inv(fac[i]); for(int i = 1; i &lt;= m; i++) { int x = i; ll mul = 1; for(int j = 2; j * j &lt;= x; j++) { if(x % j != 0)continue; int sum = 0; while(x % j == 0) sum++, x /= j; mul = mul * C(n + sum - 1, sum) % mod; } if(x != 1)mul = mul * 1ll * n % mod; ans = (ans + mul) % mod; } printf(&quot;%lld&quot;, ans); return 0;} D.I Wanna Win The Game Difficulty : 1718\\color{blue} 17181718 考虑设fi,jf_{i,j}fi,j​表示枚举到第iii个二进制位，此时权值和为jjj的方案数，然后直接转移即可，需要保证每个二进制位的111的个数为偶数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 5100;const int mod = 998244353;int n, m;ll fac[N], ifac[N];ll qpow(ll a, ll b){ ll t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}ll inv(ll x){ return qpow(x, mod - 2);}ll f[15][N];ll C(int n, int m){ return fac[n] % mod * ifac[m] % mod * ifac[n - m] % mod;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * 1ll * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); f[0][0] = 1; for(int i = 1; i &lt;= 14; i++) { for(int j = 0; j &lt;= m; j++) { for(int k = 0; k &lt;= n; k += 2) { int x = j - (1 &lt;&lt; (i - 1)) * k; if(x &lt; 0)break; f[i][j] = (f[i][j] + f[i - 1][x] * C(n, k) % mod) % mod; } } } printf(&quot;%lld&quot;, f[14][m]); return 0;} E.Spread of Information Difficulty : 2236\\color{yellow} 22362236 直接二分判定时间， 然后贪心，选取点，设fif_ifi​表示节点iii到其子树内最近的初始被覆盖的点的距离，gig_igi​表示其到子树被最远的没被覆盖住的点的距离。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;const int INF = 1e9;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int n, m;int tot;int f[N], g[N];void dfs(int x, int fa, int lim){ f[x] = INF; g[x] = 0; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x, lim); f[x] = min(f[x], f[v] + 1); g[x] = max(g[x], g[v] + 1); } if(f[x] + g[x] &lt;= lim) g[x] = -INF; else if(g[x] == lim) { f[x] = 0; g[x] = -INF; tot++; }}bool check(int x){ tot = 0; dfs(1, 0, x); if(g[1] &gt;= 0)tot++; return tot &lt;= m;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } int l = 0, r = n; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid - 1; else l = mid + 1; } printf(&quot;%d&quot;, l); return 0;} F.Deque Game Difficulty : 3125\\color{red} 31253125 首先考虑只有一个序列的情况此时设长度为nnn，假如nnn为偶数，此时很明显答案就是max⁡(a[n/2],a[n/2+1])\\max(a[n / 2], a[n / 2 + 1])max(a[n/2],a[n/2+1])，或min⁡(a[n/2],a[n/2+1])\\min(a[n/ 2], a[n / 2 + 1])min(a[n/2],a[n/2+1])若nnn为奇数此时答案为max⁡(min⁡(a[n/2],a[n/2+1]),min⁡(a[n/2+1],a[n/2+2]))\\max(\\min(a[n / 2], a[n / 2 + 1]), \\min(a[n / 2 + 1], a[n / 2 + 2]))max(min(a[n/2],a[n/2+1]),min(a[n/2+1],a[n/2+2]))或min⁡(max⁡(a[n/2],a[n/2+1]),max⁡(a[n/2+1],a[n/2+2]))\\min(\\max(a[n / 2], a[n / 2 + 1]), \\max(a[n / 2 + 1], a[n / 2 + 2]))min(max(a[n/2],a[n/2+1]),max(a[n/2+1],a[n/2+2]))，依据先后手来决定。然后将其拓展到多个序列，首先考虑所有的序列长度均为奇数， 此时先后手不会被改变，直接按照先手的取值求和即可，但是如若出现长度为偶数的序列， 此时就会出现，先后手交换的情况，此时需要使用优先队列去维护一下，对于每个长度为偶数的序列其带来的影响，最后求和即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e5 +10;int n;vector &lt;int&gt; a[N];int m[N];int v[N];ll ans;int res;int calc(int x, int n){ if(n == 2) return x == 0 ? v[2] : v[1]; if(!res) return max(min(v[n / 2 + x], v[n / 2 + 1 + x]), min(v[n / 2 + 1 + x], v[n / 2 + 2 + x])); else return min(max(v[n / 2 + x], v[n / 2 + 1 + x]), max(v[n / 2 + 1 + x], v[n / 2 + 2 + x]));}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;m[i]); for(int j = 1; j &lt;= m[i]; j++) { int x; scanf(&quot;%d&quot;, &amp;x); a[i].push_back(x); } if(!(m[i] &amp; 1))res ^= 1; } priority_queue &lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m[i]; j++) v[j] = a[i][j - 1]; if(m[i] &amp; 1) { if(m[i] == 1) ans += v[1]; else ans += calc(0, m[i]); } else { q.push(max(calc(-1, m[i]), calc(0, m[i])) - min(calc(-1, m[i]), calc(0, m[i]))); ans += min(calc(-1, m[i]), calc(0, m[i])); } } while(!q.empty()) { ans += q.top(); q.pop(); if(!q.empty())q.pop(); } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2022/10/13/ARC%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"About This Blog","text":"QWQ About 一个小窝。 文章如有 LaTeX\\LaTeXLATE​X 的显示问题，请持续刷新，或更换浏览器。 关闭浏览器的网站保护也可以解决问题。 HaveHaveHave Fun!Fun!Fun! 。","link":"/2022/06/22/About-This-Blog/"},{"title":"BSGS","text":"Baby - Step - Giant - Step BSGS 前置知识 同余 BSGS BSGS（baby-step giant-step） (北上广深，拔山盖世)是用来解决形如 ax≡b( mod m)a^x \\equiv b \\quad (\\bmod m) ax≡b(modm) 的高次同余方程，其中 a⊥ma \\perp ma⊥m 首先0≤x&lt;m0 \\le x &lt; m0≤x&lt;m（就mmm个不同的得数），设x=Am−Bx=A \\sqrt{m}-Bx=Am​−B，其中0≤A,B≤m0 \\le A,B\\le \\sqrt{m}0≤A,B≤m​，方程变为： aAm−B≡b( mod m)a^{A \\sqrt{m}-B} \\equiv b \\quad (\\bmod m) aAm​−B≡b(modm) 由于 a⊥ma \\perp ma⊥m移项可得： aAm≡baB( mod m)a^{A \\sqrt{m}} \\equiv ba^{B} \\quad (\\bmod m) aAm​≡baB(modm) 由于a,b,ma,b,ma,b,m均已知可以考虑枚举BBB用mapmapmap存储对应的值，然后再枚举AAA，检查mapmapmap中是否有值对应 因为A,BA,BA,B均不大于m\\sqrt{m}m​，所以时间复杂度为O(n)O(\\sqrt{n})O(n​)。（没算mapmapmap） 题目 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll p,b,n;map&lt;ll,ll&gt; vis;ll BSGS(){ if(1%p==n%p)return 0; int k=sqrt(p)+1;ll j=n%p; for(int i=0;i&lt;k;i++) { vis[j]=i; j=j*b%p; } ll x=1; for(int i=1;i&lt;=k;i++)x=x*b%p; j=x; for(int i=1;i&lt;=k;i++) { if(vis.count(j))return i*k-vis[j]; j=x*j%p; } return -1;}int main(){ scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;b,&amp;n); ll ans=BSGS(); ans==-1?printf(&quot;no solution&quot;):printf(&quot;%lld&quot;,ans); return 0;} exBSGS 问题仍然是去解决一个形如 ax≡b( mod m)a^x \\equiv b \\quad (\\bmod m) ax≡b(modm) 的高次同余方程，但不保证a⊥ma \\perp ma⊥m 考虑用扩展BSGS（exBSGS）(无限宝石公式)来解决这个问题 此时aaa和mmm不一定互质，我们可以将式子进一步化简为： axgcd⁡(a,m)≡bgcd⁡(a,m)( mod mgcd⁡(a,m))\\frac{a^x}{\\gcd(a,m)} \\equiv \\frac{b} {\\gcd(a,m)} \\quad (\\bmod \\frac{m}{\\gcd(a,m)}) gcd(a,m)ax​≡gcd(a,m)b​(modgcd(a,m)m​) 将左边提出一项 ax−1agcd⁡(a,m)≡bgcd⁡(a,m)( mod mgcd⁡(a,m))a^{x-1} \\frac{a}{\\gcd(a,m)} \\equiv \\frac{b} {\\gcd(a,m)} \\quad (\\bmod \\frac{m}{\\gcd(a,m)}) ax−1gcd(a,m)a​≡gcd(a,m)b​(modgcd(a,m)m​) 接下来不断除以gcd⁡(a,m)\\gcd(a,m)gcd(a,m)直到aaa与mmm互质，然后用BSGS求解 由于最后我们将式子递归执行了kkk层，此时式子变为 ax−kakgcd⁡k(a,m)≡bgcd⁡k(a,m)( mod mgcd⁡k(a,m))a^{x-k} \\frac{a^k}{\\gcd^k(a,m)} \\equiv \\frac{b} {\\gcd^k(a,m)} \\quad (\\bmod \\frac{m}{\\gcd^k(a,m)}) ax−kgcdk(a,m)ak​≡gcdk(a,m)b​(modgcdk(a,m)m​) 最后利用BSGS求解出xxx后应当再加上kkk，x+kx+kx+k即为该方程的解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=5e6+10;map&lt;ll,ll&gt; vis;ll gcd(ll a,ll b){ if(b==0)return a; return gcd(b,a%b);}ll qpow(ll a,ll b,ll p){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%p; a=a*a%p;b&gt;&gt;=1; } return t;}ll bsgs(ll a,ll b,ll p,ll k){ vis.clear(); int m=sqrt(p)+1; ll r=b%p; for(int i=0;i&lt;=m;i++) { vis[r]=i; r=r%p*a%p; } ll l=k%p,x=qpow(a,m,p); for(int i=0;i&lt;=m;i++) { if(vis.count(l)&amp;&amp;i*m-vis[l]&gt;=0) return i*m-vis[l]; l=l*x%p; } return -1e9;}ll exbsgs(ll a,ll b,ll p,ll m){ a%=p,b%=p; if(b==1||p==1&amp;&amp;m==1)return 0; ll d=gcd(a,p); if(b%d!=0)return -1; if(d==1)return bsgs(a,b,p,m); else return exbsgs(a,b/d,p/d,(m*a/d)%p)+1;}int main(){ ll a,b,p; while(scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;p,&amp;b)&amp;&amp;a&amp;&amp;b&amp;&amp;p) { ll res=exbsgs(a,b,p,1); if(res&lt;0) printf(&quot;No Solution\\n&quot;); else printf(&quot;%lld\\n&quot;,res); } return 0;} （好像用递归写的很少，大数据肯定是可以过的，但好像过不了洛谷上的hack小数据，不过小数据时我觉得直接可以暴力枚举）","link":"/2022/07/24/BSGS/"},{"title":"Balls and Boxes","text":"经典组合数学 小球与盒子 前置知识 组合数 ： Cnm=n!m!(n−m)!C_n^m = \\frac{n!}{m!(n-m)!} Cnm​=m!(n−m)!n!​ 插板法 ：用于解决不相邻组合与追加排列的问题，就是在nnn个物品之间插上mmm个板，将其分为m+1m+1m+1组。 捆绑法：将一些物品作为整体计算。 容斥原理：将重复计算的数目去除，比如： A∪B=A+B−A∩B A\\cup B = A+B- A\\cap B A∪B=A+B−A∩B 1. 球相同，盒子不同，不能有空盒 其实这个问题的实质就是把nnn个小球分为mmm组（不能空），就转化为了一个组合数问题，答案其实就是 Cn−1m−1C_{n-1}^{m-1} Cn−1m−1​ 其实就是插板法，在小球的n−1n-1n−1个空隙中插入m−1m-1m−1个板子，使其分为mmm组。 2. 球相同，盒子不同，可以有空盒 其实和上个问题差不多，我们一开始可以就向每个盒子中添加一个小球，这样就不会有空盒，答案为 Cn+m−1m−1C_{n+m-1}^{m-1} Cn+m−1m−1​ 3. 球不同，盒子不同，可以有空盒 对于每一个球，都可以放在mmm个位置中的任意一个位置，由于球与球之间是相互独立的，答案就是 mnm^n mn 4.球不同，盒子相同，不能有空盒 这个其实就是第二类斯特林数，将nnn个物体划分为kkk个非空的没有区别的集合的方案数，其递推公式为： fi,j=fi−1,j×j+fi−1,j−1f_{i,j} = f_{i-1,j}\\times j + f_{i-1,j-1} fi,j​=fi−1,j​×j+fi−1,j−1​ 其实通俗的理解就是对于第iii个球，可以放在以前的jjj个盒子中有j×fi−1,jj \\times f_{i-1,j}j×fi−1,j​种方案,或者放入一个新的盒子有fi−1,j−1f_{i-1,j-1}fi−1,j−1​种方案。 不过这是一个n2n^2n2的公式，但是其它还有一个更通用的公式： f(n,m)=1m!×∑k=0m(−1)k(mk)×(m−k)nf(n,m) = \\frac{1}{m!} \\times \\sum_{k = 0}^m (-1)^k \\dbinom{m}{k} \\times (m-k)^n f(n,m)=m!1​×k=0∑m​(−1)k(km​)×(m−k)n 5. 球不同，盒子也不同，不能有空盒 其实这个和上一种情况不同的就是，这个情况需要有序性，答案其实就是对应的斯特林数， f(n,m)×m!f(n,m) \\times m! f(n,m)×m! 就可以了。 6. 球不同， 盒子相同，可以有空盒 因为可以有空盒，其实就可以枚举每次用了几个盒子，然后将对应的斯特林数相加即可,答案就是 ∑i=1mf(n,i)\\sum_{i =1}^m f(n,i) i=1∑m​f(n,i) 其实这种数还有另一种名称叫贝尔数，它表示集合1,2,3,⋯ ,n{1,2,3,\\cdots,n}1,2,3,⋯,n的划分方案数，其实就表示了第二类斯特林数之和。 7.球相同，盒子相同，可以有空盒 首先分情况，如果一个盒子没有小球，方案数显然为1，同时如果小球比盒子要少，盒子肯定时是放不满的，所以fi,j=fi,if_{i,j} = f_{i,i}fi,j​=fi,i​，如果小球比盒子要多，就将盒子分为放满和没放满两种情况，所以fi,j=fi−j,j+fi,j−1f_{i,j} = f_{i-j,j} + f_{i,j-1}fi,j​=fi−j,j​+fi,j−1​。 8. 球相同，盒子相同，不能有空盒 只需要假设每个盒子里都已经放上了一个球，答案就是， f(n−m,m)f(n-m,m) f(n−m,m)","link":"/2022/08/26/Balls-and-Boxes/"},{"title":"CF1146H Satanic Panic","text":"CF1146H Satanic Panic 题解 题意 给定平面内的nnn个点(n≤300n \\le 300n≤300)，求有多少种方案可以构成一个五角星。 解法 首先其实找五角星就是在找一个由五个顶点构成的凸包，设f[i][j][k]f[i][j][k]f[i][j][k]表示为从iii到jjj经过了kkk个点的不同方案数。 其实五个点的凸包就是五条斜率具有单调性的线段组合而成的图形，我们可以先将所有的线段按照极角序进行排序，这样就可以得到一个状态转移方程： f[i][x][j+1]=∑f[i][y][j]f[i][x][j+1] = \\sum f[i][y][j] f[i][x][j+1]=∑f[i][y][j] 其中xxx和yyy表示一条线段的左右端点，因为排序后极角序是具有单调性的，所以上述方程的转移是成立的。 初始化所有的f[i][i][1]=1f[i][i][1] = 1f[i][i][1]=1，最后统计一下答案∑f[i][i][6]\\sum f[i][i][6]∑f[i][i][6]即可。 时间复杂度O(n3)O(n^3)O(n3)。不过CF评测机显然能在4s内跑过1e8。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 310;struct Point{ double x, y; Point(double _x = 0, double _y = 0):x(_x), y(_y) {} friend Point operator + (Point a, Point b){return Point(a.x+b.x, a.y+b.y);} friend Point operator - (Point a, Point b){return Point(a.x-b.x, a.y-b.y);} friend Point operator * (Point a, double b){return Point(a.x*b, a.y*b);} friend Point operator / (Point a, double b){return Point(a.x/b, a.y/b);}}origin;Point p[N];struct Segment{ int a, b; Point v;double An; Segment(int _a = 0, int _b = 0): a(_a), b(_b) {v = p[b]-p[a]; An = atan2(v.y, v.x);} friend bool operator &lt; (Segment x, Segment y){return x.An &lt; y.An;}}s[N * N];int n, cnt;ll f[N][N][7];int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { double x, y; scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); p[i] = Point(x, y); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(i == j)continue; s[++cnt] = Segment(i, j); } } sort(s+1, s+cnt+1); for(int i = 1; i &lt;= n; i++) f[i][i][1] = 1; for(int k = 1; k &lt;= cnt; k++) { int x = s[k].a; int y = s[k].b; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= 5; j++) f[i][y][j+1] += f[i][x][j]; } ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += f[i][i][6]; printf(&quot;%lld&quot;, ans); return 0;}","link":"/2022/08/24/CF1146H%20Satanic%20Panic/"},{"title":"CF1149C Tree Generator™","text":"CF1149C Tree Generator™ 题解 题目大意 给定一个有nnn个点的树，这颗树的括号序列，输出它的直径，mmm个询问，每次询问表示交换两个括号，输出交换两个括号后的直径。(保证每次操作后都为一棵树) 3≤n≤1e5,1≤q≤1e53 \\le n \\le 1e5 , 1 \\le q \\le 1e53≤n≤1e5,1≤q≤1e5。 解法 首先，我们需要知道括号树是怎么构建的，对于题目中所描述的括号树，我们只需要在遇到(((时向下走，遇到)))向回走，就能构造出一个满足要求的括号树， 现在需要知道三个引理。 对于括号序列中的任意一个连续子序列，将其中的匹配上的括号除去剩下的对应树上的一条链。 树上直径长度即为任意区间去掉匹配括号后的长度的最大值。 如果将(((权值设为111, )))权值设为−1-1−1, 最长去匹配区间，也就是直径 = 相邻两个区间权值和之差的最大值。 首先对于引理1，其实就是对于匹配上的括号我们走下去后，又走了回来也就是其对链长度的贡献为000，引理2其实就是对应引理1中最长的一段链其实也就是直径. 引理3其实就很清楚的得出了答案， 首先根据引理1区间内已经匹配上的括号是不会对长度产生贡献的，也就是说对应的贡献区间为： (((((((((((((((((((((((( ))))))))))))))))))))) ))))(((())))(((())))(((( 这三种，对于第一种我们可以在区间的最前面作为断点，第二种在最后面，第三种在中间来得到相邻两个区间权值和之差的最大值。 接下来就是考虑怎么维护了，其实类比最大子段和，这个也可以用线段树维护，(就是稍微麻烦了一点)。 对于区间[l,r][l,r][l,r]需要维护八个变量： sumsumsum为区间和 lmxlmxlmx为从左端点开始的连续最大值 rmxrmxrmx为从右端点开始的连续最大值 lmnlmnlmn为从左端点开始的连续最小值 rmnrmnrmn为从右端点开始的连续最小值 val1val1val1为 max⁡sum(x,y)−sum(l,x),l≤x≤y≤r\\max sum(x,y) - sum(l,x) , l \\le x \\le y \\le rmaxsum(x,y)−sum(l,x),l≤x≤y≤r val2val2val2为 max⁡sum(y,r)−sum(x,y),l≤x≤y≤r\\max sum(y, r) - sum(x, y), l \\le x \\le y \\le rmaxsum(y,r)−sum(x,y),l≤x≤y≤r valvalval为 max⁡sum(y,z)−sum(x,y),l≤x≤y≤z≤r\\max sum(y, z) - sum(x, y), l \\le x \\le y \\le z \\le rmaxsum(y,z)−sum(x,y),l≤x≤y≤z≤r， 也就是最终答案 单点修改+查询就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int n, q;int a[N];struct Segmentree{ int sum; int lmx, rmx; int lmn, rmn; int val1, val2, val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1)}t[N &lt;&lt; 2];void push_up(int p){ t[p].sum = t[ls(p)].sum + t[rs(p)].sum; t[p].lmx = max(t[ls(p)].lmx, t[ls(p)].sum + t[rs(p)].lmx); t[p].rmx = max(t[rs(p)].rmx, t[rs(p)].sum + t[ls(p)].rmx); t[p].lmn = min(t[ls(p)].lmn, t[ls(p)].sum + t[rs(p)].lmn); t[p].rmn = min(t[rs(p)].rmn, t[rs(p)].sum + t[ls(p)].rmn); t[p].val1 = max({t[ls(p)].val1, t[rs(p)].val1 - t[ls(p)].sum, t[rs(p)].lmx + t[ls(p)].rmx * 2 - t[ls(p)].sum}); t[p].val2 = max({t[rs(p)].val2, t[ls(p)].val2 + t[rs(p)].sum, t[rs(p)].sum - t[rs(p)].lmn * 2 - t[ls(p)].rmn}); t[p].val = max({t[ls(p)].val, t[rs(p)].val, t[ls(p)].val2 + t[rs(p)].lmx, t[rs(p)].val1 - t[ls(p)].rmn});}void build(int l, int r, int p){ if(l == r) { t[p].sum = a[l]; t[p].lmx = t[p].rmx = max(a[l], 0); t[p].lmn = t[p].rmn = min(a[l], 0); t[p].val1 = t[p].val2 = t[p].val = 1; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}void change(int l, int r, int p, int x, int k){ if(l == r) { t[p].sum = k; t[p].lmx = t[p].rmx = max(k, 0); t[p].lmn = t[p].rmn = min(k, 0); return; } int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) change(l, mid, ls(p), x, k); else change(mid + 1, r, rs(p), x, k); push_up(p);}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;q); n = (n - 1) &lt;&lt; 1; for(int i = 1; i &lt;= n; i++) { char x;cin &gt;&gt; x; if(x == '(')a[i] = 1; if(x == ')')a[i] = -1; } build(1, n, 1); printf(&quot;%d\\n&quot;, t[1].val); for(int i = 1; i &lt;= q; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); swap(a[x], a[y]); change(1, n, 1, x, a[x]); change(1, n, 1, y, a[y]); printf(&quot;%d\\n&quot;, t[1].val); } return 0;}","link":"/2022/09/14/CF1149C-Tree-Generator%E2%84%A2/"},{"title":"CF280C Game on Tree","text":"CF280C Game on Tree 题解 题意 给定一棵有根树，结点编号从 111 到 nnn。根结点为 111 号结点。 对于每一次操作，等概率的选择一个尚未被删去的结点并将它及其子树全部删去。当所有结点被删除之后，游戏结束；也就是说，删除111 号结点后游戏即结束。 要求求出删除所有结点的期望操作次数。 n≤105n \\le 10 ^ 5n≤105 解法 如果设fif_ifi​表示每个点的权值，权值的范围显然只有000和111， 答案其实就是求E(∑fi)E(\\sum f_i)E(∑fi​)，根据期望的线性性，可以得出E(∑fi)=∑E(fi)E(\\sum f_i) = \\sum E(f_i)E(∑fi​)=∑E(fi​)， 考虑每个点的期望其实就是这个点被选中的概率，如果这个点被选到，显然一定是在其祖先选到之前，每个节点有depthi−1depth_i - 1depthi​−1个祖先，答案就是∑i=1n1depthi\\sum_{i = 1} ^ n \\frac{1}{depth_i}∑i=1n​depthi​1​。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int depth[N];void dfs(int x, int fa){ depth[x] = depth[fa] + 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa)continue; dfs(v, x); }}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs(1, 0); double ans = 0; for(int i = 1; i &lt;= n; i++) ans += 1.0 / depth[i]; printf(&quot;%.6lf&quot;, ans); return 0;}","link":"/2022/11/02/CF280C%20Game%20on%20Tree/"},{"title":"Link Cut Tree","text":"初探Link Cut Tree Link Cut Tree 概念 Link Cut Tree 简称LCT，属于实链剖分，是应用比较广泛的链剖分之一， 链剖分其实就是对树的一些边进行轻重划分的操作，在实现树上的修改和查询时能以以一个较为优秀的复杂度去解决问题，主要还是有三类：重链剖分， 实链剖分， 和长链剖分。 性质 首先虚实剖和轻重剖最大的不同还是LCT可以做到动态的连边断边，用起来比较灵活，可以解决一些树剖解决不了的问题，主要用splay来维护，LCT支持的操作主要有： 查询、修改链上的信息 随意指定原树的根 动态连边，删边 合并两个树 动态维护连通性 使用LCT 解决问题时需要不断维护以下性质： 每一个splay维护的时一条从上到下按在原树中深度严格递增的路径，splay的中序遍历就可以得到对应的路径，也就是说不能把深度相同的放在一个splay中，也就是说一个splay维护的是对应到原树上的一条链。 每个节点只能包含在一个splay中。 边分为实边和虚边，实边包含在splay中， 虚边总是由一棵splay指向另一个节点（该splay中维护的链深度小的链的一端的父亲节点）。 当某点有多个儿子时只能向其中一个儿子拉一条实链，其他的儿子连成虚链，由对应儿子所属的splay的根节点的父亲指向该点，并且从该点不能访问其的虚儿子， 但从其虚儿子可以访问到该点也就是“认父不认子”。 支持的操作实现 access LCT的核心操作，是其他操作的基础。 首先根据性质3， 两个点不一定是直接联通的（不在一个splay中，也就是说路径上不全是实边，有虚边）,access操作就可以打通两个点之间的路径，将其变成实边。 假设现在我们有这样的一棵树， 所构成的LCT可能长这个样子， 假设我们要将A−NA - NA−N的路径打通，首先splay(N)， 将其变为所在splay的根节点， 然后把OOO变为虚儿子， 然后接着处理III，将III的右儿子设为NNN , 接着splay(H), HHH 指向AAA ，splay(A)， 然后就完成了。 其实就是先转到根，然后换儿子，更新信息， 当前操作点切换为轻边所指的父亲。 12345void access(int x) // root -&gt; x{ for(int y = 0; x; y = x, x = fa(y)) splay(x), rs(x) = y, push_up(x); // 旋转到根， 换儿子， 更新信息} makeroot 上面的access操作只是求出了根到某个点的路径，更多时候，我们需要获取指定两个节点的路径，但有可能这两个点之间的路径不是严格递增的，这样的话根据我们维护的性质，这两个点是不会出现在同一个splay中的， 这时我们可以将指定点称为原树的根，来实现makeroot， 首先access(x)后， xxx一定时splay中，中序遍历最后的点，也就是深度最大的点，接着splay(x)，xxx将没有右子树，然后反转整个splay， xxx就成为了深度最小的点，也就是根节点。 123456789101112void recover(int x) // 区间反转{ swap(ls(x), rs(x)); t[x].rev ^= 1; // 区间反转标记}void makeroot(int x) // 换根{ access(x); splay(x); recover(x);} findroot 寻找x,yx, yx,y 在原树中的根节点，来判断连通性。 123456789101112int findroot(int x) // 找根{ access(x); splay(x); while(ls(x)) // 找深度小的链的一端 { push_down(x); x = ls(x); } splay(x); return x;} split spilt操作是用来拉出x→yx \\rightarrow yx→y的路径，变成一个splay。 123456void split(int x, int y) // x -&gt; y{ makeroot(x); access(y); splay(y);} link link操作用来连边。 123456void link(int x, int y) // link x -&gt; y{ makeroot(x); if(findroot(y) != x) // 判断是否在同一棵树中 fa(x) = y;} cut cut操作用来断边。 123456789void cut(int x, int y) // cut x -&gt; y{ makeroot(x); if(findroot(y) == x &amp;&amp; fa(y) == x &amp;&amp; !ls(y)) // 判断操作是否合法 { fa(y) = rs(x) = 0; push_up(x); }} splay 的一些操作 大部分差不多。 首先核心的rotate操作 12345678910111213void rotate(int x){ int y = fa(x), z = fa(y); bool res = check(x); if(nroot(y)) t[z].son[check(y)] = x; // 不同之处，需要判断是不是为根， 如果连的是轻边 它的父亲儿子是不能有它的，不是根再更新儿子。 fa(x) = z; t[y].son[res] = t[x].son[res ^ 1]; fa(t[x].son[res ^ 1]) = y; t[x].son[res ^ 1] = y; fa(y) = x; push_up(y); push_up(x);} 然后是splay， 123456789101112131415void splay(int x){ int y = x, z, top = 0; int st[N]; st[++top] = y; while(nroot(y)) st[++top] = y = fa(y); // 记录到根的路径 while(top) push_down(st[top--]); // 下穿标记 while(nroot(x)) { int y = fa(x), z = fa(y); if(nroot(y)) (check(y) ^ check(y)) ? rotate(x) : rotate(y); rotate(x); } push_up(x);} 更新信息的操作，根据题意更改，这里以P3690 【模板】动态树（Link Cut Tree）为例， 123456789101112void push_up(int x){ t[x].sum = t[ls(x)].sum ^ t[rs(x)].sum ^ t[x].val;}void push_down(int x){ if(!t[x].rev) return; if(ls(x)) recover(ls(x)); if(rs(x)) recover(rs(x)); t[x].rev = 0;} check和nroot， 12bool check(int x) {return rs(fa(x)) == x;}bool nroot(int x) {return ls(fa(x)) == x || rs(fa(x)) == x;} // 不是根为true 附上一个完整代码P3690 【模板】动态树（Link Cut Tree） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 3e5 + 10;int n, m;int a[N];namespace LCT{ struct splaytree { int son[2], val, father, sum; int rev; #define ls(p) t[p].son[0] #define rs(p) t[p].son[1] #define fa(p) t[p].father }t[N &lt;&lt; 1]; bool check(int x) {return rs(fa(x)) == x;} bool nroot(int x) {return ls(fa(x)) == x || rs(fa(x)) == x;} void push_up(int x) { t[x].sum = t[ls(x)].sum ^ t[rs(x)].sum ^ t[x].val; } void recover(int x) { swap(ls(x), rs(x)); t[x].rev ^= 1; } void push_down(int x) { if(!t[x].rev) return; if(ls(x)) recover(ls(x)); if(rs(x)) recover(rs(x)); t[x].rev = 0; } void rotate(int x) { int y = fa(x), z = fa(y); bool res = check(x); if(nroot(y)) t[z].son[check(y)] = x; fa(x) = z; t[y].son[res] = t[x].son[res ^ 1]; fa(t[x].son[res ^ 1]) = y; t[x].son[res ^ 1] = y; fa(y) = x; push_up(y); push_up(x); } int st[N]; void splay(int x) { int y = x, z, top = 0; st[++top] = y; while(nroot(y)) st[++top] = y = fa(y); while(top) push_down(st[top--]); while(nroot(x)) { y = fa(x), z = fa(y); if(nroot(y)) (check(x) ^ check(y)) ? rotate(x) : rotate(y); rotate(x); } push_up(x); } void access(int x) { for(int y = 0; x; y = x, x = fa(y)) splay(x), rs(x) = y, push_up(x); } void makeroot(int x) { access(x); splay(x); recover(x); } int findroot(int x) { access(x); splay(x); while(ls(x)) { push_down(x); x = ls(x); } splay(x); return x; } void split(int x, int y) { makeroot(x); access(y); splay(y); } void link(int x, int y) { makeroot(x); if(findroot(y) != x) fa(x) = y; } void cut(int x, int y) { makeroot(x); if(findroot(y) == x &amp;&amp; fa(y) == x) { fa(y) = rs(x) = 0; push_up(x); } }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) LCT::t[i].val = a[i]; for(int i = 1; i &lt;= m; i++) { int opt, x, y; scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;x, &amp;y); if(opt == 0) { LCT::split(x, y); printf(&quot;%d\\n&quot;, LCT::t[y].sum); } if(opt == 1) { LCT::link(x, y); } if(opt == 2) { LCT::cut(x, y); } if(opt == 3) { LCT::splay(x); LCT::t[x].val = y; } } return 0;} 参考文献 [1] LCT总结——概念篇Flash_Hu","link":"/2022/09/14/Link-Cut-Tree/"},{"title":"Loj#6247. 九个太阳","text":"Loj#6247. 九个太阳 题解 前置知识 原根 二项式定理 单位根 题目 给定 n,Kn,Kn,K，满足KKK 是 222 的幂，求 ∑K∣i,0≤i≤n(ni)\\sum_{K\\mid i, 0 \\le i \\le n} \\dbinom{n}{i} K∣i,0≤i≤n∑​(in​) 对 998244353998244353998244353 取模 。 1≤n≤1015,1≤K≤2201 \\le n \\le 10^{15}, 1\\le K \\le 2^{20}1≤n≤1015,1≤K≤220 ， 且 KKK 为222 的幂 。 思路 首先将式子写为 ： ∑i=0n(ni)[K∣i]\\sum_{i=0}^n \\dbinom{n}{i} [K \\mid i] i=0∑n​(in​)[K∣i] 然后观察式子中的条件🤔 ，可以用单位根反演 ： 1n∑i=0n−1ωnx∗i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1​i=0∑n−1​ωnx∗i​=[xmodn=0] 化简式子为 ： ∑i=0n(ni)[K∣i]=∑i=0n1K∑j=0K−1ωni∗j(ni)=1K∑i=1n∑j=0K−1ωni∗j(ni)=1K∑j=0K−1∑i=0n(ωnj)i(ni)\\begin{aligned} \\sum_{i=0}^n \\dbinom{n}{i} [K \\mid i] &amp;=\\sum_{i=0}^n \\frac{1}{K} \\sum_{j=0}^{K-1} \\omega_n^{i \\ast j} \\dbinom{n}{i}\\\\ &amp;=\\frac{1}{K} \\sum_{i=1}^{n} \\sum_{j=0}^{K-1} \\omega_n^{i \\ast j} \\dbinom{n}{i}\\\\ &amp;=\\frac{1}{K} \\sum_{j=0}^{K-1} \\sum_{i=0}^n (\\omega_n^{j})^i \\dbinom{n}{i} \\end{aligned} i=0∑n​(in​)[K∣i]​=i=0∑n​K1​j=0∑K−1​ωni∗j​(in​)=K1​i=1∑n​j=0∑K−1​ωni∗j​(in​)=K1​j=0∑K−1​i=0∑n​(ωnj​)i(in​)​ 然后观察后面的式子，对其使用二项式定理！ (a+b)n=∑i=0n(ni)aibn−i(a+b)^n = \\sum_{i=0}^n \\dbinom{n}{i} a^i b^{n-i} (a+b)n=i=0∑n​(in​)aibn−i 拆分为 ： 1K∑j=0K−1∑i=0n(ωnj)i(ni)=1K∑j=0K−1(1+ωnj)n\\begin{aligned} \\frac{1}{K} \\sum_{j=0}^{K-1} \\sum_{i=0}^n (\\omega_n^{j})^i \\dbinom{n}{i} &amp;=\\frac{1}{K} \\sum_{j=0}^{K-1} (1+\\omega_n^j)^n \\end{aligned} K1​j=0∑K−1​i=0∑n​(ωnj​)i(in​)​=K1​j=0∑K−1​(1+ωnj​)n​ 计算时由于 998244353=223×17×7+1998244353 = 2^{23} \\times 17 \\times 7 +1998244353=223×17×7+1 刚好存在原根 333 998244353最优美的性质莫过于它是个完美恶臭数：998244353=( 114514 * ( 54-1+114 * (1+14*5+1+4) ) ) + ( 4+11451 * (4-1-15+14) ) + ( 11+41*54 + (141+541) ) + (4-1-15+14)；之所以称为完美，如果您仔细观察，您会发现每一个括号里114514都出现了正整数次！ 将 ωn\\omega_nωn​ 设为 3p−1K3^{\\frac{p-1}{K}}3Kp−1​ 即可 时间复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) 代码 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int mod=998244353;ll ans;ll qpow(ll a,ll b,ll mod){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%mod; a=(a*a)%mod;b&gt;&gt;=1; } return t;}ll inv(ll x){return (qpow(x,mod-2,mod)+mod)%mod;}int main(){ ll n,k; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); ll wn=qpow(3,(mod-1)/k,mod); for(ll i=0,c=1;i&lt;k;i++,c=c*wn%mod) { ans=(ans+qpow(1+c,n,mod))%mod; } printf(&quot;%lld&quot;,(ans*inv(k)%mod+mod)%mod); return 0;}","link":"/2022/07/22/Loj-6247-%E4%B9%9D%E4%B8%AA%E5%A4%AA%E9%98%B3/"},{"title":"NaCly_Fish&#39;s Math Contest","text":"NaCly_Fish’s Math Contest 题解 NaCly_Fish’s Math Contest A.炼金术（Alchemy） 题目描述 铃是一个爱玩游戏的女孩子。 她在游戏中想要炼制一种稀有合金 —— 这需要nnn 种金属来合成。 她准备好矿石后建造了 kkk个不同的熔炉，当熔炉启动时，会随机炼出这 nnn 种金属中的一些（也可能什么都没有）。 如果把每个熔炉炼出的金属收集起来，有了全部 nnn 种金属，就能造出合金了。澪对此很好奇，对铃说：「我考考你，有多少种情况可以炼出合金呢？」这个简单的问题铃很快就会做了，你能求出结果吗？ 答案可能很大，请对 998244353998244353998244353 取模（即除以 998244353998244353998244353 的余数）后输出。 范围限制 1≤n,k≤1091 \\le n , k \\le 10 ^ 91≤n,k≤109。 解法 首先将其看为一个k×nk \\times nk×n的矩阵，让其每一列上不都为空， 求方案数， 不难得出答案为： ∑i=0n(−1)i(2n−i)k(ni)\\sum_{i = 0}^n (-1)^i (2^{n - i}) ^ k \\dbinom{n}{i} i=0∑n​(−1)i(2n−i)k(in​) 使用二项式定理将其进一步化简为： ∑i=0n(−1)i(2k)n−i(ni)=(2k−1)n\\sum_{i = 0} ^ n (-1)^i(2^k)^{n - i} \\dbinom{n}{i} = (2^k - 1) ^ n i=0∑n​(−1)i(2k)n−i(in​)=(2k−1)n 快速幂即可， 时间复杂度O(log⁡n)O(\\log n)O(logn) Code 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;int n, k;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t % mod;}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); printf(&quot;%lld&quot;, qpow((qpow(2, k) - 1), n)); return 0;} B.生命游戏（GoL） 题目描述 有nnn个格子排成一个环，每个格子中都有一个状态为 生/死 的细胞。 如果一个格子相邻的活细胞数为111，那么这个格子中的细胞，在下一代会存活（如果是死亡的会复活）；否则会死亡。 给定初始状态，请你帮她们快速求出kkk 代之后的状态。 范围限制 3≤n≤5×105,1≤k&lt;2623\\le n \\le 5 \\times 10 ^ 5, 1 \\le k &lt; 2 ^ {62}3≤n≤5×105,1≤k&lt;262。 解法 题目背景为Conway’s Game of Life，这个是问题的简易版，其实可以在这里玩一下。 首先题目可以转化为求fi,j=fi−1,j−1⊕fi−1,j+1f_{i,j} = f_{i - 1,j - 1} \\oplus f_{i - 1, j + 1}fi,j​=fi−1,j−1​⊕fi−1,j+1​，然后根据异或的结合律和数学归纳法可以得到， fi,j=fi−2k,j−2k⊕fi−2k,j+2kf_{i,j} = f_{i - 2 ^ k,j - 2 ^k} \\oplus f_{i - 2 ^ k, j + 2^k} fi,j​=fi−2k,j−2k​⊕fi−2k,j+2k​ 然后就可以解决了，时间复杂度O(nlog⁡k)O(n\\log k)O(nlogk)。 Code 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 2e5 + 10;int n, T;int f[N], g[N];signed main(){ cin &gt;&gt; n &gt;&gt; T; for(int i = 0; i &lt; n; i++) { char x; cin &gt;&gt; x; f[i] = (x == '1'); } for(int bit = 0; bit &lt;= 62 &amp;&amp; T; bit++) { if((T &gt;&gt; bit) &amp; 1) { for(int i = 0; i &lt; n; i++) g[i] = f[((i - (1ll &lt;&lt; bit)) % n + n) % n] ^ f[((i + (1ll &lt;&lt; bit)) % n + n) % n]; memcpy(f, g, sizeof(g)); T -= (1ll &lt;&lt; bit); } } for(int i = 0; i &lt; n; i++) putchar(f[i] + '0'); return 0;} C.黑暗（Darkness） 题目描述 铃在一个黑暗的三维空间内寻找澪。这个空间可以表示为 {(x,y,z)∣x∈[0,A],y∈[0,B],z∈[0,C]}\\{ (x, y, z) | x \\in [0,A], y \\in [0, B], z \\in [0, C]\\}{(x,y,z)∣x∈[0,A],y∈[0,B],z∈[0,C]}。铃初始站在坐标为 (A,B,C)(A,B,C)(A,B,C)处，澪站在 (0,0,0)(0,0,0)(0,0,0) 处。假设铃在 (x,y,z)(x,y,z)(x,y,z) 处，她每次移动会均匀随机地尝试移动到 (x−1,y,z)(x-1,y,z)(x−1,y,z) 或 (x,y−1,z)(x,y-1,z)(x,y−1,z)或 (x,y,z−1)(x,y,z-1)(x,y,z−1)。 这个空间的外围是墙壁，不可穿过。由于空间内很暗，铃并不知道自己是否走到了墙边。也就是说，她在随机选择三种方向尝试移动时，有可能撞在墙上。 铃想要知道，自己在第一次撞墙时，「到澪的曼哈顿距离（在本题中的情况就是 x,y,zx,y,zx,y,z坐标之和）」的kkk次方的期望值。 你只需要求出答案对 998244353998244353998244353取模的结果。 范围限制 1≤A,B,C≤5×106,1≤k≤1071 \\le A, B, C \\le 5 \\times 10 ^ 6, 1 \\le k \\le 10 ^ 71≤A,B,C≤5×106,1≤k≤107。 解法","link":"/2022/10/03/NaCly-Fish-s-Math-Contest/"},{"title":"P2508 [HAOI2008]圆上的整点","text":"P2508 [HAOI2008]圆上的整点 题解 题目大意 给定rrr, 求x2+y2=r2x^2 + y^2 = r^2x2+y2=r2 的整数解的个数, 其中r≤2000000000r \\le 2000000000r≤2000000000。 解法 题目其实就是在求以原点为圆心，以rrr为半径的圆上有多少个整点。 首先我们可以先将二维平面看做全体复数，满足题目中的式子的解其实就是满足，(a+bi)(a−bi)=r2(a + bi)(a - bi) = r^2(a+bi)(a−bi)=r2的解的个数。 然后说明一个数学定义， 如果虚数a+bia + bia+bi 中a,ba, ba,b均为整数， 则称这个虚数为高斯整数， 现在问题又进一步转化为， 有多少个高斯整数zzz满足其本身与其共轭复数zˉ\\bar{z}zˉ的乘积为r2r ^ 2r2。 现在需要讨论的是一个整数如何分解成高斯整数。 首先对于每一个整数，根据算术基本定理都能将其分解成若干个素数的乘积，同样的， 一个整数NNN也可以表示为若干个复数因子的乘积，这些因子在高斯整数上能再分，也就是高斯素数。 首先我们可以先将一个整数NNN在整数上分解为若干个素数的乘积，然后再将其中的非高斯素数进一步分解。 接下来需要解决的是如何判断一个素数是不是高斯素数。 引入费马平方和定理： 奇素数ppp可以表示为两个正整数的平方和，当且仅当p=4k+1p = 4 k + 1p=4k+1， 并且方法唯一。 通过该定理我们可以得知， 4k+34k + 34k+3型的素数为高斯素数， 4k+14k + 14k+1型的素数可以被分解为一对共轭复数的乘积， 222可以被分解为(1+i)(1−i)(1 + i) (1 - i)(1+i)(1−i)。 假设p=4k+1p = 4k + 1p=4k+1型素数， q=4k+3q = 4k + 3q=4k+3型素数，NNN就可以被表示为： N=2n∏qi=4k+3qimi∏pj=4k+1pjkjN = 2^n \\prod _ {q_i = 4k + 3}q_i ^ {m_i} \\prod _{p _j = 4 k + 1} p_j ^{k_j} N=2nqi​=4k+3∏​qimi​​pj​=4k+1∏​pjkj​​ 然后就可以接着分解pjp _jpj​为一对共轭复数，接下来就是讨论每一种素数的贡献来统计有多少种方法。 4k+14k + 14k+1型素数的贡献 对于每一个pjp_jpj​，将其分解为zjz_jzj​ 和zjˉ\\bar{z_j}zj​ˉ​，然后一个分在前一个因子， 一个分在后一个因子，保证共轭或者相反，有两种分配方式， 那么对于pjkJp_j ^ {k _J}pjkJ​​， 就会有kj+1k_j + 1kj​+1 种分配方式。 4k+34k + 34k+3型素数的贡献 由于高斯素数不能分为对应的乘积形式， 可以将其分解为(a+0i)(a−0i)(a+0i)(a-0i)(a+0i)(a−0i)，那么对于qimiq_i^{m_i}qimi​​，为了保证共轭，2∣mi2 \\mid m_i2∣mi​时贡献为111, 当2∤mi2 \\not\\mid m_i2​∣mi​时对应得贡献就为000。 素数222的贡献 由于2=(1+i)(1−i)2 = (1 + i) (1 - i)2=(1+i)(1−i)，然而1+i1 + i1+i 和1−i1-i1−i的夹角为90∘90^\\circ90∘，最后统计答案×4\\times 4×4时计算重复，计算时其不应该产生任何贡献。 假设分解rrr得： r=2n∏qi=4k+3qimi∏pj=4k+1pjkjr = 2 ^ n \\prod _{q_i = 4k + 3}q_i ^ {m _ i} \\prod _{p _ j = 4k + 1} p_j ^ {k _j} r=2nqi​=4k+3∏​qimi​​pj​=4k+1∏​pjkj​​ 对应得NNN 就可分解为： N=22n∏qi=4k+3qi2mi∏pj=4k+1pj2kjN = 2 ^ {2n} \\prod _{q_i = 4k + 3}q_i ^ {2m _ i} \\prod _{p _ j = 4k + 1} p_j ^ {2k _j} N=22nqi​=4k+3∏​qi2mi​​pj​=4k+1∏​pj2kj​​ 这样的话每一个高斯素数的因子都为偶数，都有贡献，那么最后的答案为： 4∏pj=4k+1(2kj+1)4 \\prod_{p _j =4k + 1 } (2 k_j + 1) 4pj​=4k+1∏​(2kj​+1) 复杂度为O(r)O(\\sqrt r)O(r​)。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint r, ans = 1;signed main(){ cin &gt;&gt; r; for(int i = 2; i * i &lt;= r; i++) { if(r % i != 0)continue; int cnt = 0; while(r % i == 0)r /= i, cnt++; if(i % 4 == 1)ans *= (cnt * 2 + 1); } if(r != 1 &amp;&amp; r % 4 == 1)ans *= (1 * 2 + 1); cout &lt;&lt; ans * 4; return 0;} tips: 勾股数组定理， 每个本原勾股数组(a,b,c)(a, b, c)(a,b,c)， 其中2∤a,2∣b2 \\not \\mid a, 2 \\mid b2​∣a,2∣b，都可以从以下公式得出。 a=st,b=s2−t22,c=s2+t22a = st, b = \\frac{s^2 - t^2}{2}, c = \\frac{s^2 + t^2}{2}a=st,b=2s2−t2​,c=2s2+t2​， 其中s&gt;t≥0s &gt; t \\ge 0s&gt;t≥0是任意没有公因数的奇数。","link":"/2022/09/08/P2508-HAOI2008-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/"},{"title":"P3768 简单的数学题","text":"P3768 简单的数学题 题解 题意 给定n,pn,pn,p 求： (∑i=1n∑j=1nijgcd⁡(i,j)) mod p\\bigg( \\sum_{i = 1}^n \\sum_{j =1}^n i j \\gcd(i,j) \\bigg) \\bmod p (i=1∑n​j=1∑n​ijgcd(i,j))modp 其中，n≤1010,5.8×108≤p≤1.1×109n \\le 10 ^ {10}, 5.8 \\times 10 ^ 8 \\le p \\le 1.1 \\times 10 ^ 9n≤1010,5.8×108≤p≤1.1×109 解法 首先观察到nnn 的数据范围，肯定是要以一个亚线性时间复杂度跑过去的，须有用到杜教筛或Min_25筛，这里用的杜教筛。 首先化简式子： ∑i=1n∑j=1nijgcd⁡(i,j)=∑d=1nd∑i=1n∑j=1nij[gcd⁡(i,j)==d]=∑d=1nd3∑i=1⌊nd⌋∑j=1⌊nd⌋ij[gcd⁡(i,j)==1]\\begin{aligned} \\sum_{i = 1}^n \\sum_{j =1}^n i j \\gcd(i,j) &amp; = \\sum_{d = 1}^n d \\sum_{i = 1}^n \\sum_{j = 1}^n ij \\left[ \\gcd(i,j) == d \\right] \\\\ &amp; = \\sum_{d = 1}^n d^3 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} i j \\left[ \\gcd(i,j) == 1 \\right] \\\\ \\end{aligned} i=1∑n​j=1∑n​ijgcd(i,j)​=d=1∑n​di=1∑n​j=1∑n​ij[gcd(i,j)==d]=d=1∑n​d3i=1∑⌊dn​⌋​j=1∑⌊dn​⌋​ij[gcd(i,j)==1]​ 后面是个经典的式子，设为S(n)S(n)S(n)，接着化简： S(n)=∑i=1n∑j=1nij[gcd⁡(i,j)==1]=∑i=1n∑j=1nij∑d∣gcd⁡(i,j)μ(d)=∑d=1nμ(d)d2∑i=1⌊nd⌋∑j=1⌊nd⌋1\\begin{aligned} S(n) &amp; = \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} i j \\left[ \\gcd(i,j) == 1 \\right] \\\\ &amp; = \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} i j \\sum_{d \\mid \\gcd(i,j)} \\mu(d) \\\\ &amp; = \\sum_{d = 1}^{n} \\mu(d) d^2 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} 1 \\end{aligned} S(n)​=i=1∑n​j=1∑n​ij[gcd(i,j)==1]=i=1∑n​j=1∑n​ijd∣gcd(i,j)∑​μ(d)=d=1∑n​μ(d)d2i=1∑⌊dn​⌋​j=1∑⌊dn​⌋​1​ 后面的式子可以O(1)O(1)O(1)处理，再套上一个数论分块，然后就可以得到60分了，然而这并不能解决这道题，其实可以在其中的一步换一种方式去卷mu，但是有更简单的做法，重新考虑式子，对其使用欧拉反演： 有： φ∗1=Id\\varphi \\ast 1 = Id φ∗1=Id 即： ∑d∣nφ(d)=n\\sum_{d\\mid n}\\varphi(d) = n d∣n∑​φ(d)=n 原来的式子可以化为： ∑i=1n∑j=1nijgcd⁡(i,j)=∑i=1n∑j=1nij∑d∣i,d∣jφ(d)=∑d=1nφ(d)d2∑i=1⌊nd⌋∑j=1⌊nd⌋ij\\begin{aligned} \\sum_{i = 1}^n \\sum_{j = 1}^n i j \\gcd(i,j) &amp; = \\sum_{i = 1}^n \\sum_{j = 1}^n i j \\sum_{d\\mid i, d\\mid j}\\varphi(d) \\\\ &amp; = \\sum_{d = 1}^n \\varphi(d) d^2 \\sum_{i = 1}^{\\left\\lfloor \\frac{n}{d}\\right\\rfloor} \\sum_{j = 1}^{\\left\\lfloor \\frac{n}{d} \\right\\rfloor} i j \\end{aligned} i=1∑n​j=1∑n​ijgcd(i,j)​=i=1∑n​j=1∑n​ijd∣i,d∣j∑​φ(d)=d=1∑n​φ(d)d2i=1∑⌊dn​⌋​j=1∑⌊dn​⌋​ij​ 显然后面的式子可以O(1)O(1)O(1)计算， n2(n+1)24\\frac{n^2 (n+1)^2}{4} 4n2(n+1)2​ 现在考虑如何计算前面的 ∑d=1nφ(d)d2\\sum_{d = 1}^n \\varphi(d) d^2 d=1∑n​φ(d)d2 既然φ∗1=Id\\varphi \\ast 1 = Idφ∗1=Id,将φ(d)d2\\varphi(d)d^2φ(d)d2设为fff,设g=Id2g = Id^2g=Id2显然有 (f∗g)n=∑d∣nφ(d)d2(nd)2=n3\\bigg(f \\ast g\\bigg)n = \\sum_{d \\mid n} \\varphi(d)d^2 (\\frac{n}{d})^2 = n ^3 (f∗g)n=d∣n∑​φ(d)d2(dn​)2=n3 看来问题已经解决了，S(n)S(n)S(n)为我们想要求的和， ∑i=1n(f∗g)i=∑i=1ng(i)S(⌊ni⌋)=∑i=1ni3\\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i = \\sum_{i = 1} ^ n g(i) S(\\left\\lfloor \\frac{n}{i} \\right\\rfloor) = \\sum_{i = 1}^n i ^ 3 i=1∑n​(f∗g)i=i=1∑n​g(i)S(⌊in​⌋)=i=1∑n​i3 然后使用技巧， g(1)S(n)=∑i=1n(f∗g)i−∑i=2ng(i)S(⌊ni⌋)g(1)S(n) = \\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i - \\sum_{i = 2}^ng(i)S(\\left\\lfloor \\frac{n}{i}\\right\\rfloor) g(1)S(n)=i=1∑n​(f∗g)i−i=2∑n​g(i)S(⌊in​⌋) 又因为g(1)=1g(1) = 1g(1)=1,得到递归式， S(n)=∑i=1n(f∗g)i−∑i=2ng(i)S(⌊ni⌋)S(n) = \\sum_{i = 1}^n\\bigg( f\\ast g \\bigg)i - \\sum_{i = 2}^ng(i)S(\\left\\lfloor \\frac{n}{i}\\right\\rfloor) S(n)=i=1∑n​(f∗g)i−i=2∑n​g(i)S(⌊in​⌋) 需要用到： ∑i=1ni2=n(n+1)(2n+1)6∑i=1ni3=n2(n+1)24\\sum_{i = 1}^n i ^2 = \\frac{n(n+1)(2n+1)}{6} \\\\ \\sum_{i = 1}^n i ^3 = \\frac{n^2 (n+1)^2}{4} i=1∑n​i2=6n(n+1)(2n+1)​i=1∑n​i3=4n2(n+1)2​ 用杜教筛，时间复杂度O(n23)O(n^{\\frac{2}{3}})O(n32​) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;using namespace std;#define int long longconst int N = 5e6 + 10;int mod;int inv4, inv6;inline int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a%mod; a = a * a%mod; b &gt;&gt;= 1; } return t%mod;}int cnt, prime[N], phi[N];int S_phi[N];bool vis[N];inline void init(int n){ phi[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!vis[i]) { prime[++cnt] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= n; j++) { vis[i * prime[j]] = true; if(i % prime[j] == 0) { phi[i * prime[j]] = prime[j] * phi[i]; break; } phi[i * prime[j]] = phi[i] * phi[prime[j]]; } } for(int i = 1; i &lt;= n; i++) S_phi[i] = (S_phi[i-1] + phi[i]%mod * i%mod * i%mod)%mod;}inline int f(int n){ return n %mod* n%mod * (n + 1ll)%mod * (n + 1)%mod *inv4 %mod;}inline int g(int n){ return n%mod * (n + 1)%mod * (n * 2ll%mod + 1ll)%mod *inv6 %mod;}unordered_map&lt;int, int&gt; Phi;int S(int n){ if(n &lt;= 5e6)return S_phi[n]%mod; if(Phi.count(n))return Phi[n]; int sum = f(n)%mod; for(int l = 2, r; l &lt;= n; l = r + 1) { r = n/(n/l); sum = (sum - S(n/l)%mod * (g(r) - g(l-1)) %mod + mod)%mod; } return Phi[n] = sum;}signed main(){ int n; scanf(&quot;%lld%lld&quot;, &amp;mod, &amp;n); inv4 = qpow(4, mod-2); inv6 = qpow(6, mod-2); init(5e6); int ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1) { r = n/(n/l); ans = (ans + f(n/l)%mod * (S(r) - S(l-1) + mod)%mod)%mod; } printf(&quot;%lld&quot;, ans); return 0;} tips: 欧拉反演的证明 ∑d∣nφ(d)=n\\sum_{d \\mid n} \\varphi(d) = n d∣n∑​φ(d)=n 设f(n)=∑d∣nφ(d)f(n) = \\sum_{d \\mid n} \\varphi(d)f(n)=∑d∣n​φ(d)， m⊥nm \\perp nm⊥n，根据欧拉函数的积性函数的性质有： f(n)×f(m)=∑i∣nφ(i)∑j∣mφ(j)=∑i∣n∑j∣mφ(i)φ(j)=∑i∣n∑j∣mφ(ij)=∑d∣nmφ(d)=f(nm)\\begin{aligned} f(n) \\times f(m) &amp; = \\sum_{i \\mid n} \\varphi(i) \\sum_{j \\mid m} \\varphi(j) \\\\ &amp; = \\sum_{i \\mid n} \\sum_{j \\mid m} \\varphi(i) \\varphi(j) \\\\ &amp; = \\sum_{i \\mid n} \\sum_{j \\mid m} \\varphi(ij) \\\\ &amp; = \\sum_{d \\mid nm} \\varphi(d) \\\\ &amp; = f(nm) \\end{aligned} f(n)×f(m)​=i∣n∑​φ(i)j∣m∑​φ(j)=i∣n∑​j∣m∑​φ(i)φ(j)=i∣n∑​j∣m∑​φ(ij)=d∣nm∑​φ(d)=f(nm)​ 将nnn质因数分解p1c1×p2c2×p3c3×⋯×pkckp_1 ^ {c_{1}} \\times p_2 ^ {c_{2}} \\times p_3 ^ {c_{3}} \\times \\cdots \\times p_k ^ {c_{k}}p1c1​​×p2c2​​×p3c3​​×⋯×pkck​​。 所以有， f(n)=f(p1c1)×f(p2c2)×⋯×f(pkck)f(n) = f(p_1 ^ {c_{1}}) \\times f(p_2 ^ {c_{2}}) \\times \\cdots \\times f(p_k ^ {c_{k}}) f(n)=f(p1c1​​)×f(p2c2​​)×⋯×f(pkck​​) 其中的每一项有： f(pc)=∑i=0cφ(pi)=pcf(p ^ c) = \\sum_{i = 0}^ c \\varphi(p^i) = p^c f(pc)=i=0∑c​φ(pi)=pc 所以得证： f(n)=f(p1c1)×f(p2c2)×⋯×f(pkck)=Πi=1kpici=n=∑d∣nφ(d)f(n) = f(p_1 ^ {c_{1}}) \\times f(p_2 ^ {c_{2}}) \\times \\cdots \\times f(p_k ^ {c_{k}}) = \\Pi_{i =1}^k p_i^{c_i} = n = \\sum_{d \\mid n} \\varphi(d) f(n)=f(p1c1​​)×f(p2c2​​)×⋯×f(pkck​​)=Πi=1k​pici​​=n=d∣n∑​φ(d)","link":"/2022/08/28/P3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"title":"P3338 [ZJOI2014]力","text":"P3338 [ZJOI2014]力 题解 题意 给出nnn个数q1,q2,…,qnq_1,q_2, \\dots, q_nq1​,q2​,…,qn​定义 Fj=∑i=1j−1qi×qj(i−j)2−∑i=j+1nqi×qj(i−j)2Ei=FiqiF_j= \\sum_{i = 1} ^ {j - 1} \\frac{q_i \\times q_j}{(i - j)^2} - \\sum_{i = j + 1} ^ n \\frac{q_i \\times q_j}{(i - j) ^2} \\\\ E_i = \\frac{F_i} {q_i} Fj​=i=1∑j−1​(i−j)2qi​×qj​​−i=j+1∑n​(i−j)2qi​×qj​​Ei​=qi​Fi​​ 对于1≤i≤n1 \\le i \\le n1≤i≤n, 求EiE_iEi​的值。 1≤n≤1051 \\le n \\le 10 ^ 51≤n≤105 解法 首先这个题的数据范围有很大的问题， 原题目中给出的数据范围为0&lt;qi&lt;1090 &lt; q_i &lt;10^ 90&lt;qi​&lt;109， 但是数据中存在qi=0q_i = 0qi​=0的情况， 所以需要在计算时先将qiq_iqi​消去，（很让人不爽）。 现在要求计算的就是 Fi=∑j=1i−1qj(i−j)2−∑i=j+1nqj(i−j)2F_i = \\sum_{j = 1} ^ {i - 1} \\frac{q_j}{(i - j)^2} - \\sum_{i = j + 1} ^ n \\frac{q_j}{(i - j)^2} Fi​=j=1∑i−1​(i−j)2qj​​−i=j+1∑n​(i−j)2qj​​ 首先考虑拆开计算，设为Fi=Ai−BiF_i = A_i - B_iFi​=Ai​−Bi​， Ai=∑j=1j−1qj(i−j)2A_i = \\sum_{j = 1} ^ {j - 1} \\frac{q_j}{(i - j)^2}Ai​=∑j=1j−1​(i−j)2qj​​，观察可知，是一个卷积的形式，可以变为 Ai=∑j+k=iqj×1k2A_i = \\sum_{j + k = i}q_j \\times \\frac{1}{k ^2} Ai​=j+k=i∑​qj​×k21​ 然后用FFT就可以计算出AAA了，然后考虑BBB的形式和AAA的一样， 可以直接将qiq_iqi​,reverse一下，然后计算出BBB即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;const int N =4e5 + 10;const double pi = acos(-1.0);struct Complex{ double x, y; Complex(double a = 0, double b = 0) : x(a), y(b) {} friend Complex operator + (Complex a, Complex b) {return Complex(a.x + b.x, a.y + b.y);} friend Complex operator - (Complex a, Complex b) {return Complex(a.x - b.x, a.y - b.y);} friend Complex operator * (Complex a, Complex b) {return Complex(a.x * b.x - a.y * b.y, a.y * b.x + b.y * a.x);}};int n;double q[N], a[N], b[N];Complex F[N], G[N];int rev[N], len = 1;void FFT(Complex *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; rev[i])swap(a[i], a[rev[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { Complex x(cos(pi / k), type * sin(pi / k)); for(int i = 0; i &lt; len; i += k &lt;&lt; 1) { Complex w(1, 0); for(int j = 0; j &lt; k; j++) { Complex y = a[i + j]; Complex z = w * a[i + j + k]; a[i + j] = y + z; a[i + j + k] = y - z; w = w * x; } } } if(type == -1) for(int i = 0; i &lt; len; i++) a[i].x /= len;}void init(){ memset(F, 0, sizeof(F)); memset(G, 0, sizeof(G));}void Get(){ for(int i = 1; i &lt;= n; i++) F[i].x = q[i]; for(int i = 1; i &lt;= n; i++) G[i].x = 1.0 / i / i; FFT(F, len, 1), FFT(G, len, 1); for(int i = 0; i &lt;= len; i++) F[i] = F[i] * G[i]; FFT(F, len, -1);}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;q[i]); int cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt;= len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); init(); Get(); for(int i = 1; i &lt;= n; i++) a[i] = F[i].x; reverse(q + 1, q + n + 1); init(); Get(); for(int i = 1; i &lt;= n; i++) b[i] = F[i].x; reverse(q + 1, q + n + 1); for(int i = 1; i &lt;= n; i++) printf(&quot;%.8lf\\n&quot;, a[i] - b[n - i + 1]); return 0;}","link":"/2022/11/06/P3338%20%5BZJOI2014%5D%E5%8A%9B/"},{"title":"Kruskal重构树","text":"浅谈重构树 Kruskal 重构树 简介 Kruskal重构树其实就是在Kruscal算法进行的过程中，每一次加边都会合并两个集合，我们可以新建一个点，将这个点的点权设为新加的边的权值，同时将两个集合的根节点分别设为新建的点的左儿子和右儿子。然后将两个集合和新建点合并成一个集合。将新建点设为根。 这样建成的一棵二叉树就是Kruskal重构树。 如： 此图的Kruskal重构树如下： 性质 该树满足二叉堆的性质； 这颗二叉树的节点个数为2n−12n-12n−1 ，深度最大为nnn; 重构树中代表原树中的点的节点全是叶子节点，其余节点都代表了一条边的边权； 原图中两个点之间的所有简单路径上最大边权的最小值 = Kruskal 重构树上两点之间的 LCA 的权值。 因为在加边的时候所有的边都是已经排序过的所以符合二叉堆的性质。 又因为二叉堆的性质所以Kruskal 重构树上两点之间的 LCA 的权值即为原图中两个点之间的所有简单路径上最大边权的最小值。 若求两个点之间的所有简单路径上最小边权的最大值，要建最大生成树。 构造 首先对边排序 然后使用并查集辅助加边： 每新建一条边时，新建一个点，设新建点的权值为新加边的边权，合并集合。 代码： 1234567891011121314151617void kruskal(){ sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n*2;i++)f[i]=i;// 2n-1个节点 for(int i=1;i&lt;=m;i++) { if(cnt==2*n-1)break; int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt; tree[cnt].push_back(y); tree[cnt].push_back(x); w[cnt]=e[i].c; } return;} 时间复杂度O(nlog2n)O(nlog_2n)O(nlog2​n)。 应用 Kruskal重构树能够更快有效解决一些静态的树剖问题，而且复杂度还很优秀。 luogu U92652 【模板】Kruskal重构树 一道板子题（注意建成的应是一个森林）。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;const int Max=300010;int n,m,q,cnt;struct node{ int u,v,c;}e[Max];int f[Max*2],w[Max*2],lg[Max*2];int depth[Max*2],fa[Max*2][30];vector&lt;int&gt; mp[Max*2];int cmp(node x,node y){ return x.c&lt;y.c;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruskal(){ for(int i=1;i&lt;=n*2;i++)f[i]=i; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) { int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=cnt;f[y]=cnt; w[cnt]=e[i].c; mp[cnt].push_back(x); mp[cnt].push_back(y); } return;}void dfs(int now,int father){ depth[now]=depth[father]+1; fa[now][0]=father; for(int i=1;i&lt;=lg[depth[now]];i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;mp[now].size();i++) { int x=mp[now][i]; if(depth[x])continue; dfs(x,now); } return;}int LCA(int x,int y){ if(Find(x)!=Find(y))return -1; if(depth[x]&lt;depth[y])swap(x,y); while(depth[x]&gt;depth[y]) x=fa[x][lg[depth[x]-depth[y]]]; if(x==y)return w[x]; for(int i=lg[depth[x]];i&gt;=0;i--) { if(fa[x][i]==fa[y][i])continue; x=fa[x][i]; y=fa[y][i]; } return w[fa[x][0]];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); cnt=n; for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].c); kruskal(); for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); for(int i=1;i&lt;=cnt;i++) { if(f[i]!=i)continue; if(depth[f[i]])continue; dfs(f[i],0); } for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,LCA(x,y)); } return 0;} luogu P1967 货车运输 其实该问题可以转换为求xxx号城市到yyy号城市所有简单路径上小边权的最大值（注意该图建成的为一个森林）。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;const int maxm=5e4+10;int n,m,q,cnt;struct node{ int u,v,c;}e[maxm];int f[maxn*2],depth[maxn*2],father[maxn*2][30];int lg[maxn*2],w[maxn*2];vector&lt;int&gt; mp[maxn*2];int cmp(node x,node y){ return x.c&gt;y.c;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruscal(){ for(int i=1;i&lt;=n*2;i++)f[i]=i; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) { int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt;w[cnt]=e[i].c; mp[cnt].push_back(x); mp[cnt].push_back(y); } return;}void dfs(int now,int fa){ depth[now]=depth[fa]+1; father[now][0]=fa; for(int i=1;i&lt;=lg[depth[now]];i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=0;i&lt;mp[now].size();i++) { int x=mp[now][i]; if(depth[x])continue; dfs(x,now); } return;}int LCA(int x,int y){ if(Find(x)!=Find(y))return -1; if(depth[x]&lt;depth[y])swap(x,y); while(depth[x]&gt;depth[y]) x=father[x][lg[depth[x]-depth[y]]]; if(x==y)return w[x]; for(int i=lg[depth[x]];i&gt;=0;i--) { if(father[x][i]==father[y][i])continue; x=father[x][i];y=father[y][i]; } return w[father[x][0]];}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].c); cnt=n; kruscal(); for(int i=1;i&lt;=n;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); for(int i=1;i&lt;=cnt;i++) { if(f[i]!=i)continue; if(depth[f[i]])continue; dfs(f[i],0); } scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,LCA(x,y)); } return 0;} luogu P4768 [NOI2018] 归程 这道题主要在于求最小的步行路程，不用考虑开车所经过的路程。 所以我们只需要两点之间路径上的边权最小值最大即可，设这个值为hhh,若h&gt;Sh&gt;Sh&gt;S,则步行路程为零，若h≤Sh\\le Sh≤S，我们便需要去判断在哪里下车。 在Kruskal重构树中，任意节点的子树节点都是可以相互抵达的，所以我们可以用树上倍增去求出，这棵树上大于水位线的最小值，然后输出这个节点子树中，到达终点的最短路的最小值。 最短路+树上倍增+Kruskal重构树。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e5+10;const int maxm=4e5+10;const ll INF=5147483647;int T,n,m,q,k,s,cnt;ll lastans;int f[maxn*2],lg[maxn];int depth[maxn*2],fa[maxn*2][31];struct node{ int u,v,l,a;}e[maxm];struct road{ int to,cost;};struct power{ ll w,l;}p[maxn*2];vector&lt;road&gt; mp[maxn];vector&lt;int&gt; tree[maxn*2];typedef pair&lt;ll,int&gt; Pair;void _clean(){ memset(f,0,sizeof(f)); memset(depth,0,sizeof(depth)); for(int i=0;i&lt;=cnt;i++) for(int j=0;j&lt;=30;j++) fa[i][j]=0; for(int i=1;i&lt;=n;i++)mp[i].clear(); for(int i=1;i&lt;=cnt;i++)tree[i].clear(); cnt=0;lastans=0;}void makelog(){ for(int i=1;i&lt;=maxn;i++) lg[i]=lg[i-1]+(i==1&lt;&lt;(lg[i-1]+1)); return;}bool cmp(node x,node y){ return x.a&gt;y.a;}int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void kruscal(){ sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n*2;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { if(cnt==2*n-1)break; int x=Find(e[i].u),y=Find(e[i].v); if(x==y)continue; cnt++; f[x]=f[y]=cnt; tree[cnt].push_back(y); tree[cnt].push_back(x); p[cnt].w=e[i].a; } for(int i=1;i&lt;=cnt;i++)p[i].l=INF; return;}void dij(){ priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt; q; bool vis[maxn];ll dis[maxn]; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=n;i++)dis[i]=INF; dis[1]=0; q.push(make_pair(0,1)); while(!q.empty()) { int x=q.top().second; int c=q.top().first; q.pop(); if(vis[x])continue; vis[x]=true; for(int i=0;i&lt;mp[x].size();i++) { if(dis[mp[x][i].to]&gt;dis[x]+mp[x][i].cost) { dis[mp[x][i].to]=dis[x]+mp[x][i].cost; q.push(make_pair(dis[mp[x][i].to],mp[x][i].to)); } } } for(int i=1;i&lt;=n;i++)p[i].l=dis[i]; return;}void dfs(int now,int father){ depth[now]=depth[father]+1; fa[now][0]=father; for(int i=1;i&lt;=lg[depth[now]];i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;tree[now].size();i++) { dfs(tree[now][i],now); p[now].l=min(p[now].l,p[tree[now][i]].l);// 更新最短路最小值 } return;}ll ask(int x,int y){ for(int i=lg[depth[x]];i&gt;=0;i--) if(p[fa[x][i]].w&gt;y)x=fa[x][i]; return p[x].l;}int main(){ makelog(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); cnt=n; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].l,&amp;e[i].a); mp[e[i].u].push_back((road){e[i].v,e[i].l}); mp[e[i].v].push_back((road){e[i].u,e[i].l}); } kruscal(); dij(); dfs(cnt,0); scanf(&quot;%d%d%d&quot;,&amp;q,&amp;k,&amp;s); for(int i=1;i&lt;=q;i++) { int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int vx=(x+k*lastans-1)%n+1; int py=(y+k*lastans)%(s+1); lastans=ask(vx,py); printf(&quot;%lld\\n&quot;,lastans); } _clean(); } return 0;} 完结撒花~~","link":"/2022/06/13/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"title":"P3830 [SHOI2012]随机树","text":"P3830 [SHOI2012]随机树 题解 题意 解法 首先解决第一个问题，叶节点平均深度的期望值，可以设fif_ifi​表示有iii个叶子节点的随机树的平均深度的期望值，可以得到转移方程为 fi=fi−1×(i−1)−fi−1+(fi−1+1)×2if_i = \\frac{f_{i - 1} \\times (i - 1) - f_{i - 1} + (f_{i - 1} + 1) \\times 2}{i} fi​=ifi−1​×(i−1)−fi−1​+(fi−1​+1)×2​ 其实就是计算当前有iii个叶子节点时在i−1i - 1i−1个叶子节点的情况下，展开一个节点，计算其深度的影响，化简后也就是 fi=fi−1+2if_i= f_{i- 1} + \\frac{2} {i} fi​=fi−1​+i2​ 然后第二个问题就麻烦了，树深度的期望值，首先根据期望的线性性有 E(x)=∑i=1+∞P(i≤x)E(x) = \\sum_{i = 1} ^ {+ \\infty} P(i \\le x) E(x)=i=1∑+∞​P(i≤x) 然后可以设fi,jf_{i, j}fi,j​为有iii个叶子节点且深度大于等于jjj的树的出现概率，得出转移方程为 fi,j=∑k=1i−1fk,j−1+fi−k,j−1−fk,j−1×fi−k,j−1i−1f_{i, j} = \\sum_{k = 1} ^ {i - 1} \\frac{f_{k, j - 1} + f_{i - k, j - 1} - f_{k, j - 1} \\times f_{i - k, j - 1}}{i- 1} fi,j​=k=1∑i−1​i−1fk,j−1​+fi−k,j−1​−fk,j−1​×fi−k,j−1​​ 首先kkk时枚举的左子树中叶子节点的数量，然后求左子树中深度大于等于j−1j - 1j−1 的概率，由于左右子树深度都大于j−1j - 1j−1的情况在fk,j−1f_{k , j - 1}fk,j−1​和fi−k,j−1f_ {i - k, j - 1}fi−k,j−1​中都统计过，所以要去减去重复的部分，对于除以i−1i - 1i−1的部分可以去看这个证明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int n, q;namespace SubTask1{ double f[N]; void getans() { for(int i = 2; i &lt;= n; i++) f[i] = f[i - 1] + 2.0 / i; printf(&quot;%.6lf&quot;, f[n]); }}namespace SubTask2{ double f[N][N]; void getans() { for(int i = 1; i &lt;= n; i++) f[i][0] = 1; for(int i = 2; i &lt;= n; i++) { for(int j = 1; j &lt; i; j++) { for(int k = 1; k &lt; i; k++) f[i][j] += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1]; f[i][j] /= (i - 1) * 1.0; } } double ans = 0; for(int i = 1; i &lt; n; i++) ans += f[n][i]; printf(&quot;%.6lf&quot;, ans); }}int main(){ scanf(&quot;%d%d&quot;, &amp;q, &amp;n); if(q == 1)SubTask1::getans(); if(q == 2)SubTask2::getans(); return 0;}","link":"/2022/11/01/P3830%20%5BSHOI2012%5D%E9%9A%8F%E6%9C%BA%E6%A0%91/"},{"title":"P4841 [集训队作业2013]城市规划","text":"P4841 [集训队作业2013]城市规划 题解 题意 求nnn个点的简单(无重边无自环)有标号无向连通图数目，对100453580910045358091004535809取模。 解法 设f(n)f(n)f(n)为点数为nnn的无向连通图的数量，g(n)g(n)g(n)为点数为nnn的无向图之间连边的方案数，对于任意两个点可以连或不连，易得g(n)=2(n2)g(n) = 2 ^ {\\binom{n}{2}}g(n)=2(2n​)，然后钦定一个点， 枚举设这个点的连通块大小，得 g(n)=∑i=1n(n−1i−1)f(i)g(n−i)g(n) = \\sum_{i = 1} ^ n \\dbinom{n - 1}{i - 1}f(i) g(n - i) g(n)=i=1∑n​(i−1n−1​)f(i)g(n−i) 然后化简式子 2(n2)=∑i=1n(n−1i−1)f(i)2(n−i2)2(n2)(n−1)!=∑i=1nf(i)(i−1)!2(n−i2)(n−i)!2^{\\binom{n}{2}} = \\sum_{ i= 1}^n \\dbinom{n - 1}{i - 1}f(i)2^{\\binom{n - i}{2}}\\\\ \\frac{2 ^ {\\binom{n}{2}}}{(n - 1) !} = \\sum_{i = 1} ^ n \\frac{f(i)}{(i - 1) !} \\frac{2 ^ {\\binom{n - i}{2}}}{(n - i)!} 2(2n​)=i=1∑n​(i−1n−1​)f(i)2(2n−i​)(n−1)!2(2n​)​=i=1∑n​(i−1)!f(i)​(n−i)!2(2n−i​)​ 可以看出是一个卷积的形式，然后构造多项式 F(x)=∑i=1∞f(i)(i−1)!xiG(x)=∑i=0∞2(i2)i!xiH(x)=∑i=1∞2(i2)(i−1)!xiF(x) = \\sum_{i = 1} ^ {\\infty} \\frac{f(i)}{(i - 1) !}x^i \\\\ G(x) = \\sum_{i = 0} ^ {\\infty}\\frac{2 ^ {\\binom{i}{2}}}{i!}x^i \\\\ H(x) = \\sum_{i = 1} ^ {\\infty} \\frac{2 ^ {\\binom{i}{2}}}{(i - 1) !}x^i F(x)=i=1∑∞​(i−1)!f(i)​xiG(x)=i=0∑∞​i!2(2i​)​xiH(x)=i=1∑∞​(i−1)!2(2i​)​xi 之前推出来H=F∗GH = F \\ast GH=F∗G， 所以F=H∗G−1(modxn+1)F = H \\ast G ^{-1} \\pmod {x ^ {n + 1}}F=H∗G−1(modxn+1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;bits/stdc++.h&gt;using namespace std;namespace Poly// 使用NTT实现{ #define int long long #define vec vector &lt;int&gt; const int mod = 1004535809; // 模数 const int g = 3; // 原根 const int gi = 334845270; // 逆元 const int N = 6e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// 快速幂 int inv(int x) { return qpow(x, mod - 2);}// 逆元 void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// 初始化 void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 乘法逆 void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// 多项式求导 void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// 多项式积分 poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// 多项式ln函数 void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式exp函数 const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式开根 void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// 多项式幂函数 #undef int}using namespace Poly;#define int long longint n;int fac[N], ifac[N];int c(int n, int m){ if(n &lt; m)return 0; return n * (n - 1) / 2 % (mod - 1);}signed main(){ scanf(&quot;%lld&quot;, &amp;n); n = n + 1; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); poly F, G, H; G.clear(n); for(int i = 0; i &lt; n; i++) G.v[i] = qpow(2, c(i, 2)) * ifac[i] % mod; H.clear(n); for(int i = 1; i &lt; n; i++) H.v[i] = qpow(2, c(i, 2)) * ifac[i - 1] % mod; F.clear(n); inverse(G, F, n); F = F * H; printf(&quot;%lld&quot;, F.v[n - 1] * fac[n - 2] % mod); return 0;}","link":"/2022/10/08/P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/"},{"title":"UVA10173 Smallest Bounding Rectangle","text":"UVA10173 Smallest Bounding Rectangle 题意 给定多组数据，每组数据给定 nnn 个坐标，求能覆盖这nnn个点的最小矩形，并输出其面积。 思路 其实这道题跟P3187 [HNOI2007]最小矩形覆盖并没有多大的区别，而且也省去了求矩形顶点坐标的步骤，（当时内心是非常开心，但发现这数据比P3187强得多的时候，内心是崩溃的。。。），但这道题显然数据是强得太多了，我一份A了P3187的代码并没有过不了这道题。。（我后来改了一下找左边点时的旋转方向好像就A了）想要比较强的数据的话可以上这里。 对于最小矩形覆盖，其最小矩形的一条边必定在这nnn个点的凸包上，这样我们就先求出凸包再使用旋转卡壳，找到在以当前边为矩形的一条边时，在最左边，最右边，最上边的点，然后用向量加减的方法求出矩形的高和宽，再进一步求面积就好了。 （别忘了会出现最小矩形覆盖无解的情况）。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define double long double #define eps 1e-18using namespace std;const int maxn=5e4+10;struct geometric { double x, y; geometric(double X=0, double Y=0) :x(X), y(Y) {} friend geometric operator + (const geometric a, const geometric b) { return geometric(a.x+b.x, a.y+b.y); } friend geometric operator - (const geometric a, const geometric b) { return geometric(a.x-b.x, a.y-b.y); } friend geometric operator * (const geometric a, double p) { return geometric(a.x*p, a.y*p); } friend geometric operator / (const geometric a, double p) { return geometric(a.x/p, a.y/p); }// 向量的四则运算}p[maxn], st[maxn];int n, cnt, top;double S=1e20;double dis(geometric a, geometric b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } // 向量模长double dot(geometric a1, geometric a2, geometric b1, geometric b2) { return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y); }// 点积double cross(geometric a1, geometric a2, geometric b1, geometric b2) { return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x); } // 叉积bool cmp(geometric a, geometric b){ double tmp; tmp=cross(p[1], a, p[1], b); if(tmp&gt;0)return true; if(tmp==0)return dis(p[1], a)&lt;=dis(p[1], b); return false;}int main(){ while(true) { memset(st,0,sizeof(st)); memset(p,0,sizeof(p)); scanf(&quot;%d&quot;, &amp;n); if(n==0)break; top=0;cnt=0;S=1e20; for(int i=1;i&lt;=n;i++) { double x, y; scanf(&quot;%Lf%Lf&quot;, &amp;x, &amp;y); p[++cnt]=geometric(x, y); if(i==1) continue; if(p[cnt].y&lt;p[1].y) swap(p[cnt], p[1]); if(p[cnt].y==p[1].y&amp;&amp;p[cnt].x&gt;p[1].x) swap(p[cnt], p[1]); } sort(p+2, p+cnt+1, cmp); st[++top]=p[1]; for(int i=2;i&lt;=cnt;i++) { while(top&gt;1&amp;&amp;cross(st[top-1], st[top], st[top], p[i])&lt;=0) top--; st[++top]=p[i]; } st[++top]=p[1]; // 求凸包 if(top&lt;=3) { printf(&quot;0.0000\\n&quot;); continue; } // 凸包顶点只有两个时，最小矩形覆盖无解。 st[0]=st[top-1]; for(int i=2, j=3,l,r;i&lt;=top;i++) { r=(i==top)?1:i;l=i-1; while(cross(st[i-1], st[i], st[i], st[j])&lt;cross(st[i-1], st[i], st[i], st[j+1])) j=(j==top-1)?1:j+1; // 找最上边的点 while(dot(st[i-1], st[i], st[i], st[r])&lt;dot(st[i-1], st[i], st[i], st[r+1])) r=(r==top-1)?1:r+1; // 找最右边的点 while(dot(st[i], st[i-1], st[i-1], st[l])&lt;dot(st[i], st[i-1], st[i-1], st[l-1])) l=(l==1)?top-1:l-1; // 找最左边的点 double wide, high, len=dis(st[i-1], st[i]); wide=fabs(dot(st[i], st[i-1], st[i-1], st[l]))/len+fabs(dot(st[i-1], st[i], st[i], st[r]))/len+len; // 宽 high=fabs(cross(st[i-1], st[i], st[i-1], st[j]))/len; // 高 S=min(S, high*wide); } printf(&quot;%.4Lf\\n&quot;, S); } return 0;} 感谢观看！！！","link":"/2022/06/29/UVA10173-Smallest-Bounding-Rectangle/"},{"title":"P3312 [SDOI2014]数表","text":"P3312 [SDOI2014]数表 题解 题意 求， ∑i=1n∑j=1mσ(gcd⁡(i,j))[σ(gcd⁡(i,j))≤k]\\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\sigma(\\gcd(i, j)) [\\sigma(\\gcd(i, j)) \\le k] i=1∑n​j=1∑m​σ(gcd(i,j))[σ(gcd(i,j))≤k] 1≤n,m≤105，1≤T≤2×1041 \\le n, m \\le 10 ^ 5， 1 \\le T \\le 2 \\times 10 ^ 41≤n,m≤105，1≤T≤2×104。 解法 考虑到TTT组数据显然不能每次都重新处理一遍，先不考虑限制，化一下柿子， ans=∑i=1n∑j=1mσ(gcd⁡(i,j))=∑t=1σ(t)∑i=1⌊nt⌋∑j=1⌊mt⌋[gcd⁡(i,j)=1]=∑t=1σ(t)∑i=1⌊nt⌋∑j=1⌊mt⌋∑d∣gcd⁡(i,j)μ(d)=∑t=1σ(t)∑d=1μ(d)∑i=1⌊ntd⌋∑j=1⌊mtd⌋1\\begin{aligned} ans &amp; = \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\sigma(\\gcd(i, j)) \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} [\\gcd(i, j) = 1] \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} \\sum_{d | \\gcd(i, j)} \\mu(d) \\\\ &amp; = \\sum_{t = 1} \\sigma(t) \\sum_{d = 1} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} 1 \\end{aligned} ans​=i=1∑n​j=1∑m​σ(gcd(i,j))=t=1∑​σ(t)i=1∑⌊tn​⌋​j=1∑⌊tm​⌋​[gcd(i,j)=1]=t=1∑​σ(t)i=1∑⌊tn​⌋​j=1∑⌊tm​⌋​d∣gcd(i,j)∑​μ(d)=t=1∑​σ(t)d=1∑​μ(d)i=1∑⌊tdn​⌋​j=1∑⌊tdm​⌋​1​ 加上限制柿子变为， ans=∑σ(t)≤k∑d=1μ(d)∑i=1⌊ntd⌋∑j=1⌊mtd⌋1ans = \\sum_{\\sigma(t) \\le k} \\sum_{d = 1} \\mu(d) \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} 1 ans=σ(t)≤k∑​d=1∑​μ(d)i=1∑⌊tdn​⌋​j=1∑⌊tdm​⌋​1 然后枚举tdtdtd， ans=∑p=1⌊np⌋⌊mp⌋∑1≤σ(d)≤kσ(d)μ(pd)ans = \\sum_{p = 1} \\lfloor \\frac{n}p \\rfloor \\lfloor \\frac{m}{p} \\rfloor \\sum_{1 \\le \\sigma(d) \\le k} \\sigma(d) \\mu({\\frac{p}{d}}) ans=p=1∑​⌊pn​⌋⌊pm​⌋1≤σ(d)≤k∑​σ(d)μ(dp​) 可以先将询问离线下来，按kkk排序，树状数组动态维护即可。 时间复杂度O(Tnlog⁡n+nlog⁡2n)O(T\\sqrt n \\log n + n \\log^2 n)O(Tn​logn+nlog2n)。 (注意约数和不是单调递增的(维生素b)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 10;const int M = 1e5;const ll mod = (1ll &lt;&lt; 31);int n, m;struct query{ int n, m, k, i; query(int n = 0, int m = 0, int k = 0, int i = 0) : n(n), m(m), k(k), i(i) {} friend bool operator &lt; (query a, query b) {return a.k &lt; b.k;}};query q[N];ll ans[N];struct BIT{ ll b[N]; BIT(){memset(b, 0, sizeof(b));} int lowbit(int x){return x &amp; (-x);} void add(int x, ll k) { for(int i = x; i &lt;= M; i += lowbit(i)) b[i] = (b[i] + k) % mod; } ll sum(int x) { ll s = 0; for(int i = x; i &gt;= 1; i -= lowbit(i)) s = (s + b[i]) % mod; return s; } ll query(int l, int r) { return (sum(r) - sum(l - 1) + mod) % mod; }};BIT bit;int prime[N], cnt, mu[N];bool vis[N];struct node{ int i, s; friend bool operator &lt; (node a, node b) {return a.s &lt; b.s;}};node S[N];void init(){ mu[1] = 1; for(int i = 2; i &lt;= M; i++) { if(!vis[i])prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= M; j++) { vis[i * prime[j]] = true; if(i % prime[j] == 0)break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= M; i++) S[i].i = i; for(int i = 1; i &lt;= M; i++) for(int j = i; j &lt;= M; j += i) S[j].s = (S[j].s + i * 1ll) % mod; sort(S + 1, S + M + 1);}int main(){ init(); int T; scanf(&quot;%d&quot;, &amp;T); for(int i = 1; i &lt;= T; i++) { int n, m, k; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); q[i] = query(n, m, k, i); } sort(q + 1, q + T + 1); for(int i = 1, j = 1; i &lt;= T; i++) { while(S[j].s &lt;= q[i].k &amp;&amp; j &lt; M) { for(int k = S[j].i; k &lt;= M; k += S[j].i) bit.add(k, (S[j].s * mu[k / S[j].i] % mod + mod) % mod); j++; } int n = q[i].n, m = q[i].m, id = q[i].i; for(int l = 1, r; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans[id] = (ans[id] + 1ll * (n / l) * (m / l) % mod * bit.query(l, r) % mod + mod) % mod; } } for(int i = 1; i &lt;= T; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;}","link":"/2022/11/11/P3312%20%5BSDOI2014%5D%E6%95%B0%E8%A1%A8/"},{"title":"三角剖分","text":"咕咕咕了 blog blog","link":"/2022/08/16/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"},{"title":"使用GitHub Actions 持续集成部署Hexo","text":"使用GitHub Actions 持续集成部署Hexo 使用GitHub Actions 持续集成部署Hexo Hexo 作为一个静态的博客框架，相比于wordpress，也是有其轻便，速度快的优点，但是毕竟是静态的，部署起来并没有那么方便，如果在本地的话每次更新，都需要hexo clean -d, 会很麻烦。Github Actions 早在2018年就发布了最初的版本， 作为一个方便的可以持续集成部署的工具，我们可以用它来部署hexo，让blog以后的更新维护更加方便快捷。 需要两个仓库，一个来放blog的源码， 一个放html, 如name.github.io 。 首先在git bash中运行： 生成密钥 yaml >folded1ssh-keygen -t rsa -f github-deploy-key 此时可以得到两个文件一个是 github-deploy-key, 另一个是github-deploy-key.pub, 首先复制github-deploy-key的内容然后，到博客的源码仓库，打开Settings-&gt;Secrets-&gt;Actions， 选择New Secrets，Name 填HEXO_DEPLOY_PRI,(这个后面文件会用到建议不做更改)，然后打开博客页面文件所在的仓库，打开Settings-&gt;Deploy Key， 选择Add deploy key， 名字填HEXO_DEPLOY_PUB, 把github-deploy-key.pub的内容复制进去。 在博客源码的仓库中新建.github/workflows/deploy.yml, 接下来就是配置Github Actions，根据注释修改内容， 填在deploy.yml， 中： Actions yaml >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162name: Hexo deployon: push: branches: - main #当该分支的内容改变时会触发Actions，请根据实际情况更改成对应分支env: GIT_USER: #用户名 GIT_EMAIL: #邮箱 DEPLOY_REPO: #用户名/name.github.io DEPLOY_BRANCH: #和上个分支相同jobs: build: name: Build on node $ and $ runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] # 使用最新的Ubuntu环境 steps: - name: Checkout uses: actions/checkout@v3 #使用 actions/checkout@v3 版本为 node.16 - name: Checkout deploy repo uses: actions/checkout@v3 with: repository: $ ref: $ path: .deploy_git - name: Use Node.js $ uses: actions/setup-node@v3 #使用 actions/setup-node@v3 版本为 node.16 with: node-version: 16 - name: Configuration environment env: HEXO_DEPLOY_PRI: $ run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;&quot; #用户名 git config --global user.email &quot;&quot; # 邮箱 - name: Install dependencies run: | npm install npm install hexo-cli -g # 部署hexo 环境 - name: Deploy hexo run: | hexo clean hexo g hexo d #部署 depoly 根据实际情况更改即可 ，推荐搭配GitHub的Cloud VSCode 使用效果更佳。","link":"/2022/10/12/%E4%BD%BF%E7%94%A8GitHub%20Actions%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2Hexo/"},{"title":"动态DP","text":"动态DP🙈✍️ 动态DP 前言 稍微写了写，不算难想，就是难写。 正文 动态DP 动态DP(DDP)，是用来解决一些在特定条件下待修的DP问题。 例如P4719&quot;动态 DP&quot;&amp;动态树分治。主要还是解决这类问题，就拿这个举例子吧。 首先不难列出状态转移方程， 设f0/1f_{0 / 1}f0/1​表示当前点选或不选的最大权值，可得 {fx,0=fx,0+∑max⁡(fv,1,fv,0)fx,1=fx,1+∑fv,0+wx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = f_{x, 0} + \\sum \\max(f_{v, 1}, f_{v, 0})\\\\ &amp;f_{x, 1} = f_{x, 1} + \\sum f_{v, 0} + w_x \\end{aligned} \\right. ⎩⎨⎧​​fx,0​=fx,0​+∑max(fv,1​,fv,0​)fx,1​=fx,1​+∑fv,0​+wx​​ 然而题目中有要求带修，每次重新跑一边DP是O(nm)O(nm)O(nm)的，我们可以用数据结构维护。 广义矩阵乘法 我们将矩阵乘法定义为 A×B=∑i=1n∑j=1n∑k=1nmax⁡{Ai,k+Bk,j}A \\times B = \\sum_{i = 1}^n\\sum_{j = 1}^n\\sum_{k = 1}^n \\max\\{ A_{i, k} + B_{k, j}\\} A×B=i=1∑n​j=1∑n​k=1∑n​max{Ai,k​+Bk,j​} 然后考虑每次的修改其实就可以看作对当前点到根节点的路径上的信息进行了修改，可以用树剖降低时间复杂度，设g0/1g_{0 / 1}g0/1​表示当前点不考虑重儿子的影响下的答案，状态转移方程变为， {fx,0=gx,0+max⁡(fson,1,fson,0)fx,1=gx,1+fson,0\\left \\{ \\begin{aligned} &amp;f_{x, 0} = g_{x, 0} + \\max(f_{son, 1}, f_{son, 0})\\\\ &amp;f_{x, 1} = g_{x, 1} + f_{son, 0} \\\\ \\end{aligned} \\right. {​fx,0​=gx,0​+max(fson,1​,fson,0​)fx,1​=gx,1​+fson,0​​ 然后列出转移矩阵为， [gx,0gx,0gx,1−∞]×[fson,0fson,1]=[fx,0fx,1]\\begin{bmatrix} g_{x, 0} &amp; g_{x, 0} \\\\ g_{x, 1} &amp; -\\infty \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son, 0} \\\\ f_{son, 1} \\\\ \\end{bmatrix} = \\begin{bmatrix} f_{x,0} \\\\ f_{x, 1} \\\\ \\end{bmatrix} [gx,0​gx,1​​gx,0​−∞​]×[fson,0​fson,1​​]=[fx,0​fx,1​​] 线段树维护即可，每次查询查询当前节点所咋重链的答案即可。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 1e9;int n, m;int a[N];int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ int dat[3][3]; Matrix(){memset(dat, 0, sizeof(dat));} int *operator [] (int i){return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 1; i &lt;= 2; i++) for(int j = 1; j &lt;= 2; j++) for(int k = 1; k &lt;= 2; k++) C[i][j] = max(C[i][j], A[i][k] + B[k][j]); return C; }};int fa[N], depth[N], siz[N], son[N], top[N];int id[N], w[N], tot, ed[N];void dfs1(int x, int father){ fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[son[x]] &lt; siz[v]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; w[tot] = x; ed[topfather] = tot; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}int f[N][2], g[N][2];Matrix v[N];void dp(int x){ f[x][1] = g[x][1] = a[x]; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dp(v); f[x][0] += max(f[v][0], f[v][1]); f[x][1] += f[v][0]; if(v == son[x])continue; g[x][0] += max(f[v][0], f[v][1]); g[x][1] += f[v][0]; }}struct Segmentree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1)};Segmentree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) { Matrix A; int x = w[l]; A[1][1] = g[x][0]; A[1][2] = g[x][0]; A[2][1] = g[x][1]; A[2][2] = -INF; v[x] = A; return void(t[p].val = A); } build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r, rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r) return void(t[p].val = v[w[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, int val){ v[x][2][1] += val - a[x]; a[x] = val; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; v[x][1][1] += max(A[1][1], A[2][1]) - max(B[1][1], B[2][1]); v[x][1][2] = v[x][1][1]; v[x][2][1] += A[1][1] - B[1][1]; }}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 1); dp(1); build(1, n, 1); for(int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); update(x, y); Matrix ans = query(1, n, 1, 1, ed[1]); printf(&quot;%d\\n&quot;, max(ans[1][1], ans[2][1])); } return 0;} 应用 P5024 保卫王国 直接列出转移方程为， {fx,0=fx,1+∑fx,1fx,1=fx,0+∑min⁡(fx,0,fx,1)+cx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = f_{x, 1} + \\sum f_{x , 1} \\\\ &amp;f_{x, 1} = f_{x, 0} + \\sum \\min(f_{x, 0}, f_{x, 1}) + c_x \\end{aligned} \\right. ⎩⎨⎧​​fx,0​=fx,1​+∑fx,1​fx,1​=fx,0​+∑min(fx,0​,fx,1​)+cx​​ 考虑题目中的强制选其实就是在对应值上加上−∞-\\infty−∞，强制选就是加上∞\\infty∞，然后设g0/1g_{0/1}g0/1​列出方程为 {fx,0=gx,0+fson,1fx,1=fx,1+min⁡(fson,0,fson,1)+cx\\left \\{ \\begin{aligned} &amp;f_{x, 0} = g_{x, 0} + f_{son , 1} \\\\ &amp;f_{x, 1} = f_{x, 1} + \\min(f_{son, 0}, f_{son, 1}) + c_x \\end{aligned} \\right. {​fx,0​=gx,0​+fson,1​fx,1​=fx,1​+min(fson,0​,fson,1​)+cx​​ 列出转移矩阵为， [gx,1gx,1gx,0+∞]×[fson,0fson,1]=[fx,1fx,0]\\begin{bmatrix} g_{x,1} &amp;g_{x, 1} \\\\ g_{x, 0} &amp; + \\infty \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son,0} \\\\ f_{son,1} \\\\ \\end{bmatrix} = \\begin{bmatrix} f_{x, 1} \\\\ f_{x, 0} \\\\ \\end{bmatrix} [gx,1​gx,0​​gx,1​+∞​]×[fson,0​fson,1​​]=[fx,1​fx,0​​] 然后维护一下就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 10;const ll INF = 1e18;int n, m;int cnt, head[N];ll p[N];char s[2];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ ll dat[3][3]; Matrix(){memset(dat, 0x3f, sizeof(dat));} ll *operator [] (int i){return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 1; i &lt;= 2; i++) for(int j = 1; j &lt;= 2; j++) for(int k = 1; k &lt;= 2; k++) C[i][j] = min(C[i][j], A[i][k] + B[k][j]); return C; }};int fa[N], depth[N], siz[N], top[N], son[N];int id[N], tot, w[N], ed[N];void dfs1(int x, int father){ fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[son[x]] &lt; siz[v]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; w[tot] = x; ed[topfather] = tot; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}ll f[N][2], g[N][2];Matrix v[N];void dp(int x){ f[x][1] = g[x][1] = p[x]; f[x][0] = g[x][0] = 0; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dp(v); f[x][1] += min(f[v][1], f[v][0]); f[x][0] += f[v][1]; if(v == son[x])continue; g[x][1] += min(f[v][1], f[v][0]); g[x][0] += f[v][1]; }}struct Segmentree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid (l + r &gt;&gt; 1)};Segmentree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) { Matrix A; int x = w[l]; A[1][1] = g[x][1]; A[1][2] = g[x][1]; A[2][1] = g[x][0]; A[2][2] = INF; v[x] = A; return void(t[p].val = A); } build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r, rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r)return void(t[p].val = v[w[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, ll val){ v[x][1][1] += val - p[x]; v[x][1][2] += val - p[x]; p[x] = val; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; v[x][1][1] += min(A[1][1], A[2][1]) - min(B[1][1], B[2][1]); v[x][1][2] = v[x][1][1]; v[x][2][1] += A[1][1] - B[1][1]; }}int main(){ scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, s); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;p[i]); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 1); dp(1); build(1, n, 1); for(int i = 1; i &lt;= m; i++) { int a, x, b, y; ll tmp; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;x, &amp;b, &amp;y); if(!x &amp;&amp; !y &amp;&amp; (fa[a] == b || fa[b] == a)) {printf(&quot;-1\\n&quot;);continue;} tmp = (x ? INF : 0) + (y ? INF : 0); ll A = p[a], B = p[b]; update(a, x ? A - INF : A + INF); update(b, y ? B - INF : B + INF); Matrix ans = query(1, n, 1, id[1], ed[1]); printf(&quot;%lld\\n&quot;, min(ans[1][1], ans[2][1]) + tmp); update(a, A); update(b, B); } return 0;} P6021 洪水 不难设出转移方程为， fx=min⁡(wx,∑fv)f_x = \\min(w_x, \\sum f_v) fx​=min(wx​,∑fv​) 直接设gxg_xgx​，列出转移矩阵， [gxwx00]×[fson0]=[fx0]\\begin{bmatrix} g_x &amp; w_x \\\\ 0 &amp; 0 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} f_{son} \\\\ 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} f_x \\\\ 0 \\\\ \\end{bmatrix} [gx​0​wx​0​]×[fson​0​]=[fx​0​] 简单维护一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2e5 + 10;const int INF = 1e14;int n, m;int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}struct Matrix{ int dat[2][2]; Matrix() {dat[0][0] = dat[0][1] = dat[1][0] = dat[1][1] = INF;} int * operator [] (int i) {return dat[i];} friend Matrix operator * (Matrix A, Matrix B) { Matrix C; for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) C[i][j] = min(C[i][j], A[i][k] + B[k][j]); return C; }};Matrix M[N];int fa[N], top[N], siz[N], son[N];int id[N], ed[N], tot, a[N];int f[N], w[N];void dfs1(int x, int father){ fa[x] = father; int s = 0; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x]) continue; dfs1(v, x); s += f[v]; siz[x] += siz[v]; if(siz[v] &gt; siz[son[x]]) son[x] = v; } if(siz[x] == 1)f[x] = w[x]; else f[x] = min(s, w[x]);}void dfs2(int x, int topfather){ top[x] = topfather; id[x] = ++tot; a[tot] = x; ed[topfather] = tot; M[x][0][0] = 0, M[x][0][1] = w[x], M[x][1][0] = 0, M[x][1][1] = 0; if(!son[x]) return void(M[x][0][0] = w[x]); dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); M[x][0][0] += f[v]; }}struct Segementree{ Matrix val; #define ls(p) (p &lt;&lt; 1) #define rs(p) (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1)};Segementree t[N &lt;&lt; 2];void push_up(int p){ t[p].val = t[ls(p)].val * t[rs(p)].val;}void build(int l, int r, int p){ if(l == r) return void(t[p].val = M[a[l]]); build(l, mid, ls(p)); build(mid + 1, r, rs(p)); push_up(p);}Matrix query(int l, int r, int p, int x, int y){ if(x &lt;= l &amp;&amp; r &lt;= y)return t[p].val; if(y &lt;= mid)return query(l, mid, ls(p), x, y); if(x &gt; mid)return query(mid + 1, r, rs(p), x, y); return query(l, mid, ls(p), x, y) * query(mid + 1, r ,rs(p), x, y);}void modify(int l, int r, int p, int x){ if(l &gt; x || r &lt; x)return; if(l == r)return void(t[p].val = M[a[x]]); modify(l, mid, ls(p), x); modify(mid + 1, r, rs(p), x); push_up(p);}void update(int x, int v){ M[x][0][1] += v; w[x] += v; if(siz[x] == 1)M[x][0][0] += v; while(x != 0) { Matrix B = query(1, n, 1, id[top[x]], ed[top[x]]); modify(1, n, 1, id[x]); Matrix A = query(1, n, 1, id[top[x]], ed[top[x]]); x = fa[top[x]]; M[x][0][0] += A[0][0] - B[0][0]; }}signed main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for(int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); } dfs1(1, 0); dfs2(1, 1); build(1, n, 1); cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++) { char opt; int x, y; cin &gt;&gt; opt; if(opt == 'Q') { cin &gt;&gt; x; Matrix ans = query(1, n, 1, id[x], ed[top[x]]); cout &lt;&lt; ans[0][0] &lt;&lt; endl; } else { cin &gt;&gt; x &gt;&gt; y; update(x, y); } } return 0;} 后记 debug破防了😅😅😅","link":"/2022/11/09/%E5%8A%A8%E6%80%81DP/"},{"title":"Emoji","text":"😀","link":"/2022/06/15/emoji/"},{"title":"Loj#6670.「XXOI 2019」一个希望直接实现","text":"Loj#6670.「XXOI 2019」一个希望直接实现 题解 题意 定义一个1−n1 - n1−n的排列PPP的kkk划分为：把PPP从左到右每kkk个划分成一组， 如果有剩下的，则剩下的一共成一组。 定义PPP的kkk最小取样为：把它的kkk划分P′P'P′中，每组只保留这一组中最小的数。 那么就会得到nk\\frac{n}{k}kn​个数，如果它们从左到右构成一个递增的等差数列， 则称其为「可以达成愿望」的。 如果PPP的kkk最小取样是「可以达成愿望」的，则f(P,k)=1f(P, k) = 1f(P,k)=1， 否则f(P,k)=0f(P, k) = 0f(P,k)=0。 给定nnn，定义PnP_nPn​为1−n1 - n1−n的全排列的集合， 求： ∑p∈Pn∑k∣nf(P,k)\\sum_{p \\in P_n } \\sum_{k | n}f(P, k) p∈Pn​∑​k∣n∑​f(P,k) 对998244353998244353998244353取模。 解法 首先假设块长为kkk， 不难发现，满足条件的等差数列的首项一定是111，公差d∈[1,k]d \\in [1, k]d∈[1,k]，然后我们只需要去枚举约数，去求对应的kkk， 然后枚举公差ddd，去确定对应的方案数，确定公差后对应的等差数列也就确定为： 1,1+d,1+2d,⋯ ,1+(k−1)d1,1 + d, 1 + 2d , \\cdots ,1 + (k - 1)d 1,1+d,1+2d,⋯,1+(k−1)d 然后考虑最后一个块，会有多出来的能填的数，我们就可以将其填在前面，接下来考虑等差数列每一项之间的数，这之间的数肯定不能填在后面的块内，倒着填数的时候只能填在这个块和这个块之前，也就是说每次填数会少k−1k - 1k−1个数，多d−1d - 1d−1个数，也构成了一个等差数列。比如n=9,k=3n = 9, k = 3n=9,k=3时， 对应的方案数为A22×A32×A42×33A_2^2 \\times A_3^2 \\times A_4^2 \\times 3 ^ 3A22​×A32​×A42​×33，由于我们只考虑了除了等差数列之外的数，所以必须最后乘上每个块内的最小值的排列方案数。 code >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 3e5 + 10;const int mod = 998244353;int n;int fac[N], ifac[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int A(int n, int m){ return fac[n] % mod * ifac[n - m] % mod;}int calc(int x){ int sum = 0, len = n / x; for(int d = 1; d &lt;= x; d++) { int res = 1; for(int i = 0, j = x - 1; i &lt; len; i++, j += x - d) res = res * A(j, x - 1) % mod * x % mod; sum = (sum + res) % mod; } return sum;}signed main(){ int sum = 0; cin &gt;&gt; n; int ans = 0; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= n; i++) ifac[i] = inv(fac[i]); for(int i = 1; i &lt; n; i++) { if(n % i)continue; ans = (ans + calc(i)) % mod; } ans = (ans + fac[n] + mod) % mod; cout &lt;&lt; ans; return 0;}","link":"/2022/09/25/%E3%80%8CXXOI-2019%E3%80%8D%E4%B8%80%E4%B8%AA%E5%B8%8C%E6%9C%9B%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0/"},{"title":"多项式学习笔记","text":"超全的多项式全家桶(❁´◡`❁) 感谢Meteorshower-Y的大力支持和指导， 这是大佬的blog！！ヾ(≧▽≦*)o 多项式学习笔记 快速傅里叶变换(FFT) 快速傅里叶变换(FFT)，主要用于加速多项式乘法，对于两个多项式AAA和BBB， FFT可以将朴素的O(n2)O(n^2)O(n2)优化为O(nlog⁡n)O(n \\log n)O(nlogn)。 单位元 先看一下单位元的几个性质，在接下来的算法中有很大的用途。 ωnk=e2πikn\\omega_n ^ k = e ^{\\frac{2\\pi i k}{n}}ωnk​=en2πik​ ωdndk=ωnk\\omega_{dn} ^ {dk} = \\omega_n^kωdndk​=ωnk​ ωnk=a+bi,ωn−k=a−bi\\omega_n^k = a + bi, \\omega_n^{-k} = a - biωnk​=a+bi,ωn−k​=a−bi ωnk+n2=−ωnk\\omega _n ^{k + \\frac{n}{2}} = - \\omega_n^kωnk+2n​​=−ωnk​ 以上变换均可由欧拉公式eiθ=cos⁡θ+isin⁡θe^{i \\theta} = \\cos \\theta + i\\sin \\thetaeiθ=cosθ+isinθ推得。 离散傅里叶变换(DFT) 离散傅里叶变换(DFT) 主要是利用分治思想，根据一个nnn次的多项式可以由n+1n + 1n+1个点唯一确定， 首先将多项式 A(x)=∑i=0naixiA(x) = \\sum_{i=0} ^n a_i x^i A(x)=i=0∑n​ai​xi 其系数进行奇偶性分类，得到， A0(x)=a0+a2x1+a4x2+⋯A1(x)=a1+a3x1+a5x2+⋯A_0(x)= a_0+a_2 x^1 +a_4 x^2 + \\cdots \\\\ A_1(x)= a_1+a_3 x^1 +a_5 x^2 + \\cdots \\\\ A0​(x)=a0​+a2​x1+a4​x2+⋯A1​(x)=a1​+a3​x1+a5​x2+⋯ 所以我们可以表示为 ： A(x)=A0(x2)+x⋅A1(x2)A(x) = A_0 (x^2) +x \\cdot A_1(x^2) A(x)=A0​(x2)+x⋅A1​(x2) 将 ωnk\\omega_n^kωnk​ 与 ωnk+n2\\omega_n^{k+ \\frac{n}{2}}ωnk+2n​​代入得： {A(ωnk)=A0(ωn2k)+ωnkA1(ωn2k)A(ωnk+n2)=A0(ωn2k)−ωnkA1(ωn2k)\\left\\{ \\begin{aligned} &amp;A(\\omega_n^k) = A_0(\\omega_n^{2k})+\\omega_n^k A_1(\\omega_n^{2k}) \\\\ &amp;A(\\omega_n^{k+ \\frac{n}{2}}) = A_0(\\omega_n^{2k})-\\omega_n^k A_1(\\omega_n^{2k}) \\\\ \\end{aligned} \\right. {​A(ωnk​)=A0​(ωn2k​)+ωnk​A1​(ωn2k​)A(ωnk+2n​​)=A0​(ωn2k​)−ωnk​A1​(ωn2k​)​ 同时我们可以发现两个式子只有常数不一样，递归计算即可。 时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn) 。 在这里我们将系数变成了点值。 离散傅里叶逆变换(IDFT) 离散傅里叶逆变换(IDFT)，可以将点值快速转化为系数，从而得出结果多项式。 需要用到单位根反演： 1n∑i=0n−1ωnx∗i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1​i=0∑n−1​ωnx∗i​=[xmodn=0] 证明 ： 由于 ωnx∗i=ωnx∗(i−1)∗ωnx\\omega_n ^ {x \\ast i} = \\omega_n^ {x \\ast (i-1)} \\ast \\omega_n^xωnx∗i​=ωnx∗(i−1)​∗ωnx​ 所以ωnx∗i\\omega _n ^{x\\ast i}ωnx∗i​ 为等比数列， ∴1n∑i=0n−1ωnx∗i={1n∑i=0n−11i=nn=1x mod n=01n⋅1−ωnn∗x1−ωnx=1n⋅1−1x1−ωnx=0x mod n≠0\\therefore \\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i}= \\left\\{ \\begin{aligned} &amp;\\frac{1}{n} \\sum_{i=0}^{n-1} 1^i = \\frac{n}{n} = 1 &amp; x \\bmod n=0\\\\ &amp;\\frac{1}{n} \\cdot \\frac{1- \\omega _n ^ {n \\ast x}}{1-\\omega _n ^ x} = \\frac{1}{n} \\cdot \\frac{1-1^x}{1-\\omega_n^x} =0 &amp; x\\bmod n \\ne 0 \\end{aligned} \\right. ∴n1​i=0∑n−1​ωnx∗i​=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​n1​i=0∑n−1​1i=nn​=1n1​⋅1−ωnx​1−ωnn∗x​​=n1​⋅1−ωnx​1−1x​=0​xmodn=0xmodn​=0​ 证明 设c=a∗bci=∑j=0iaj⋅bi−j=∑p=0∑q=0ap⋅bq[(p+q) mod n=0]nci=∑p=0∑q=0ap⋅bq∑j=0ωn(p+q−i)j=∑j=0ωn(−i)j(∑p=0ωnpjap)(∑q=0ωnqjbq)设fa(j)=∑i=0ωnijai,fa−1(j)=∑i=0ωn(−i)jainci=∑j=0ωn(−i)jfa(j)fb(j)=∑j=0ωn(−i)jfc(j)=ffc−1(i)设 c= a\\ast b \\\\ \\begin{aligned} c_i &amp;= \\sum_{j=0}^i a_j \\cdot b_{i-j} \\\\ &amp;=\\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q [(p+q) \\bmod n=0] \\\\ nc_i &amp;= \\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q \\sum_{j=0} \\omega_n^{(p+q-i)j}\\\\ &amp;= \\sum_{j=0}\\omega_n^{(-i)j} \\bigg( \\sum_{p=0} \\omega_n^{pj} a_p\\bigg) \\bigg( \\sum_{q=0} \\omega_n^{qj} b_q\\bigg) \\end{aligned} \\\\ 设 f_a(j) = \\sum_{i=0} \\omega_n^{ij} a_i , f_a^{-1}(j) =\\sum_{i=0} \\omega_n^{(-i)j} a_i \\\\ \\begin{aligned} nc_i &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_a(j)f_b(j) \\\\ &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_c(j) \\\\ &amp;= f_{f_c}^{-1} (i) \\end{aligned} 设c=a∗bci​nci​​=j=0∑i​aj​⋅bi−j​=p=0∑​q=0∑​ap​⋅bq​[(p+q)modn=0]=p=0∑​q=0∑​ap​⋅bq​j=0∑​ωn(p+q−i)j​=j=0∑​ωn(−i)j​(p=0∑​ωnpj​ap​)(q=0∑​ωnqj​bq​)​设fa​(j)=i=0∑​ωnij​ai​,fa−1​(j)=i=0∑​ωn(−i)j​ai​nci​​=j=0∑​ωn(−i)j​fa​(j)fb​(j)=j=0∑​ωn(−i)j​fc​(j)=ffc​−1​(i)​ 因为 faf_afa​ 就是 aaa 在 DFT 后的结果，所以fa−1f_a^{-1}fa−1​就是 对应的IDFT，最后除以对应长度nnn，即为所求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e6 + 10;const double pi = acos(-1.0);int n, m;struct Complex{ double a, b; Complex(double x = 0, double y = 0) : a(x), b(y) {} friend Complex operator + (Complex x, Complex y) {return Complex(x.a + y.a, x.b + y.b);} friend Complex operator - (Complex x, Complex y) {return Complex(x.a - y.a, x.b - y.b);} friend Complex operator * (Complex x, Complex y) {return Complex(x.a * y.a - x.b * y.b, x.b * y.a + y.b * x.a);}};int recover[N];Complex F[N], G[N], H[N];void FFT(Complex *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { Complex x(cos(pi / k), type * sin(pi / k)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { Complex w(1, 0); for(int j = 0; j &lt; k; j++) { Complex y = a[i + j]; Complex z = w * a[i + j + k]; a[i + j] = y + z; a[i + j + k] = y - z; w = w * x; } } } if(type == -1) for(int i = 0; i &lt; len; i++) a[i].a /= len;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;F[i].a); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;G[i].a); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt;= len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); FFT(F, len, 1), FFT(G, len, 1); for(int i = 0; i &lt;= len; i++) H[i] = F[i] * G[i]; FFT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%d &quot;, (int)(H[i].a + 0.5)); return 0;} 快速数论变换(NTT) 快速数论变换(NTT)相比于FFT虽然时间复杂度均为O(nlog⁡n)O(n\\log n)O(nlogn)，但是FFT的精度却难以保证，并且常数很大， 所以有时NTT才是更好的选择。 原根 原根定义为：设mmm为正整数，aaa是整数，若a mod ma \\bmod mamodm的阶等于φ(m)\\varphi (m)φ(m)，则称aaa为 mod m\\bmod mmodm的一个原根。 原根有一个很重要的性质可以支持像FFT中单位根一样的运算，即：若PPP为素数， 假设一个数ggg是PPP的原根， 那么gi mod Pg^i \\bmod PgimodP的结果两两不同。 可以得到： ωn≡gp−1n(modp)\\omega_n \\equiv g^{\\frac{p - 1}{n}} \\pmod p ωn​≡gnp−1​(modp) 然后我们就可以将FFT中的ωn\\omega _nωn​替换为gp−1ng^{\\frac{p - 1}{n}}gnp−1​ 但是注意的是NTT对模数有要求，其模数必须要满足原根的定义，否则是不能使用NTT的，比如998244353998244353998244353就为NTT模数， 其原根为333。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e6 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int n, m;int F[N], G[N], H[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int recover[N];void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j]; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = (w * x) % mod; } } } if(type == -1) { int inv = qpow(len, mod - 2); for(int i = 0; i &lt; len; i++) a[i] = a[i] * inv % mod; }}signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;G[i]); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(F, len, 1), NTT(G, len, 1); for(int i = 0; i &lt; len; i++) H[i] = (F[i] * G[i]) % mod; NTT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%lld &quot;, H[i]); return 0;} 快速沃尔什变换 (FWT) 给定两个长度为2n2 ^ n2n的两个序列A,BA,BA,B， 求序列CCC， Ci=∑j⊕k=iAj×BkC_i = \\sum_{j \\oplus k = i} A_j \\times B_k Ci​=j⊕k=i∑​Aj​×Bk​ 其中⊕\\oplus⊕表示位运算与，或，异或。 或运算 首先求序列FWT[A]=∑i=i∣jAjFWT[A] = \\sum_{i = i | j} A _ jFWT[A]=∑i=i∣j​Aj​，来求出满足条件的iii的子集，显然会有 Ci=∑i=j∣kAj×Bk⇒FWT[C]=FWT[A]×FWT[B]C_i = \\sum_{i = j | k} A_j \\times B_k \\Rightarrow FWT[C] = FWT[A] \\times FWT[B] Ci​=i=j∣k∑​Aj​×Bk​⇒FWT[C]=FWT[A]×FWT[B] 接下来就是考虑如何进行FWTFWTFWT运算， 有 FWT[A]=merge(FWT[A0],FWT[A0]+FWT[A1])IFWT[A]=merge(IFWT[A0],IFWT[A1]−FWT[A0])FWT[A] = merge(FWT[A_0], FWT[A_0] + FWT[A_1]) \\\\ IFWT[A] = merge(IFWT[A_0], IFWT[A_1] - FWT[A_0]) FWT[A]=merge(FWT[A0​],FWT[A0​]+FWT[A1​])IFWT[A]=merge(IFWT[A0​],IFWT[A1​]−FWT[A0​]) 12345678910111213void FWT_or(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { a[i + j + k] = ((a[i + j + k] + a[i + j] * type + mod) % mod + mod) % mod; } } }} 与运算 同或运算，有 FWT[A]=merge(FWT[A0]+FWT[A1],FWT[A1])IFWT[A]=merge(IFWT[A0]−IFWT[A1],IFWT[A1])FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_1])\\\\ IFWT[A] = merge(IFWT[A_0] - IFWT[A_1], IFWT[A_1]) FWT[A]=merge(FWT[A0​]+FWT[A1​],FWT[A1​])IFWT[A]=merge(IFWT[A0​]−IFWT[A1​],IFWT[A1​]) 12345678910111213void FWT_and(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { a[i + j] = ((a[i + j] + a[i + j + k] * type + mod) % mod + mod) % mod; } } }} 异或运算 推导得 FWT[A]=merge(FWT[A0]+FWT[A1],FWT[A0]−FWT[A1])IFWT[A]=merge(IFWT[A0]+IFWT[A1]2,IFWT[A0]−IFWT[A1]2)FWT[A] = merge(FWT[A_0] + FWT[A_1], FWT[A_0] - FWT[A_1]) \\\\ IFWT[A] = merge(\\frac{IFWT[A_0] + IFWT[A_1]}{2}, \\frac{IFWT[A_0] - IFWT[A_1]}{2}) \\\\ FWT[A]=merge(FWT[A0​]+FWT[A1​],FWT[A0​]−FWT[A1​])IFWT[A]=merge(2IFWT[A0​]+IFWT[A1​]​,2IFWT[A0​]−IFWT[A1​]​) 123456789101112131415void FWT_xor(int *a, int len, int type){ for(int k = 1; k &lt; len; k &lt;&lt;= 1) { for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { for(int j = 0; j &lt; k; j++) { int x = a[i + j], y = a[i + j + k]; a[i + j] = ((x + y) % mod * type + mod) % mod; a[i + j + k] = ((x - y + mod) % mod * type + mod) % mod; } } }} 任意模数快速数论变换 普通的NTT对模数是有要求的其必须满足原根的相关定义，模数必须可以写成a⋅2k+1a \\cdot 2 ^ k + 1a⋅2k+1的形式。 比如： 469762049=7×226+1(g=3)998244353=119×223+1(g=3)1004535809=479×221+1(g=3)469762049 = 7 \\times 2 ^ {26} + 1 (g = 3) \\\\ 998244353 = 119 \\times 2 ^{23} + 1(g = 3) \\\\ 1004535809 = 479 \\times 2 ^ {21} + 1(g = 3) 469762049=7×226+1(g=3)998244353=119×223+1(g=3)1004535809=479×221+1(g=3) 如果题目中模数为1e9+71e9 + 71e9+7，那么NTT就会受到限制，然后就可以使用任意模数NTT，（也可以称为三模数NTT）， 计算时可以先找三个大质数， 分别计算结果，然后用中国剩余定理CRT合并即可。 首先记三次NTT的结果为： ans≡a1(modp1)ans≡a2(modp2)ans≡a3(modp3)ans \\equiv a_1 \\pmod {p_1} \\\\ ans \\equiv a_2 \\pmod {p_2} \\\\ ans \\equiv a_3 \\pmod {p_3} ans≡a1​(modp1​)ans≡a2​(modp2​)ans≡a3​(modp3​) 先合并前两个得到: ans≡a4(modp1p2)ans \\equiv a_4 \\pmod {p_1 p_2} ans≡a4​(modp1​p2​) 将其转化为等式为： ans=kp1p2+a4ans = k p_1 p_2 + a_4 ans=kp1​p2​+a4​ 接着求kkk： k=(a3−a4)p1−1p2−1(modp3)k = (a_3 - a_4)p_1^{-1} p_2 ^ {-1} \\pmod {p_3} k=(a3​−a4​)p1−1​p2−1​(modp3​) 所以： ans≡kp1p2+a4(modp1p2p3)ans \\equiv kp_1 p_2 + a_4 \\pmod {p_1p_2p_3} ans≡kp1​p2​+a4​(modp1​p2​p3​) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define int __int128const int N = 4e5 + 10;const int g = 3;int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){if(ch == '-')f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x*10 + ch-'0'; ch = getchar();} return x * f;}void write(int x){ char ch[100], len = 0; if(x == 0)ch[++len] = '0'; while(x)ch[++len] = x%10 + '0', x /= 10; while(len)putchar(ch[len--]); printf(&quot; &quot;);}int p[3] = {469762049, 998244353, 1004535809};int qpow(int a, int b, int i){ int t = 1; while(b != 0) { if(b &amp; 1) t = t * a % p[i]; a = a * a % p[i]; b &gt;&gt;= 1; } return t % p[i];}int inv(int x, int i){ return qpow(x, p[i] - 2, i);}int gi[3];void init(){ for(int i = 0; i &lt; 3; i++) gi[i] = inv(g, i);}int F[N], G[N], H[N];int recover[N];void NTT(int *a, int len, int type, int f){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi[f], (p[f] - 1) / (k &lt;&lt; 1), f); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % p[f]; int z = w * a[i + j + k] % p[f]; a[i + j] = (y + z) % p[f]; a[i + j + k] = (y - z + p[f]) % p[f]; w = w * x % p[f]; } } } if(type == -1) { int iv = inv(len, f); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % p[f]; }}int A[N], B[N], C[3][N];void CRT(int len){ int M = p[0] * p[1]; for(int i = 0; i &lt;= len; i++) { H[i] = (p[1] * C[0][i] % M * inv(p[1], 0) % M + p[0] * C[1][i] % M * inv(p[0], 1) % M) % M; }}int n, m, mod;void merge(int len){ for(int i = 0; i &lt;= len; i++) { int k = ((C[2][i] - H[i]) % p[2] + p[2]) % p[2] * inv(p[0] * p[1], 2) % p[2]; H[i] = ((k * p[0] * p[1] % mod + H[i] % mod) % mod + mod) % mod; }}void prework(){ memcpy(A, F, sizeof(F)); memcpy(B, G, sizeof(G));}void update(int x, int len){ for(int i = 0; i &lt; len; i++) C[x][i] = A[i] * B[i] % p[x];}signed main(){ init(); n = read(), m = read(), mod = read(); for(int i = 0; i &lt;= n; i++) F[i] = read(); for(int i = 0; i &lt;= m; i++) G[i] = read(); int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; 3; i++) { prework(); NTT(A, len, 1, i), NTT(B, len, 1, i); update(i, len); NTT(C[i], len, -1, i); } CRT(n + m); merge(n + m); for(int i = 0; i &lt;= (n + m); i++) write(H[i]); return 0;} 多项式乘法逆 定义多项式F−1F ^ {-1}F−1为多项式FFF的乘法逆元，满足 F∗F−1≡1(modxn)F \\ast F ^ {-1} \\equiv 1 \\pmod{x^n} F∗F−1≡1(modxn) 假设我们已经得知F∗G′≡1(modxn2)F \\ast G' \\equiv 1 \\pmod {x ^ {\\frac{n}{2}}}F∗G′≡1(modx2n​)， 来求F∗G≡1(modxn)F \\ast G \\equiv 1 \\pmod {x ^ n}F∗G≡1(modxn) ∵F∗G′≡1mod xn2,F∗G≡1(modxn)∴F∗G≡1(modxn2)∴G′−G≡0(modxn2)∴(G′−G)2≡0(modxn)G′2−2GG′+G2≡0(modxn)\\because F \\ast G' \\equiv 1 \\mod {x ^ {\\frac{n}{2}}} , F \\ast G \\equiv 1 \\pmod {x ^ n} \\\\ \\therefore F \\ast G \\equiv 1 \\pmod {x ^ {\\frac{n}{2}}} \\\\ \\therefore G' - G \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ \\therefore (G' - G) ^ 2 \\equiv 0 \\pmod {x ^ n} \\\\ G'^2 - 2 G G' + G^2 \\equiv 0 \\pmod {x ^ n} \\\\ ∵F∗G′≡1modx2n​,F∗G≡1(modxn)∴F∗G≡1(modx2n​)∴G′−G≡0(modx2n​)∴(G′−G)2≡0(modxn)G′2−2GG′+G2≡0(modxn) 接下来两边同时∗F\\ast F∗F， FG′2−2G′+G≡0(modxn)∴G≡2G′−FG′2(modxn)F G'^2 - 2 G' + G \\equiv 0 \\pmod {x ^ n} \\\\ \\therefore G \\equiv 2 G' - FG'^2 \\pmod {x ^ n} FG′2−2G′+G≡0(modxn)∴G≡2G′−FG′2(modxn) 然后直接递归即可， 使用NTT， 时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int F[N], G[N];int recover[N];void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}int c[N];void mul(int n, int *a, int *b){ if(n == 1) { b[0] = inv(a[0]); return; } mul((n + 1) &gt;&gt; 1, a, b); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}signed main(){ int n; scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); mul(n, F, G); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, (G[i] % mod + mod) % mod); return 0;} 多项式对数函数(多项式求ln) 定义多项式对数函数为 G=ln⁡(F)(modxn)G = \\ln (F) \\pmod {x ^ n} G=ln(F)(modxn) 假设我们有多项式F(x)F(x)F(x)和G(x)G(x)G(x)， 记G=ln⁡F(modxn)G = \\ln F \\pmod {x ^ n}G=lnF(modxn)， G≡ln⁡F(modxn)G′≡(ln⁡F)’(modxn)G′≡(ln⁡′F)∗F′(modxn)G′≡F′F(modxn)G \\equiv \\ln F \\pmod {x ^ n} \\\\ G'\\equiv (\\ln F)’ \\pmod {x ^ n} \\\\ G' \\equiv (\\ln' F )\\ast F ' \\pmod {x ^n} \\\\ G' \\equiv \\frac{F'}{F} \\pmod {x^n} G≡lnF(modxn)G′≡(lnF)’(modxn)G′≡(ln′F)∗F′(modxn)G′≡FF′​(modxn) 多项式求逆，再积回去就好啦。 需要用到求导：xa′=axa−1x ^ {a'} = ax ^ {a - 1}xa′=axa−1， 积分：∫xadx=1a+1xa+1\\int x^a \\mathrm{d}x = \\frac{1}{a + 1}x ^ {a + 1}∫xadx=a+11​xa+1。需要保证F0=1F_0 = 1F0​=1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}void diff(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i - 1] = i * a[i] % mod; b[n - 1] = 0;}void integ(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i] = a[i - 1] * inv(i) % mod; b[0] = 0;}int F[N], G[N], H[N];void polyln(int *a, int *b, int n){ int f[N], h[N]; memset(f, 0, sizeof(f)); memset(h, 0, sizeof(h)); diff(a, f, n); inverse(a, h, n); mul(f, h, H, n, n); integ(H, b, n);}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polyln(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} 多项式指数函数(多项式exp) 定义多项式指数函数为 G(x)=eF(x)(modxn)G(x) = e ^ {F(x)} \\pmod {x ^ n} G(x)=eF(x)(modxn) 牛顿迭代 牛顿迭代用于求函数零点，通过不断地切线逼近所求值，但最终也只是近似值，迭代的次数越多，精确度越高，误差越小。 假如我们要对一个非常大的数aaa开方，手算，利用牛顿法来解决这个问题，其实本质上是求得f(x)=x2−af(x) = x ^2 - af(x)=x2−a精确到整数得零点，假设我们已经求得了一个近似值x0x_0x0​，那么我们只需要过(x0,f(x0))(x_0, f(x_0))(x0​,f(x0​))这个点， 作这个函数图像的切线，取切线与xxx轴的交点作为新的x0x_0x0​。 假设我们要求一个函数f(x)f(x)f(x)的零点， 初始近似值是x0x_0x0​，则切线方程为 y=f′(x0)(x−x0)+f(x0)y = f'(x_0)(x - x_0) + f(x_0) y=f′(x0​)(x−x0​)+f(x0​) 令y=0y = 0y=0，得到x=x0−f(x0)f′(x0)x = x_0 - \\frac{f(x_0)}{f'(x_0)}x=x0​−f′(x0​)f(x0​)​。 假设我们现在要求F(G(x))≡0F(G(x)) \\equiv 0F(G(x))≡0，然后利用上面的式子每一次令 G(x)=G0(x)−F(G0(x))F′(G0(x))G(x) = G_0(x) - \\frac{F(G_0(x))}{F'(G_0(x))} G(x)=G0​(x)−F′(G0​(x))F(G0​(x))​ 然后就可以很快的逼近真实值。 接下来推一下多项式exp B(x)≡eA(x)(modxn)ln⁡B(x)−A(x)≡0(modxn)B(x) \\equiv e ^ {A(x)} \\pmod {x ^ n} \\\\ \\ln B(x) - A(x) \\equiv 0 \\pmod {x^ n} B(x)≡eA(x)(modxn)lnB(x)−A(x)≡0(modxn) 现在问题变为了使得F(G(x))=ln⁡G(x)−A(x)≡0F(G(x)) = \\ln G(x) - A(x) \\equiv 0F(G(x))=lnG(x)−A(x)≡0。 然后求导， F′(G0(x))=1G0(x)F'(G_0(x)) = \\frac{1}{G_0(x)} F′(G0​(x))=G0​(x)1​ 然后接着带入上面牛顿迭代的式子， G(x)=G0(x)(1−ln⁡G0(x)+A(x))G(x) = {G_0(x)(1 - \\ln G_0(x) + A(x))} G(x)=G0​(x)(1−lnG0​(x)+A(x)) 每次迭代，使用多项式求ln⁡\\lnln，然后再做一遍多项式乘法，然后就可以得到答案，时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn)。 需要保证F0=0F_0 = 0F0​=0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}void diff(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i - 1] = i * a[i] % mod; b[n - 1] = 0;}void integ(int *a, int *b, int n){ for(int i = 1; i &lt; n; i++) b[i] = a[i - 1] * inv(i) % mod; b[0] = 0;}int F[N], G[N], H[N];void polyln(int *a, int *b, int n){ int f[N], h[N]; memset(f, 0, sizeof(f)); memset(h, 0, sizeof(h)); diff(a, f, n); inverse(a, h, n); mul(f, h, H, n, n); integ(H, b, n);}void polyexp(int *a, int *b, int n){ if(n == 1) { b[0] = 1; return; } polyexp(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); c[0] = 1; int f[N]; memset(f, 0, sizeof(f)); polyln(b, f, n); add(c, a, c, n, n, 1); add(c, f, c, n, n, -1); mul(c, b, c, n, n); for(int i = 0; i &lt; n; i++) b[i] = c[i]; for(int i = n; i &lt; len; i++) b[i] = 0;}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polyexp(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} 多项式开根 多项式开根用来解决 G2(x)≡F(x)(modxn)G^2(x) \\equiv F(x) \\pmod {x^n} G2(x)≡F(x)(modxn) 假设我们有G′2(x)≡F(x)(modxn2),H(G(x))=G2(x)−FG'^2(x) \\equiv F(x) \\pmod {x ^ {\\frac{n}{2}}}, H(G(x)) = G^2(x) - FG′2(x)≡F(x)(modx2n​),H(G(x))=G2(x)−F，求G2(x)≡F(x)(modxn)G^2(x) \\equiv F(x) \\pmod {x ^ n}G2(x)≡F(x)(modxn)， G′2(x)≡F(x)mod xn2,G2(x)≡F(x)(modxn2)G2(x)−F≡0(modxn2)H(G)≡0(modxn2)G≡G′−H(G′)H′(G′)(modxn)G≡G′2+F2G′(modxn)G'^2 (x) \\equiv F(x) \\mod x ^ {\\frac{n}{2}} , G^2(x) \\equiv F(x) \\pmod {x ^ {\\frac{n}{2}}} \\\\ G^2(x) - F \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ H(G) \\equiv 0 \\pmod {x ^ {\\frac{n}{2}}} \\\\ G \\equiv G' - \\frac{H(G')}{H'(G')} \\pmod {x ^ n} \\\\ G \\equiv \\frac{G'^2 + F} {2G'} \\pmod {x ^ n} G′2(x)≡F(x)modx2n​,G2(x)≡F(x)(modx2n​)G2(x)−F≡0(modx2n​)H(G)≡0(modx2n​)G≡G′−H′(G′)H(G′)​(modxn)G≡2G′G′2+F​(modxn) 需要保证F0=1F_0 = 1F0​=1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 4e5 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}int inv2 = inv(2);void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = (y - z + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}void inverse(int *a, int *b, int n){ if(n == 1) { b[0] = inv(a[0]); return; } inverse(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); for(int i = 0; i &lt; n; i++) c[i] = a[i]; for(int i = n; i &lt; len; i++) c[i] = 0; NTT(c, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++)b[i] = 0;}void mul(int *a, int *b, int *c, int n, int m){ int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); NTT(a, len, 1), NTT(b, len, 1); for(int i = 0; i &lt; len; i++) c[i] = a[i] * b[i] % mod; NTT(c, len, -1);}void add(int *a, int *b, int *c, int n, int m, int k){ for(int i = 0; i &lt;= max(n, m); i++) c[i] = (a[i] + k * b[i] + mod) % mod;}int F[N], G[N], H[N];void polysqrt(int *a, int *b, int n){ if(n == 1) { b[0] = 1; return; } polysqrt(a, b, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); int c[N]; memset(c, 0, sizeof(c)); int f[N]; memset(f, 0, sizeof(f)); inverse(b, f, n); for(int i = 0; i &lt; n; i++) c[i] = a[i]; NTT(f, len, 1), NTT(b, len, 1), NTT(c, len, 1); for(int i = 0; i &lt; len; i++) b[i] = (b[i] + c[i] * f[i] % mod) % mod * inv2 % mod; NTT(b, len, -1); for(int i = n; i &lt; len; i++) b[i] = 0;}int n;signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); polysqrt(F, G, n); for(int i = 0; i &lt; n; i++) printf(&quot;%lld &quot;, G[i]); return 0;} 多项式幂函数 多项式幂函数是用来解决 G(x)≡(F(x))kmod xnG(x) \\equiv (F(x)) ^ k \\mod x ^ n G(x)≡(F(x))kmodxn 先求一遍ln⁡\\lnln然后乘以kkk再使用exp⁡\\expexp，就好啦。 需保证F0=1F_0 = 1F0​=1。 多项式的一些普通情况 多项式求ln 不保证F0=1F_0 = 1F0​=1。不存在，有定理： 在模意义下当且仅当F0=1F_0 = 1F0​=1， F(x)F(x)F(x)有对数多项式问题。 多项式求exp 不保证F0=0F_0 = 0F0​=0 。同多项式求ln⁡\\lnln。 多项式开根 不保证F0=1F_0 = 1F0​=1，但保证F0F_0F0​是 mod 998244353\\bmod 998244353mod998244353下的二次剩余。 边界求一遍二次剩余即可。 多项式幂函数 不保证F0=1F_0 = 1F0​=1。可以先找到系数不为000的一项，然后让式子除以这一项最后再乘回来就好了 F(x)k=(F(x)xt)kxtkF(x)^k = \\bigg( \\frac{F(x)}{x ^ t} \\bigg) ^ k x ^ {tk} F(x)k=(xtF(x)​)kxtk 分治FFT/NTT 给定序列ggg和fff， 其中 fi=∑j=1ifi−jgjf_i= \\sum_{j = 1} ^ i f _{i - j} g _ j fi​=j=1∑i​fi−j​gj​ 求fff， 这里给出一个多项式求逆的方法，（找时间再补分治FFT / NTT） 设F(x)=∑i=0∞fixi,G(x)=∑i=0∞gixiF(x) = \\sum_{i = 0} ^ {\\infty} f_i x ^ i , G(x) = \\sum_{i = 0} ^ {\\infty}g_i x ^ iF(x)=∑i=0∞​fi​xi,G(x)=∑i=0∞​gi​xi，且g0=0g_0 = 0g0​=0， 所以有 F(x)G(x)=∑i=0∞∑j+k=ifjgk=F(x)−f0x0F(x)G(x)≡F(x)−f0(modxn)F(x)≡(1−G(x))−1(modxn)F(x) G(x) = \\sum_{i = 0} ^ {\\infty} \\sum_{j + k = i}f_jg_k = F(x) - f_0 x ^ 0 \\\\ F(x)G(x) \\equiv F(x) - f_0 \\pmod {x ^ n} \\\\ F(x) \\equiv (1 - G(x)) ^ {-1} \\pmod {x ^ n} F(x)G(x)=i=0∑∞​j+k=i∑​fj​gk​=F(x)−f0​x0F(x)G(x)≡F(x)−f0​(modxn)F(x)≡(1−G(x))−1(modxn) 下降幂多项式乘法 假设我们已知nnn次多项式f(x)f(x)f(x)在[0,n][0, n][0,n]的点值， 求它的下降幂表示， 设f(x)=∑i=0nbixi‾=∑i=0nbix!(x−i)!f(x) = \\sum_{i = 0} ^ n b_i x^{\\underline{i}} = \\sum_{i = 0} ^ n b_i\\frac{x!}{(x -i)!}f(x)=∑i=0n​bi​xi​=∑i=0n​bi​(x−i)!x!​，则有 f(x)x!=∑i=0nbi1(x−i)!=b∗ex\\frac{f(x)}{x!} = \\sum_{i = 0} ^ n b_i \\frac{1}{(x - i) !} = b \\ast e^x x!f(x)​=i=0∑n​bi​(x−i)!1​=b∗ex 先转化为点值最后卷上exe^xex即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 998244353;const int g = 3;const int gi = 332748118;const int N = 8e5 + 10;int recover[N];int n, m;int A[N], B[N], F[N], G[N], H[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void NTT(int *a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}int fac[N], ifac[N];signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 0; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;F[i]); for(int i = 0; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;G[i]); int len = 1, cnt = 0, Len = max(n, m) &lt;&lt; 1; while(len &lt;= (Len &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= Len; i++) fac[i] = fac[i - 1] * i % mod; for(int i = 1; i &lt;= Len; i++) ifac[i] = inv(fac[i]); for(int i = 0; i &lt;= Len; i++) { if(i &amp; 1)B[i] = ((mod - ifac[i]) % mod + mod) % mod; else B[i] = ifac[i]; A[i] = ifac[i]; } NTT(A, len, 1); NTT(B, len, 1); NTT(F, len, 1); NTT(G, len, 1); for(int i = 0; i &lt; len; i++) { F[i] = A[i] * F[i] % mod; G[i] = A[i] * G[i] % mod; } NTT(F, len, -1); NTT(G, len, -1); for(int i = 0; i &lt;= Len; i++) H[i] = F[i] % mod * G[i] % mod * fac[i] % mod; NTT(H, len, 1); for(int i = 0; i &lt; len; i++) H[i] = H[i] * B[i] % mod; NTT(H, len, -1); for(int i = 0; i &lt;= n + m; i++) printf(&quot;%lld &quot;, H[i]); return 0;} 多项式除法 给定一个nnn次多项式F(x)F(x)F(x)和一个mmm次多项式G(x)G(x)G(x)， 求多项式A(x),B(x)A(x),B(x)A(x),B(x)，满足： A(x)A(x)A(x)次数为n−mn - mn−m， B(x)B(x)B(x)次数小于mmm F(x)=A(x)∗G(x)+B(x)F(x) = A(x) \\ast G(x) + B(x)F(x)=A(x)∗G(x)+B(x) 所有运算在模998244353998244353998244353下进行。 定义一种让多项式反转的操作为A′(x)=xnA(1x)A'(x) = x^n A(\\frac{1}{x})A′(x)=xnA(x1​)，然后化简式子 F(x)=A(x)∗G(x)+B(x)xnF(1x)=xn−mA(1x)∗xmG(1x)+xn−m+1∗xm−1B(1x)F′(x)=A′(x)∗G′(x)+xn−m+1∗B′(x)F′(x)≡A′(x)∗G′(x)(modxn−m+1)A′(x)≡F′(x)∗G′−1(x)(modxn−m+1)F(x) = A(x) \\ast G(x) + B(x) \\\\ x^n F(\\frac{1}{x}) = x^{n - m} A(\\frac{1}{x}) \\ast x^m G(\\frac{1}{x}) + x^{n - m + 1}\\ast x ^{m - 1} B(\\frac{1}{x}) \\\\ F'(x) = A'(x) \\ast G'(x) + x^{n - m + 1} \\ast B'(x) \\\\ F'(x) \\equiv A'(x) \\ast G'(x) \\pmod {x^{n - m + 1}} \\\\ A'(x) \\equiv F'(x) \\ast G'^{-1}(x) \\pmod {x^{n - m + 1}} F(x)=A(x)∗G(x)+B(x)xnF(x1​)=xn−mA(x1​)∗xmG(x1​)+xn−m+1∗xm−1B(x1​)F′(x)=A′(x)∗G′(x)+xn−m+1∗B′(x)F′(x)≡A′(x)∗G′(x)(modxn−m+1)A′(x)≡F′(x)∗G′−1(x)(modxn−m+1) 先进行多项式求逆，然后再推B(x)=F(x)−A(x)∗G(x)B(x) = F(x) - A(x) \\ast G(x)B(x)=F(x)−A(x)∗G(x)。 多项式多点求值 咕咕咕 多项式复合函数 有F(x),G(x)F(x), G(x)F(x),G(x)，求 H(x)≡F(G(x))(modxn+1)H(x) \\equiv F(G(x)) \\pmod {x^{n + 1}} H(x)≡F(G(x))(modxn+1) 即： H(x)≡∑i=0n[xi]F(x)×G(x)i(modxn+1)H(x) \\equiv \\sum_{i = 0} ^n[x^i] F(x) \\times G(x)^i \\pmod {x^{n + 1}} H(x)≡i=0∑n​[xi]F(x)×G(x)i(modxn+1) 对998244353998244353998244353取模。 设m=nm = \\sqrt nm=n​，则 ∑i=0n[xi]F(x)G(x)i=∑i=0m−1∑j=0m−1[xim+j]F(x)G(x)im+j=∑i=0m−1G(x)im∑j=0m−1[xim+j]F(x)G(x)j\\sum_{i = 0} ^ n [x^i] F(x)G(x) ^ i = \\sum_{i = 0} ^ {m - 1} \\sum_{j = 0} ^ {m - 1}[x^{im + j}]F(x)G(x)^{im + j} = \\sum_{i = 0}^{m - 1}G(x)^{im}\\sum_{j = 0} ^ {m - 1}[x^{im+j}]F(x)G(x)^j i=0∑n​[xi]F(x)G(x)i=i=0∑m−1​j=0∑m−1​[xim+j]F(x)G(x)im+j=i=0∑m−1​G(x)imj=0∑m−1​[xim+j]F(x)G(x)j 然后预处理G(x)imG(x)^{im}G(x)im和G(x)jG(x)^jG(x)j，其它的直接暴力计算， 时间复杂度O(n2+nnlog⁡n)O(n^2 + n \\sqrt n \\log n)O(n2+nn​logn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &lt;bits/stdc++.h&gt;using namespace std;namespace Poly// 使用NTT实现{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // 模数 const int g = 3; // 原根 const int gi = 332748118; // 逆元 const int N = 8e4 + 10; // size int save[3][32]; int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// 快速幂 int inv(int x) { return qpow(x, mod - 2);}// 逆元 void prework() { for(int i = 1, k = 1; i &lt;= 20; i++, k &lt;&lt;= 1) { save[0][i] = qpow(g, (mod - 1) / (k &lt;&lt; 1)); save[1][i] = qpow(gi, (mod - 1) / (k &lt;&lt; 1)); save[2][i] = inv(k); } } void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// 初始化 void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); int cnt = 1; for(int k = 1; k &lt; len; k &lt;&lt;= 1, cnt++) { int x = (type == 1) ? save[0][cnt] : save[1][cnt]; for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = save[2][cnt]; for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 乘法逆 void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// 多项式求导 void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// 多项式积分 poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// 多项式ln函数 void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式exp函数 const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式开根 void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// 多项式幂函数 #undef int}using namespace Poly;int n, m;poly Gpow[200], Gm[200];int main(){ prework(); cin &gt;&gt; n &gt;&gt; m; n = n + 1; m = m + 1; poly F, G, H; F.clear(n); G.clear(m); for(int i = 0; i &lt; n; i++) cin &gt;&gt; F.v[i]; for(int i = 0; i &lt; m; i++) cin &gt;&gt; G.v[i]; int l = sqrt(n) + 1; Gpow[0].v[0] = 1; Gm[0].v[0] = 1; Gpow[0].length(n); Gm[0].length(n); Gpow[1] = G; Gpow[1].length(n); for(int i = 2; i &lt;= l; i++) { Gpow[i] = Gpow[i - 1] * G; Gpow[i].length(n); Gpow[i].memset0(n, n &lt;&lt; 1); } Gm[1] = Gpow[l]; Gm[1].length(n); for(int i = 2; i &lt;= l; i++) { Gm[i] = Gm[i - 1] * Gpow[l]; Gm[i].length(n); Gm[i].memset0(n, n &lt;&lt; 1); } poly A; A.clear(n); H.clear(n); for(int i = 0; i &lt; l; i++) { A.memset0(0, n &lt;&lt; 1); A.length(n); for(int j = 0; j &lt; l; j++) { for(int k = 0; k &lt; n; k++) A.v[k] = (A.v[k] + F.v[i * l + j] * Gpow[j].v[k]) % mod; } A = A * Gm[i]; A.length(n); H = H + A; } for(int i = 0; i &lt; n; i++) cout &lt;&lt; H.v[i] &lt;&lt; &quot; &quot;; return 0;} 多项式复合逆 有F(x)F(x)F(x)，求 G(F(x))≡x(modxn)G(F(x)) \\equiv x \\pmod {x ^ n} G(F(x))≡x(modxn) 对998244353998244353998244353取模。 有拉格朗日反演公式： [xn]G(x)=1n[xn−1](xF(x))n[x^n]G(x) = \\frac{1}{n}[x^{n - 1}](\\frac{x}{F(x)})^n [xn]G(x)=n1​[xn−1](F(x)x​)n 这个是求单项系数的， 需要求的是所有系数。 利用解决多项式复合函数的方法， 令m=nm = \\sqrt nm=n​， 则 G(x)=∑i=1n(1i[xi−1](xF(x))i)=∑i=0m−1∑j=1m(1im+j[xim+j−1](xF(x))im+j)xim+j=∑i=0m−1∑j=1m(1im+j[xim+j−1](xF(x))im(xF(x))j)xim+jG(x) = \\sum_{i = 1}^{n}\\bigg ( \\frac{1}{i}[x^{i - 1}] (\\frac{x}{F(x)})^i \\bigg) = \\sum_{i = 0}^{m - 1}\\sum_{j = 1} ^{m }\\bigg( \\frac{1}{im + j}[x^{im + j - 1}](\\frac{x}{F(x)})^{im + j} \\bigg)x^{im + j} = \\sum_{i = 0}^{m - 1}\\sum_{j = 1} ^ m \\bigg( \\frac{1}{im + j} [x^{im + j - 1}](\\frac{x}{F(x)})^im (\\frac{x}{F(x)})^j \\bigg)x^{im + j} G(x)=i=1∑n​(i1​[xi−1](F(x)x​)i)=i=0∑m−1​j=1∑m​(im+j1​[xim+j−1](F(x)x​)im+j)xim+j=i=0∑m−1​j=1∑m​(im+j1​[xim+j−1](F(x)x​)im(F(x)x​)j)xim+j 然后就是和多项式复合函数的一样的处理方法，时间复杂度O(n2+nlog⁡n)O(n^2 + \\sqrt n \\log n)O(n2+n​logn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define vec vector &lt;int&gt;const int N = 8e4 + 10;const int mod = 998244353;const int g = 3;const int gi = 332748118;struct poly{ vector &lt;int&gt; v; poly(){v.resize(N);}};int save[3][32];int recover[N];int qpow(int a, int b){ int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t;}int inv(int x){ return qpow(x, mod - 2);}void prework(){ for(int i = 1, k = 1; i &lt;= 20; i++, k &lt;&lt;= 1) { save[0][i] = qpow(g, (mod - 1) / (k &lt;&lt; 1)); save[1][i] = qpow(gi, (mod - 1) / (k &lt;&lt; 1)); save[2][i] = inv(k); }}void NTT(vec &amp;a, int len, int type){ for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); int cnt = 1; for(int k = 1; k &lt; len; k &lt;&lt;= 1, cnt++) { int x = (type == 1) ? save[0][cnt] : save[1][cnt]; for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = save[2][cnt]; for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; }}vec tmp;void inverse(poly &amp;A, poly &amp;B, int n){ if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0;}int n;poly Finv[200], Fm[200];signed main(){ poly F; prework(); cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; F.v[i]; for(int i = 0; i &lt; n; i++) F.v[i] = F.v[i + 1]; n = n - 1; int m = sqrt(n) + 1; poly A; inverse(F, A, n); Finv[0].v[0] = Fm[0].v[0] = 1; int len = 1, cnt = 0; while(len &lt;= (n &lt;&lt; 1))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); Finv[1] = A; NTT(A.v, len, 1); for(int i = 2; i &lt;= m; i++) { NTT(Finv[i - 1].v, len, 1); for(int j = 0; j &lt; len; j++) Finv[i].v[j] = Finv[i - 1].v[j] * A.v[j] % mod; NTT(Finv[i].v, len, -1); NTT(Finv[i - 1].v, len, -1); for(int j = n; j &lt; (n &lt;&lt; 1); j++) Finv[i].v[j] = 0; } A = Finv[m]; NTT(A.v, len, 1); Fm[1] = Finv[m]; for(int i = 2; i &lt;= m; i++) { NTT(Fm[i - 1].v, len, 1); for(int j = 0; j &lt; len; j++) Fm[i].v[j] = Fm[i - 1].v[j] * A.v[j] % mod; NTT(Fm[i].v, len, -1); NTT(Fm[i - 1].v, len, -1); for(int j = n; j &lt; (n &lt;&lt; 1); j++) Fm[i].v[j] = 0; } poly G; bool res = false; for(int i = 0; i &lt;= m; i++) { for(int j = 1; j &lt;= m; j++) { if(i * m + j - 1 &gt; n) { res = true; break; } int sum = 0; for(int k = 0; k &lt;= i * m + j - 1; k++) sum = (sum + Finv[j].v[k] * Fm[i].v[i * m + j - 1 - k] % mod) % mod; G.v[i * m + j] = sum * inv(i * m + j) % mod; } if(res)break; } for(int i = 0; i &lt;= n; i++) cout &lt;&lt; G.v[i] &lt;&lt; &quot; &quot;; return 0;}","link":"/2022/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"多项式板子","text":"多项式板子 多项式模板 目前支持 多项式乘法 多项式求逆 多项式开根 多项式幂函数 多项式对数函数 多项式指数函数 任意模数NTT （常数巨大, 卡常的话建议预处理原根） 不含任意模数NTT： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178namespace Poly// 使用NTT实现{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // 模数 const int g = 3; // 原根 const int gi = 332748118; // 逆元 const int N = 6e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// 快速幂 int inv(int x) { return qpow(x, mod - 2);}// 逆元 void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// 初始化 void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} void memset0(int l, int r){for(int i = l; i &lt; r; i++)v[i] = 0;} void print(int n){for(int i = 0; i &lt; n; i++)printf(&quot;%lld &quot;, v[i]); printf(&quot;\\n&quot;);} int &amp;operator [] (int i){return v[i];} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A[i] = (A[i] + B[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A[i] = ((A[i] - B[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A[i] = (A[i] * B[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = inv(A[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B[i] = (2 - B[i] * tmp[i] % mod + mod) % mod * B[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B[i] = 0; }// 乘法逆 void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B[i - 1] = i * A[i] % mod; B[n - 1] = 0; B.length(n); }// 多项式求导 void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B[i] = A[i - 1] * inv(i) % mod; B[0] = 0; B.length(n); }// 多项式积分 poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// 多项式ln函数 void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B[i] = C[i]; for(int i = n; i &lt; len; i++)B[i] = 0; }// 多项式exp函数 const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G[i] = A[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B[i] = (B[i] + G[i] * H[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B[i] = 0; }// 多项式开根 void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I[i] *= k) %= mod; Exp(I, B, n); }// 多项式幂函数 #undef int}using namespace Poly; 含任意模数NTT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313namespace Poly// 使用NTT实现{ #define int long long #define vec vector &lt;int&gt; const int mod = 998244353; // 模数 const int g = 3; // 原根 const int gi = 332748118; // 逆元 const int N = 4e5 + 10; // size int recover[N]; int qpow(int a, int b) { int t = 1; while(b != 0) { if(b &amp; 1)t = t * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return t; }// 快速幂 int inv(int x) { return qpow(x, mod - 2);}// 逆元 void init(int n, int m, int &amp;len) { len = 1; int cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt ++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); }// 初始化 void NTT(vec &amp;a, int len, int type) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi, (mod - 1) / (k &lt;&lt; 1)); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % mod; int z = w * a[i + j + k] % mod; a[i + j] = (y + z) % mod; a[i + j + k] = ((y - z) % mod + mod) % mod; w = w * x % mod; } } } if(type == -1) { int iv = inv(len); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % mod; } }// NTT struct poly { vector &lt;int&gt; v; int len; poly(){v.resize(N); len = 0;} void clear(int n){v.clear(); v.resize(N); len = n;} void length(int n){len = n;} friend poly operator + (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = (A.v[i] + B.v[i]) % mod; return A; } friend poly operator - (poly A, poly B) { A.length(max(A.len, B.len)); for(int i = 0; i &lt;= A.len; i++) A.v[i] = ((A.v[i] - B.v[i]) % mod + mod) % mod; return A; } friend poly operator * (poly A, poly B) { int len; init(A.len, B.len, len); NTT(A.v, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) A.v[i] = (A.v[i] * B.v[i]) % mod; NTT(A.v, len, -1); A.len += B.len; return A; } }; vec tmp; void inverse(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = inv(A.v[0]);return;} inverse(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); tmp.clear(); tmp.resize(len); for(int i = 0; i &lt; n; i++) tmp[i] = A.v[i]; NTT(tmp, len, 1), NTT(B.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (2 - B.v[i] * tmp[i] % mod + mod) % mod * B.v[i] % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 乘法逆 void diff(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i - 1] = i * A.v[i] % mod; B.v[n - 1] = 0; B.length(n); }// 多项式求导 void integ(poly &amp;A, poly &amp;B, int n) { for(int i = 1; i &lt; n; i++) B.v[i] = A.v[i - 1] * inv(i) % mod; B.v[0] = 0; B.length(n); }// 多项式积分 poly C, D, E, F, G, H, I; void Ln(poly &amp;A, poly &amp;B, int n) { E.clear(n); F.clear(n); diff(A, E, n); inverse(A, F, n); E = E * F; integ(E, B, n); B.length(n); }// 多项式ln函数 void Exp(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Exp(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); C.clear(n); D.clear(n); C.v[0] = 1; Ln(B, D, n); C = B * (C + A - D); for(int i = 0; i &lt; n; i++)B.v[i] = C.v[i]; for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式exp函数 const int inv2 = inv(2); void Sqrt(poly &amp;A, poly &amp;B, int n) { if(n == 1){B.v[0] = 1; return;} Sqrt(A, B, (n + 1) &gt;&gt; 1); int len; init(n, n, len); G.clear(n); H.clear(n); inverse(B, H, n); for(int i = 0; i &lt; n; i++)G.v[i] = A.v[i]; NTT(H.v, len, 1), NTT(B.v, len, 1), NTT(G.v, len, 1); for(int i = 0; i &lt; len; i++) B.v[i] = (B.v[i] + G.v[i] * H.v[i] % mod) % mod * inv2 % mod; NTT(B.v, len, -1); for(int i = n; i &lt; len; i++)B.v[i] = 0; }// 多项式开根 void Pow(poly &amp;A, poly &amp;B, int n, int k) { I.clear(n); Ln(A, I, n); for(int i = 0; i &lt; n; i++)(I.v[i] *= k) %= mod; Exp(I, B, n); }// 多项式幂函数 #undef int namespace anyNTT // 任意模数NTT { #define int __int128 int read() { int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){if(ch == '-')f = -1; ch = getchar();} while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){x = x*10 + ch-'0'; ch = getchar();} return x * f; } void write(int x) { char ch[100]; int len = 0; if(x == 0)ch[++len] = '0'; while(x)ch[++len] = x%10 + '0', x /= 10; while(len)putchar(ch[len--]); printf(&quot; &quot;); } int p[3] = {469762049, 998244353, 1004535809}; int qpow(int a, int b, int i) { int t = 1; while(b != 0) { if(b &amp; 1) t = t * a % p[i]; a = a * a % p[i]; b &gt;&gt;= 1; } return t % p[i]; } int inv(int x, int i) { return qpow(x, p[i] - 2, i); } int gi[3]; void init() { for(int i = 0; i &lt; 3; i++) gi[i] = inv(g, i); } int F[N], G[N], H[N]; int recover[N]; void NTT(int *a, int len, int type, int f) { for(int i = 0; i &lt; len; i++) if(i &lt; recover[i])swap(a[i], a[recover[i]]); for(int k = 1; k &lt; len; k &lt;&lt;= 1) { int x = qpow(type == 1 ? g : gi[f], (p[f] - 1) / (k &lt;&lt; 1), f); for(int i = 0; i &lt; len; i += (k &lt;&lt; 1)) { int w = 1; for(int j = 0; j &lt; k; j++) { int y = a[i + j] % p[f]; int z = w * a[i + j + k] % p[f]; a[i + j] = (y + z) % p[f]; a[i + j + k] = (y - z + p[f]) % p[f]; w = w * x % p[f]; } } } if(type == -1) { int iv = inv(len, f); for(int i = 0; i &lt; len; i++) a[i] = a[i] * iv % p[f]; } } int A[N], B[N], C[3][N]; void CRT(int len) { int M = p[0] * p[1]; for(int i = 0; i &lt;= len; i++) { H[i] = (p[1] * C[0][i] % M * inv(p[1], 0) % M + p[0] * C[1][i] % M * inv(p[0], 1) % M) % M; } } int n, m, mod; void merge(int len) { for(int i = 0; i &lt;= len; i++) { int k = ((C[2][i] - H[i]) % p[2] + p[2]) % p[2] * inv(p[0] * p[1], 2) % p[2]; H[i] = ((k * p[0] * p[1] % mod + H[i] % mod) % mod + mod) % mod; } } void prework() { memcpy(A, F, sizeof(F)); memcpy(B, G, sizeof(G)); } void update(int x, int len) { for(int i = 0; i &lt; len; i++) C[x][i] = A[i] * B[i] % p[x]; } void anyNTT(poly F, poly G, poly &amp;H, int p) { init(); mod = (int)p; for(int i = 0; i &lt; F.len; i++) anyNTT::F[i] = (int)F.v[i]; for(int i = 0; i &lt; G.len; i++) anyNTT::G[i] = (int)G.v[i]; n = F.len, m = G.len; int len = 1, cnt = 0; while(len &lt;= (n + m))len &lt;&lt;= 1, cnt++; for(int i = 0; i &lt; len; i++) recover[i] = (recover[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); for(int i = 0; i &lt; 3; i++) { prework(); NTT(A, len, 1, i), NTT(B, len, 1, i); update(i, len); NTT(C[i], len, -1, i); } CRT(n + m); merge(n + m); for(int i = 0; i &lt;= (n + m); i++) H.v[i] = (long long)anyNTT::H[i]; } } #undef int}using namespace Poly;","link":"/2022/09/30/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90/"},{"title":"反演变换","text":"用的好像很少，毕竟是数竞知识。 反演变换 前言 反演变换适用于题目中出现多个圆或直线之间的相切关系的情况，反演变换可以有效简便的解决这类问题。 定义 设在平面内给定一点OOO和常数kkk，对于平面内任意一AAA，确定A′A'A′，使A′A'A′为直线OAOAOA上一点，并且OA⃗⋅OA′⃗=k\\vec{OA} \\cdot \\vec{OA'} = kOA⋅OA′=k，我们称这种变换为反演变换，点OOO即为反演中心A′A'A′为AAA关于点OOO的反演点。 反演变换本质上是属于平移，旋转，反射一类的几何变换。 以OOO点为圆心，∣k∣\\sqrt{|k|}∣k∣​为半径作圆，就得到了一个圆的反演变换： 接下来讨论其相关性质。 性质 性质1 反演变换可逆 对于定义里的描述，A′A'A′为AAA关于OOO点的反演点，同时就有AAA是关于A′A'A′的反演点。 性质2 在圆内的点其反演点一点在圆外 在圆外的点其反演点一定在圆内 在圆上的点的反演点与其在同一个位置 观察图形很容易得到的性质。 接下来引入一些几何图形关于圆的反演。 性质3 过反演中心的直线其反演后为自身 不过反演中心的直线，反演后为过反演中心的圆 也许需要证明？也挺好推的，设反演中心为原点，直线解析式为y=k1x+by = k_1 x+by=k1​x+b，反演得到的线段为y=k2xy = k_2xy=k2​x，可以推得交点为bk2−k1\\frac{b}{k2-k1}k2−k1b​，设为ccc，再设交点的反演点为(x,k2x)(x,k_2x)(x,k2​x)，再根据反演的定义得(c2+k22c2)(x2+k2x2)=r4(c^2 + k_2^2 c^2)(x^2 + k^2x^2) = r^4(c2+k22​c2)(x2+k2x2)=r4,拆开后去掉常数项，会得到一个xy+y2=C(C∈R)x^y + y^2 = C \\quad (C\\in \\mathbb{R})xy+y2=C(C∈R)的圆的方程。 性质4 不过反演中心的圆，其反演后仍为一个不过反演中心的圆 过反演中心的圆，其反演后为不过反演中心的一条直线 证明的话依然是利用解析式去证明，和上个性质证明过程没有太大区别。 性质5 两条直线或曲线的夹角大小在反演变换下是不变的。 体现了反演的反向保角性 性质6 两个圆相切，它们的反演图形也相切 （易证） 后记 现在你可以去尝试暴切CMO了","link":"/2022/08/17/%E5%8F%8D%E6%BC%94%E5%8F%98%E6%8D%A2/"},{"title":"常系数齐次线性递推","text":"初探常系数齐次线性递推 常系数齐次线性递推 定义 设有数列a0,a1,a2,⋯ ,ana_0, a_1, a_2, \\cdots , a_na0​,a1​,a2​,⋯,an​满足线性关系, an=∑i=1kan−i×fia_n= \\sum_{i = 1} ^ k a_{n-i} \\times f_i an​=i=1∑k​an−i​×fi​ 则称这个数列满足kkk阶齐次线性递推关系。 矩阵乘法 设有一个满足齐次线性递推关系的数列aaa， 满足上述定义，现在求ana_nan​。 假设现在维护一个列矩阵，行数为kkk， A=(anan−1⋯an−k+2an−k+1)A = \\begin{pmatrix}a_n\\\\a_{n-1}\\\\ \\cdots \\\\ a_{n-k+2} \\\\ a_{n-k + 1} \\end{pmatrix} A=⎝⎜⎜⎜⎜⎛​an​an−1​⋯an−k+2​an−k+1​​⎠⎟⎟⎟⎟⎞​ 设 M=(f1f2f3⋯fk−2fk−1100⋯00010⋯00⋯⋯⋯⋯⋯⋯000010)M = \\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix} M=⎝⎜⎜⎜⎜⎛​f1​10⋯0​f2​01⋯0​f3​00⋯0​⋯⋯⋯⋯0​fk−2​00⋯1​fk−1​00⋯0​⎠⎟⎟⎟⎟⎞​ 就可得 (f1f2f3⋯fk−2fk−1100⋯00010⋯00⋯⋯⋯⋯⋯⋯000010)×(an−1an−2⋯an−k+1an−k)=(anan−1⋯an−k+2an−k+1)\\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix} \\times \\begin{pmatrix} a_{n-1}\\\\ a_{n-2}\\\\ \\cdots \\\\ a_{n-k+1} \\\\ a_{n-k} \\end{pmatrix} = \\begin{pmatrix} a_{n}\\\\ a_{n-1}\\\\ \\cdots \\\\ a_{n-k+2} \\\\ a_{n-k+1} \\end{pmatrix} ⎝⎜⎜⎜⎜⎛​f1​10⋯0​f2​01⋯0​f3​00⋯0​⋯⋯⋯⋯0​fk−2​00⋯1​fk−1​00⋯0​⎠⎟⎟⎟⎟⎞​×⎝⎜⎜⎜⎜⎛​an−1​an−2​⋯an−k+1​an−k​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​an​an−1​⋯an−k+2​an−k+1​​⎠⎟⎟⎟⎟⎞​ 接下来用矩阵快速幂就可以做到O(k3log2n)O(k^3log_2 n)O(k3log2​n)了 (f1f2f3⋯fk−2fk−1100⋯00010⋯00⋯⋯⋯⋯⋯⋯000010)n×(ak−1ak−2⋯a1a0)=(an+k−1an+k−2⋯an+1an)\\begin{pmatrix} f_1&amp;f_2&amp;f_3&amp;\\cdots&amp;f_{k-2}&amp;f_{k-1} \\\\ 1&amp;0&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;\\cdots&amp;0&amp;0 \\\\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\\\ 0&amp;0&amp;0&amp;0&amp;1&amp;0 \\end{pmatrix}^n \\times \\begin{pmatrix} a_{k-1}\\\\ a_{k-2}\\\\ \\cdots \\\\ a_{1} \\\\ a_{0} \\end{pmatrix} = \\begin{pmatrix} a_{n+k-1}\\\\ a_{n+k-2}\\\\ \\cdots \\\\ a_{n+1} \\\\ a_{n} \\end{pmatrix} ⎝⎜⎜⎜⎜⎛​f1​10⋯0​f2​01⋯0​f3​00⋯0​⋯⋯⋯⋯0​fk−2​00⋯1​fk−1​00⋯0​⎠⎟⎟⎟⎟⎞​n×⎝⎜⎜⎜⎜⎛​ak−1​ak−2​⋯a1​a0​​⎠⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎛​an+k−1​an+k−2​⋯an+1​an​​⎠⎟⎟⎟⎟⎞​ 特征多项式 咕咕咕。","link":"/2022/09/03/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"title":"并查集","text":"浅谈并查集 并查集 并查集（冰茶姬Disjoint−SetDisjoint-SetDisjoint−Set）是一种树形的数据结构，它可以处理一些不交集的合并以及查询问题。主要为两种操作： 查找（Find）：确定某个元素处于哪个子集； 合并（Merge）：将两个子集合并成一个集合。 初始化 12345void makeSet(int size) { for (int i = 0; i &lt; size; i++) fa[i] = i; // i就在它本身的集合里 return;} 查找 通俗地讲一个故事：几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。 在这样的思想下，并查集的查找算法诞生了。 123456789int fa[MAXN]; // 记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己int find(int x) { // 寻找x的祖先 if (fa[x] == x) // 如果x是祖先则返回 return x; else return find(fa[x]); // 如果不是则x的爸爸问x的爷爷} 路径压缩 一层一层的找父亲效率太低了，所以我们直接把在路径上的每个节点都直接连接到根上，这就是路径压缩。 123456int find(int x) { if (x != fa[x]) // x不是自身的父亲，即x不是该集合的代表 fa[x] = find(fa[x]); // 查找x的祖先直到找到代表,于是顺手路径压缩 return fa[x];} 合并 宴会上，一个家族的祖先突然对另一个家族说：我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。 我们之前说过，并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。 1234567void MergeSet(int x, int y) { // x 与 y 所在家族合并 x = find(x); y = find(y); fa[x] = y; // 把 x 的祖先变成 y 的祖先的儿子} 启发式合并 (奇技淫巧) 在合并集合时，无论将哪一个集合连接到另一个集合的下面，都能得到正确的结果。但不同的连接方法存在时间复杂度的差异。 所以合并时利用点数和深度的估价函数来降低时间复杂度。 “秩”：树的深度(未路径压缩) / 集合大小 。均摊复杂度 O(logN)O(logN)O(logN)。 1234567891011121314151617181920212223//记录并初始化子树的大小为 1void MergeSet(int x, int y) { int x=find(x), y=find(y); if (x==y) return; if (size[x] &gt; size[y]) // 保证小的合到大的里 swap(x, y); fa[x] = y; size[y] += size[x];}//按大小合并int depth[maxn];// 深度void MergeSet(int x, int y) { int x=find(x),y=find(y) if(depth[x]&lt;depth[y])fa[x]=y; if(depth[x]&gt;depth[y])fa[y]=x; if(depth[x]==depth[y]) { depth[y]++; fa[x]=y; }// 深度小的合并到深度大的集合里}//按秩合并 同时采用 “路径压缩” 和 “按秩合并” 优化的并查集， 每次Get操作复杂度可进一步降低到O(α(N))O(α(N))O(α(N))(一个比对数函数增长还慢的函数，对于∀N⩽221019729\\forall N \\leqslant 2^{2^{10^{19729}}}∀N⩽221019729，都有α(N)&lt;5\\alpha(N)&lt;5α(N)&lt;5，故α(N)\\alpha(N)α(N)，可近似看成一个常数，由著名计算机科学家R.E.Tarjan于1975年发表的论文中给出了证明)。 带权并查集 并查集其实就是一个森林，我们可以在树上的每条边上记录一个权值，维护一个数组ddd,用d[x]d[x]d[x]保存节点xxx到父节点fa[x]fa[x]fa[x]之间的边权，在路径压缩的同时不断更新ddd数组。 1234567int find(int x){ if(x==fa[x])return x; int root=find(fa[x]); // 求集合代表 d[x]+=d[fa[x]]; // 边权求和，维护d数组 return fa[x]=root; // 路径压缩} 并查集的应用 并查集能在一张无向图中维护节点之间的连通性，这是并查集的一个基本用途，实际上，并查集可以动态维护具有传递性的关系。 最小生成树算法中的KruskalKruskalKruskal和最近公共祖先中的TarjanTarjanTarjan算法都是基于并查集的算法。 例题🚀️ luoguP1196 银河英雄传说 这道题呢就是用到了带权并查集，在本题中我们可以把每两号相邻的战舰之间的权值看为111。 两号战舰之间的战舰数目，其实就是第iii号战舰的深度与第jjj号战舰的深度的差的绝对值-111。 并且我们还需要用一个sizesizesize数组去存每个集合的大小，去更新每个点的深度。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int T,f[30010],dep[30010],size[30010];int find(int x){ if(x==f[x])return x; int fn=find(f[x]); dep[x]+=dep[f[x]];// 更新权值 return f[x]=fn;}// 查找集合代表void Union(int x,int y){ x=find(x); y=find(y); dep[x]+=size[y]; f[x]=y; size[y]+=size[x]; size[x]=0;// 这一列上已经没有战舰 return;}// 合并int main(){ scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=30000;i++)f[i]=i,size[i]=1;// 初始化每个集合的代表为自己，每一列上只有一艘战舰 while(T!=0) { T--; char a;int b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a=='M')Union(b,c); if(a=='C') { if(find(b)!=find(c))printf(&quot;-1\\n&quot;);// 不在同一列，输出-1 else printf(&quot;%d\\n&quot;,abs(dep[b]-dep[c])-1);// 计算有多少艘战舰 } } return 0;} luoguP2502 旅行 这是一道枚举加并查集，首先我们可以先把每条边按速度从大到小排序然后去枚举最大边和最小边，使速度比最小。 枚举的同时不断加边，用并查集来判断起点和终点是否联通,输出时不要忘记分子分母同除最大公因数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm=5e3+10;int n,m,s,t,f[510],xl,yl;double Min=2147483647;struct node{ int u,v,c;};// 结构体存边node edge[maxm];int _find(int x){ if(x==f[x])return x; return f[x]=_find(f[x]);}// 查找集合代表void _union(int x,int y){ x=_find(x); y=_find(y); f[x]=y; return;}// 合并int cmp(node x,node y){ return x.c&gt;y.c;}// 排序int gcd(int x,int y){ if(y==0)return x; return gcd(y,x%y);}// 求最大公因数，辗转相除法int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].c); _union(edge[i].u,edge[i].v); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); if(_find(s)!=_find(t)) { printf(&quot;IMPOSSIBLE&quot;); return 0; }// 如果把所有边加入后起点终点不连通，输出IMPOSSIBLE sort(edge+1,edge+m+1,cmp); for(int i=1;i&lt;=m;i++)// 枚举最大边 { for(int j=1;j&lt;=n;j++)f[j]=j; for(int j=i;j&lt;=m;j++)// 枚举最小边 { _union(edge[j].u,edge[j].v); if(_find(s)==_find(t)) { double tim=(1.0*edge[i].c)/(1.0*edge[j].c); if(tim&lt;Min) { xl=edge[i].c; yl=edge[j].c; Min=tim;// 找最小速度比 } break; } } } if(gcd(xl,yl)==yl)cout&lt;&lt;xl/yl; else cout&lt;&lt;xl/gcd(xl,yl)&lt;&lt;'/'&lt;&lt;yl/gcd(xl,yl);// 输出 return 0;} luoguP1955 程序自动分析 题目读起来很简单，只需要先用并查集处理是等于的约束条件，之后在处理不等于的条件，如果不等于的两个数在同一联通块就输出NONONO，否则输出YESYESYES。 但是本题的数据范围过大，无法把输入的xxx作为数组下标存储，所以我们需要用到离散化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int t,f[maxn],book[maxn*2];struct node{ int a,b,e;};int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ x=Find(f[x]); y=Find(f[y]); f[x]=y; return;}int cmp(node x,node y){ return x.e&gt;y.e;}int main(){ scanf(&quot;%d&quot;,&amp;t); while(t!=0) { t--; int n,tot=0; scanf(&quot;%d&quot;,&amp;n); node p[maxn]; for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d&quot;,&amp;p[i].a,&amp;p[i].b,&amp;p[i].e); book[++tot]=p[i].a; book[++tot]=p[i].b; } sort(book+1,book+tot+1); int indx=unique(book+1,book+tot+1)-book-1; for(int i=1;i&lt;=n;i++) { p[i].a=lower_bound(book+1,book+indx+1,p[i].a)-book; p[i].b=lower_bound(book+1,book+indx+1,p[i].b)-book; } bool k=true; for(int i=1;i&lt;=indx;i++)f[i]=i; sort(p+1,p+n+1,cmp); for(int i=1;i&lt;=n;i++) { if(p[i].e==1) Union(p[i].a,p[i].b); else { if(Find(p[i].a)==Find(p[i].b)) { cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; k=false; break; } } } if(k==true)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; } return 0;} luoguP2024 食物链 这是一道种类并查集，需要分析清楚AAA种群，BBB种群，CCC种群之间的关系。 首先这三个种群之间的关系只有同类、猎物和天敌，这三种，所以我们可以开一个三倍的并查集，一倍存同类，二倍存猎物，三倍存天敌，然后不断去判断就好了，具体看代码注释（用到了拓展域的并查集）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int n,k,f[maxn*3],ans;int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ f[Find(f[x])]=Find(f[y]); return;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n*3;i++)f[i]=i; for(int i=1;i&lt;=k;i++) { int flag,x,y; scanf(&quot;%d%d%d&quot;,&amp;flag,&amp;x,&amp;y); if(x&gt;n||y&gt;n) { ans++;continue; }// 如果不在当前食物链范围内，就是假话 if(flag==1) { if(Find(x+n)==Find(y)||Find(x+2*n)==Find(y)) { ans++;continue; }// 如果x是y的猎物或天敌，为假话 Union(x,y);Union(x+n,y+n);Union(x+2*n,y+2*n); // 如果是真，x的同类就是y的同类，x的猎物就是y的猎物，x的天敌就是y的天敌 } else { if(x==y) { ans++;continue; } if(Find(x)==Find(y)||Find(x)==Find(y+n)) { ans++;continue; }// 如果x是y的同类或猎物为假话 Union(x+n,y);Union(x+2*n,y+n);Union(x,y+2*n); // 如果为真，x的猎物就是y的同类，x的天敌就是y的猎物，x的同类就是y的天敌 } } printf(&quot;%d&quot;,ans); return 0;} luoguP1197 星球大战 如果我们正着按顺序去摧毁，显然在时间复杂度上不允许，所以我们可以去使用逆向思维，把摧毁改为修建再利用并查集判断联通性就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=4e5+10;int n,k,m,b[maxn],B[maxn],f[maxn];int tot,ans[maxn];vector&lt;int&gt; mp[maxn];int Find(int x){ if(x==f[x])return x; return f[x]=Find(f[x]);}void Union(int x,int y){ f[Find(f[x])]=Find(f[y]);}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) { int x,y;cin&gt;&gt;x&gt;&gt;y; mp[x].push_back(y); mp[y].push_back(x); }// 存双向图 cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;b[i]; B[b[i]]=1; }// 标记是否被摧毁 tot=n-k;// 摧毁后有几个联通块 for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;mp[i].size();j++) { if(!B[i]&amp;&amp;!B[mp[i][j]]&amp;&amp;Find(i)!=Find(mp[i][j]))// 如果没有被摧毁合并 { tot--;// 每减一条边联通块-1 Union(i,mp[i][j]); } } }// 建好摧毁后的联通块 ans[k+1]=tot; for(int i=k;i&gt;=1;i--) { tot++;B[b[i]]=0;// 修建 for(int j=0;j&lt;mp[b[i]].size();j++) { if(!B[mp[b[i]][j]]&amp;&amp;Find(b[i])!=Find(mp[b[i]][j])) { tot--; Union(b[i],mp[b[i]][j]); } } ans[i]=tot; } for(int i=1;i&lt;=k+1;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; return 0;} 可持久化并查集 并查集作为一个数据结构，也是有可持久化版本的。 顾名思义，可持久化并查集=可持久化+并查集=可持久化数组+并查集=主席树+并查集。👀️ 首先，因为需要记录历史版本，所以路径压缩显然是不能用的； 其次，为了让并查集的高度尽量保持平衡，我们需要用到按秩合并。（如果并查集退化到一条链的情况下，效率会非常低） 可持久化并查集的操作有以下几种： 回到历史版本（毕竟是可持久化数组）； 合并（毕竟是并查集）； 查询祖先。 对于第一个操作： 1root[i]=root[k]; 对于第二个操作：其实就是按秩合并； 对于第三个操作：在可持续化数组中查询。 初始建树 12345678910111213int build(int l,int r){ cnt++;int p=cnt; if(l==r) { t[p].fa=l; return p; } int mid=(l+r)&gt;&gt;1; t[p].ls=build(l,mid); t[p].rs=build(mid+1,r); return p;} 合并 1234567891011121314int merge(int now,int l,int r,int fat,int son){ cnt++;int p=cnt; t[p]=t[now]; if(l==r) { t[p].fa=fat; return p; } int mid=(l+r)&gt;&gt;1; if(son&lt;=mid)t[p].ls=merge(t[p].ls,l,mid,fat,son); else t[p].rs=merge(t[p].rs,mid+1,r,fat,son); return p;} 按秩合并的修改深度 1234567891011void add(int p,int l,int r,int x){ if(l==r) { t[p].depth++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)add(t[p].ls,l,mid,x); else add(t[p].rs,mid+1,r,x);} 得到元素在当前版本的元素编号 1234567int get_indx(int p,int l,int r,int x){ if(l==r)return p; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return get_indx(t[p].ls,l,mid,x); else return get_indx(t[p].rs,mid+1,r,x);} 查询祖先 123456int find(int now,int x){ int father=get_indx(now,1,n,x); if(x==t[father].fa)return father; return find(now,t[father].fa);} 最后放一下完整代码吧（QWQ）。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm=2e5+10;int n,m,root[maxm],cnt;struct TREE{ int ls,rs,fa,depth;}t[maxm&lt;&lt;5];int build(int l,int r){ cnt++;int p=cnt; if(l==r) { t[p].fa=l; return p; } int mid=(l+r)&gt;&gt;1; t[p].ls=build(l,mid); t[p].rs=build(mid+1,r); return p;}void add(int p,int l,int r,int x){ if(l==r) { t[p].depth++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)add(t[p].ls,l,mid,x); else add(t[p].rs,mid+1,r,x);}int get_indx(int p,int l,int r,int x){ if(l==r)return p; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return get_indx(t[p].ls,l,mid,x); else return get_indx(t[p].rs,mid+1,r,x);}int find(int now,int x){ int father=get_indx(now,1,n,x); if(x==t[father].fa)return father; return find(now,t[father].fa);}int merge(int now,int l,int r,int fat,int son){ cnt++;int p=cnt; t[p]=t[now]; if(l==r) { t[p].fa=fat; return p; } int mid=(l+r)&gt;&gt;1; if(son&lt;=mid)t[p].ls=merge(t[p].ls,l,mid,fat,son); else t[p].rs=merge(t[p].rs,mid+1,r,fat,son); return p;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); root[0]=build(1,n); for(int i=1;i&lt;=m;i++) { int opt;scanf(&quot;%d&quot;,&amp;opt); if(opt==1) { int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); root[i]=root[i-1]; int f1=find(root[i],a); int f2=find(root[i],b); if(t[f1].fa==t[f2].fa)continue; if(t[f1].depth&gt;t[f2].depth)swap(f1,f2); root[i]=merge(root[i-1],1,n,t[f2].fa,t[f1].fa); if(t[f1].depth==t[f2].depth)add(root[i],1,n,t[f2].fa); } if(opt==2) { int k;scanf(&quot;%d&quot;,&amp;k); root[i]=root[k]; } if(opt==3) { int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); root[i]=root[i-1]; int f1=find(root[i],a); int f2=find(root[i],b); if(t[f1].fa==t[f2].fa)printf(&quot;1\\n&quot;); else printf(&quot;0\\n&quot;); } } return 0;} 拓展—可持久化带权并查集 可持久化并查集+边带权（逃）。 最后附上我的题单。 完结撒花~~（终于写完了）🎉️ 🎉️ 🎉️ PS： （一些资料和图例参考自OIwiki和算法竞赛进阶指南QwQ~,不喜勿喷）","link":"/2022/06/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"快速傅里叶变换","text":"初探多项式 快速傅里叶变换 前置知识 复数 1.前言 快速傅里叶变换是用来加速多项式乘法的，对于两个多项式 AAA 和BBB ，朴素计算时的n2n^2n2是满足不了需求的,快速傅里叶变换可以在O(log⁡n)O(\\log n)O(logn)的时间内计算A×BA \\times BA×B 。 先看一下单位元的几个性质，在接下来的算法中有很大的用途。 ωnk=e2πikn(1,1)\\tag{1,1} \\omega_n^k = e ^{\\frac{2 \\pi i k}{n}} ωnk​=en2πik​(1,1) ωdndk=ωnk(1,2)\\tag{1,2} \\omega_{dn}^{dk} = \\omega_n^k ωdndk​=ωnk​(1,2) ωnk=a+biωn−k=a−bi(1,3)\\tag{1,3} \\omega_{n}^k = a+bi \\\\ \\omega_{n}^{-k} = a-bi ωnk​=a+biωn−k​=a−bi(1,3) ωnk+n2=−ωnk(1,4)\\tag{1,4} \\omega_n^{k+ \\frac{n}{2}} = - \\omega_n^k ωnk+2n​​=−ωnk​(1,4) 以上变换均可由欧拉公式 eiθ=cos⁡θ+i⋅sin⁡θe^{i \\theta}= \\cos\\theta + i \\cdot \\sin\\thetaeiθ=cosθ+i⋅sinθ 推得。 2.离散傅里叶变换 离散傅里叶变换(DFT) 主要是利用分治思想， 首先将多项式 A(x)=∑i=0naixi(2,1)\\tag{2,1} A(x) = \\sum_{i=0} ^n a_i x^i A(x)=i=0∑n​ai​xi(2,1) 其系数进行奇偶性分类，得到， A0(x)=a0+a2x1+a4x2+⋯A1(x)=a1+a3x1+a5x2+⋯(2,2)\\tag{2,2} A_0(x)= a_0+a_2 x^1 +a_4 x^2 + \\cdots \\\\ A_1(x)= a_1+a_3 x^1 +a_5 x^2 + \\cdots \\\\ A0​(x)=a0​+a2​x1+a4​x2+⋯A1​(x)=a1​+a3​x1+a5​x2+⋯(2,2) 所以我们可以表示为 ： A(x)=A0(x2)+x⋅A1(x2)(2,3)\\tag{2,3} A(x) = A_0 (x^2) +x \\cdot A_1(x^2) A(x)=A0​(x2)+x⋅A1​(x2)(2,3) 将 ωnk\\omega_n^kωnk​ 与 ωnk+n2\\omega_n^{k+ \\frac{n}{2}}ωnk+2n​​代入得： {A(ωnk)=A(ωn2k)+ωnkA1(ωn2k)A(ωnk+n2)=A(ωn2k)−ωnkA1(ωn2k)(2,4)\\tag{2,4} \\left\\{ \\begin{aligned} &amp;A(\\omega_n^k) &amp;= &amp;A(\\omega_n^{2k})+\\omega_n^k A_1(\\omega_n^{2k}) \\\\ &amp;A(\\omega_n^{k+ \\frac{n}{2}}) &amp;= &amp;A(\\omega_n^{2k})-\\omega_n^k A_1(\\omega_n^{2k}) \\\\ \\end{aligned} \\right. {​A(ωnk​)A(ωnk+2n​​)​==​A(ωn2k​)+ωnk​A1​(ωn2k​)A(ωn2k​)−ωnk​A1​(ωn2k​)​(2,4) 同时我们可以发现两个式子只有常数一样，递归计算即可。 时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn) 。 在这里我们将系数变成了点值 3. 离散傅里叶逆变换 离散傅里叶逆变换IDFT 可以将点值快速转化为系数，从而得出结果多项式。 需要用到单位根的一个性质： 1n∑i=0n−1ωnx∗i=[x mod n=0]\\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i} = [x \\bmod n =0] n1​i=0∑n−1​ωnx∗i​=[xmodn=0] 证明 ： 由于 ωnx∗i=ωnx∗(i−1)∗ωnx\\omega_n ^ {x \\ast i} = \\omega_n^ {x \\ast (i-1)} \\ast \\omega_n^xωnx∗i​=ωnx∗(i−1)​∗ωnx​ 所以ωnx∗i\\omega _n ^{x\\ast i}ωnx∗i​ 为等比数列 ∴1n∑i=0n−1ωnx∗i={1n∑i=0n−11i=nn=1x mod n=01n⋅1−ωnn∗x1−ωnx=1n⋅1−1x1−ωnx=0x mod n≠0(3,1)\\tag{3,1} \\therefore \\frac{1}{n} \\sum_{i=0}^{n-1} \\omega_n^{x \\ast i}= \\left\\{ \\begin{aligned} &amp;\\frac{1}{n} \\sum_{i=0}^{n-1} 1^i = \\frac{n}{n} = 1 &amp; x \\bmod n=0\\\\ &amp;\\frac{1}{n} \\cdot \\frac{1- \\omega _n ^ {n \\ast x}}{1-\\omega _n ^ x} = \\frac{1}{n} \\cdot \\frac{1-1^x}{1-\\omega_n^x} =0 &amp; x\\bmod n \\ne 0 \\end{aligned} \\right. ∴n1​i=0∑n−1​ωnx∗i​=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​n1​i=0∑n−1​1i=nn​=1n1​⋅1−ωnx​1−ωnn∗x​​=n1​⋅1−ωnx​1−1x​=0​xmodn=0xmodn​=0​(3,1) 证明： 设c=a∗bci=∑j=0iaj⋅bi−j=∑p=0∑q=0ap⋅bq[(p+q) mod n=0]nci=∑p=0∑q=0ap⋅bq∑j=0ωn(p+q−i)j=∑j=0ωn(−i)j(∑p=0ωnpjap)(∑q=0ωnqjbq)设fa(j)=∑i=0ωnijai,fa−1(j)=∑i=0ωn(−i)jainci=∑j=0ωn(−i)jfa(j)fb(j)=∑j=0ωn(−i)jfc(j)=ffc−1(i)(3,2)\\tag{3,2} 设 c= a\\ast b \\\\ \\begin{aligned} c_i &amp;= \\sum_{j=0}^i a_j \\cdot b_{i-j} \\\\ &amp;=\\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q [(p+q) \\bmod n=0] \\\\ nc_i &amp;= \\sum_{p=0}\\sum_{q=0} a_p \\cdot b_q \\sum_{j=0} \\omega_n^{(p+q-i)j}\\\\ &amp;= \\sum_{j=0}\\omega_n^{(-i)j} \\bigg( \\sum_{p=0} \\omega_n^{pj} a_p\\bigg) \\bigg( \\sum_{q=0} \\omega_n^{qj} b_q\\bigg) \\end{aligned} \\\\ 设 f_a(j) = \\sum_{i=0} \\omega_n^{ij} a_i , f_a^{-1}(j) =\\sum_{i=0} \\omega_n^{(-i)j} a_i \\\\ \\begin{aligned} nc_i &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_a(j)f_b(j) \\\\ &amp;= \\sum_{j=0} \\omega_n^{(-i)j}f_c(j) \\\\ &amp;= f_{f_c}^{-1} (i) \\end{aligned} 设c=a∗bci​nci​​=j=0∑i​aj​⋅bi−j​=p=0∑​q=0∑​ap​⋅bq​[(p+q)modn=0]=p=0∑​q=0∑​ap​⋅bq​j=0∑​ωn(p+q−i)j​=j=0∑​ωn(−i)j​(p=0∑​ωnpj​ap​)(q=0∑​ωnqj​bq​)​设fa​(j)=i=0∑​ωnij​ai​,fa−1​(j)=i=0∑​ωn(−i)j​ai​nci​​=j=0∑​ωn(−i)j​fa​(j)fb​(j)=j=0∑​ωn(−i)j​fc​(j)=ffc​−1​(i)​(3,2) 因为 faf_afa​ 就是 aaa 在 DFT 后的结果，所以fa−1f_a^{-1}fa−1​就是 对应的IDFT，最后除以对应长度nnn，即为所求。 4.代码实现 在写FFT 时可以将DFT和IDFT合在一起这样会更简便，同时使用位逆序变换，更加简便快捷。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e7+10;const double pi=acos(-1.0);struct Complex{ double a,b; Complex(double x=0,double y=0):a(x),b(y) {} friend Complex operator + (Complex x,Complex y){ return Complex(x.a+y.a,x.b+y.b); } friend Complex operator - (Complex x,Complex y){ return Complex(x.a-y.a,x.b-y.b); } friend Complex operator * (Complex x,Complex y){ return Complex(x.a*y.a-x.b*y.b,x.b*y.a+y.b*x.a); }};int n,m,recover[maxn];Complex F[maxn],G[maxn],H[maxn];void FFT(Complex *a,int len,int type){ for(int i=0;i&lt;len;i++) if(i&lt;recover[i])swap(a[i],a[recover[i]]); for(int k=1;k&lt;len;k&lt;&lt;=1) { Complex x(cos(pi/k),type*sin(pi/k)); for(int i=0;i&lt;len;i+=(k&lt;&lt;1)) { Complex w(1,0); for(int j=0;j&lt;k;j++) { Complex y=a[i+j]; Complex z=w*a[i+j+k]; a[i+j]=y+z;a[i+j+k]=y-z; w=w*x; } } } if(type==-1) for(int i=0;i&lt;len;i++)a[i].a/=len;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) { double x; scanf(&quot;%lf&quot;,&amp;x); F[i].a=x; } for(int i=0;i&lt;=m;i++) { double x; scanf(&quot;%lf&quot;,&amp;x); G[i].a=x; } int len=1,cnt=0; while(len&lt;=(n+m))len&lt;&lt;=1,cnt++; for(int i=0;i&lt;len;i++) recover[i]=(recover[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(cnt-1)); FFT(F,len,1);FFT(G,len,1); for(int i=0;i&lt;=len;i++)H[i]=F[i]*G[i]; FFT(H,len,-1); for(int i=0;i&lt;=n+m;i++) printf(&quot;%d &quot;,(int)(H[i].a+0.5)); return 0;}","link":"/2022/07/21/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"title":"扩展Lucas定理","text":"用的比较多的lucas定理吧 扩展Lucas定理 前置知识 Lucas定理 中国剩余定理 逆元 问题 首先 LucasLucasLucas 和 ExLucasExLucasExLucas 都是用来求解形如： Cnmmod pC^m_n \\mod p Cnm​modp 的问题 对于 ppp 为质数的情况就可以直接用 LucasLucasLucas 来解决，但是对于 ppp 不是质数的话，就需要用到 ExLucasExLucasExLucas 。 求解 由于 ppp 不为质数可以将 ppp 进行质因数分解: （不分解肯定要T飞） p=∏i=1npikip= \\prod_{i=1}^n p_i^{k_i} p=i=1∏n​piki​​ 分解完后由于两两互质可以用中国剩余定理进行合并求解。 进一步化简： Cnmmod pkC^m_n \\mod p^k Cnm​modpk 为： n!m!×(n−m)!mod pk\\dfrac{n!}{m! \\times (n-m)!} \\mod p^k m!×(n−m)!n!​modpk 显然需要求逆元但是分母上的两项不一定与模数互质，不能求出直接的逆元，进行进进一步拆分， 提出 n!n!n! 的中的 ppp 的倍数： n!=p⌊np⌋×⌊np⌋!×∏p∤inin! = p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor} \\times \\left\\lfloor\\frac{n}{p}\\right\\rfloor ! \\times \\prod_{p \\nmid i}^n i n!=p⌊pn​⌋×⌊pn​⌋!×p∤i∏n​i 首先 p⌊np⌋p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor}p⌊pn​⌋ 可以直接快速幂， ⌊np⌋!\\left\\lfloor\\frac{n}{p}\\right\\rfloor ! ⌊pn​⌋! 考虑递归求解，那么后面不能被整除的数该怎么办？ 仔细观察🤔 可以看出，有循环节，那么我们可以这样统计: ((p−1)!)⌊np⌋mod p((p-1)!)^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor} \\mod p ((p−1)!)⌊pn​⌋modp 这里的 p 为模数 p的k次方哦 可以直接统计阶乘再加上一个快速幂，由于有 p⌊np⌋p ^ {\\left\\lfloor\\frac{n}{p}\\right\\rfloor} p⌊pn​⌋ 这一项，不能直接求逆元，应在求组合数时处理。 最后用中国剩余定理合并即为答案。 另外对于统计ppp的指数需要用到一个柿子： ∑i=1⌊npi⌋\\sum_{i=1}\\left\\lfloor\\frac{n}{p^i}\\right\\rfloor \\\\\\\\ i=1∑​⌊pin​⌋ 其实就是统计贡献。 时间复杂度为 O(log⁡n)O(\\log n)O(logn) 级别的 。 题目 这里放上我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int maxn=1e6+10;ll cnt,prime[maxn],b[maxn],tot,pk[maxn];bool vis[maxn];ll qpow(ll a,ll b,ll mod){ ll tot=1; while(b!=0) { if(b&amp;1)tot=(tot*a)%mod; a=a*a%mod;b&gt;&gt;=1; } return tot;}// 快速幂ll fac(ll x,ll p,ll k)// k 为 p的k次方{ if(!x)return 1; ll f=1; for(int i=2;i&lt;=k;i++) if(i%p)f=f*i%k;// 处理循环节 f=qpow(f,x/k,k); for(int i=2;i&lt;=x%k;i++) if(i%p)f=f*i%k;// 多余部分 return f*fac(x/p,p,k)%k;// 计算提出p后的部分}ll sta(ll x,ll p){ ll sum=0; for(ll i=p;i&lt;=x;i*=p)sum+=x/i; return sum;}// 统有多少个因子pvoid exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if(b==0){x=1,y=0;return;} exgcd(b,a%b,x,y); ll z=x;x=y;y=z-a/b*y;}// 扩欧ll inv(ll v,ll p){ ll x,y; exgcd(v,p,x,y); return (x+p)%p;} // 逆元ll C(ll n,ll m,ll p,ll k){ if(n&lt;m)return 0; return fac(n,p,k)%k*inv(fac(m,p,k),k)%k*inv(fac(n-m,p,k),k)%k*qpow(p,sta(n,p)-sta(m,p)-sta(n-m,p),k)%k;}// 组合数ll exlucas(ll n,ll m,ll mod){ ll x=mod; for(int i=2;x!=1;i++) { if(x%i==0) { ll tmp=1; while(x%i==0) { tmp*=i; x/=i; } b[++tot]=C(n,m,i,tmp); pk[tot]=tmp; }//质因数分解，和计算部分答案 } ll ans=0; for(int i=1;i&lt;=tot;i++) { ll Mi=mod/pk[i]; ans=(ans+Mi*b[i]*inv(Mi,pk[i]))%mod; } return ans%mod;}// CRT 合并统计答案int main(){ ll n,m,mod; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;mod); printf(&quot;%lld&quot;,exlucas(n,m,mod)%mod); return 0;} 🙀 🙀 🙀 应用 [国家集训队]礼物 其实就是求： ∏i=1mCn−∑j=1i−1w[j]w[i]mod P\\prod_{i=1}^m C_{n-\\sum_{j=1}^{i-1} w[j]}^{w[i]} \\mod P i=1∏m​Cn−∑j=1i−1​w[j]w[i]​modP 由于 PPP 不为质数所以需要用到 ExLucasExLucasExLucas code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int maxn=1e5+10;ll w[maxn],S[maxn];ll qpow(ll a,ll b,ll p){ ll t=1; while(b!=0) { if(b&amp;1)t=(t*a)%p; a=a*a%p;b&gt;&gt;=1; } return t%p;}ll stac(ll n,ll p){ ll sum=0; for(ll i=p;i&lt;=n;i*=p)sum+=n/i; return sum;}void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if(b==0){x=1,y=0;return;} exgcd(b,a%b,x,y); ll z=x;x=y;y=z-a/b*y;}ll inv(ll v,ll p){ ll x,y; exgcd(v,p,x,y); return(x+p)%p;}ll fact(ll n,ll p,ll k){ if(n==0)return 1; ll res=1; for(ll i=1;i&lt;=k;i++) if(i%p)res=res*i%k; res=qpow(res,n/k,k); for(ll i=1;i&lt;=n%k;i++) if(i%p)res=res*i%k; return res*fact(n/p,p,k)%k;}ll C(ll n,ll m,ll p,ll k){ if(n&lt;m)return 0; return fact(n,p,k)%k*inv(fact(m,p,k),k)%k*inv(fact(n-m,p,k),k)%k*qpow(p,stac(n,p)-stac(m,p)-stac(n-m,p),k)%k;}ll exlucas(ll n,ll m,ll mod){ int k=0; ll x=mod,b[maxn],a[maxn]; for(ll i=2;x!=1;i++) { if(x%i==0) { ll tmp=1; while(x%i==0) { tmp*=i; x/=i; } b[++k]=tmp; a[k]=C(n,m,i,tmp); } } ll ans=0; for(int i=1;i&lt;=k;i++) { ll Mi=mod/b[i]; ans=(ans+Mi*inv(Mi,b[i])*a[i])%mod; } return ans;}int main(){ ll n,m,mod; scanf(&quot;%lld&quot;,&amp;mod); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { scanf(&quot;%lld&quot;,&amp;w[i]); S[i]=S[i-1]+w[i]; } if(S[m]&gt;n) { printf(&quot;Impossible\\n&quot;); return 0; } ll ans=1; for(int i=1;i&lt;=m;i++) ans=(ans*exlucas(n-S[i-1],w[i],mod))%mod; printf(&quot;%lld&quot;,ans); return 0;}","link":"/2022/07/19/%E6%89%A9%E5%B1%95Lucas%E5%AE%9A%E7%90%86/"},{"title":"数值积分","text":"高数必备 数值积分 前置知识 我也不知道为什么突然来到了高等数学，那就胡一下吧，也许主要写的是高等数学？。 tips:以下内容仅供参考，毕竟是胡的 导数 导数(Derivative)，也称为导函数值，又名微商。在数学中发挥着很重要的作用。 导数是函数的局部性质。一个函数在某一点的导数描述了这个函数在这一点附近的变化率。如果函数的自变量和取值都是实数的话，函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率。导数的本质是通过极限的概念对函数进行局部的线性逼近。 ——––baidu 其实通俗的来讲导数就是一个函数的变化率，比较经典的就是二次函数求切线。 假设我们要求某一光滑曲线在MMM点的切线，先在函数图像上取一点NNN，假设直线MTMTMT为MMM点的切线，当∠NMT\\angle {NMT}∠NMT无限小时此时的直线MNMNMN就已经成为切线，设直线MNMNMN的斜率为tan⁡ϕ\\tan \\phitanϕ，有： tan⁡ϕ=f(x)−f(x0)x−x0\\tan \\phi = \\frac{f(x) - f(x_0)}{x-x_0} tanϕ=x−x0​f(x)−f(x0​)​ 当NNN逼近与MMM时， tan⁡ϕ=lim⁡x→x0f(x)−f(x0)x−x0\\tan \\phi = \\lim\\limits_{x \\to x_0} \\frac{f(x) - f(x_0)}{x-x_0} tanϕ=x→x0​lim​x−x0​f(x)−f(x0​)​ 令Δx=x−x0\\Delta x = x-x_0Δx=x−x0​，所以 tan⁡ϕ=lim⁡x→0f(x0+Δx)−f(x0)Δx\\tan \\phi = \\lim\\limits_{x \\to 0} \\frac{f(x_0+\\Delta x) - f(x_0)}{\\Delta x} tanϕ=x→0lim​Δxf(x0​+Δx)−f(x0​)​ 此处 tan⁡ϕ\\tan \\phitanϕ即为函数在x0x_0x0​处导数的取值，现在引出导数真正的 emp 定义 。 假设函数y=f(x)y = f(x)y=f(x)在点x0x_0x0​处的邻域有定义，当自变量xxx在x0x_0x0​处取得增量Δx\\Delta xΔx(仍然在邻域内)，相应的函数取得增量Δy=f(x0+Δx)−f(x0)\\Delta y = f(x_0+\\Delta x) - f(x_0)Δy=f(x0​+Δx)−f(x0​)，如果ΔyΔx\\frac{\\Delta y}{\\Delta x}ΔxΔy​在Δx→0\\Delta x \\to 0Δx→0时的极限存在，称为函数y=f(x)y = f(x)y=f(x)在x0x_0x0​处可导，它的导数可以写成 f′(x0)=lim⁡x→0f(x0+Δx)−f(x0)Δxf'(x_0) = \\lim\\limits_{x \\to 0} \\frac{f(x_0+\\Delta x) - f(x_0)}{\\Delta x} f′(x0​)=x→0lim​Δxf(x0​+Δx)−f(x0​)​ f′(x0)f'(x_0)f′(x0​)也可以记成dydx\\frac{\\mathrm{d}y}{\\mathrm{d}x}dxdy​或者df(x)dx\\frac{\\mathrm{d}f(x)}{\\mathrm{d}x}dxdf(x)​,另外函数在x0x_0x0​处可导的充分必要条件是，函数在x0x_0x0​处的左右两侧的导数都 必须存在，并且相等 。 另外有一些函数的导数都是比较特殊的，这里就不再涉及。 微分 首先思考一个简答的问题，一个正方形金属薄片边长为xxx，受温度变化影响边长增加了Δx\\Delta xΔx，求其面积变化了多少。 设正方形面积为AAA ,这样我们就得到了一个函数A=x2A = x^2A=x2，计算ΔA\\Delta AΔA为: ΔA=(x0+Δx)2−x02=2x0Δx+(Δx)2\\Delta A = (x_0+ \\Delta x)^2 - x_0^2 = 2x_0\\Delta x + (\\Delta x)^2 ΔA=(x0​+Δx)2−x02​=2x0​Δx+(Δx)2 首先第一部分2x0Δx2 x_0 \\Delta x2x0​Δx为一个线性函数，第二部分中当Δx→0\\Delta x \\to 0Δx→0时，(Δx)2(\\Delta x)^2(Δx)2是比Δx\\Delta xΔx高阶的无穷小，即(Δx)2=ο(Δx)(\\Delta x)^2 =\\omicron(\\Delta x)(Δx)2=ο(Δx) 好了增量Δy\\Delta yΔy现在已经可以表示为： Δy=AΔx+ο(Δx)\\Delta y = A \\Delta x + \\omicron(\\Delta x ) Δy=AΔx+ο(Δx) 其中AAA是不依赖Δx\\Delta xΔx的常数，并且Δy\\Delta yΔy与AΔxA\\Delta xAΔx的差为： Δy−AΔx=ο(Δx)\\Delta y - A\\Delta x =\\omicron(\\Delta x) Δy−AΔx=ο(Δx) 是比Δx\\Delta xΔx更高阶的无穷小，这样当A≠0A \\ne 0A​=0，且∣Δx∣|\\Delta x |∣Δx∣无穷小时，Δy\\Delta yΔy就可以近似的表示为Δy=AΔx\\Delta y = A \\Delta xΔy=AΔx。 接下来给出定义 ，设函数y=f(x)y = f(x)y=f(x)在某区间内有定义，x0x_0x0​及x0+Δxx_0+ \\Delta xx0​+Δx在这段区间内，如果函数的增量 Δy=f(x0+Δx)−f(x0)\\Delta y = f(x_0 + \\Delta x) - f(x_0) Δy=f(x0​+Δx)−f(x0​) 可以表示为 Δy=AΔx+ο(Δx)\\Delta y = A \\Delta x + \\omicron(\\Delta x) Δy=AΔx+ο(Δx) 其中AAA是不依赖于Δx\\Delta xΔx常数，那么称函数y=f(x)y = f(x)y=f(x)在x0x_0x0​处是可微的，而AΔxA\\Delta xAΔx叫做函数y=f(x)y = f(x)y=f(x)在x0x_0x0​处相当于自变量增量 Δx\\Delta xΔx的 微分(Differential) 记作dydydy，即 dy=AΔx\\mathrm{d}y = A \\Delta x dy=AΔx 积分 积分(integral)是微积分学与数学分析的一个核心概念。通常分为定积分和不定积分两种。（主要区别就是定积分得到的结果是一个数，不定积分得到的是函数） tips：不定积分是求导运算的逆运算。这一结论被称为微积分基本定理 (fundamental theorem of calculus)。 直观的说，对于一个给定的正实数值函数，在一个实数区间上的定积分可以理解为在坐标平面上，由曲线，直线以及轴围围成的 曲边梯形的面积值（一种确定的实数值） 如果一个函数的积分存在，并且有限，就说这个函数是可积的。一般来说，被积函数不一定只有一个变量，积分域也可以是不同维度的空间，甚至是没有直观几何意义的抽象空间。对于只有一个变量xxx的实值函数fff在闭区间[a,b][a,b][a,b]上的积分记作： ∫abf(x)dx\\int _{a}^{b} f(x) \\mathrm{d}x ∫ab​f(x)dx 其中的dx\\mathrm{d}xdx就是积分变量。 黎曼积分(Riemann Integral)，就是所说的正常积分，定积分。其求积分值的核心思想就是通过无限逼近来确定这个积分值，需要注意的是，如果f(x)f(x)f(x)去负值，则对应的面积值也为负值。 对于一个闭区间[a,b][a,b][a,b]的分割PPP就是指在这一个区间中取一个有限的点列a=x0&lt;x1&lt;x2&lt;⋯&lt;xn=ba = x_0 &lt; x_1 &lt; x_2 &lt; \\cdots &lt; x_n = ba=x0​&lt;x1​&lt;x2​&lt;⋯&lt;xn​=b每个子区间长度的最大值定义为λ=max⁡(xi+1−xi)\\lambda = \\max(x_{i+1}-x_i)λ=max(xi+1​−xi​)。 定义取样分割为在进行分割PPP后在每一个子区间[xi,xi+1][x_{i},x_{i+1}][xi​,xi+1​]中取出一点xi≤ti≤xi+1x_i \\le t_i \\le x_{i+1}xi​≤ti​≤xi+1​,其区间长度最大值仍用λ\\lambdaλ来表示。 对于一个在区间[a,b][a,b][a,b]有定义的实值函数fff，fff关于取样分割x0⋯xn,t0⋯tn−1x_0 \\cdots x_n , t_0 \\cdots t_{n-1}x0​⋯xn​,t0​⋯tn−1​的黎曼和表示为： ∑i=0n−1f(ti)(xi+1−xi)\\sum_{i=0}^{n-1}f(t_i)(x_{i+1}-x_i) i=0∑n−1​f(ti​)(xi+1​−xi​) 上述式子中的每一项是子区间长度xi+1−xix_{i+1}- x_ixi+1​−xi​与在tit_iti​处的f(ti)f(t_i)f(ti​)的乘积，其实直观的来说就是将一个曲线梯形分割成无限个小的图形将其面积相加。 看来需要一个更严格的定义，我们需要把λ\\lambdaλ趋近于0函数值才能更精确。 设SSS是函数fff在闭区间[a,b][a,b][a,b]上的黎曼积分，当且仅当∀ϵ&gt;0,∃δ&gt;0\\forall \\epsilon &gt; 0, \\exists \\delta &gt; 0∀ϵ&gt;0,∃δ&gt;0，使得∀x0⋯xn,t0⋯tn−1\\forall x_0 \\cdots x_n , t_0 \\cdots t_{n-1}∀x0​⋯xn​,t0​⋯tn−1​，只要它的子区间长度最大值λ≤δ\\lambda \\le \\deltaλ≤δ就有： ∣∑i=0n−1f(ti)(xi+1−xi)−S∣&lt;ϵ\\bigg| \\sum_{i = 0}^{n-1} f(t_i)(x_{i+1} -x_i)-S \\bigg| &lt; \\epsilon ∣∣∣∣​i=0∑n−1​f(ti​)(xi+1​−xi​)−S∣∣∣∣​&lt;ϵ 也就是说，对于一个函数fff，如果在闭区间[a,b][a,b][a,b]上无论如何取样分割，只要它的子区间长度最大值足够小，函数fff的黎曼和都会趋向一个确定的值，那么在闭区间[a,b][a,b][a,b]上的黎曼积分存在，并且定义为黎曼和的极限，这时候我们称函数fff为黎曼可积的。 黎曼积分还有一个更有操作性的积分定义叫做达布积分，（自行了解吧）。 还有一个非常重要的定理， 若F(x)F(x)F(x)为f(x)f(x)f(x)的不定积分 ，则f(x)f(x)f(x)为F(x)F(x)F(x)的导数；反之亦然。 根据以上定理，我们有： ∫abf(x)dx=F(b)−F(a)\\int_a^b f(x) \\mathrm{d}x = F(b)-F(a) ∫ab​f(x)dx=F(b)−F(a) 正文 终于进入到了主题。 数值积分，是用来求定积分的近似值。 这里我们只阐述一种数值积分的求法，使用SimpsonSimpsonSimpson公式。 Simpson公式 SimpsonSimpsonSimpson公式就是在积分区间[a,b][a,b][a,b]中去找三个点a,ba,ba,b和m=(a+b)/2m = (a+b)/2m=(a+b)/2，计算其原函数在此处的值，然后用抛物线来拟合原函数。 tips：幂函数的积分公式： ∫xαdx=1α+1xα+1+C(C为常数项)\\int x^{\\alpha} \\mathrm{d}x = \\frac{1}{\\alpha+1}x^{\\alpha+1}+C \\quad (\\text{C为常数项}) ∫xαdx=α+11​xα+1+C(C为常数项) 尝试推导一下公式🤔 设f(x)f(x)f(x)为原函数，g(x)=Ax2+Bx+Cg(x) = Ax^2 + Bx +Cg(x)=Ax2+Bx+C为拟合后的函数，有： ∫abf(x)dx≈∫abAx2+Bx+C=A3(b3−a3)+B2(b2−a2)+C(a−b)=(b−a)6(2A(b2+ab+a2)+3B(b+a)+6C)=(b−a)6(2Ab2+2Aab+2Aa2+3Bb+3Ba+6C)=(b−a)6(Aa2+Ba+C+Ab2+Bb+C+4(A(a+b2)2+B(a+b2)+C))=(b−a)6(f(a)+f(b)+4f(a+b2))\\begin{aligned} \\int_a^bf(x)\\mathrm{d}x &amp;\\approx \\int_a^b Ax^2 + Bx +C \\\\ &amp;= \\frac{A}{3}(b^3 - a^3) + \\frac{B}{2}(b^2 - a^2) + C(a-b) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(2A(b^2+ab+a^2)+3B(b+a)+6C \\bigg) \\\\ &amp;= \\frac{(b-a)}{6}(2Ab^2 + 2 Aab +2Aa^2+3Bb+3Ba+6C) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(Aa^2 + Ba+C+Ab^2 + Bb +C +4(A(\\frac{a+b}{2})^2 + B(\\frac{a+b}{2})+C)\\bigg) \\\\ &amp;= \\frac{(b-a)}{6}\\bigg(f(a)+f(b)+4f(\\frac{a+b}{2})\\bigg) \\end{aligned} ∫ab​f(x)dx​≈∫ab​Ax2+Bx+C=3A​(b3−a3)+2B​(b2−a2)+C(a−b)=6(b−a)​(2A(b2+ab+a2)+3B(b+a)+6C)=6(b−a)​(2Ab2+2Aab+2Aa2+3Bb+3Ba+6C)=6(b−a)​(Aa2+Ba+C+Ab2+Bb+C+4(A(2a+b​)2+B(2a+b​)+C))=6(b−a)​(f(a)+f(b)+4f(2a+b​))​ 最终SimpsonSimpsonSimpson公式为： ∫abf(x)dx≈(b−a)(f(a)+f(b)+4f(a+b2))6\\int_a^b f(x) \\mathrm{d}x \\approx \\frac{(b-a)(f(a)+f(b)+4f(\\frac{a+b}{2}))}{6} ∫ab​f(x)dx≈6(b−a)(f(a)+f(b)+4f(2a+b​))​ 1234double simpson(double l, double r){ return (r - l)*(f(l) + f(r) + 4*f((l+r)/2))/6;} 有一个结论：SimpsonSimpsonSimpson公式的误差为 −190(r−l2)5f(4)(ξ)-\\frac{1}{90}(\\frac{r-l}{2})^5f^{(4)}(\\xi) −901​(2r−l​)5f(4)(ξ) 其中ξ\\xiξ为区间[l,r][l,r][l,r]中的某个值。 是不是还没说数值积分学这玩意干嘛，很明显是解决积分问题的，想想上面我们说的黎曼积分的定义，其精确度很明显是由区间分割决定的，如何区间分割呢？ 自适应Simpson法 现在来解决精度问题，让其实现自动控制分割区间的大小。 SimpsonSimpsonSimpson公式是通过一个二次函数去拟合原函数的，也就是说我们当前分割的区间对应的函数值越接近一个二次函数图像，误差就越小。 也就是说我们在计算时需要判断当前区间是否接近一个二次函数，判断过程如下： 首先将当前段直接代入求积分，在将当前这一段分成两个区间，求这两段的积分，如果当前段的积分值和分割成两段之后的积分之和相差很小的话就可以直接计算了否则递归。 有一个结论：三点SimpsonSimpsonSimpson与分成两个子区间后两个子区间SimpsonSimpsonSimpson和差值是原来绝对误差的115\\frac{1}{15}151​（我不太会证） 1234567891011double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L)+ auto_simpson(mid, r, eps/2, R);} The first question 给定积分： ∫LRcx+dax+bdx\\int_L^R \\frac{cx+d}{ax+b} \\mathrm{d}x ∫LR​ax+bcx+d​dx 保留至小数点后六位。 直接使用公式即可。 或者直接积出来，直接暴切 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;double a, b, c, d;double f(double x){ return (c*x + d)/(a*x + b);}double simpson(double l, double r){ return (r - l)*(f(l) + f(r) + 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L)+ auto_simpson(mid, r, eps/2, R);}int main(){ double l, r; scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;l, &amp;r); printf(&quot;%.6lf&quot;, auto_simpson(l, r, 1e-6, simpson(l, r))); return 0;} The second question 给定积分： ∫0∞xax−xdx\\int_0^{\\infty} x ^{\\frac{a}{x}-x} \\mathrm{d}x ∫0∞​xxa​−xdx 保留小数点后5位，会出现积分发散的情况。 好像这个式子是一个不可积分函数，只能用SimpsonSimpsonSimpson，(也只会SimpsonSimpsonSimpson),但是下界是0，上界是∞\\infty∞，需要找到式子的一些性质。 可以证明： a&lt;0a &lt; 0a&lt;0时原积分发散 ∵ax−x=a−x2x∴a−x2&lt;0,xa−x2x=1xx2−ax∵x→0,x2→0,1x→∞∴0&lt;x&lt;1,xk→0,k→∞∴x→0,f(x)→∞\\begin{aligned} &amp;\\because \\frac{a}{x} - x = \\frac{a-x^2}{x} \\\\ &amp;\\therefore a-x^2 &lt; 0,x^{\\frac{a-x^2}{x}} = \\frac{1}{x^{\\frac{x^2-a}{x}}}\\\\ &amp;\\because x \\to 0 ,x^2 \\to 0, \\frac{1}{x} \\to \\infty \\\\ &amp;\\therefore 0 &lt; x &lt; 1,x^k \\to 0,k \\to \\infty \\\\ &amp;\\therefore x\\to 0,f(x)\\to \\infty \\end{aligned} ​∵xa​−x=xa−x2​∴a−x2&lt;0,xxa−x2​=xxx2−a​1​∵x→0,x2→0,x1​→∞∴0&lt;x&lt;1,xk→0,k→∞∴x→0,f(x)→∞​ a&gt;0a&gt;0a&gt;0时原积分收敛 ∵xa−x2x=1xx2−ax∴x→∞,f(x)→0\\begin{aligned} &amp;\\because x^{\\frac{a-x^2}{x}} = \\frac{1}{x^{\\frac{x^2-a}{x}}} \\\\ &amp;\\therefore x \\to \\infty ,f(x)\\to 0 \\end{aligned} ​∵xxa−x2​=xxx2−a​1​∴x→∞,f(x)→0​ 因为在a&gt;0a&gt;0a&gt;0的时候收敛所以右边界不用设太大，可以自己打表试一下。 特判a&lt;0a&lt;0a&lt;0，在[1e−8,20][1e-8,20][1e−8,20]作为积分范围即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;double a;double f(double x){ return pow(x, a/x - x);}double simpson(double l, double r){ return (r - l)*(f(l) + f(r)+ 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L+R-fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L) + auto_simpson(mid, r, eps/2, R);}int main(){ scanf(&quot;%lf&quot;, &amp;a); double l = 1e-9; double r = 20; if(a &lt; 0) printf(&quot;orz&quot;); else printf(&quot;%.5lf&quot;, auto_simpson(l, r, 1e-8, simpson(l, r))); return 0;} The third question 给定一个由圆台和圆锥构成的组合体，给定一个角度求求其在平面上的投影面积。 体现了自适应辛普森法的一个常见用途，用来求曲边图形的面积 。 先来考虑投影的形状，首先一个圆的投影肯定是一个大小相同的圆，圆锥的投影就是一个圆加上了一个点，一级这个点和圆的两条切线，圆台的投影就是两个圆加上它们的公切线。 连起来的话就是一个非常鬼畜的东西。 然后暴力即可（画的好像不太标准\\kk） 是一个封闭图形，并且将其看作一个函数直接求积分即可。 再去观察图形，此时这棵树的投影已经变为了若干个圆弧加上若干个梯形和三角形。 既然是求积分的话而且还存在圆弧弧就需要用的SimpsonSimpsonSimpson公式了。 需要用梯形腰的左右两个端点作为一段函数的定义域。 然后就是高度为hhh的物体投影到水平面上长度会变为htan⁡α\\frac{h}{\\tan \\alpha}tanαh​，来确定横坐标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#include &lt;pthread.h&gt;#define dwd 1919810.114514#define ochen 114514.1919810using namespace std;const int N = 510;int n;double alpha;double H, Tan;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// 向量的四则运算 double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} // 向量模长 double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);}// 点积 double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} // 叉积 double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a2,b1,b2)/(dis(a1,a2)*dis(b1,b2));}// 向量夹角 double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));}// 两向量围成的四边形面积 double angle(geometric a){return atan2(a.y,a.x);}// 极角 geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} // 向量逆时针旋转 geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} // 向量顺时针旋转}opt;struct circle{ geometric p; double r; circle(geometric _p = 0, double _r = 0): p(_p), r(_r) {}};circle c[N];struct line{ geometric a, b; line(geometric _a = 0, geometric _b = 0):a(_a), b(_b) {} double calc(double x) { double k = (b.y-a.y)/(b.x-a.x); double b = a.y-k*a.x; return k*x+b; }}seg[N];double f(double x){ double sum = 0; for(int i = 1; i &lt;= n; i++) { if(x &lt; c[i].p.x + c[i].r &amp;&amp; x &gt; c[i].p.x - c[i].r) sum = max(sum, sqrt(c[i].r*c[i].r-(x-c[i].p.x)*(x-c[i].p.x))); }//在圆里面 for(int i = 1; i &lt; n; i++) { if(x &gt; seg[i].a.x &amp;&amp; x &lt; seg[i].b.x) sum = max(sum, seg[i].calc(x)); }//在切线范围内 //取最大可以满足所有情况 return sum;}double simpson(double l, double r){ return (r-l)*(f(l) + f(r) + 4*f((l+r)/2))/6;}double auto_simpson(double l, double r, double eps, double fx){ double mid = (l+r)/2; double L = simpson(l, mid); double R = simpson(mid, r); if(fabs(L + R - fx) &lt;= 15*eps) return L + R + (L + R - fx)/15; else return auto_simpson(l, mid, eps/2, L) + auto_simpson(mid, r, eps/2, R);}int main(){ scanf(&quot;%d%lf&quot;, &amp;n, &amp;alpha); Tan = 1.0/tan(alpha); n = n + 1; for(int i = 1; i &lt;= n; i++) { double h; scanf(&quot;%lf&quot;, &amp;h); c[i].p.x = h*Tan; c[i].p.x += c[i-1].p.x; } for(int i = 1; i &lt; n; i++) { double r; scanf(&quot;%lf&quot;, &amp;r); c[i].r = r; }// 输入 c[n].r = 0; for(int i = 1; i &lt; n; i++) { double x1 = c[i].p.x; double x2 = c[i+1].p.x; double r1 = c[i].r; double r2 = c[i+1].r; double a1 = r1*(r1-r2)/(x2-x1); double a2 = r2*(r1-r2)/(x2-x1); seg[i] = line(geometric(x1+a1, sqrt(r1*r1-a1*a1)),geometric(x2+a2, sqrt(r2*r2-a2*a2))); }//计算线段 double l = c[1].p.x - c[1].r; double r = c[n].p.x - c[n].r; for(int i = 1; i &lt;= n; i++) { l = min(l, c[i].p.x - c[i].r); r = max(r, c[i].p.x + c[i].r); }//必须计算积分区间。 printf(&quot;%.2lf&quot;, 2*auto_simpson(l, r, 1e-6, simpson(l, r))); // 一遍只计算了一半 return 0;} 后记 其实高数挺多公式的，我这里就算随便提了一下吧。 参考文献 [1] 高等数学 同济大学数学系 [2]OIwiki-数值积分 [3]百度百科","link":"/2022/08/15/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"},{"title":"杜教筛","text":"亚线性筛之一 杜教筛 前置知识 积性函数 前言 首先先看一下积性函数吧，积性函数就是在对于所有的互质的 aaa 和 bbb ，总有 f(ab)=f(a)f(b)f(ab) = f(a)f(b)f(ab)=f(a)f(b) ， 则 f(x)f(x)f(x) 为积性函数。 比较常见的主要有： d(x)=∑i∣n1σ(x)=∑i∣niφ(x)=∑i=1x1[gcd(x,i)=1]μ(x)={1x=1(−1)k∏i=1kqi=10max⁡{qi}&gt;1ϵ(x)=[x=1]d(x)= \\sum_{i \\mid n} 1 \\\\ \\sigma (x) = \\sum_{i \\mid n} i \\\\ \\varphi (x) = \\sum_{i=1}^x 1 [gcd(x,i)=1] \\\\ \\mu (x) = \\left\\{ \\begin{aligned} &amp;1 &amp;x=1 \\\\ &amp;(-1)^k &amp;\\prod_{i=1}^k q_i=1 \\\\ &amp;0&amp;\\max\\left\\{ q_i \\right\\} &gt; 1 \\end{aligned} \\right. \\\\ \\epsilon (x) = [x=1] d(x)=i∣n∑​1σ(x)=i∣n∑​iφ(x)=i=1∑x​1[gcd(x,i)=1]μ(x)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​1(−1)k0​x=1i=1∏k​qi​=1max{qi​}&gt;1​ϵ(x)=[x=1] 积性函数有以下性质： 若 f(x),g(x)f(x),g(x)f(x),g(x)为积性函数，则， h(x)=f(xp)h(x)=fp(x)h(x)=f(x)g(x)h(x)=∑d∣xf(d)g(xd)h(x) = f(x^p) \\\\ h(x) = f^p(x) \\\\ h(x) = f(x)g(x) \\\\ h(x) = \\sum_{d \\mid x} f(d)g(\\frac{x}{d}) h(x)=f(xp)h(x)=fp(x)h(x)=f(x)g(x)h(x)=d∣x∑​f(d)g(dx​) 中的h(x)h(x)h(x)也为积性函数。 杜教筛主要是用来求像这些积性函数的前缀和。 正文 对于求一个数论函数的前缀和，杜教筛可以在低于线性时间的复杂度内求解。 对于数论函数 fff ， 要求计算 S(n)=∑i=1nf(i)S(n) = \\sum_{i=1}^n f(i)S(n)=∑i=1n​f(i) 。 首先构造一个 S(n)S(n)S(n) 关于S(⌊ni⌋)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor)S(⌊in​⌋) 的递推式 对于任意一个数论函数 ggg ，必须满足 ∑i=1n∑d∣ig(d)f(id)=∑i=1ng(i)S(⌊ni⌋) ⟺ ∑i=1n(f∗g)(i)=∑i=1ng(i)S(⌊ni⌋)\\sum_{i=1}^n \\sum_{d \\mid i}g(d)f(\\frac{i}{d})= \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\iff \\sum_{i=1}^n(f \\ast g)(i) = \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) i=1∑n​d∣i∑​g(d)f(di​)=i=1∑n​g(i)S(⌊in​⌋)⟺i=1∑n​(f∗g)(i)=i=1∑n​g(i)S(⌊in​⌋) 简单的证明： ∑i=1n∑d∣ig(d)f(id)=∑i=1n∑j=1⌊ni⌋g(i)f(j)=∑i=1ng(i)∑j=1⌊ni⌋f(j)=∑i=1ng(i)S(⌊ni⌋)\\sum_{i=1}^n \\sum_{d \\mid i}g(d)f(\\frac{i}{d})\\\\ = \\sum_{i=1}^n\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor} g(i)f(j)\\\\ = \\sum_{i=1}^ng(i)\\sum_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor} f(j)\\\\ = \\sum_{i=1}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ i=1∑n​d∣i∑​g(d)f(di​)=i=1∑n​j=1∑⌊in​⌋​g(i)f(j)=i=1∑n​g(i)j=1∑⌊in​⌋​f(j)=i=1∑n​g(i)S(⌊in​⌋) 求出递推式 g(1)S(n)=∑i=1n(f∗g)(i)−∑i=2ng(i)S(⌊ni⌋)g(1)S(n)=\\sum_{i=1}^n(f \\ast g)(i)-\\sum_{i=2}^ng(i)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) g(1)S(n)=i=1∑n​(f∗g)(i)−i=2∑n​g(i)S(⌊in​⌋) 可以用数论分块对后半部分快速求出结果。 问题 题目：求 ： S1(n)=∑i=1nμ(i)S2(n)=∑i=1nφ(i)S_1(n)=\\sum_{i=1}^n \\mu(i)\\\\ S_2(n)=\\sum_{i=1}^n \\varphi(i) S1​(n)=i=1∑n​μ(i)S2​(n)=i=1∑n​φ(i) 第一部分求莫比乌斯函数前缀和 ∵ϵ=μ∗1∴ϵ=∑d∣nμ(d)S1(n)=∑i=1nϵ(i)−∑i=2nS1(⌊ni⌋)=1−∑i=2nS1(⌊ni⌋)\\because \\epsilon =\\mu \\ast 1 \\\\ \\therefore \\epsilon = \\sum_{d \\mid n}\\mu (d) \\\\ S_1(n) = \\sum_{i=1}^n \\epsilon(i) -\\sum_{i=2}^nS_1(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ = 1-\\sum_{i=2}^nS_1(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) ∵ϵ=μ∗1∴ϵ=d∣n∑​μ(d)S1​(n)=i=1∑n​ϵ(i)−i=2∑n​S1​(⌊in​⌋)=1−i=2∑n​S1​(⌊in​⌋) 直接整除分块 第二部分求欧拉函数前缀和 ∵φ∗1=ID∴∑i=1n(φ∗1)(i)=∑i=1n1⋅S2(⌊ni⌋)∑i=1nID(i)=∑i=1n1⋅S2(⌊ni⌋)12n(n+1)=∑i=1nS2(⌊ni⌋)S2(n)=12n(n+1)−∑i=2nS2(⌊ni⌋)\\because \\varphi \\ast 1 =ID \\\\ \\therefore \\sum_{i=1}^n (\\varphi \\ast 1)(i)=\\sum_{i=1}^n 1 \\cdot S_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ \\sum_{i=1}^n ID(i)= \\sum_{i=1}^n 1 \\cdot S_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ \\frac{1}{2}n(n+1) = \\sum_{i=1}^nS_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ S_2(n)=\\frac{1}{2}n(n+1)-\\sum_{i=2}^nS_2(\\left\\lfloor\\frac{n}{i}\\right\\rfloor) \\\\ ∵φ∗1=ID∴i=1∑n​(φ∗1)(i)=i=1∑n​1⋅S2​(⌊in​⌋)i=1∑n​ID(i)=i=1∑n​1⋅S2​(⌊in​⌋)21​n(n+1)=i=1∑n​S2​(⌊in​⌋)S2​(n)=21​n(n+1)−i=2∑n​S2​(⌊in​⌋) 时间复杂度O(n23)O(n ^{\\frac{2}{3}})O(n32​) code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e6+10;int T,cnt,n;ll mu[maxn],prime[maxn],S1[maxn],S2[maxn];bool vis[maxn];map&lt;ll,ll&gt; eit;void Mu(){ mu[1]=1; for(int i=2;i&lt;=2e6;i++) { if(!vis[i]) { prime[++cnt]=i; mu[i]=-1; } for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=2e6;j++) { vis[prime[j]*i]=true; if(i%prime[j]==0) { mu[prime[j]*i]=0; break; } mu[prime[j]*i]=-mu[i]; } } for(int i=1;i&lt;=2e6;i++) S1[i]=S1[i-1]+mu[i];}ll S_mu(ll x){ if(x&lt;=2e6)return S1[x]; if(eit[x])return eit[x]; ll res=1; for(ll l=2,r;l&lt;=x;l=r+1) { r=x/(x/l); res-=S_mu(x/l)*(r-l+1); } return eit[x]=res;}ll S_phi(ll x){ ll res=0; for(ll l=1,r;l&lt;=x;l=r+1) { r=x/(x/l); res+=(S_mu(r)-S_mu(l-1))*(x/l)*(x/l); } return (res-1)/2+1;}int main(){ Mu(); scanf(&quot;%d&quot;,&amp;T); while(T--) { scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld %lld\\n&quot;,S_phi(n),S_mu(n)); } return 0;} 对于一些筛法的小技巧： 对于比较大的数据时，筛法在筛前半段时花费的时间显然是比较长的，这时我们可以直接线性筛一遍先记录下来，在求后半段时就可以省下大部分时间，称为根号分治。","link":"/2022/07/19/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"title":"欧拉路浅谈","text":"真的只是浅谈！ 欧拉路 概念 欧拉路：在一个图中，可以从其中一点出发，不重复地走完其所有边，那么这个图就称为欧拉图。 如果起点和终相同，那么这个图为欧拉回路。 欧拉路路存在的充要条件： 1.图是连通的，若不连通不可能一次性遍历所有边。 2.对于无向图：有且仅有两个点，与其相连的边数为奇数，其他点相连边数为偶数；或所有点为偶数点。对于两个奇数点，一个为起点，一个为终点。起点需要出去，终点需要进入，所以与奇数个点相连。 如果存在这样一个欧拉路，其所有点相连边数都为偶数，那说明它是欧拉回路。 3.对于有向图：除去终点和起点，所有点的入度和出度相等。起点出度比入度大1，终点入度比出度大1.若起点和终点出入度也相同，则为欧拉回路。 欧拉路一般称为一笔画问题。 求解 DFS 设给定一张图，已知这张图是欧拉路，要求输出整条欧拉路。 此时可以采用DFS来遍历整张图，寻找欧拉路。 使用DFS寻找欧拉路的基本思想如下： DFS寻找到第一个无边可走的节点，则这个节点必定为终点。 接下来由于DFS的递归回溯，会退回终点的上一个节点，继续往下搜索，直到寻找到第二个无边可走的节点，则这个节点必定为欧拉路中终点前最后访问的节点。 于是当通过DFS遍历完整张图后，就可以倒序储存下整个欧拉路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int edge[1000][1000];//为了方便优先访问编号小的节点，这里使用邻接矩阵来存边//如果使用vector来存图，那还需要对每个节点连接的边进行排序int ans[1000000];int degree[1000];//用于储存每个点的度，以求起点int p=0;void dfs(int now){ for(int i=1;i&lt;=1000;i++)//顺序寻找可访问的边，优先找编号小的节点 { if(edge[now][i])//若这条边尚未访问过 { edge[now][i]--;//已访问过的边要删去，防止重复访问 edge[i][now]--;//有向图的话请删去这一行 dfs(i); } } ans[++p]=now;//将访问的节点储存进答案数组 //由于递归的特性，这里储存的是逆序过程}int main(){ int n; cin&gt;&gt;n;//边的个数 for(int i=1;i&lt;=n;i++) { int a,b; cin&gt;&gt;a&gt;&gt;b; edge[a][b]++; edge[b][a]++;//有向图的话删去这行 degree[a]++,degree[b]++;//两个点的度都+1 } int start=0; for(int i=1;i&lt;=1000;i++) { if(degree[i]%2)//如果找到奇数点 { start=i;//那这个奇数点就作为起点，由于顺序遍历，这个起点编号必定最小 break; } } if(!start)//如果还没找到奇数点，说明是欧拉回路 { for(int i=1;i&lt;=1000;i++) if(degree[i])//寻找最小的有度的点即可 { start=i; break; } } dfs(start);//dfs寻找欧拉路 for(int i=p;i&gt;=1;i--) cout&lt;&lt;ans[i];//输出给定的欧拉路 return 0;}","link":"/2022/06/14/%E6%AC%A7%E6%8B%89%E8%B7%AF%E6%B5%85%E8%B0%88/"},{"title":"每日总结","text":"每日总结 每日总结 2022-7-18 今天，学长zh_dou为我们准备了四个非常简单的数论题，结果整寄了 😑 呜呜呜~ 😭 T1是一道莫反/容斥，都掌握的不太好，主要还是学到了Dirichlet 前缀和: 对于已知一个序列 aaa ，求 一个序列 bbb ： bk=∑i∣kaib_k = \\sum_{i | k} a_i bk​=i∣k∑​ai​ 可以在O(nlog⁡log⁡n)O(n\\log\\log n)O(nloglogn)的时间复杂度内求出： 123for(int i=1;i&lt;=cnt;i++) for(int j=1;j*prime[i]&lt;=n;j++) b[prime[i]*j]+=b[j]; T2拓欧+构造，很有意思 T3神一般的容斥 T4纯数学题，非常考验数学技巧。 开始搞数学了🙃 2022-7-19 数论！ 2022-7-20 数论！！ 2022-7-21 数论！！！ 2022-9-4 算是做的一点题吧。 Test 1 T1 Not Equal Rectangle 玄学构造即可，首先考虑n,mn,mn,m非常小的情况，不难发现构造一个每条对角线上数字相同的矩阵就可满足，对于n&gt;25,m&gt;25n &gt; 25, m &gt; 25n&gt;25,m&gt;25时，可以考虑将整个矩阵划分为若干个上述25×2525 \\times 2525×25的矩阵，然后将不同子矩阵上填的的数错开，即可，模数为23即可，数学证明略。 T2 One to One 可以发现，建好的边把点划分为若干个基环树和树。 如果为基环树，直接计算贡献为a×nba \\times n^ba×nb 如果是树，设fi,jf_{i,j}fi,j​，转移方程为 fi,j=fi−1,j+fi−1,j−1×sizeif_{i,j} = f_{i-1,j} + f_{i-1,j-1} \\times size_i fi,j​=fi−1,j​+fi−1,j−1​×sizei​ 如果有kkk棵树，答案即为 ∑i=1kfk,i×(i−1)!×nk−i\\sum_{i = 1} ^ k f_{k,i} \\times (i-1)! \\times n^{k-i} i=1∑k​fk,i​×(i−1)!×nk−i T3 CF1109F Sasha and Algorithm of Silence’s Sounds LCT + Segment tree 直接维护即可。 Test 2 T1 ARC134E Modulo Nim 首先可以看出0对结果无影响，以及相同的数对结果也没有影响，接下来考虑胜利条件， 当集合中有数≤2\\le 2≤2时，很明显，{1}, {2},先手必败， {1，2} 先手必胜。 所有数&gt;2&gt;2&gt;2时如果有奇数，则选择m=2m = 2m=2，剩余集合{1}, 先手必胜。 所有数都是偶数且有 mod 4=2\\bmod 4 = 2mod4=2时，选择m=4m = 4m=4，剩余集合{2}，先手必胜。 考虑m=3m = 3m=3时，若剩余集合为{1}或{2},先手必胜。 若剩余几个为{1,2}，且所有数都是4的倍数，则剩余数只能形如12k+4,12k+812k+4, 12k+812k+4,12k+8，若此时集合为{4，8}. 先手必败，否则选择m=12m = 12m=12，先手必胜。 若剩余集合为{0}，所有数必须形如12k12k12k， 此时胜败不确定。 接下来分情况转移，状压转移胜负，最后用所有情况减去必败情况即为答案。 T2 ARC134F Flipping Coins 多项式 + 生成函数。 T3 CF1455G Forbidden Value 首先将指令看成树形结构，然后使用树形dp和启发式合并。 Test 3 T1 二龙戏珠 典型的卡特兰数例题，其实就是求从(0,0)走到(n,m) 且不经过直线y=Ax+By = Ax +By=Ax+B上方的方案数。 答案即为 Cn+mn−A×Cn+mn−1C_{n+m} ^ n - A \\times C_{n+m} ^ {n-1} Cn+mn​−A×Cn+mn−1​ T2 老鼠偷奶酪 模拟。 T3 脑袋砸核桃 问题可以转化为gcd卷积，即求∑gcd⁡(i,j)=xaibj\\sum_{\\gcd(i,j) = x} a_i b_j∑gcd(i,j)=x​ai​bj​，使用后缀和和后缀差分实现。 T4 巨斧砍大树 LCT 动态维护最小生成树。 Test 4 T1 ARC124E Pass to Next 如果每个人都至少给出了一个球，其实可以让每个人都少给相同的个数，效果相同，所以至少有一个人没给球。 然后根据结论列出dp方程即可。 T2 CF1470E Strange Permutation 由于操作互不重叠，可以将原问题转化为求翻转操作，二分 + 递推即可。 T3 P8434 「WHOI-2」D&amp;D 集合 AAA的装饰子集即不被其它任何数包含的子集，aaa 包含 bbb 当且仅当 a∣b=aa | b = aa∣b=a，即 bbb 为 1 的位 aaa 也为 1。 考虑原序列的装饰子集 SSS，假设 x∈Sx\\in Sx∈S，因为 xxx 不被任何数包含，所以对于任意子串 [l,r],x[l,r], x[l,r],x 同样不被区间内任何数包含。因此 xxx必然作为某个划分子串的装饰子集内的一个元素。所有子串的装饰子集包含 SSS。 考虑 x∉Sx\\notin Sx∈/​S，假设存在 y∈aiy\\in a_iy∈ai​ 包含 xxx。因 xxx不可能作为 yyy 所在子串的装饰子集，故所有子串的装饰子集不包含 SSS 以外的元素。 这证明了所有子串装饰子集等于 SSS。 令 lil_ili​ 表示使得 [li,i][l_i, i][li​,i]包含所有 SSS内元素的最大的 lil_ili​,显然可以双指针求出。 容易得到 DP fif_ifi​ 表示 [1,i][1, i][1,i]的答案，f1=0f_1 = 0f1​=0.若 lil_ili​ 存在，则有转移方程 fi=∑j=0li−1fjf_i = \\sum\\limits_{j = 0} ^ {l_i - 1} f_jfi​=j=0∑li​−1​fj​，表示将[j,i](j≤li)[j, i](j \\le l_i)[j,i](j≤li​) 划为子串。前缀和优化即可做到 O(n)\\mathcal{O}(n)O(n)。 求 SSS 相当容易，只需对每个数 aia_iai​ 检查是否存在aj≠aia_j\\neq a_iaj​​=ai​有 aja_jaj​包含 aia_iai​,可以再搞个 DP 算这玩意，也可以直接高维后缀和，相当好写。 Test 5 T1 robo 模拟。 T2 expand 先预处理出最短路和最大体积然后状压dp转移即可。 T3 birthday 根据抽屉原理对于操作1当区间长度大于13时肯定会得到yes，所以当区间长度小于14时二分搜索即可，对于操作2线段树维护即可，到叶子节点时在下穿tag。 Test 6 T1 trees 考虑每个权值的影响，将权值从小到大排序后，即可得到答案为： ∑i=1nval[i]×Ci−1k−1\\sum_{i = 1}^n val[i] \\times C_{i-1}^{k-1} i=1∑n​val[i]×Ci−1k−1​ T2 bridge 矩阵加速递推。 T3 flowers 寻找循环节即可。 2022-9-10 小总结（ Test 1 T1 ARC100E Or Plus Max 考虑枚举子集，维护每个集合的最大值和次大值，最后统一取maxmaxmax即可。 T2 CF615F LEGOndary Grandmaster 可以对题意使用技巧, 将原来的010101串的偶数维取反，每次在原串的取反操作等价于在新串中交换两个相邻的字符，然后就可以巧妙的将问题转化为：交换新串的字符，将其变为目标串。 很显然，首先两个串的111的个数要相同，然后不难得出，设sss中第iii个111的下标为xix_ixi​，ttt中第iii个111的下表为yiy_iyi​，最少交换次数就为∑i=1n∣xi−yi∣\\sum_{i = 1}^n | x_i - y_i|∑i=1n​∣xi​−yi​∣，nnn为其中111的个数，但是我们显然需要更好操作的形式，设aia_iai​表示sss中前iii个数中111的个数， bib_ibi​表示ttt中前iii个数中111的个数，答案就变为了∑i=1n∣ai−bi∣\\sum_{i = 1} ^ n |a_i - b_i|∑i=1n​∣ai​−bi​∣，然后直接统计前缀， 后缀中等于ai−bi=ja_i - b_i = jai​−bi​=j的个数×j\\times j×j就好了。 时间复杂度O(n2)O(n^2)O(n2)。 T3 数列 显然对于没一个位置的答案就是sufmax−preminsuf _ {max}-pre_{min}sufmax​−premin​，直接统计删去每个数的贡献就可以了。 Test 2 T1 排列 如果不加任何限制，显然将所有的正数排列在一起是最优的答案，也就是说当有必须的限制，让一个负数夹在两个证数之间时，会对答案产生影响，这时会有三个选择，要么选择前面的答案，要么算上负数，要么选择后面的答案， 不难想到，可以用最小割来解决这个问题。 将每个位置拆成两个点l,rl, rl,r，如果当前位置是一个正数，将sss连向lll， rrr 连向ttt，权值为正数的值，统计和，如果是一个负数，就将lll连向rrr， 权值为其绝对值，对于每一个限制(a,b)(a, b)(a,b)， 将lal_ala​连向lbl_blb​， rar_ara​连向rbr_brb​就好了， 跑最小割来得到答案。 T2 ARC127F ±AB 结论题， 类似欧几里得算法。 T3 CF1616H Keep XOR Low 建010101trie, 设f(u,v)f(u, v)f(u,v)表示从uuu的子树和vvv的子树中选一些数，两两异或不大于xxx的方案数， 类似树形dp转移即可。 Test 3 T1 珠江夜游 画一次函数图像就可以很直观的看出答案一定是最靠右的与distdistdist的交点， O(n)O(n)O(n)即可解决。 T2 旅行计划 欧拉路径 T3 基站建设 二维区间dp， 转移即可。 Test 4 T1 ARC101E Ribbons on Tree 巧妙的树形dp， 用了一手容斥的技巧。 T2 ARC088E Papple Sort 很明显的贪心思路就是对于每一种字符，位置靠右的肯定要对上位置靠左的来让移动步数最少， 这样我们就可以先对每一个字符标上编号， 问题就转化成了统计逆序对个数。 T3 交换 分治维护一个栈，同时统计方案数。 Test 5 T1 CF1422F Boring Queries 首先对于每个大于2e5\\sqrt {2e5}2e5​的大质数显然只会出现了一次， 小于2e5\\sqrt{2e5}2e5​的质数有868686个， 这样就可以对于小的质数用RMQ求解，大质数就可以统计[l,r][l,r][l,r]内不同数的个数来计算贡献，主席树维护。 T2 序列 不错的期望dp T3 CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths 上古神题了，算是dsu的应用好题，（毕竟是算法提出者本人出的题）。 由于只需要统计a−va - va−v这222222个字母，可以考虑用二进制压缩，对于能以构成回文路径的肯定是只有一个字符出现了奇数次或均出现了偶数次，可以二进制压缩表示每个字符的奇偶性状态，然后根据异或的性质，维护根到当前节点的异或值，disx⊕disydis_x \\oplus dis_ydisx​⊕disy​， 就可以得到xxx到yyy的路径的状态。 首先合法的状态只有232323种，直接可以开桶跑dsu on tree，暴力枚举状态就可以解决了。 2022-9-14 Test 1 T1 树 首先考虑莫比乌斯反演，变为统计 k∣gcdk∣gcdk∣gcd 的点对数量。 对于每个边权，首先去掉重复的质因子，这样它的质因子只有不超过 c=7c=7c=7个。 那么对于每个 kkk，将边权是 kkk 的倍数的边取出，用并查集计算答案。 对于修改涉及的边，我们一开始不将它们加入并查集。然后我们枚举 q+1q+1q+1 个时刻，再将这些边加入，统计答案，再删去即可。 时间复杂度 O(L+(n+q2)2clog⁡n)O(L+(n+q^2)2^c\\log n)O(L+(n+q2)2clogn)。 T2 ARC133D Range XOR 把它们模4的结果进行分类，我们可以得到: w4x=xw4x+1=1w4x+2=x+1w4x+3=0 w_{4x}=x \\\\ w_{4x+1}=1\\\\ w_{4x+2}=x+1\\\\ w_{4x+3}=0\\\\ w4x​=xw4x+1​=1w4x+2​=x+1w4x+3​=0 可以用数位dp解决，f[i][j][k]f[i][j][k]f[i][j][k]表示还有 iii 位,第一个数是否卡上界，第二个数是否卡上界的方案数。 T3 CF1503E 2-Coloring 合法的情形其实就是以下情况： 然后将直接统计即可。 Test 2 T1 tree 在AAA树上建主席树， 每个点上储存到根路径上的信息。求出每个点在BBB树上的DFS序，然变后成一个区间最大值的问题，这样就处理好了每个AAA树上的点在BBB树的贡献。 T2 ARC111E Simple Math 3 考虑iii的取值， 可以得到i≤⌊d−2c−b⌋i \\le \\lfloor \\frac{d- 2}{c - b} \\rfloori≤⌊c−bd−2​⌋，设m=⌊d−2c−b⌋m = \\lfloor \\frac{d- 2}{c - b} \\rfloorm=⌊c−bd−2​⌋然后答案就为： m−∑i=1m(⌊a+cid⌋−⌊a−1+bid⌋)m - \\sum_{i = 1} ^ {m} (\\lfloor \\frac{a + ci}{d} \\rfloor - \\lfloor \\frac{a - 1+ bi}{d} \\rfloor) m−i=1∑m​(⌊da+ci​⌋−⌊da−1+bi​⌋) 类欧几里得解决即可。 T3 ARC101F Robots and Exits 将操作映射到平面直角坐标系上就不难得出状态转移方程， 树状数组优化一下就好了。 2022-9-24 Test 1 T1 note 其实对于一定满足题意的NNN最大可以为102345678900000102345678900000102345678900000，其实求解数列AAA满足Ai=Ai−1+1A_i = A_{i - 1} + 1Ai​=Ai−1​+1，并且构成AiA_iAi​的数字中必须包换数列BBB，也就是说我们可以先枚举数列AAA，直接暴力去求⌊A10⌋\\lfloor \\frac{A}{10} \\rfloor⌊10A​⌋，去判断满足了那些BiB_iBi​ 然后去除这一位去构造新的数列A′A'A′这样做的话每次数列长度会变为原先的110\\frac{1}{10}101​，复杂度O(lg⁡n)O(\\lg n)O(lgn)。 T2 CF1119H Triple 首先题目要求的其实就是nnn个桶xorxorxor卷积后的结果，不难写出一个O(n2k)O(n2^k)O(n2k)的转移dp，但其实可以转化为多项式的形式，用FWT解决， 首先构造多项式为： Fi,j=(−1)g(j&amp;ai)x+(−1)g(j&amp;bi)y+(−1)g(j&amp;ci)zF_{i, j} = (-1) ^ {g(j \\&amp; a_i)}x + (-1)^{g(j \\&amp; b_i)}y + (-1) ^ {g(j \\&amp; c_i)}z Fi,j​=(−1)g(j&amp;ai​)x+(−1)g(j&amp;bi​)y+(−1)g(j&amp;ci​)z 然后考虑化简式子： ∏Fi,j=∏((−1)g(j&amp;ai)x+(−1)g(j&amp;bi)y+(−1)g(j&amp;ci)z)\\prod F_{i, j} = \\prod \\bigg( (-1) ^ {g(j \\&amp; a_i)}x + (-1)^{g(j \\&amp; b_i)}y + (-1) ^ {g(j \\&amp; c_i)}z \\bigg) ∏Fi,j​=∏((−1)g(j&amp;ai​)x+(−1)g(j&amp;bi​)y+(−1)g(j&amp;ci​)z) 将其都异或上aia_iai​，然后就可以设出方程 c1+c2−c3−c4=∑iFi,jc_1 + c_2 - c_3 - c_4 = \\sum_i F_{i, j} c1​+c2​−c3​−c4​=i∑​Fi,j​ 问题就可以得到解决了 T3 CF241B Friends 主要是用到了01trie 上二分的方式求出第k大， 然后将每一位拆开， 一位一位的加就可以用O(nlog⁡n)O(n \\log n)O(nlogn)的复杂度解决这个问题了 Test 2 T1 axelavir 打表题， 有OIES做法，也可以使用dp转移 T2 ARC111F Do you like query problems? 首先可以将和去转换成期望， 最后答案乘上方案数， 每次操作对答案的影响其实就是 12m+1E(∑i=lrai,j)\\frac{1}{2 m + 1} E(\\sum_{i = l} ^ r a_{i, j}) 2m+11​E(i=l∑r​ai,j​) 求的就是对应的qqq次求和，由于期望是线性的可以对每个aia_iai​单独计算贡献， ∑j=1q12m+1E(∑i=lrai,j)=∑j=1q12m+1∑i=1ni(n−i+1)n(n+1)2E(ai,j)\\begin{aligned} \\sum_{j = 1} ^ q \\frac{1}{2 m + 1} E(\\sum_{i = l} ^ r a_{i, j}) &amp; = \\sum_{j = 1} ^ q \\frac{1}{2 m + 1} \\sum_{i = 1} ^ n \\frac{i (n - i + 1)}{\\frac{n (n + 1)}{2}} E(a_{i, j}) \\end{aligned} j=1∑q​2m+11​E(i=l∑r​ai,j​)​=j=1∑q​2m+11​i=1∑n​2n(n+1)​i(n−i+1)​E(ai,j​)​ 然后化简式子即可得到答案为 m−1n(n+1)(2m+1)∑i=1ni(n−i+1)∑j=1q(1−(1−Pi)j−1)\\frac{m - 1} { n(n + 1)(2 m + 1)} \\sum_{i = 1} ^ n i(n - i + 1)\\sum_{j = 1} ^ q (1 - (1 - P_i)^ {j - 1}) n(n+1)(2m+1)m−1​i=1∑n​i(n−i+1)j=1∑q​(1−(1−Pi​)j−1) T3 ARC120E 1D Party 首先对于每个点的运动过程可以画成图像： 不同颜色代表不同的路径其实对应的答案就是最高点，然后将其转化为若干个三角形 然后就可以得到一个O(n2)O(n ^ 2)O(n2)的转移方程： fi=min⁡j=1i−2(max⁡(fj,ai−aj−12))f_i= \\min_{j= 1} ^ {i - 2} (\\max(f_j, \\frac{a_i - a_{j - 1}}{2})) fi​=j=1mini−2​(max(fj​,2ai​−aj−1​​)) 考虑优化转移，其实上述方程枚举了许多无用状态，手玩可知， 只需要从有444个点的三角形和555个点的三角形转移过来就行了， 更多的点的三角形其实可以拆成444个点和555个点的。 然后方程就转化为了 fi=min⁡(max⁡(fi−2,ai−ai−32),max⁡(fi−3,ai−ai−42))f_i = \\min(\\max(f_{i - 2}, \\frac{a_i - a_{i - 3}}{2}),\\max(f_{i -3}, \\frac{a_i - a_{i -4}}{2})) fi​=min(max(fi−2​,2ai​−ai−3​​),max(fi−3​,2ai​−ai−4​​)) 时间复杂度O(n)O(n)O(n)。 Test 3 T1 导出子图 状压dp即可 T2 ARC135 F Delete 1, 4, 7, … 设f(i)=⌊3i+12⌋f(i) =\\lfloor \\frac{3i + 1}{2} \\rfloorf(i)=⌊23i+1​⌋， 那么f(i)f(i)f(i)其实就是第一次操作后第iii个位置的数， 设第kkk次操作后位置iii为fk(i)f^k(i)fk(i)， 然后有 fk(n+2k)=fkn+3kf^k(n + 2 ^ k) = f^k n + 3 ^ k fk(n+2k)=fkn+3k 数学归纳法可证，然后预处理进行二进制拆分即可做到O(2ylog⁡n+2xk)O(2^y \\log n + 2^x k)O(2ylogn+2xk)的时间复杂度。 T3 ARC 138 D Priority Queue 首先把所有可能的最终集合排序并找到字典序， 最大的，显然就是贪心的子啊第iii次插入时插入iii即可，然后就可以设出一个O(n2)O(n ^ 2)O(n2)的dp,状压一下即可。 Test 4 T1 归并 其实根据题意不难发现，比较时对于这两段区间的最大值是递增的， 插入的区间是连续的，可以建一棵平衡树，修改时比较两段的当前最大值即可，时间复杂度是均摊的可以通过此题。 T2 ARC112E Cigar Box 首先考虑每一次操作只有最后一次操作才是有意义的，首先考虑一个长度为kkk的操作序列， 对答案的贡献就是(mk)\\dbinom{m}{k}(km​)，再加上放的方向为(mk)2m−k\\dbinom{m}{k} 2 ^ {m - k}(km​)2m−k,再去考虑递增区间作为合法区间的影响， 答案即为 ∑i=0f(i)(mi)2m−i\\sum _ {i = 0} f(i) \\dbinom{m}{i} 2 ^ {m - i} i=0∑​f(i)(im​)2m−i T3 ARC120F Wine Thief 定义f(n,k)f(n, k)f(n,k)为在一个长度为nnn的环内取kkk个的方案数，g(n,k)g(n, k)g(n,k)为在长度为nnn的数组内取kkk个数的方案数，不难得出g(n,k)=(n−k+1k)g(n, k) = \\dbinom{n - k + 1}{k}g(n,k)=(kn−k+1​),f(n,k)=g(n−1,k)+g(n−3,k−1)f(n, k) = g(n - 1, k) + g(n - 3, k - 1)f(n,k)=g(n−1,k)+g(n−3,k−1)， 统计出现次数计算答案即可。 2022-9-27 Test 1 T1 牛堡的十字路口 斜率优化dp T2 CF1109E Sasha and a Very Easy Test 其实就是用数据结构维护任意模数的区间乘，单点除， 区间求和，首先观察数据范围，每个数质因数分解后，质因数的个数不会超过101010个在进行除的时候，由于题目中满足一定可以整除，取模时把数拆成与模数互质和不互质的部分，然后互质的部分， 之间求逆元， 不互质的部分就去对质因子进行减操作，线段树维护即可。 T3 ARC087F Squirrel Migration 首先考虑什么样的排列能够使权值最大。 考虑权值上界： 对于每一条边，如果把它切掉则树会分成S1S_1S1​ 和 S2S_2S2​ 两个联通块，不妨 设∣S1∣≤∣S2∣|S_1|\\le |S_2|∣S1​∣≤∣S2​∣。 那么这一条边显然最多被经过 2∣S1∣2|S_1|2∣S1​∣ 次。 此时，∀u∈S1,pu∈S2\\forall u\\in S_1,p_u\\in S_2∀u∈S1​,pu​∈S2​。 考虑将重心 GGG 拉出来作为根。如果存在多个重心则随便选一个即可。 那么现在每一个 S1S_1S1​ 一定是一棵子树。 容易发现，使得权值最大的等价条件为 ∀(G,v),u∈subtree(v),pu∉subree(v)\\forall (G,v),u\\in subtree(v),p_u\\notin subree(v)∀(G,v),u∈subtree(v),pu​∈/​subree(v)。 有了这个结论，就容易使用容斥求答案了。 fif_ifi​ 表示钦定 iii 个点不满足条件，剩下点任意的方案数。 则 Ans=∑(−1)ifi(n−i)!Ans=\\sum (-1)^if_i(n-i)!Ans=∑(−1)ifi​(n−i)! 单独考虑每一个(G,v)(G,v)(G,v) 的 subtree(v)subtree(v)subtree(v)，设其大小为 xxx。 容易得到这个子树中fi=(xi)2i!f_i=\\binom{x}{i}^2i!fi​=(ix​)2i!。 最终的 fff 把所有的子树使用背包合并起来即可，复杂度 O(n2)O(n^2)O(n2)。 2022-9-30 Test 1 T1 会议选址 首先， 一个点在一条链上动的时候， dis(u,i)dis(u,i)dis(u,i)为一个凸函数，可以使用树分治加速， 三度化平衡时间复杂度。 T2 CF618G Combining Slimes 可以根据期望的线性性对每个数分别统计贡献，设每个格子使得jjj至少出现一次的概率为ci,jc_{i, j}ci,j​，然后就可以得到转移为 ci,j=ci−1,j−1×ci,j−1c_{i,j} = c_{i-1, j - 1} \\times c_{i, j - 1} ci,j​=ci−1,j−1​×ci,j−1​ 再设Ci,jC_{i,j}Ci,j​表示使用iii个各自恰好出现一次jjj的概率 Ci,j=ci,h×(1−ci−1,j)C_{i, j} = c_{i,h} \\times (1 - c_{i- 1, j}) Ci,j​=ci,h​×(1−ci−1,j​) 最终的转移方程fi,jf_{i,j}fi,j​即为 fi,j=j+∑k=1j−1fi−1,k×Ci−1,k∑k=1j−1Ci−1,kf_{i,j} = j + \\frac{\\sum_{k = 1} ^ {j - 1} f_{i - 1, k} \\times C_{i -1, k}}{\\sum _{k = 1} ^ {j - 1} C_{i - 1, k}} fi,j​=j+∑k=1j−1​Ci−1,k​∑k=1j−1​fi−1,k​×Ci−1,k​​ 只处理前50项即可，矩乘。 T3 CF1609G A Stroll Around the Matrix 由于a,ba, ba,b的差分数列均为单调递增的，可以证明每次选差分值小的走会最优，再考虑每个差分值的贡献， 贡献即为 ∑i=1n+m−2di×(n+m−i−1)\\sum_{i = 1} ^ {n + m - 2} d_i \\times (n + m -i - 1) i=1∑n+m−2​di​×(n+m−i−1) 最后要加上(a[1]+b[1])×(n+m−1)(a[1] + b[1]) \\times(n + m - 1)(a[1]+b[1])×(n+m−1)即为答案。 注意到n≤100n \\le 100n≤100， 可以用线段树维护bbb， 暴力更改aaa，每次对差分值排序， 对于每个aia_iai​在bbb的线段树上二分即可。 2022-10-3 Test 1 T1 P3616 富金森林公园 观察题目其实是在求对于每一个询问的高度xxx， 求满足hi−1&lt;x≤hih _ {i - 1} &lt; x \\le h_ihi−1​&lt;x≤hi​的个数，线段树区间修改，单点查询即可。 T2 区间排序 如果排完序想要相同的话,那么 max−min+1=r−l+1−xmax-min+1=r-l+1-xmax−min+1=r−l+1−x（xxx是区间不是第一次出现的数) 化简得 max−min+x+l=rmax-min+x+l=rmax−min+x+l=r从坐往右扫,maxminmax minmaxmin 使用单调栈维护,xxx用个mapmapmap记录上次出现位置,l是定值即可,复杂度O(nlog⁡n)O(n \\log n)O(nlogn)。 2022-10-5 Test 1 T1 小K的外挂 设fif_ifi​为向左走再向右跳的最大值，gig_igi​为次大值， 每次跳的时候，如果遇到标记的就去跳次大值，否则跳最大值，倍增即可。 T2 小Z的作业 设fif_ifi​表示以iii为左端点，能满足条件的右端点的最小值，不难发现fif_ifi​是单调递增的可以倒着加边，LCT维护去更新fif_ifi​，查询是O(1)O(1)O(1)的， 用LCT维护时开一个set来维护加入的能以让联通块减少的边，当加入边时如果两点已经联通，就去删去两点路径上的编号最大的边， 总体把边当成点建边即可。 2022-10-8 Test 1 T1 分组 考虑贪心将每一个字符串倒过来建一棵trie树，然后在树上贪心即可。 T2 ARC136E Non-coprime DAG 令f(x)f(x)f(x)为xxx的最小质因子，考虑xxx可以到达yyy的条件，按照奇偶性分类： 2∣x,2∣y2 \\mid x, 2 \\mid y2∣x,2∣y， xxx肯定可以到达yyy 2∤x,2∣y2 \\not \\mid x, 2 \\mid y2​∣x,2∣y， x+f(x)≤yx + f(x) \\le yx+f(x)≤y 2∣x,2∤y2 \\mid x, 2 \\not \\mid y2∣x,2​∣y，2≤y−f(y)2 \\le y - f(y)2≤y−f(y) 2∤x,2∤y2 \\not \\mid x, 2 \\not \\mid y2​∣x,2​∣y，x+f(x)≤y−f(y)x + f(x) \\le y - f(y)x+f(x)≤y−f(y) 然后考虑对应的贡献区间为[x−f(x)+1，n+f(x)−1][x - f(x) + 1，n + f(x) - 1][x−f(x)+1，n+f(x)−1]，然后差分前缀和取max⁡\\maxmax即可。 T3 美好的每一天~不连续的存在 我的评价是听说gal挺好玩，建议去玩。 Test 2 T1 小D的序列 可以用等差数列求和公式判断。 T2 小S排座位 贪心前缀后缀即可。 Test 3 T1 sequence 主席树二分。 T2 训练(train) 区间dp。 T3 糖果(candy) 贪心，其实就像是一个二分图匹配， 先预处理出在每个点可以选的符合要求的点，然后再处理对应的点集， 选的时候，选点集大小小的，就像一个二分图匹配的过程。 T4 遗迹(ruin) 组合数学 + dp。 Test 3 T1 题目 折半搜索即可。 T2 名字 据期望线性性，询问的答案就是 E(dep(u))+E(dep(v))−2×E(dep(lca(u,v)))E(dep(u))+E(dep(v))−2×E(dep(lca(u,v)))E(dep(u))+E(dep(v))−2×E(dep(lca(u,v)))。 E(dep(u))E(dep(u))E(dep(u))很好求，直接枚举uuu 的父亲是谁就行 设 u&lt;vu&lt;vu&lt;v则 E(dep(lca(u,v)))E(dep(lca(u,v)))E(dep(lca(u,v)))只跟 uuu有关，证明即考虑 vvv 一直向上跳，跳到第一个编号 ≤u≤u≤u的点，那么这个点以正比于 aaa 的概率在 [1,u][1,u][1,u]中随机。 如果跳到了 uuu，那么期望深度就是 E(dep(u))E(dep(u))E(dep(u))则设跳到的点是 x(x&lt;u)x(x&lt;u)x(x&lt;u)期望深度就是 E(dep(lca(x,u)))E(dep(lca(x,u)))E(dep(lca(x,u)))，这只与xxx有关，用类似上面的方法递推就行。 时间复杂度 O(nlogmod+q)O(nlogmod+q)O(nlogmod+q)，可以离线求逆元做到 O(n+logmod+q)O(n+logmod+q)O(n+logmod+q)。 2022-10-17 Test 1 T1 CF311B Cats Transport 对于每一只猫可以计算出何时出发的人可以正好接走它。 如此得到一个长 mmm 的时间数组 ttt，将它从小到大排序。 题意变为：把数组分为ppp段，每段的代价是所有数与该段最大值的差值之和。求最小代价。 令SSS 数组为ttt数组的前缀和。 所求即为 fi,j=min⁡k=0j−1{fi−1,k+tj×(j−k)−Sj+Sk}f_{i, j} = \\min_{k = 0} ^ {j - 1} \\{ f_{i - 1, k} + t_j \\times (j - k) - S_j + S_k \\} fi,j​=k=0minj−1​{fi−1,k​+tj​×(j−k)−Sj​+Sk​} 然后斜率优化即可。 T2 CF1553F Pairwise Modulo 首先先将答案拆成两部分计算，然后对于每一部分，考虑直接暴力枚举， 由于aia_iai​互不相同，时间复杂度均摊下来是nlog⁡mn \\log mnlogm的，可以通过。 T3 CF1693D Decinc Dividing 首先观察题目不难得出一个结论那就是， 对于一个子区间[l,r][l, r][l,r]，有解的充要条件是， 不存在l≤a&lt;b&lt;c&lt;d≤rl \\le a &lt; b &lt; c &lt; d \\le rl≤a&lt;b&lt;c&lt;d≤r， 使得pb&gt;pa&gt;pd&gt;pcp_b &gt; p_a &gt; p_d &gt; p_cpb​&gt;pa​&gt;pd​&gt;pc​或pb&lt;pa&lt;pd&lt;pcp_b &lt; p_a &lt; p_d &lt; p_cpb​&lt;pa​&lt;pd​&lt;pc​，然后直接用单调栈维护即可。 Test 2 T1 CF1396D Rainbow Rectangles 不妨反过来考虑，先处理出最终的答案，然后逆着处理，每次删除一个新颜色 [prec,i][pre_c,i][prec​,i]的答案会取max⁡\\maxmax，然后每次查询一次全局贡献和。显然这是可以使用线段树维护的，然而直接取 max⁡\\maxmax,由于f(l)f(l)f(l)是单调的可以直接写一个线段树二分找到对应区间， 然后执行区间覆盖即可，时间复杂度O(n2log⁡n)O(n^2 \\log n)O(n2logn)。 T2 最长上升连续子序列 直接构造多项式求解。 T3 Die Siedler 考虑转化问题，将每个位置的卡牌转移到第一个位置上来，首先对于这种转化方式容易得到其得到满足要求的序列所需的最小步数，是与原序列是等价的，同时对于每种卡包， 也用相同的转化方式，然后相加减的答案就是原序列的答案。 对于一个长度为nnn的序列，其转化即为 ∑i=1nai2i−1(i−1)!\\sum_{i = 1} ^n a_i 2 ^ {i - 1} (i - 1) ! i=1∑n​ai​2i−1(i−1)! 然后考虑已知这种表达方式如何求解，其实只要贪心即可，去倒着填，对于第一个位置的数，其可以减少若干倍的2nn!−12 ^ n n! - 12nn!−1(转化一周)， 也就是说，最后所有卡牌转为为第一个位置的时候，答案可以表示为， v=R+∑i=1nbixi−y(2nn!−1)v = R + \\sum_{i = 1} ^ n b_i x_i - y (2 ^ n n! - 1) v=R+i=1∑n​bi​xi​−y(2nn!−1) 裴蜀定理解出即可， 然后考虑到数据范围，需要使用根号分治，当d&lt;2nn!d &lt; \\sqrt {2 ^ n n !}d&lt;2nn!​时，直接暴力枚举，d≤2nn!d \\le \\sqrt {2 ^n n!}d≤2nn!​时，根据转移，可以跑同余最短路，然后问题就解决了。 Test 3 T1 花环 哈希解决即可。 T2 最短最长最短路 可以根据竞赛图一个点到其他点的距离不超过222的性质，直接得出答案。 T3 花环 区间dp转移即可。 T4 二分图最大权匹配 根据曼哈顿距离的性质，直接建图即可。 Test 4 T1 sequence KKK段求和的 gcd⁡\\gcdgcd 等于KKK段右端点前缀和的 gcd⁡\\gcdgcd 也就是求最大的数 xxx 使得 x∣sumNx|sum_Nx∣sumN​，且有 K−1K−1K−1 个 ppp满足 x∣sumpx|sum_px∣sump​ 可以 O(N+σ1V)O(N+σ1V)O(N+σ1V) 求出。 T2 xor 笛卡尔树分治过程中0−10-10−1 trie启发式合并即可。 T3 dawn 约瑟夫环上的nim游戏。 T4 nogirlfriend 后缀数组加平衡树维护。 Test 5 T1 brime 直接筛素数，枚举即可，复杂度kln⁡nk \\ln nklnn，kkk为质数个数。 T2 sequence dp矩阵优化转移。 T3 iiidx 线段树维护期望值即可。 T4 inception 对于每次询问建虚树然后，大力分类讨论，即可。 2022-11-3 Test 1 T1 正方形 可以先将所有询问下来， 然后预处理出以每个点为右下角的最大边长，排序后，从大到小，依次加点用并查集维护连通性即可。 T2 计数 可以用范德蒙德卷积。 2022-11-10 Test 1 T1 GCD和LCM 求的柿子为， ans=∑i=1n∑j=1mlcm(i,j)[gcd⁡(i,j)≤k]=∑t=1k∑i=1n∑j=1mlcm(i,j)[gcd⁡(i,j)=t]=∑t=1k∑i=1n∑j=1mijgcd⁡(i,j)[gcd⁡(i,j)=t]=∑t=1kt∑i=1⌊nt⌋∑j=1⌊mt⌋ij[gcd⁡(i,j)=1]=∑t=1kt∑i=1⌊nt⌋∑j=1⌊mt⌋ij∑d∣gcd⁡(i,j)μ(d)=∑t=1kt∑d=1μ(d)d2∑i=1⌊ntd⌋∑j=1⌊mtd⌋ij\\begin{aligned} \\\\ ans &amp;= \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m lcm(i,j) [\\gcd(i,j) \\le k]\\\\ &amp; = \\sum_{t = 1} ^k \\sum_{i = 1} ^ n\\sum_{j = 1} ^ m lcm(i, j) [\\gcd(i, j) = t] \\\\ &amp;= \\sum_{t = 1} ^ k \\sum_{i = 1} ^ n \\sum_{j = 1} ^ m \\frac{ij}{\\gcd(i, j)}[\\gcd(i, j) = t] \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor} \\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} ij [\\gcd(i, j) = 1] \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{i = 1} ^ {\\lfloor \\frac{n}{t} \\rfloor} \\sum_{j = 1} ^ {\\lfloor \\frac{m}{t} \\rfloor} ij \\sum_{d | \\gcd(i, j)} \\mu(d) \\\\ &amp;= \\sum_{t = 1} ^ k t \\sum_{d = 1} \\mu(d) d^2 \\sum_{i = 1} ^ {\\lfloor \\frac{n}{td} \\rfloor}\\sum_{j = 1} ^ {\\lfloor \\frac{m}{td} \\rfloor} ij \\\\ \\end{aligned} \\\\ ans​=i=1∑n​j=1∑m​lcm(i,j)[gcd(i,j)≤k]=t=1∑k​i=1∑n​j=1∑m​lcm(i,j)[gcd(i,j)=t]=t=1∑k​i=1∑n​j=1∑m​gcd(i,j)ij​[gcd(i,j)=t]=t=1∑k​ti=1∑⌊tn​⌋​j=1∑⌊tm​⌋​ij[gcd(i,j)=1]=t=1∑k​ti=1∑⌊tn​⌋​j=1∑⌊tm​⌋​ijd∣gcd(i,j)∑​μ(d)=t=1∑k​td=1∑​μ(d)d2i=1∑⌊tdn​⌋​j=1∑⌊tdm​⌋​ij​ 观察数据范围，需要进一步优化，考虑枚举tdtdtd，并将后面的求和设为S(x)S(x)S(x)， ans=∑p=1S(⌊np⌋)S(⌊mp⌋)∑1≤d≤k,d∣pp2dμ(pd)ans = \\sum_{p = 1} S(\\lfloor \\frac{n}{p} \\rfloor) S(\\lfloor \\frac{m}{p} \\rfloor) \\sum_{1 \\le d \\le k, d|p} \\frac{p^2}{d} \\mu(\\frac{p}{d}) \\\\ ans=p=1∑​S(⌊pn​⌋)S(⌊pm​⌋)1≤d≤k,d∣p∑​dp2​μ(dp​) 然后将数据离线下来，按照kkk排序后，每次移动上界用树状数组维护对于每个ppp下的∑1≤d≤k,d∣pp2dμ(pd)\\sum_{1 \\le d \\le k, d|p} \\frac{p^2}{d} \\mu(\\frac{p}{d})∑1≤d≤k,d∣p​dp2​μ(dp​)，每个答案求和即可，时间复杂度O(qnlog⁡n+nlog⁡2n)O(q\\sqrt n \\log n + n \\log^2 n)O(qn​logn+nlog2n)。 T2 平面图 直接平面图转对偶图，启发式分裂完事了。 2022-11-11 Test 1 T1 序列 直接跑DAG上的dp即可。 T2 直接猜结论，随便证一证就可以发现，可以先把树处理出来，对于非树边上的权值，进行树上路径的最小值覆盖即可。 T3 首先观察到质因子数会很少，直接状压DP即可。 T4 考虑化简柿子为， max⁡{ai,i∈[l,r]}−min⁡{ai,i∈[l,r]}≤r−l+k\\max\\{ a_i, i \\in [l, r] \\} - \\min\\{ a_i, i \\in [l, r] \\} \\le r - l + k max{ai​,i∈[l,r]}−min{ai​,i∈[l,r]}≤r−l+k 换一下柿子维护即可。","link":"/2022/07/18/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/"},{"title":"狄利克雷卷积与莫比乌斯反演","text":"狄利克雷卷积与莫比乌斯反演详解 狄利克雷卷积与莫比乌斯反演 狄利克雷卷积 前言 狄利克雷卷积(Dirichlet Convolution)，在数论中是一个非常重要的工具，可以很方便的用来推出莫比乌斯反演(Mobius Inversion)的公式以及问题 🤔 正文 定义 狄利克雷卷积是定义在数论函数间的二元运算。 数论函数，是指定义域为 N\\mathbb{N}N ，值域为 C\\mathbb{C}C ， 的一类函数，每个数论函数可以视为一个复数的序列。 定义式为： (f∗g)(n)=∑d∣nf(d)g(nd)(d∈N)\\bigg(f \\ast g\\bigg) (n) = \\sum_{d \\mid n} f(d)g(\\frac{n}{d}) (d \\in \\mathbb{N}) \\\\ (f∗g)(n)=d∣n∑​f(d)g(dn​)(d∈N) 也可以写为 ： (f∗g)(n)=∑d∣nf(nd)g(d)(d∈N)\\bigg(f \\ast g\\bigg) (n) = \\sum_{d \\mid n} f(\\frac{n}{d})g(d) (d \\in \\mathbb{N}) (f∗g)(n)=d∣n∑​f(dn​)g(d)(d∈N) 同时由于对称性，又可以写为 ： (f∗g)(n)=∑xy=nf(x)g(y)(x,y∈N)\\bigg(f \\ast g\\bigg) (n) = \\sum_{xy=n} f(x)g(y) (x,y \\in \\mathbb{N}) (f∗g)(n)=xy=n∑​f(x)g(y)(x,y∈N) “+” 定义为了数论函数直接的直接相加， &quot; ∗\\ast∗ &quot;，其实就是乘 常见的数论函数 单位函数 ε(n)=[n=1]\\varepsilon (n) = \\left[ n=1 \\right] ε(n)=[n=1] 幂函数 Idk(n)=nkId_k(n) = n^k Idk​(n)=nk 约数函数 σ(n)=∑d∣ndk(d∈N)\\sigma(n) = \\sum_{d \\mid n} d^k (d \\in \\mathbb{N}) σ(n)=d∣n∑​dk(d∈N) 欧拉函数 φ(n)\\varphi(n)φ(n) 表示1 n1 ~ n1 n中与 nnn 互质的整数的个数有多少个 φ(n)=n∏p∣n(1−1p)(p∈P)\\varphi (n) = n \\prod_{p|n}(1-\\frac{1}{p}) (p \\in \\mathbb{P}) φ(n)=np∣n∏​(1−p1​)(p∈P) （容斥可证） 有趣的是上面所写的函数均为积性函数，其中单位函数和幂函数为完全积性函数。 相关定理 若 fff ， ggg 为积性函数，则 f∗gf \\ast gf∗g 也为积性函数 证明： 设gcd(a,b)=1∴(f∗g)(a)⋅(f∗g)(b)=∑i∣af(i)g(ai)⋅∑j∣bf(j)g(bj)=∑i∣a∑j∣bf(i)g(ai)⋅f(j)g(bj)=∑d∣abf(d)g(abd)=(f∗g)(ab)用到了积性函数的性质设 gcd(a,b) =1 \\\\ \\begin{aligned} \\therefore \\bigg(f \\ast g\\bigg)(a) \\cdot (f \\ast g) (b) &amp;= \\sum_{i \\mid a} f(i) g(\\frac{a}{i}) \\cdot \\sum_{j \\mid b} f(j) g(\\frac{b}{j}) \\\\ &amp;= \\sum_{i \\mid a} \\sum_{j \\mid b} f(i) g(\\frac{a}{i}) \\cdot f(j) g(\\frac{b}{j}) \\\\ &amp;= \\sum_{d \\mid ab} f(d)g(\\frac{ab}{d}) \\\\ &amp;= (f \\ast g) (ab) \\\\ \\end{aligned}\\\\ 用到了积性函数的性质\\\\ 设gcd(a,b)=1∴(f∗g)(a)⋅(f∗g)(b)​=i∣a∑​f(i)g(ia​)⋅j∣b∑​f(j)g(jb​)=i∣a∑​j∣b∑​f(i)g(ia​)⋅f(j)g(jb​)=d∣ab∑​f(d)g(dab​)=(f∗g)(ab)​用到了积性函数的性质 f∗g=g∗ff \\ast g = g \\ast f \\\\f∗g=g∗f 证明 ： (f∗g)(n)=∑ij=nf(i)g(j)=∑ji=nf(j)g(i)=(g∗j)(n)\\begin{aligned} \\bigg(f \\ast g\\bigg)(n) &amp;= \\sum_{ij=n} f(i)g(j) \\\\ &amp;= \\sum_{ji=n} f(j)g(i) \\\\ &amp;= (g \\ast j) (n) \\end{aligned} (f∗g)(n)​=ij=n∑​f(i)g(j)=ji=n∑​f(j)g(i)=(g∗j)(n)​ 对称性。 (f∗g)∗h=f∗(g∗h)(f \\ast g ) \\ast h = f \\ast (g \\ast h)(f∗g)∗h=f∗(g∗h) 利用对称性的式子去拆开即可得证。 f∗(g+h)=f∗g+f∗hf \\ast (g+h) = f \\ast g + f \\ast hf∗(g+h)=f∗g+f∗h 证明： (f∗(g+h))(n)=∑ij=nf(i)(g+h)(j)=∑ij=nf(i)[g(j)+h(j)]=∑ij=nf(i)g(j)+f(i)h(j)=∑ij=nf(i)g(j)+∑ij=nf(i)h(j)=(f∗g+f∗h)(n)\\begin{aligned} \\bigg(f \\ast (g + h )\\bigg) (n) &amp;= \\sum_{ij=n} f(i)\\bigg( g + h \\bigg)(j) \\\\ &amp;= \\sum_{ij=n} f(i)\\bigg[ g(j) + h(j) \\bigg] \\\\ &amp;= \\sum_{ij=n} f(i)g(j) + f(i)h(j) \\\\ &amp;= \\sum_{ij=n} f(i)g(j) + \\sum_{ij=n} f(i)h(j) \\\\ &amp;= \\bigg(f \\ast g + f \\ast h\\bigg) (n) \\end{aligned} (f∗(g+h))(n)​=ij=n∑​f(i)(g+h)(j)=ij=n∑​f(i)[g(j)+h(j)]=ij=n∑​f(i)g(j)+f(i)h(j)=ij=n∑​f(i)g(j)+ij=n∑​f(i)h(j)=(f∗g+f∗h)(n)​ 特殊的卷积 Idk∗1=σk Id_k \\ast 1 = \\sigma_k \\\\ Idk​∗1=σk​ 证明： (Idk∗1)(n)=∑d∣nIdk(d)1(nd)=∑d∣nIdk(d)=∑d∣ndk=σ(n)\\begin{aligned} \\bigg( Id_k \\ast 1\\bigg) (n) &amp;= \\sum_{d \\mid n} Id_k (d) 1 (\\frac{n}{d}) \\\\ &amp;= \\sum_{d \\mid n} Id_k (d) \\\\ &amp;= \\sum_{d \\mid n} d^k \\\\ &amp;= \\sigma (n) \\end{aligned} (Idk​∗1)(n)​=d∣n∑​Idk​(d)1(dn​)=d∣n∑​Idk​(d)=d∣n∑​dk=σ(n)​ 同时可以得到一个应用广泛的式子 ： (f∗1)(n)=∑d∣nf(d)\\bigg( f \\ast 1 \\bigg) (n) = \\sum_{d \\mid n} f(d) (f∗1)(n)=d∣n∑​f(d) φ∗1=Id \\varphi \\ast 1 = Id φ∗1=Id 证明 ： ∵(φ∗1)(n)=∑d∣nφ(d)将n拆分为∏pk∴(φ∗1)(n)=(φ∗1)(∏pk)=∏(φ∗1)(piki)=∏∑j=1kiφ(pij)=∏piki=n∴φ∗1=Id\\because \\bigg( \\varphi \\ast 1 \\bigg)(n) = \\sum_{d \\mid n} \\varphi (d) \\\\ 将 n 拆分为 \\prod p^k \\\\ \\begin{aligned} \\therefore \\bigg( \\varphi \\ast 1 \\bigg)(n) &amp;= \\bigg( \\varphi \\ast 1 \\bigg)(\\prod p^k) \\\\ &amp;= \\prod \\bigg( \\varphi \\ast 1 \\bigg)( p_i^{k_i}) \\\\ &amp;= \\prod \\sum_{j=1}^{k_i}\\varphi(p_i^j) \\\\ &amp;= \\prod p_i^{k_i} \\\\ &amp;= n \\\\ \\end{aligned}\\\\ \\therefore \\varphi \\ast 1 =Id ∵(φ∗1)(n)=d∣n∑​φ(d)将n拆分为∏pk∴(φ∗1)(n)​=(φ∗1)(∏pk)=∏(φ∗1)(piki​​)=∏j=1∑ki​​φ(pij​)=∏piki​​=n​∴φ∗1=Id 1∗1=d1 \\ast 1 = d 1∗1=d 证明 ： (1∗1)(n)=∑d∣n1(d)1(nd)=∑d∣n1=d(n)\\begin{aligned} \\bigg( 1 \\ast 1 \\bigg)(n) &amp;= \\sum_{d \\mid n} 1(d) 1(\\frac{n}{d}) \\\\ &amp;= \\sum_{d \\mid n} 1 \\\\ &amp;= d(n) \\end{aligned} (1∗1)(n)​=d∣n∑​1(d)1(dn​)=d∣n∑​1=d(n)​ 上述的运算加以结合可以得到更多结论 。 狄利克雷卷积逆 需要用到单位元，有 ： (f∗ε)(n)=∑d∣nε(d)f(nd)=f(n)\\bigg(f \\ast \\varepsilon \\bigg)(n) = \\sum_{d \\mid n} \\varepsilon(d)f(\\frac{n}{d}) =f (n) (f∗ε)(n)=d∣n∑​ε(d)f(dn​)=f(n) 定义 ： f∗f−1=ϵf \\ast f^{-1} = \\epsilon f∗f−1=ϵ 即为狄利克雷卷积逆 关于进一步的推导，占个坑🙃 🙃 🙃 积性函数一定有狄利克雷逆，且它也是积性函数 莫比乌斯反演 前置知识 狄利克雷卷积 介绍 莫比乌斯函数 定义莫比乌斯函数为： μ(x)={1x=1(−1)k∏i=1kqi=10max⁡{qi}&gt;1\\mu (x) = \\left\\{ \\begin{aligned} &amp;1 &amp;x=1 \\\\ &amp;(-1)^k &amp;\\prod_{i=1}^k q_i=1 \\\\ &amp;0&amp;\\max\\left\\{ q_i \\right\\} &gt; 1 \\end{aligned} \\right. μ(x)=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​1(−1)k0​x=1i=1∏k​qi​=1max{qi​}&gt;1​ 推导 g=f∗1 ⟺ f=g∗μg=f \\ast 1 \\iff f= g \\ast \\mu g=f∗1⟺f=g∗μ 也就是 ： f(n)=∑d∣ng(d) ⟺ g(n)=∑d∣nμ(d)f(nd)f(n) = \\sum_{d \\mid n} g(d) \\iff g(n) = \\sum_{d \\mid n} \\mu(d) f( \\frac{n}{d}) f(n)=d∣n∑​g(d)⟺g(n)=d∣n∑​μ(d)f(dn​) 莫比乌斯函数的性质： ∑d∣nnμ(d)=[n=1]\\sum_{d \\mid n} ^n \\mu(d) = [n=1] d∣n∑n​μ(d)=[n=1] 接下来证明莫比乌斯反演定理 ： f(n)=∑d∣ng(d)=∑d∣ng(nd)∑d∣nμ(d)f(nd)=∑d∣nμ(d)∑d1∣ndg(d1)∑d∣n∑d1∣ndμ(d)g(d1)=∑d1∣n∑d∣nd1μ(d)g(d1)=∑d1∣ng(d1)∑d∣nd1μ(d)=g(n)\\begin{aligned} &amp;f(n)=\\sum_{d \\mid n}g(d)=\\sum_{d \\mid n}g(\\frac{n}{d})\\\\ &amp;\\sum_{d \\mid n} \\mu(d)f(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d) \\sum_{d_1 \\mid \\frac{n}{d}}g(d_1) \\\\ &amp;\\sum_{d \\mid n}\\sum_{d_1 \\mid \\frac{n}{d}} \\mu(d)g(d_1) \\\\ &amp;= \\sum_{d_1 \\mid n} \\sum_{d \\mid \\frac{n}{d_1}}\\mu(d)g(d_1) \\\\ &amp;= \\sum_{d_1 \\mid n} g(d_1) \\sum_{d \\mid \\frac{n}{d_1}} \\mu(d) \\\\ &amp;=g(n) \\\\ \\end{aligned} ​f(n)=d∣n∑​g(d)=d∣n∑​g(dn​)d∣n∑​μ(d)f(dn​)=d∣n∑​μ(d)d1​∣dn​∑​g(d1​)d∣n∑​d1​∣dn​∑​μ(d)g(d1​)=d1​∣n∑​d∣d1​n​∑​μ(d)g(d1​)=d1​∣n∑​g(d1​)d∣d1​n​∑​μ(d)=g(n)​ 上述仅为充分性证明，必要性证明逆推即可。 问题 坑。","link":"/2022/07/20/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"title":"生成函数学习笔记","text":"初探生成函数 生成函数 普通生成函数(OGF) 定义序列aaa的生成函数为 F(x)=∑i=0∞aixiF(x) = \\sum_{i = 0} ^ {\\infty} a_ix^i F(x)=i=0∑∞​ai​xi 运算 其加法运算为 F(x)±G(x)=∑i=0∞(ai±bi)xiF(x) \\pm G(x) = \\sum_{i = 0} ^ {\\infty} (a_i \\pm b_i) x^ i F(x)±G(x)=i=0∑∞​(ai​±bi​)xi 乘法运算，也就是卷积为 F(x)∗G(x)=∑i=0∞(∑j=0iajbi−j)xiF(x) \\ast G(x) = \\sum_{i = 0} ^ {\\infty} \\bigg( \\sum_{j = 0} ^ i a_jb_{i - j} \\bigg)x^i F(x)∗G(x)=i=0∑∞​(j=0∑i​aj​bi−j​)xi 其为序列∑i=0naibn−i\\sum_ {i = 0}^n a_i b_{n - i}∑i=0n​ai​bn−i​的生成函数。 封闭形式 根据等比数列求和公式可得 F(x)=∑i=0∞aixi=a0×1−x∞1−x=a01−xF(x) = \\sum_{i = 0} ^ {\\infty} a_i x^i = a_0 \\times \\frac{1 - x ^ {\\infty}}{1 - x} = \\frac{a_0}{1 - x} F(x)=i=0∑∞​ai​xi=a0​×1−x1−x∞​=1−xa0​​ 牛顿二项式定理 定义组合数为 (nm)=nm‾m!,n∈C,m∈N\\dbinom{n}{m} = \\frac{n ^ {\\underline{m}}}{m!}, n \\in \\mathbb{C}, m \\in \\mathbb{N} (mn​)=m!nm​​,n∈C,m∈N 指数型生成函数(EGF) 定义序列aaa的指数型生成函数为 F(x)=∑i=0∞aixii!F(x) = \\sum_{i = 0} ^ {\\infty} a_i \\frac{x^i}{i !} F(x)=i=0∑∞​ai​i!xi​ 显然有 ex=∑i=1∞e0xii!=∑i=1∞xii!ex+e−x2=∑i=0∞x2i(2i)!ex−e−x2=∑i=0∞x2i+1(2i+1)!e^x = \\sum_{i = 1}^{\\infty} \\frac{e^0 x^i}{i!} = \\sum_{i = 1}^{\\infty}\\frac{x^i}{i!} \\\\ \\frac{e^x + e^{-x}}{2} = \\sum_{i = 0}^{\\infty} \\frac{x^{2i}}{(2i)!} \\\\ \\frac{e^x - e ^ {-x}}{2} =\\sum_{i = 0}^{\\infty} \\frac{x ^ {2i + 1}}{(2i+1)!} ex=i=1∑∞​i!e0xi​=i=1∑∞​i!xi​2ex+e−x​=i=0∑∞​(2i)!x2i​2ex−e−x​=i=0∑∞​(2i+1)!x2i+1​ 可以应用到组合数学中。","link":"/2022/09/30/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"矩阵树定理","text":"矩阵树定理讲解 矩阵树定理 前置知识-行列式 定义 对于一个n×nn \\times nn×n的矩阵，其行列式为， det⁡(A)=∑P(−1)μ(P)∏i=1nA(i,pi)\\det(A) = \\sum_{P}(-1)^{\\mu(P)}\\prod_{i = 1} ^ n A(i, p_i) det(A)=P∑​(−1)μ(P)i=1∏n​A(i,pi​) 其中PPP为1−n1 - n1−n的一个排列， μ(P)\\mu(P)μ(P)为排列PPP的逆序对个数。 性质 单位矩阵III的行列式为111， 上三角矩阵和下三角矩阵的行列式都是对角线乘积。 交换矩阵的两行，行列式变号（改变了奇数个逆序对）。 若某一行乘以kkk，行列式乘以kkk。 行的线性性。 ∣a+a′b+b′cd∣=∣abcd∣+∣a′b′cd∣\\begin{vmatrix} a + a'&amp; b+ b' \\\\ c &amp; d\\end{vmatrix} = \\begin{vmatrix} a &amp; b \\\\ c &amp; d\\end{vmatrix} + \\begin{vmatrix} a'&amp; b' \\\\ c &amp; d\\end{vmatrix} ∣∣∣∣​a+a′c​b+b′d​∣∣∣∣​=∣∣∣∣​ac​bd​∣∣∣∣​+∣∣∣∣​a′c​b′d​∣∣∣∣​ 有某两行一样的矩阵，行列式为000。 粗略的证明：根据1，假设我们交换相同的两行，会使行列式变号， 但是交换后，行列式并没有发生改变，也就是行列式只能等于000 用矩阵的上一行加上另一行的倍数， 行列式不变。 证明： ∵∣abc⋯abc∣=0=∣abc⋯kakbkc∣=0∴∣abc⋯d+kae+kbf+kc∣=∣abc⋯kakbkc∣+∣abc⋯def∣=∣abc⋯def∣\\because \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ a &amp; b &amp; c\\end{vmatrix} = 0 =\\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ ka &amp; kb &amp; kc\\end{vmatrix} = 0 \\\\ \\therefore \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d + ka &amp; e + kb &amp;f + kc\\end{vmatrix} = \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ ka &amp; kb &amp; kc\\end{vmatrix} + \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d &amp; e &amp; f\\end{vmatrix} = \\begin{vmatrix} a &amp; b &amp; c \\\\ &amp; \\cdots \\\\ d &amp; e &amp; f\\end{vmatrix} ∵∣∣∣∣∣∣​aa​b⋯b​cc​∣∣∣∣∣∣​=0=∣∣∣∣∣∣​aka​b⋯kb​ckc​∣∣∣∣∣∣​=0∴∣∣∣∣∣∣​ad+ka​b⋯e+kb​cf+kc​∣∣∣∣∣∣​=∣∣∣∣∣∣​aka​b⋯kb​ckc​∣∣∣∣∣∣​+∣∣∣∣∣∣​ad​b⋯e​cf​∣∣∣∣∣∣​=∣∣∣∣∣∣​ad​b⋯e​cf​∣∣∣∣∣∣​ 消元法求行列式 首先高斯消元的过程中我们用到的是交换两行，行列式的值变号， 某一行乘上一个数，行列式乘上对应值，一行加上另一行的倍数，行列式不变，最后得到上三角矩阵后，把影响逆回去即可。 P7112 行列式求值 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 610;int a[N][N];int n, p;signed main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) scanf(&quot;%lld&quot;, &amp;a[i][j]); int ans = 1, f = 1; for(int i = 1; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(a[i][i]) { int div = a[j][i] / a[i][i]; for(int k = i; k &lt;= n; k++) a[j][k] = (a[j][k] - div * a[i][k] % p + p) % p; swap(a[i], a[j]); f = - f; } swap(a[i], a[j]); f = -f; } } for(int i = 1; i &lt;= n; i++) ans = (ans * a[i][i]) % p; ans = f * ans; printf(&quot;%lld&quot;, (ans + p) % p); return 0;} 概念 矩阵树定理(Matrix-tree Theorem) 是把图的生成树个数和矩阵行列式联系起来的定理。（有很大的用处！） 定义 首先设有无向图G=(V,E)G = (V, E)G=(V,E)， 有ppp个顶， qqq条边。 然后我们把GGG的每条边任意指定一个方向， 这样就可以定义GGG的关联矩阵(Incidence Matrix)M(G)M(G)M(G), 为一个p×qp \\times qp×q的矩阵， Mi,j={−1vi is the start of ej1vi is the end of ej0ortherwiseM_{i,j} = \\left\\{ \\begin{aligned} &amp; -1 &amp; v_i \\ is \\ the \\ start\\ of \\ e_j \\\\ &amp; 1 &amp; v_i \\ is \\ the \\ end \\ of \\ e_j \\\\ &amp; 0 &amp; ortherwise \\end{aligned} \\right. Mi,j​=⎩⎪⎨⎪⎧​​−110​vi​ is the start of ej​vi​ is the end of ej​ortherwise​ 接着定义GGG的拉普拉斯矩阵(Laplacian Matrix)L(G)L(G)L(G)， 为一个p×pp \\times pp×p的矩阵， Li,j={−mi,ji≠j ,mi,j edge between vi,vjdeg(vi)i=jL_{i, j} = \\left\\{ \\begin{aligned} &amp; -m_{i, j} &amp;i \\not = j \\ ,m_{i,j} \\ edge \\ between \\ v_i, v_j \\\\ &amp; deg(v_i) &amp;i = j \\end{aligned} \\right. Li,j​={​−mi,j​deg(vi​)​i​=j ,mi,j​ edge between vi​,vj​i=j​ 注意到MMM与GGG指定的方向有关， 对LLL没有影响，举一个例子： 对应的关联矩阵MMM为 ∣100−1−1−1−1−1000011001001∣\\begin{vmatrix}1&amp;0&amp;0&amp;-1&amp;-1\\\\-1&amp;-1&amp;-1&amp;0&amp;0\\\\0&amp;0&amp;1&amp;1&amp;0\\\\0&amp;1&amp;0&amp;0&amp;1\\end{vmatrix} ∣∣∣∣∣∣∣∣​1−100​0−101​0−110​−1010​−1001​∣∣∣∣∣∣∣∣​ 对应的拉普拉斯矩阵LLL为 ∣3−1−1−1−13−1−1−1−120−1−102∣\\begin{vmatrix} 3 &amp; -1 &amp; -1 &amp; -1 \\\\ -1 &amp; 3 &amp; -1 &amp; -1\\\\ -1 &amp; -1 &amp; 2 &amp; 0\\\\ -1 &amp; -1 &amp; 0 &amp; 2 \\end{vmatrix} ∣∣∣∣∣∣∣∣​3−1−1−1​−13−1−1​−1−120​−1−102​∣∣∣∣∣∣∣∣​ 另外LLL的非主对角线上的元素不一定是−1-1−1 ， GGG中允许重边存在。 引理 Lemma 1 MMT=LM M ^T = LMMT=L,其中MTM^TMT表示MMM的转置 证明：由定义易得：(MMT)i,j=∑ek∈EMi,kMk,jT=∑ek∈EMi,kMj,k(MM^T)_{i,j} = \\sum_{e_k \\in E} M_{i,k} M ^T_{k,j} = \\sum_{e_k \\in E} M_{i,k}M_{j,k}(MMT)i,j​=∑ek​∈E​Mi,k​Mk,jT​=∑ek​∈E​Mi,k​Mj,k​，i=ji = ji=j时就相当于连了几条边也就是入度，i≠ji \\not = ji​=j时两点之间有连边的话其中必定是一个终点和一个起点，也就是对应的−mi,j-m_{i,j}−mi,j​，得证。 接下来引入一些MMM的子矩阵，称为Reduce Incidence Matrix，M0M_0M0​是去掉MMM最后一行得到的(p−1)×q(p - 1) \\times q(p−1)×q矩阵。 定义一个(p−1)×(p−1)(p - 1) \\times (p - 1)(p−1)×(p−1)的矩阵M0[S]M_0[S]M0​[S],其中集合S={i1,i2,⋯ ,ip−1}∈{1,2,⋯ ,q}S = \\{i _ 1, i_2, \\cdots ,i_{p-1}\\} \\in \\{1, 2, \\cdots , q\\}S={i1​,i2​,⋯,ip−1​}∈{1,2,⋯,q}q其实就是抽出M0M_0M0​中p−1p - 1p−1列，得到的一个新的矩阵。 Lemma 2 令SSS是边集EEE的一个大小为p−1p - 1p−1的子集，若G′=(V,S)G' = (V,S)G′=(V,S)不构成生成树，则det⁡M0[S]=0\\det M_0[S] = 0detM0​[S]=0，若G′G'G′构成生成树，则det⁡M0[S]=±1\\det M_0[S] = \\pm 1detM0​[S]=±1，其中det⁡\\detdet表示矩阵的行列式 Lemma 3 Binet-Cauchy Theorem 设A=(ai,j)A = (a_{i,j})A=(ai,j​)是一个m×nm \\times nm×n矩阵， B=(bi,j)B = (b_{i,j})B=(bi,j​)是一个n×mn \\times mn×m矩阵，则有det⁡(AB)=∑S(det⁡A[s])(det⁡B[s])\\det (AB) = \\sum_{S} (\\det A[s])(\\det B[s])det(AB)=∑S​(detA[s])(detB[s])， 其中SSS大小为mmm，且是{1,2,⋯ ,n}\\{ 1, 2, \\cdots , n\\}{1,2,⋯,n}的子集。 Lemma 4 Matrix-tree Theorem 设图G=(V,E)G = (V, E)G=(V,E), 拉普拉斯矩阵LLL, 则GGG的生成树的个数等于det⁡L0\\det L_0detL0​， 其中L0L_0L0​是去掉LLL第iii列第iii行得到的子矩阵 拓展 无向图 设GGG是一个有nnn个顶点的无向图，定义其度数矩阵为 Di,i(G)=deg(i), Di,j(G)=0, i!=jD_{i,i}(G) = deg(i), \\ D_{i, j}(G) = 0, \\ i != j Di,i​(G)=deg(i), Di,j​(G)=0, i!=j 其邻接矩阵为 Ai,j(G)=Aj,i(G)=e(i,j),i≠jA_{i, j}(G) = A_{j , i}(G) = e(i, j), i \\not= j Ai,j​(G)=Aj,i​(G)=e(i,j),i​=j 其拉普拉斯矩阵为 L(G)=D(G)−A(G)L(G) = D(G) - A(G) L(G)=D(G)−A(G) 有向图 设GGG是一个有nnn个顶点的有向图， 定义其出度矩阵为 Diiout(G)=degout(i),Dijout=0,i≠jD^{out}_{ii}(G) = \\mathrm{deg^{out}}(i), D^{out}_{ij} = 0, i\\neq j Diiout​(G)=degout(i),Dijout​=0,i​=j 类似的入度矩阵也这样定义 定义其邻接矩阵为 Ai,j=e(i,j), i≠jA_{i,j} = e(i, j), \\ i \\not = j Ai,j​=e(i,j), i​=j 其拉普拉斯矩阵LoutL^{out}Lout为 Lout(G)=Dout(G)−A(G)L^{out}(G) = D^{out}(G) - A(G) Lout(G)=Dout(G)−A(G) LinL^{in}Lin为 Lin(G)=Din(G)−A(G)L^{in}(G) = D^{in}(G) - A(G) Lin(G)=Din(G)−A(G) 带权-乘积之和 对于带权无向图，若存在边u→vu\\rightarrow vu→v，边权为ccc， 则Dx,x+c,Dy,y+c,Ax,y+c,Ay,x+cD_{x, x} + c, D_{y,y} + c, A_{x, y} + c, A_{y, x} + cDx,x​+c,Dy,y​+c,Ax,y​+c,Ay,x​+c。删去任意一行和任意一列，求剩下的矩阵行列式即可。 对于带权有向图，若存在边u→vu \\rightarrow vu→v，边权为ccc，外向树中Dy,y+cD_{y, y} + cDy,y​+c， 内向树中Dx,x+cD_{x, x} + cDx,x​+c， 内向树和外向树中Ax,y+cA_{x, y} + cAx,y​+c。删去指定的根所在的行和列，求剩下的矩阵行列式即可。 P6178Matrix-Tree 定理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 310;const int mod = 1e9 + 7;ll D[N][N], A[N][N], L[N][N];int n, m, t;void add(int u, int v, int c, int type){ if(t == 0) { (D[u][u] += c) %= mod; (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; (A[v][u] += c) %= mod; } else { (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; }}ll ans;void gauss(){ ll f = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(L[i][i]) { ll div = L[j][i] / L[i][i]; for(int k = i; k &lt;= n; k++) L[j][k] = ((L[j][k] - L[i][k] * div % mod) % mod + mod) % mod; swap(L[i], L[j]); f = -f; } f = -f; swap(L[i], L[j]); } } ans = f; for(int i = 2; i &lt;= n; i++) ans = (ans % mod * (L[i][i] + mod) % mod + mod) % mod;}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z, t); } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) L[i][j] = (D[i][j] - A[i][j] + mod) % mod; gauss(); printf(&quot;%lld&quot;, ans); return 0;} 带权-权值之和 上面的构造方式只是求了每个生成树边权乘积的和， 接下来需要解决，每个生成树边权之和的和，对于一条边权为www的边，只需要将边权设为关于xxx的多项式wx+1wx + 1wx+1，消元后最后的行列式的值的一次项系数就是答案， 对应的乘法改为(a+bx)(c+dx)=ac+(ad+bc)x(a + bx) (c + dx) = ac + (ad + bc)x(a+bx)(c+dx)=ac+(ad+bc)x，除法为a+bxc+dx=ac+bc−adc2x\\frac{a + bx} {c + dx} = \\frac{a}{c} + \\frac{bc - ad}{c ^ 2}xc+dxa+bx​=ca​+c2bc−ad​x，接下来证明一下构造方式的正确性，我们需要求的答案其实可以表示为每个边权×\\times×含有这条边权的生成树的个数，就可以构造一个多项式来求解，（老套路了），首先乘法的定义很好理解，说一下除法的，首先我们需要求的是C+Dx=1c+dxC + Dx = \\frac{1}{c + dx}C+Dx=c+dx1​，即(C+Dx)(c+dx)=1 mod x2(C + Dx)(c + dx) = 1 \\bmod x^2(C+Dx)(c+dx)=1modx2，展开即可得到C=1c,D=−dc2C = \\frac{1}{c}, D = -\\frac{d}{c^2}C=c1​,D=−c2d​，然后再乘上a+bxa + bxa+bx，就可以得到新的式子为ac+bc−adc2x\\frac{a}{c} + \\frac{bc - ad}{c^2}xca​+c2bc−ad​x。 P6624 作业题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 310;const int mod = 1e9 + 7;ll D[N][N], A[N][N], L[N][N];int n, m, t;void add(int u, int v, int c, int type){ if(t == 0) { (D[u][u] += c) %= mod; (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; (A[v][u] += c) %= mod; } else { (D[v][v] += c) %= mod; (A[u][v] += c) %= mod; }}ll ans;void gauss(){ ll f = 1; for(int i = 2; i &lt;= n; i++) { for(int j = i + 1; j &lt;= n; j++) { while(L[i][i]) { ll div = L[j][i] / L[i][i]; for(int k = i; k &lt;= n; k++) { L[j][k] = ((L[j][k] - L[i][k] * div % mod) % mod + mod) % mod; } swap(L[i], L[j]); f = -f; } f = -f; swap(L[i], L[j]); } } ans = f; for(int i = 2; i &lt;= n; i++) ans = (ans % mod * (L[i][i] + mod) % mod + mod) % mod;}int main(){ scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for(int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z, t); } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) L[i][j] = (D[i][j] - A[i][j] + mod) % mod; gauss(); printf(&quot;%lld&quot;, ans); return 0;} 后记 证明以后再补吧（逃","link":"/2022/09/18/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"title":"笛卡尔树","text":"用的有点少的数据结构 笛卡尔树 前置知识 单调栈 正文 性质 笛卡尔树，是一种不常用的数据结构吧，其同时满足二叉搜索树和小根堆的性质 假设们有一个数组aia_iai​，将其数组的下标记为kkk,其权值记为www，那么建成的笛卡尔树满足以下性质： kkk值满足二叉搜索树的性质，lsk&lt;k&lt;rskls_k&lt;k&lt;rs_klsk​&lt;k&lt;rsk​ www值满足小根堆的性质，lsw&lt;w,rsw&lt;wls_w&lt;w,rs_w&lt;wlsw​&lt;w,rsw​&lt;w 建树 首先加入第iii个数时，iii肯定在[1，i−1][1，i-1][1，i−1]构成的树右链的末尾节点，此时先插入iii，将其插到右链末尾节点，但此时这颗树不一定满足第二个性质，需要对其进行调整，若此时iii的父节点的www值比iii大，一直找到右链上www值比iii小的然后，先将iii节点的左儿子设为这个节点的右儿子，再将这个节点的右儿子设为iii,将nnn个点插入后，即可得到一棵笛卡尔树。 123456789101112void build(){ int top=0,st[maxn]; memset(st,0,sizeof(st)); for(int i=1;i&lt;=n;i++) { while(top&amp;&amp;a[st[top]]&gt;a[i])top--; if(!top)ls[i]=st[top+1]; else ls[i]=rs[st[top]],rs[st[top]]=i; st[++top]=i; }} 问题 我也不知道能干啥 🙃","link":"/2022/07/24/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"title":"类欧几里德","text":"很不错的算法呢，就是式子有点长，但还是不难推的( ´･･)ﾉ(._.`) 类欧几里得算法 前置知识 数学技巧 顶底函数 前言 类欧几里德算法是由洪华敦在 2016 年冬令营营员交流中提出的内容，其本质可以理解为，使用一个类似辗转相除法来做函数求和的过程。 主要还是推式子🤔 正文 问题1 设 f(a,b,c,n)=∑i=0n⌊ai+bc⌋(1,1)\\tag{1,1} f(a,b,c,n)= \\sum_{i=0}^n \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor f(a,b,c,n)=i=0∑n​⌊cai+b​⌋(1,1) 其中a,b,c,n∈Za,b,c,n \\in \\mathbb{Z}a,b,c,n∈Z。 一眼不可做，似乎像数论分块，但又好像不太行的样子。 a,b,c,na,b,c,na,b,c,n之间的关系也没给，那就分情况吧 首先考虑第一种情况a≥c,b≥ca \\ge c,b \\ge ca≥c,b≥c，（也是最简单的一种情况） 此时式子可以进一步化简为 ： f(a,b,c,n)=∑i=0n⌊ai+bc⌋=∑i=0n⌊(⌊ac⌋×c+a mod c)i+⌊bc⌋×c+b mod cc⌋=∑i=0n(⌊ac⌋i+⌊bc⌋+⌊(a mod c)i+b mod cc⌋)=∑i=0n⌊ac⌋i+∑i=0n⌊bc⌋+∑i=0n⌊(a mod c)i+b mod cc⌋=n(n+1)2⌊ac⌋+(n+1)⌊bc⌋+f(a mod c,b mod c,c,n)(1,2)\\tag{1,2} \\begin{aligned} f(a,b,c,n) &amp;= \\sum_{i=0}^n \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n \\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg) \\\\ &amp;=\\sum_{i=0}^n \\lfloor \\frac{a}{c} \\rfloor i+\\sum_{i=0}^n \\lfloor \\frac{b}{c}\\rfloor +\\sum_{i=0}^n \\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\frac{n(n+1)}{2} \\lfloor \\frac{a}{c} \\rfloor+(n+1)\\lfloor \\frac{b}{c}\\rfloor + f(a \\bmod c,b\\bmod c,c,n) \\end{aligned} f(a,b,c,n)​=i=0∑n​⌊cai+b​⌋=i=0∑n​⌊c(⌊ca​⌋×c+amodc)i+⌊cb​⌋×c+bmodc​⌋=i=0∑n​(⌊ca​⌋i+⌊cb​⌋+⌊c(amodc)i+bmodc​⌋)=i=0∑n​⌊ca​⌋i+i=0∑n​⌊cb​⌋+i=0∑n​⌊c(amodc)i+bmodc​⌋=2n(n+1)​⌊ca​⌋+(n+1)⌊cb​⌋+f(amodc,bmodc,c,n)​(1,2) 此时我们把式子化为了一个含有fff的递归式，接下来a,ba,ba,b必定会变得小于ccc，还需讨论另一种情况 a&lt;c,b&lt;ca &lt; c,b&lt; ca&lt;c,b&lt;c时，这时候也不能用上面的方法，🤔 利用枚举贡献的方法，将式子化为 ： f(a,b,c,n)=∑i=0n∑j=0⌊ai+bc⌋−11(1,3)\\tag{1,3} f(a,b,c,n)=\\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} 1 f(a,b,c,n)=i=0∑n​j=0∑⌊cai+b​⌋−1​1(1,3) 似乎什么都没有做的样子。。 需要进一步化简： ∑i=0n∑j=0⌊ai+bc⌋−11=∑i=0n∑j=0⌊an+bc⌋−1[j&lt;⌊ai+bc⌋](1,4)\\tag{1,4} \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} 1 = \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\bigg[j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\bigg] i=0∑n​j=0∑⌊cai+b​⌋−1​1=i=0∑n​j=0∑⌊can+b​⌋−1​[j&lt;⌊cai+b​⌋](1,4) 改了第二层求和的上界，好像有点头绪了 现在限制我们的就是后面的条件表达式了，也许可以将转化为某种方便计算的形式: ∵j&lt;⌊ai+bc⌋∴j≤ai+bc−1∴jc≤ai+b−c∴jc&lt;ai+b−c+1∴i&gt;jc+c−b−1a∴i&gt;⌊jc+c−b−1a⌋(1,5)\\tag{1,5} \\because j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\\\ \\therefore j\\le \\frac{ai+b}{c} -1 \\\\ \\therefore jc\\le ai+b-c \\\\ \\therefore jc &lt; ai+b-c+1\\\\ \\therefore i&gt;\\frac{jc+c-b-1}{a} \\\\ \\therefore i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor ∵j&lt;⌊cai+b​⌋∴j≤cai+b​−1∴jc≤ai+b−c∴jc&lt;ai+b−c+1∴i&gt;ajc+c−b−1​∴i&gt;⌊ajc+c−b−1​⌋(1,5) 这样的话原来的式子就变为了： f(a,b,c,n)=∑i=0n∑j=0⌊an+bc⌋−1[i&gt;⌊jc+c−b−1a⌋]=∑j=0⌊an+bc⌋−1∑i=0n[i&gt;⌊jc+c−b−1a⌋]=∑j=0⌊an+bc⌋−1∑i=⌊jc+c−b−1a⌋+1n1=∑j=0⌊an+bc⌋−1(n−⌊jc+c−b−1a⌋)=∑j=0⌊an+bc⌋−1n−∑j=0⌊an+bc⌋−1⌊jc+c−b−1a⌋=⌊an+bc⌋n−f(c,c−b−1,a,⌊an+bc⌋−1)(1,6)\\tag{1,6} \\begin{aligned} f(a,b,c,n) &amp;= \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor+1}^n1 \\\\ &amp;=\\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} (n-\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor) \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1}n- \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1}\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\\\ &amp;= \\lfloor\\frac{an+b}{c} \\rfloor n-f(c,c-b-1,a,\\lfloor\\frac{an+b}{c} \\rfloor-1) \\end{aligned} f(a,b,c,n)​=i=0∑n​j=0∑⌊can+b​⌋−1​[i&gt;⌊ajc+c−b−1​⌋]=j=0∑⌊can+b​⌋−1​i=0∑n​[i&gt;⌊ajc+c−b−1​⌋]=j=0∑⌊can+b​⌋−1​i=⌊ajc+c−b−1​⌋+1∑n​1=j=0∑⌊can+b​⌋−1​(n−⌊ajc+c−b−1​⌋)=j=0∑⌊can+b​⌋−1​n−j=0∑⌊can+b​⌋−1​⌊ajc+c−b−1​⌋=⌊can+b​⌋n−f(c,c−b−1,a,⌊can+b​⌋−1)​(1,6) 将⌊an+bc⌋\\lfloor\\frac{an+b}{c} \\rfloor⌊can+b​⌋设为mmm再整理一下，又得到一个递归式： f(a,b,c,n)=mn−f(c,c−b−1,a,m−1)(1,7)\\tag{1,7} f(a,b,c,n)=mn-f(c,c-b-1,a,m-1) f(a,b,c,n)=mn−f(c,c−b−1,a,m−1)(1,7) 综上（1,2）（1,6）： f(a,b,c,n)={n(n+1)2⌊ac⌋+(n+1)⌊bc⌋+f(a mod c,b mod c,c,n)a≥c∨b≥c⌊an+bc⌋n−f(c,c−b−1,a,⌊an+bc⌋−1)a&lt;c∧b&lt;c(1,8)\\tag{1,8} f(a,b,c,n)= \\left\\{ \\begin{aligned} &amp; \\frac{n(n+1)}{2} \\lfloor \\frac{a}{c} \\rfloor+(n+1)\\lfloor \\frac{b}{c}\\rfloor + f(a \\bmod c,b\\bmod c,c,n) &amp;a\\ge c\\vee b \\ge c\\\\ &amp;\\lfloor\\frac{an+b}{c} \\rfloor n-f(c,c-b-1,a,\\lfloor\\frac{an+b}{c} \\rfloor-1) &amp;a&lt;c\\land b&lt;c \\end{aligned} \\right. f(a,b,c,n)=⎩⎪⎪⎨⎪⎪⎧​​2n(n+1)​⌊ca​⌋+(n+1)⌊cb​⌋+f(amodc,bmodc,c,n)⌊can+b​⌋n−f(c,c−b−1,a,⌊can+b​⌋−1)​a≥c∨b≥ca&lt;c∧b&lt;c​(1,8) 可以在O(log⁡n)O(\\log n)O(logn)时间内求出。 问题2 设 g(a,b,c,n)=∑i=0ni⌊ai+bc⌋(2,1)\\tag{2,1} g(a,b,c,n)= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor g(a,b,c,n)=i=0∑n​i⌊cai+b​⌋(2,1) 其中a,b,c,n∈Za,b,c,n \\in \\mathbb{Z}a,b,c,n∈Z。 上个问题的升级版，（不就是多了个iii嘛，别骂了别骂了) 接着分情况，a≥c,b≥ca\\ge c,b\\ge ca≥c,b≥c时： g(a,b,c,n)=∑i=0ni⌊ai+bc⌋=∑i=0ni⌊(⌊ac⌋×c+a mod c)i+⌊bc⌋×c+b mod cc⌋=∑i=0ni(⌊ac⌋i+⌊bc⌋+⌊(a mod c)i+b mod cc⌋)=∑i=0n⌊ac⌋i2+∑i=0n⌊bc⌋i+∑i=0n⌊(a mod c)i+b mod cc⌋i=n(n+1)(2n+1)6⌊ac⌋+n(n+1)2⌊bc⌋+g(a mod c,b mod c,c,n)(2,2)\\tag{2,2} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n i \\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\\\ &amp;= \\sum_{i=0}^n i \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg) \\\\ &amp;=\\sum_{i=0}^n \\lfloor \\frac{a}{c} \\rfloor i^2+\\sum_{i=0}^n \\lfloor \\frac{b}{c}\\rfloor i +\\sum_{i=0}^n \\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor i \\\\ &amp;= \\frac{n(n+1)(2n+1)}{6} \\lfloor \\frac{a}{c} \\rfloor+ \\frac{n(n+1)}{2} \\lfloor \\frac{b}{c}\\rfloor+g(a\\bmod c,b\\bmod c,c,n) \\end{aligned} g(a,b,c,n)​=i=0∑n​i⌊cai+b​⌋=i=0∑n​i⌊c(⌊ca​⌋×c+amodc)i+⌊cb​⌋×c+bmodc​⌋=i=0∑n​i(⌊ca​⌋i+⌊cb​⌋+⌊c(amodc)i+bmodc​⌋)=i=0∑n​⌊ca​⌋i2+i=0∑n​⌊cb​⌋i+i=0∑n​⌊c(amodc)i+bmodc​⌋i=6n(n+1)(2n+1)​⌊ca​⌋+2n(n+1)​⌊cb​⌋+g(amodc,bmodc,c,n)​(2,2) 看来我们完成了一半了（似乎不是） a&lt;c,b&lt;ca&lt;c,b&lt;ca&lt;c,b&lt;c 时，枚举贡献将式子化为： g(a,b,c,n)=∑i=0n∑j=0⌊ai+bc⌋−1i(2,3)\\tag{2,3} g(a,b,c,n)=\\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} i g(a,b,c,n)=i=0∑n​j=0∑⌊cai+b​⌋−1​i(2,3) 改变上界： ∑i=0n∑j=0⌊ai+bc⌋−1i=∑i=0n∑j=0⌊an+bc⌋−1i[j&lt;⌊ai+bc⌋](2,4)\\tag{2,4} \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{ai+b}{c} \\rfloor -1} i = \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} i \\bigg[j&lt; \\lfloor\\frac{ai+b}{c} \\rfloor \\bigg] i=0∑n​j=0∑⌊cai+b​⌋−1​i=i=0∑n​j=0∑⌊can+b​⌋−1​i[j&lt;⌊cai+b​⌋](2,4) 转化条件表达式： g(a,b,c,n)=∑i=0n∑j=0⌊an+bc⌋−1i[i&gt;⌊jc+c−b−1a⌋]=∑j=0⌊an+bc⌋−1∑i=0ni[i&gt;⌊jc+c−b−1a⌋]=∑j=0⌊an+bc⌋−1∑i=⌊jc+c−b−1a⌋+1ni(2,5)\\tag{2,5} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^n \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} i \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n i \\Bigg[i&gt;\\bigg\\lfloor \\frac{jc+c-b-1}{a}\\bigg\\rfloor \\Bigg] \\\\ &amp;= \\sum_{j=0}^{\\lfloor\\frac{an+b}{c} \\rfloor -1} \\sum_{i=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor+1}^n i \\\\ \\end{aligned} g(a,b,c,n)​=i=0∑n​j=0∑⌊can+b​⌋−1​i[i&gt;⌊ajc+c−b−1​⌋]=j=0∑⌊can+b​⌋−1​i=0∑n​i[i&gt;⌊ajc+c−b−1​⌋]=j=0∑⌊can+b​⌋−1​i=⌊ajc+c−b−1​⌋+1∑n​i​(2,5) 设k=⌊jc+c−b−1a⌋,m=⌊an+bc⌋k=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor,m=\\lfloor \\frac{an+b}{c}\\rfloork=⌊ajc+c−b−1​⌋,m=⌊can+b​⌋，接着化简： g(a,b,c,n)=∑i=0m−1∑k+1ni=∑i=0m−1(n−k)(n+k+1)2=∑i=0m−1n2+n−k2−k2=12(mn2+mn−∑j=0m−1(⌊jc+c−b−1a⌋)2−∑i=0m−1⌊jc+c−b−1a⌋)(2,6)\\tag{2,6} \\begin{aligned} g(a,b,c,n) &amp;= \\sum_{i=0}^{m-1}\\sum_{k+1}^ni \\\\ &amp;= \\sum_{i=0}^{m-1}\\frac{(n-k)(n+k+1)}{2} \\\\ &amp;= \\sum_{i=0}^{m-1}\\frac{n^2+n-k^2-k}{2} \\\\ &amp;= \\frac{1}{2}\\bigg(mn^2+mn-\\sum_{j=0}^{m-1}(\\lfloor\\frac{jc+c-b-1}{a}\\rfloor)^2-\\sum_{i=0}^{m-1}\\lfloor\\frac{jc+c-b-1}{a}\\rfloor\\bigg) \\end{aligned} g(a,b,c,n)​=i=0∑m−1​k+1∑n​i=i=0∑m−1​2(n−k)(n+k+1)​=i=0∑m−1​2n2+n−k2−k​=21​(mn2+mn−j=0∑m−1​(⌊ajc+c−b−1​⌋)2−i=0∑m−1​⌊ajc+c−b−1​⌋)​(2,6) 。。。好像化的没问题啊，出现了一个没见过的平方，👀，先定义为h(a,b,c,n)h(a,b,c,n)h(a,b,c,n)吧，整理一下得： g(a,b,c,n)={n(n+1)(2n+1)6⌊ac⌋+n(n+1)2⌊bc⌋+g(a mod c,b mod c,c,n)a≥c∨b≥c12(⌊an+bc⌋n(n+1)−h(c,c−b−1,a,⌊an+bc⌋−1)−f(c,c−b−1,a,⌊an+bc⌋−1))a&lt;c∧b&lt;c(2,7)\\tag{2,7} g(a,b,c,n)= \\left\\{ \\begin{aligned} &amp; \\frac{n(n+1)(2n+1)}{6} \\lfloor \\frac{a}{c} \\rfloor+ \\frac{n(n+1)}{2} \\lfloor \\frac{b}{c}\\rfloor+g(a\\bmod c,b\\bmod c,c,n) &amp; a\\ge c\\vee b\\ge c \\\\ &amp; \\frac{1}{2}\\bigg( \\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor n(n+1) - h(c,c-b-1,a,\\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor-1)-f(c,c-b-1,a,\\bigg\\lfloor\\frac{an+b}{c}\\bigg\\rfloor-1)\\bigg) &amp; a&lt;c \\land b&lt;c \\end{aligned} \\right. g(a,b,c,n)=⎩⎪⎪⎨⎪⎪⎧​​6n(n+1)(2n+1)​⌊ca​⌋+2n(n+1)​⌊cb​⌋+g(amodc,bmodc,c,n)21​(⌊can+b​⌋n(n+1)−h(c,c−b−1,a,⌊can+b​⌋−1)−f(c,c−b−1,a,⌊can+b​⌋−1))​a≥c∨b≥ca&lt;c∧b&lt;c​(2,7) 接下来解决带平方的问题。 问题3 设 h(a,b,c,n)=∑i=0n(⌊ai+bc⌋)2(3,1)\\tag{3,1} h(a,b,c,n)=\\sum_{i=0}^n \\bigg(\\bigg\\lfloor \\frac{ai+b}{c}\\bigg\\rfloor \\bigg)^2 h(a,b,c,n)=i=0∑n​(⌊cai+b​⌋)2(3,1) 其中a,b,c,n∈Za,b,c,n \\in \\mathbb{Z}a,b,c,n∈Z。 上个问题还没有完全解决，需要解出h(a,b,c,n)h(a,b,c,n)h(a,b,c,n)，（不就多了个平方嘛，轻车熟路了，别打了别打了） h(a,b,c,n)=∑i=0n(⌊ai+bc⌋)2=∑i=0n(⌊(⌊ac⌋×c+a mod c)i+⌊bc⌋×c+b mod cc⌋)2=∑i=0n(⌊ac⌋i+⌊bc⌋+⌊(a mod c)i+b mod cc⌋)2(3,2)\\tag{3,2} \\begin{aligned} h(a,b,c,n) &amp;= \\sum_{i=0}^n \\bigg(\\bigg\\lfloor\\frac{ai+b}{c} \\bigg\\rfloor\\bigg)^2\\\\ &amp;= \\sum_{i=0}^n \\bigg(\\bigg\\lfloor\\frac{(\\lfloor \\frac{a}{c} \\rfloor \\times c +a \\bmod c)i+\\lfloor \\frac{b}{c} \\rfloor \\times c +b \\bmod c}{c} \\bigg\\rfloor \\bigg)^2\\\\ &amp;= \\sum_{i=0}^n \\bigg(\\lfloor \\frac{a}{c} \\rfloor i+\\lfloor \\frac{b}{c}\\rfloor +\\bigg\\lfloor \\frac{(a\\bmod c)i+b \\bmod c}{c} \\bigg\\rfloor \\bigg)^2 \\\\ \\end{aligned} h(a,b,c,n)​=i=0∑n​(⌊cai+b​⌋)2=i=0∑n​(⌊c(⌊ca​⌋×c+amodc)i+⌊cb​⌋×c+bmodc​⌋)2=i=0∑n​(⌊ca​⌋i+⌊cb​⌋+⌊c(amodc)i+bmodc​⌋)2​(3,2) 手动多项式乘法！ 原式变为： h(a,b,c,n)=h(a mod c,b mod c,c,n)+2⌊bc⌋f(a mod c,b mod c,c,n)+2⌊ac⌋g(a mod c,b mod c,c,n)+⌊ac⌋2n(n+1)(2n+1)6+⌊bc⌋2(n+1)+⌊ac⌋⌊bc⌋n(n+1)(3,3)\\tag{3,3} h(a,b,c,n) =h(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{b}{c}\\right\\rfloor f(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{a}{c}\\right\\rfloor g(a\\bmod c,b\\bmod c,c,n) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2(n+1) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor n(n+1) h(a,b,c,n)=h(amodc,bmodc,c,n)+2⌊cb​⌋f(amodc,bmodc,c,n)+2⌊ca​⌋g(amodc,bmodc,c,n)+⌊ca​⌋26n(n+1)(2n+1)​+⌊cb​⌋2(n+1)+⌊ca​⌋⌊cb​⌋n(n+1)(3,3) 接着考虑a&lt;c,b&lt;ca&lt;c,b&lt;ca&lt;c,b&lt;c的情况，设k=⌊jc+c−b−1a⌋,m=⌊an+bc⌋k=\\lfloor\\frac{jc+c-b-1}{a}\\rfloor,m=\\lfloor \\frac{an+b}{c}\\rfloork=⌊ajc+c−b−1​⌋,m=⌊can+b​⌋， 平方可以拆成： n2=2n(n+1)2−n=(2∑i=0ni)−n(3,3)\\tag{3,3} n^2=2\\frac{n(n+1)}{2}-n=\\bigg( 2\\sum_{i=0}^n i\\bigg) -n n2=22n(n+1)​−n=(2i=0∑n​i)−n(3,3) 避免了出现∑×∑\\sum \\times \\sum∑×∑，神一样的数学技巧 h(a,b,c,n)=∑i=0n⌊ai+bc⌋2=∑i=0n[(2∑j=1⌊ai+bc⌋j)−⌊ai+bc⌋]=(2∑i=0n∑j=1⌊ai+bc⌋j)−f(a,b,c,n)(3,4)\\tag{3,4} \\begin{aligned} h(a,b,c,n) &amp;=\\sum_{i=0}^n\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor^2 \\\\ &amp;=\\sum_{i=0}^n\\left[\\left(2\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j \\right)-\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\right]\\\\ &amp;=\\left(2\\sum_{i=0}^n\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j\\right) -f(a,b,c,n)\\\\ \\end{aligned} h(a,b,c,n)​=i=0∑n​⌊cai+b​⌋2=i=0∑n​⎣⎢⎡​⎝⎜⎛​2j=1∑⌊cai+b​⌋​j⎠⎟⎞​−⌊cai+b​⌋⎦⎥⎤​=⎝⎜⎛​2i=0∑n​j=1∑⌊cai+b​⌋​j⎠⎟⎞​−f(a,b,c,n)​(3,4) 接着化简前面的部分： ∑i=0n∑j=1⌊ai+bc⌋j=∑i=0n∑j=0⌊ai+bc⌋−1(j+1)=∑j=0m−1(j+1)∑i=0n[j&lt;⌊ai+bc⌋]=∑j=0m−1(j+1)∑i=0n[i&gt;k]=∑j=0m−1(j+1)(n−k)=12nm(m+1)−∑j=0m−1(j+1)⌊jc+c−b−1a⌋=12nm(m+1)−g(c,c−b−1,a,m−1)−f(c,c−b−1,a,m−1)(3,5)\\tag{3,5} \\begin{aligned} \\sum_{i=0}^n\\sum_{j=1}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor}j &amp;=\\sum_{i=0}^n\\sum_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1}(j+1)\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^n\\left[j&lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor\\right]\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^n[i&gt;k]\\\\ &amp;=\\sum_{j=0}^{m-1}(j+1)(n-k)\\\\ &amp;=\\frac{1}{2}nm(m+1)-\\sum_{j=0}^{m-1}(j+1)\\left\\lfloor \\frac{jc+c-b-1}{a} \\right\\rfloor\\\\ &amp;=\\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1) \\end{aligned} i=0∑n​j=1∑⌊cai+b​⌋​j​=i=0∑n​j=0∑⌊cai+b​⌋−1​(j+1)=j=0∑m−1​(j+1)i=0∑n​[j&lt;⌊cai+b​⌋]=j=0∑m−1​(j+1)i=0∑n​[i&gt;k]=j=0∑m−1​(j+1)(n−k)=21​nm(m+1)−j=0∑m−1​(j+1)⌊ajc+c−b−1​⌋=21​nm(m+1)−g(c,c−b−1,a,m−1)−f(c,c−b−1,a,m−1)​(3,5) 整理一下： h(a,b,c,n)={h(a mod c,b mod c,c,n)+2⌊bc⌋f(a mod c,b mod c,c,n)+2⌊ac⌋g(a mod c,b mod c,c,n)+⌊ac⌋2n(n+1)(2n+1)6+⌊bc⌋2(n+1)+⌊ac⌋⌊bc⌋n(n+1)a≥c∨b≥cn⌊an+bc⌋(⌊an+bc⌋+1)−2g(c,c−b−1,a,⌊an+bc⌋−1)−2f(c,c−b−1,a,⌊an+bc⌋−1)−f(a,b,c,n)a&lt;c∧b&lt;c(3,6)\\tag{3,6} h(a,b,c,n)= \\left\\{ \\begin{aligned} &amp;h(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{b}{c}\\right\\rfloor f(a\\bmod c,b\\bmod c,c,n) +2\\left\\lfloor\\frac{a}{c}\\right\\rfloor g(a\\bmod c,b\\bmod c,c,n) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2\\frac{n(n+1)(2n+1)}{6}+\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2(n+1) +\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor n(n+1) &amp; a\\ge c \\vee b\\ge c \\\\ &amp; n\\lfloor \\frac{an+b}{c}\\rfloor(\\lfloor \\frac{an+b}{c}\\rfloor+1)-2g(c,c-b-1,a,\\lfloor \\frac{an+b}{c}\\rfloor-1)-2f(c,c-b-1,a,\\lfloor \\frac{an+b}{c}\\rfloor-1)-f(a,b,c,n) &amp; a&lt;c \\land b&lt;c \\end{aligned} \\right. h(a,b,c,n)=⎩⎪⎪⎨⎪⎪⎧​​h(amodc,bmodc,c,n)+2⌊cb​⌋f(amodc,bmodc,c,n)+2⌊ca​⌋g(amodc,bmodc,c,n)+⌊ca​⌋26n(n+1)(2n+1)​+⌊cb​⌋2(n+1)+⌊ca​⌋⌊cb​⌋n(n+1)n⌊can+b​⌋(⌊can+b​⌋+1)−2g(c,c−b−1,a,⌊can+b​⌋−1)−2f(c,c−b−1,a,⌊can+b​⌋−1)−f(a,b,c,n)​a≥c∨b≥ca&lt;c∧b&lt;c​(3,6) 时间复杂度均为O(log⁡n)O(\\log n)O(logn)！ 后寄 推完后人傻了😱😱😱，推hhh后半部分的时候照着OIWiki打的，我太菜了，呜呜呜~。","link":"/2022/07/24/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"},{"title":"虚树","text":"虚树讲解 虚树 前言 在一些树形dp的题目中，有的题目会出现关键点的要求，此时数据范围会和询问的总个数有关，这类问题每次跑一边树形dp复杂度不优，虚树可以将复杂度降至O(∑ki)O(\\sum k_i)O(∑ki​)，来解决问题。 正文 虚树 虚树其实就是对于每次询问，只保留了有用的关键节点建出来的树形结构，可以有效的降低时间复杂度。 虚树的构建 假设我们现在有kkk个关键点，对其建成一棵虚树的操作如下。 将关键点按dfs序排序 遍历一遍，求出相邻两个关键点的LCA 根据原树中的节点关系建树 这个过程可以使用单调栈来实现。 首先将根节点加入单调栈中，按dfs序排序后逐个加入当前询问中的关键点，假设当前加入的点为kik_iki​，先求出kik_iki​和当前栈顶的LCA，如果当前的栈顶元素和求出的LCA不同，说明新加入的元素不在当前的子树中，我们需要按dfs序找到LCA在栈中的位置，将dfs序大于LCA的弹出栈同时进行连边操作。如果LCA不在栈中需要将其加入栈中，最后加入当前节点，处理完后，还需要将最后栈中存下的节点之间建好边。 通过上述过程，不难看出栈中维护的是一条到栈顶元素的链，建好虚树后，就可以在上面dp了，时间复杂度O(∑(klog⁡k+klog⁡n))O(\\sum(k \\log k + k \\log n))O(∑(klogk+klogn))。 代码如下， 1234567891011121314151617181920212223242526272829bool cmp(int x, int y){ return dfn[x] &lt; dfn[y];}void insert(int x){ if(st[top] == x)return; int lca = LCA(x, st[top]); if(lca != st[top]) { while(dfn[lca] &lt; dfn[st[top - 1]]) add(st[top - 1], st[top]), top--; if(dfn[lca] &gt; dfn[st[top - 1]]) add(lca, st[top]), st[top] = lca; else add(lca, st[top--]); } st[++top] = x;}void build(int n){ sort(k + 1, k + n + 1, cmp); st[++top] = 1; for(int i = 1; i &lt;= n; i++) insert(k[i]); for(int i = 1; i &lt; top; i++) add(st[i], st[i + 1]);} 说实话我不会五行建虚树。 应用 P2495 消耗战 首先考虑转移方程不难得到，设fxf_xfx​表示使xxx不与其子树中任意一个关键点连通的最小代价，枚举其子节点， 若vvv是关键点，fx=fx+w(x,v)f_x = f_x + w(x, v)fx​=fx​+w(x,v) 若vvv不是关键点，fx=fx+min⁡{fv,w(x,v)}f_x = f_x + \\min\\{f_v, w(x, v)\\}fx​=fx​+min{fv​,w(x,v)} 这样每次跑一遍是O(nq)O(nq)O(nq)的，考虑每次建出虚树来直接在虚树上转移即可优化复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2.5e5 + 10;const int M = 5e5 + 10;const int INF = 1e15;int n, m;int cnt, head[N];struct edge{ int to, nxt, cost; edge(int _v = 0, int _n = 0, int _c = 0): to(_v), nxt(_n), cost(_c) {}}e[M &lt;&lt; 1];void add(int u, int v, int c){ e[++cnt] = edge(v, head[u], c); head[u] = cnt;}int tot;int siz[N], fa[N], top[N], son[N], depth[N], id[N];int Min[N];void dfs1(int x, int father){ siz[x] = 1; fa[x] = father; depth[x] = depth[father] + 1; int maxs = -1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; int c = e[i].cost; if(v == father)continue; Min[v] = min(Min[x], c); dfs1(v, x); siz[x] += siz[v]; if(siz[v] &gt; maxs) maxs = siz[v], son[x] = v; }}void dfs2(int x, int topfather){ id[x] = ++tot; top[x] = topfather; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x])continue; dfs2(v, v); }}int LCA(int x, int y){ while(top[x] != top[y]) { if(depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } if(depth[x] &gt; depth[y])swap(x, y); return x;}int st[N];vector&lt;int&gt; v[N];void calc(int x){ if(tot == 1) { st[++tot] = x; return; } int lca = LCA(x, st[tot]); if(lca == st[tot])return; while(tot &gt; 1 &amp;&amp; id[st[tot-1]] &gt;= id[lca]) { v[st[tot-1]].push_back(st[tot]); tot--; } if(st[tot] != lca) { v[lca].push_back(st[tot]); st[tot] = lca; } st[++tot] = x;}int dp(int x){ if(!v[x].size())return Min[x]; int sum = 0; for(int i = 0; i &lt; v[x].size(); i++) sum += dp(v[x][i]); v[x].clear(); return min(Min[x], sum);}int a[N];bool cmp(int x, int y){ return id[x] &lt; id[y];}signed main(){ scanf(&quot;%lld&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y, z; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); } Min[1] = INF; dfs1(1, 0); dfs2(1, 1); int T; tot = 0; scanf(&quot;%lld&quot;, &amp;T); while(T--) { int m; scanf(&quot;%lld&quot;, &amp;m); for(int i = 1; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a+1, a+m+1, cmp); st[++tot] = 1; for(int i = 1; i &lt;= m; i++)calc(a[i]); while(tot) { v[st[tot-1]].push_back(st[tot]); tot--; } printf(&quot;%lld\\n&quot;, dp(1)); } return 0;} CF613D Kingdom and its Cities 首先考虑如何转移，显然就是分一下情况设fxf_xfx​表示让以xxx的子树中询问点不连通的最少花费，gxg_xgx​表示当前子树中还有多少个需要断开的询问点 当前点是询问点时，fx=fx+gx,gx=1f_x = f_x + g_x, g_x = 1fx​=fx​+gx​,gx​=1 当前点不是询问点时，fx=fx+1,gx=0f_x = f_x + 1, g_x = 0fx​=fx​+1,gx​=0 然后建出虚树转移即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, q;int k[N], b[N];int cnt, head[N];struct edge{ int to, nxt; edge(int v = 0, int x = 0) : to(v), nxt(x) {}};edge e[N &lt;&lt; 1];void add(int u, int v){ e[++cnt] = edge(v, head[u]); head[u] = cnt; e[++cnt] = edge(u, head[v]); head[v] = cnt;}int tim, dfn[N];int depth[N], top[N], son[N], siz[N], fa[N];void dfs1(int x, int father){ dfn[x] = ++tim; fa[x] = father; depth[x] = depth[fa[x]] + 1; siz[x] = 1; for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x])continue; dfs1(v, x); siz[x] += siz[v]; if(siz[v] &gt; siz[son[x]]) son[x] = v; }}void dfs2(int x, int topfather){ top[x] = topfather; if(!son[x])return; dfs2(son[x], topfather); for(int i = head[x]; i; i = e[i].nxt) { int v = e[i].to; if(v == fa[x] || v == son[x]) continue; dfs2(v, v); }}int LCA(int x, int y){ while(top[x] != top[y]) { if(depth[top[x]] &lt; depth[top[y]]) swap(x, y); x = fa[top[x]]; } if(depth[x] &gt; depth[y]) swap(x, y); return x;}int st[N], t;int f[N], h[N], c[N];vector &lt;int&gt; g[N];void link(int x, int y){ g[x].push_back(y);}void clear(int x){ f[x] = h[x] = c[x] = 0; g[x].clear();}void insert(int x){ if(st[t] == x)return; int lca = LCA(st[t], x); if(lca != st[t]) { while(dfn[lca] &lt; dfn[st[t - 1]]) link(st[t - 1], st[t]), t--; if(dfn[lca] &gt; dfn[st[t - 1]]) clear(lca), link(lca, st[t]), st[t] = lca; else link(lca, st[t--]); } st[++t] = x; clear(x);}bool cmp(int x, int y){ return dfn[x] &lt; dfn[y];}void build(int n){ sort(k + 1, k + n + 1, cmp); t = 0; st[++t] = 1; clear(1); for(int i = 1; i &lt;= n; i++) insert(k[i]); for(int i = 1; i &lt; t; i++) link(st[i], st[i + 1]);}void dp(int x, int fa){ for(auto v : g[x]) { dp(v, x); f[x] += f[v]; h[x] += h[v]; } if(f[x] == -1)return; if(b[x])f[x] += h[x], h[x] = 1; else if(h[x] &gt; 1)f[x]++, h[x] = 0;}int main(){ scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); add(x, y); } dfs1(1, 0); dfs2(1, 0); scanf(&quot;%d&quot;, &amp;q); for(int i = 1; i &lt;= q; i++) { int m; scanf(&quot;%d&quot;, &amp;m); for(int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;k[j]), b[k[j]] = 1; bool flag = true; for(int j = 1; j &lt;= m; j++) { if(b[fa[k[j]]] &amp;&amp; k[j] != 1) { printf(&quot;-1\\n&quot;); flag = false; break; } } if(flag){build(m); dp(1, 0); printf(&quot;%d\\n&quot;, f[1]);} for(int j = 1; j &lt;= m; j++) b[k[j]] = 0; } return 0;} 后记 不算难，（难的是真的难。","link":"/2022/11/07/%E8%99%9A%E6%A0%91/"},{"title":"计算几何","text":"真的是超详细的计算几何全家桶哦！ヾ(≧▽≦*)o upd：2022-7-25 又进行了一些修修补补，内容更多了，但我还是蒟蒻。 另外这篇文章的代码过于恶臭，请见谅。 计算几何 前置知识 可以在二维生物和三维生物之间自由转换 前言 计算几何的话估计很久就已经不考了吧，但学一学的话，似乎也是无所谓有也无所谓无的吧很有好处的，（毕竟可以水题）。 计算几何 定义：对几何外形信息的计算机表示分析。（其实就是利用计算机建立数学模型解决几何问题。） 计算几何研究的对象是几何图形。早期人们对于图像的研究一般都是先建立坐标系，把图形转换成函数，然后用插值和逼近的数学方法，特别是用样条函数作为工具来分析图形，取得了可喜的成功。然而，这些方法过多地依赖于坐标系的选取，缺乏几何不变性，特别是用来解决某些大挠度曲线及曲线的奇异点等问题时，有一定的局限性。 二维计算几何基础 平面直角坐标系 平面直角坐标系其实就是笛卡尔坐标系，在计算几何中，我们经常会用到坐标表示，点和向量都是通过坐标来保存的。 极坐标系 极角坐标系，是指在平面内由极点，极轴和极径组成的坐标系。 其实极点就是对应平面直角坐标系中的原点，极轴对应的就是xxx正半轴（似乎不太严谨），利用一个有序点对P(d,θ)P(d,\\theta)P(d,θ)来表示一个点，ddd就是对应的极径，θ\\thetaθ为与极轴的夹角，（其实和平面直角坐标系没啥区别） 向量及其运算 向量的基础知识 向量（也称为欧几里得向量、几何向量、矢量）：既有大小又有方向的量称为向量。在数学中研究的向量为自由向量，即只要不改变它的大小和方向，起点和终点可以任意平行移动的向量。记a⃗\\vec{a}a或a。 有向线段：带有方向的线段称为有向线段。有向线段三要素：起点，方向，长度，有了三要素，终点就唯一确定。我们用有向线段表示向量。 向量的模：有向线段AB→\\overrightarrow{AB}AB的长度称为向量的模，其实就是向量的大小。即为∣AB→∣|\\overrightarrow{AB}|∣AB∣或∣a⃗∣|\\vec{a}|∣a∣。 零向量：模为零的向量。零向量的方向任意。 单位向量：模为 1 的向量称为该方向上的单位向量。 平行向量：方向相同或相反的两个非零向量。记作a∥ba\\parallel ba∥b。对于多个互相平行的向量，可以任作一条直线与这些向量平行，那么任一组平行向量都可以平移到同一直线上，所以平行向量又叫共线向量。 滑动向量：沿着直线作用的向量称为滑动向量。 固定向量：作用于一点的向量称为固定向量。 相等向量：模相等且方向相同的向量。 相反向量：模相等且方向相反的向量。 向量的夹角：已知两个非零向量 a⃗,b⃗\\vec{a},\\vec{b}a,b, 作OA→=a⃗,OB→=b⃗\\overrightarrow{OA}=\\vec{a},\\overrightarrow{OB}=\\vec{b}OA=a,OB=b， 那么向量 a⃗\\vec{a}a与向量 b⃗\\vec{b}b 的夹角。记作：⟨a,b⟩\\left\\langle a,b \\right\\rangle⟨a,b⟩，显然当 θ=0\\theta=0θ=0 时，两向量同向， θ=π\\theta= \\piθ=π 时两向量反向，θ=π2\\theta = \\frac{\\pi}{2}θ=2π​ 时，两向量垂直，记作 a⃗⊥b⃗\\vec{a} \\perp \\vec{b}a⊥b 。并且我们规定 θ∈[0,π]\\theta \\in [0,\\pi]θ∈[0,π] 。 注意：平面向量具有方向性，我们并不能比较两个向量的大小（但可以比较两向量的模长）。但是两个向量可以相等。 向量的运算 设a⃗=(x1,y1)\\vec{a}=(x_1,y_1)a=(x1​,y1​),b⃗=(x2,y2)\\vec{b}=(x_2,y_2)b=(x2​,y2​)。 加减法 既然向量具有平移不变性，那么a⃗+b⃗\\vec{a}+\\vec{b}a+b就是将两条有向线段相连，即:a⃗+b⃗=(x1+x2,y1+y2)\\vec{a}+\\vec{b}=(x_1+x_2,y_1+y_2)a+b=(x1​+x2​,y1​+y2​)。 那向量的减法a⃗−b⃗\\vec{a}-\\vec{b}a−b，其实就是a⃗+(−b⃗)\\vec{a}+(-\\vec{b})a+(−b),即a⃗−b⃗=(x1−x2,y1−y2)\\vec{a}-\\vec{b}=(x_1-x_2,y_1-y_2)a−b=(x1​−x2​,y1​−y2​)。 向量的加减法是满足以下法则的： 三角形法则：若要求和的向量首尾顺次相连，那么这些向量的和为第一个向量的起点指向最后一个向量的终点； 平行四边形法则：若要求和的两个向量共起点，那么它们的和向量为以这两个向量为邻边的平行四边形的对角线，起点为两个向量共有的起点，方向沿平行四边形对角线方向。 所以说向量的加减法就有了几何意义，并且满足交换律和结合律。 数乘 规定⌈实数λ与向量a⃗的积⌋\\left\\lceil 实数\\lambda与向量\\vec{a}的积 \\right\\rfloor⌈实数λ与向量a的积⌋为一个向量，这种运算就是数乘。记作λa⃗\\lambda\\vec{a}λa,并且满足以下性质： ∣λa⃗∣=∣λ∣∣a⃗∣|\\lambda\\vec{a}|=|\\lambda||\\vec{a}|∣λa∣=∣λ∣∣a∣； 当λ&gt;0\\lambda&gt;0λ&gt;0时，λa⃗\\lambda\\vec{a}λa与a⃗\\vec{a}a同向，当λ=0\\lambda=0λ=0时，λa⃗=0\\lambda\\vec{a}=0λa=0，当λ&lt;0\\lambda&lt;0λ&lt;0时，λa⃗\\lambda\\vec{a}λa与a⃗\\vec{a}a方向相反。 λ(μa⃗)=(λμ)a⃗(λ+μ)a⃗=λa⃗+μa⃗λ(a⃗+b⃗)=λa⃗+λb⃗(−λ)a⃗=−(λa⃗)=−λ(a⃗)λ(a⃗−b⃗)=λa⃗−λb⃗\\lambda(\\mu\\vec{a})=(\\lambda\\mu)\\vec{a} \\\\ (\\lambda+\\mu)\\vec{a}=\\lambda\\vec{a}+\\mu\\vec{a} \\\\ \\lambda(\\vec{a}+\\vec{b})=\\lambda\\vec{a}+\\lambda\\vec{b} \\\\ (-\\lambda)\\vec{a}=-(\\lambda\\vec{a})=-\\lambda(\\vec{a}) \\\\ \\lambda(\\vec{a}-\\vec{b})=\\lambda\\vec{a}-\\lambda\\vec{b} λ(μa)=(λμ)a(λ+μ)a=λa+μaλ(a+b)=λa+λb(−λ)a=−(λa)=−λ(a)λ(a−b)=λa−λb （向量的数乘其实就是对向量进行放缩） 点积 向量的点积也叫数量积、内积，向量的点积表示为a⃗⋅b⃗\\vec{a}·\\vec{b}a⋅b,是一个实数。计算式为： a⃗⋅b⃗=∣a⃗∣∣b⃗∣cosθ(θ=⟨a⃗,b⃗⟩)(θ表示a⃗,b⃗的夹角)\\vec{a}·\\vec{b}=|\\vec{a}||\\vec{b}|cos\\theta(\\theta=\\left\\langle \\vec{a},\\vec{b} \\right\\rangle)(\\theta表示\\vec{a},\\vec{b}的夹角) a⋅b=∣a∣∣b∣cosθ(θ=⟨a,b⟩)(θ表示a,b的夹角) 三角形恒等变换的推导： ∵a⃗⋅b⃗=∣a⃗∣∣b⃗∣cosθ∴a⃗⋅b⃗=(x1)2+(y1)2⋅(x2)2+(y2)2⋅cosθ∵cosθ=cos(α−β)=cosαcosβ+sinαsinβ∵cosα=x1(x1)2+(y1)2,sinα=x1(y1)2+(y1)2cosβ=x2(x2)2+(y2)2,sinβ=y2(x2)2+(y2)2∴整理代入得：a⃗⋅b⃗=x1x2+y1y2\\because \\vec{a}·\\vec{b}=|\\vec{a}||\\vec{b}|cos\\theta\\\\ \\therefore \\vec{a}·\\vec{b}=\\sqrt{(x_1)^2+(y_1)^2}·\\sqrt{(x_2)^2+(y_2)^2}·cos\\theta\\\\ \\because cos\\theta=cos(\\alpha-\\beta)=cos\\alpha cos\\beta + sin\\alpha sin\\beta\\\\ \\because cos\\alpha=\\dfrac{x_1}{\\sqrt{(x_1)^2+(y_1)^2}},sin\\alpha=\\dfrac{x_1}{\\sqrt{(y_1)^2+(y_1)^2}}\\\\ cos\\beta=\\dfrac{x_2}{\\sqrt{(x_2)^2+(y_2)^2}},sin\\beta=\\dfrac{y_2}{\\sqrt{(x_2)^2+(y_2)^2}}\\\\ \\therefore 整理代入得：\\vec{a}·\\vec{b}=x_1x_2+y_1y_2 ∵a⋅b=∣a∣∣b∣cosθ∴a⋅b=(x1​)2+(y1​)2​⋅(x2​)2+(y2​)2​⋅cosθ∵cosθ=cos(α−β)=cosαcosβ+sinαsinβ∵cosα=(x1​)2+(y1​)2​x1​​,sinα=(y1​)2+(y1​)2​x1​​cosβ=(x2​)2+(y2​)2​x2​​,sinβ=(x2​)2+(y2​)2​y2​​∴整理代入得：a⋅b=x1​x2​+y1​y2​ 同时点积是满足交换律，结合律和分配律的。 叉积 也叫矢量积，外积。几何意义是两向量由平行四边形法则围成的面积。叉积是一个向量，垂直于原来两个向量所在的平面。（根据叉乘的模是平行四边形的面积我们可以想象，叉乘的结果是一个有方向的面，而面的方向平行于面的法线，所以面的方向垂直于面上任何一个向量），即： ∣a⃗×b⃗∣=∣a⃗∣∣b⃗∣sin⟨a,b⟩|\\vec{a} × \\vec{b}|=|\\vec{a}||\\vec{b}|sin\\left\\langle a,b \\right\\rangle ∣a×b∣=∣a∣∣b∣sin⟨a,b⟩ （upd：这里的叉积定义感觉不太严谨，毕竟在数学中一般定义⟨a,b⟩∈[0,π]\\left\\langle a,b \\right\\rangle \\in [0,\\pi]⟨a,b⟩∈[0,π],这里显然∈[0,2π]\\in[0,2 \\pi]∈[0,2π]，但这可以帮助我们推出坐标表示下的公式） 并且，a⃗×b⃗=(x1y2−x2y2)\\vec{a}×\\vec{b}=(x_1y_2-x_2y_2)a×b=(x1​y2​−x2​y2​)。 叉积是一个有向面积： a⃗×b⃗=0\\vec{a}×\\vec{b}=0a×b=0，等价于a⃗,b⃗\\vec{a},\\vec{b}a,b，共线（可以反向）； a⃗×b⃗&gt;0\\vec{a}×\\vec{b}&gt;0a×b&gt;0，b⃗\\vec{b}b在a⃗\\vec{a}a左侧； a⃗×b⃗&lt;0\\vec{a}×\\vec{b}&lt;0a×b&lt;0，b⃗\\vec{b}b在a⃗\\vec{a}a右侧。 需要注意的是a⃗×b⃗≠b⃗×a⃗\\vec{a} \\times \\vec{b} \\ne \\vec{b} \\times \\vec{a}a×b​=b×a，只是绝对值相等。 判断两向量共线 两个非零向量a⃗\\vec{a}a与b⃗\\vec{b}b共线 ⟺ \\iff⟺有唯一实数λ\\lambdaλ，使得b⃗=λa⃗\\vec{b}=\\lambda\\vec{a}b=λa。由向量的数乘即可得证。 推论：如果lll为已经过点 A 且平行于已知非零向量a⃗\\vec{a}a的直线，那么对空间任一点 O，点 P 在直线lll上的充要条件是存在实数ttt，满足等式：OP⃗=OA⃗+ta⃗\\vec{OP}=\\vec{OA}+t\\vec{a}OP=OA+ta。 其中向量a⃗\\vec{a}a叫做直线lll的方向向量。 基本定理和坐标表示 平面向量基本定理 平面向量基本定理：两个向量a⃗\\vec{a}a和b⃗\\vec{b}b不共线的充要条件是，对于和向量a⃗\\vec{a}a，b⃗\\vec{b}b共面的任意向量p⃗\\vec{p}p​，有唯一实数对(x,y)(x,y)(x,y)满足p⃗=xa⃗+yb⃗\\vec{p}=x\\vec{a}+y\\vec{b}p​=xa+yb。 证明(非常简单): 对于平面上的任意向量可以沿指定方向被分解为任意两个向量，平面上的任意两个向量可以沿指定方向合成任意指定向量。对于有唯一实数对我们可以用反证法:假设有两个及以上的实数对满足要求为(m,n)∴xa⃗+yb⃗=ma⃗+nb⃗∴(x−m)a⃗=(n−y)b⃗∵a⃗和b⃗不共线∴x=m,n=y与假设矛盾所以结论成立证毕对于平面上的任意向量可以沿指定方向被分解为任意两个向量，\\\\ 平面上的任意两个向量可以沿指定方向合成任意指定向量。\\\\ 对于有唯一实数对我们可以用反证法:\\\\ 假设有两个及以上的实数对满足要求为(m,n)\\\\ \\therefore x\\vec{a}+y\\vec{b}=m\\vec{a}+n\\vec{b}\\\\ \\therefore (x-m)\\vec{a}=(n-y)\\vec{b}\\\\ \\because \\vec{a}和\\vec{b}不共线\\\\ \\therefore x=m,n=y\\\\ 与假设矛盾所以结论成立\\\\证毕 对于平面上的任意向量可以沿指定方向被分解为任意两个向量，平面上的任意两个向量可以沿指定方向合成任意指定向量。对于有唯一实数对我们可以用反证法:假设有两个及以上的实数对满足要求为(m,n)∴xa+yb=ma+nb∴(x−m)a=(n−y)b∵a和b不共线∴x=m,n=y与假设矛盾所以结论成立证毕 在同一平面内的两个不共线的向量称为基底。 如果基底相互垂直，那么我们在分解的时候就是对向量正交分解。 平面向量的坐标表示 如果取与横轴与纵轴方向相同的单位向量i,ji,ji,j作为一组基底，根据平面向量基本定理，平面上的所有向量与有序实数对(x,y)(x,y)(x,y)一一对应。 而有序数对(x,y)(x,y)(x,y)与平面直角坐标系上的点一一对应，那么我们作OP⃗=p⃗\\vec{OP}=\\vec{p}OP=p​，那么终点P(x,y)P(x,y)P(x,y)也是唯一确定的。由于我们研究的都是自由向量，可以自由平移起点，这样，在平面直角坐标系里，每一个向量都可以用有序实数对唯一表示。 坐标运算 平面向量线性运算 由平面向量的线性运算，我们可以推导其坐标运算，主要方法是将坐标全部化为用基底表示，然后利用运算律进行合并，之后表示出运算结果的坐标形式。 对于向量a⃗=(m,n)\\vec{a}=(m,n)a=(m,n)和向量b⃗=(p,q)\\vec{b}=(p,q)b=(p,q)，则有： a⃗+b⃗=(m+n,n+q)a⃗−b⃗=(m−n,n−q)ka⃗=(km,kn),kb⃗=(kq,kq)\\vec{a}+\\vec{b}=(m+n,n+q)\\\\ \\vec{a}-\\vec{b}=(m-n,n-q)\\\\ k\\vec{a}=(km,kn),k\\vec{b}=(kq,kq) a+b=(m+n,n+q)a−b=(m−n,n−q)ka=(km,kn),kb=(kq,kq) 向量的坐标表示 已知两点A(a,b),B(c,d)A(a,b),B(c,d)A(a,b),B(c,d),则AB⃗=(c−a,d−b)\\vec{AB}=(c-a,d-b)AB=(c−a,d−b)。 平移一点 将一点PPP沿一定方向平移某单位长度，只需要将要平移的方向和距离组合成一个向量，利用三角形法则，用OP⃗\\vec{OP}OP加上这个向量即可，得到的向量终点即为平移后的点。 三点共线的判定 在平面上A,B,CA,B,CA,B,C三点共线的充要条件是：OC⃗=λOB⃗+(1−λ)OA⃗,(O为平面内不与直线AC共线任意一点)\\vec{OC}=\\lambda\\vec{OB}+(1-\\lambda)\\vec{OA},(O为平面内不与直线AC共线任意一点)OC=λOB+(1−λ)OA,(O为平面内不与直线AC共线任意一点)。 证明： 若点B与AC共线，由共线向量定理可知：AC⃗=λAB⃗∴AC⃗=λAB⃗ ⟺ OC⃗−OA⃗=λ(OB⃗−OA⃗) ⟺ OC⃗=(1−λ)OA⃗+λOB⃗证毕若点B与AC共线，由共线向量定理可知：\\vec{AC}=\\lambda\\vec{AB}\\\\ \\therefore \\vec{AC}=\\lambda\\vec{AB}\\iff\\vec{OC}-\\vec{OA}=\\lambda(\\vec{OB}-\\vec{OA})\\iff\\vec{OC}=(1-\\lambda)\\vec{OA}+\\lambda\\vec{OB}\\\\ 证毕 若点B与AC共线，由共线向量定理可知：AC=λAB∴AC=λAB⟺OC−OA=λ(OB−OA)⟺OC=(1−λ)OA+λOB证毕 三维计算几何基础 坐标表示 和平面直角坐标系差不多，就是变成了空间直角坐标系，加了条zzz轴，多了个右手定则和左手定则（也不常用），表示空间中的一个点的时候，用一个有序数对(x,y,z)(x,y,z)(x,y,z)即可。 向量a⃗(x,y,z)\\vec{a}(x,y,z)a(x,y,z)的模长为： ∣a⃗∣=x2+y2+z2|\\vec{a}|=\\sqrt{x^2+y^2+z^2} ∣a∣=x2+y2+z2​ 向量运算 数乘 并没有太大的变化，只不过是变成了三维坐标，设 a⃗=(x,y,z)\\vec{a}=(x,y,z)a=(x,y,z),有 ka⃗=(kx,ky,kz)k \\vec{a} = (kx,ky,kz) ka=(kx,ky,kz) 点积 设a⃗=(x1,y1,z1),b⃗=(x2,y2,z2)\\vec{a}=(x_1,y_1,z_1),\\vec{b}= (x_2,y_2,z_2)a=(x1​,y1​,z1​),b=(x2​,y2​,z2​)，则 a⃗⋅b⃗=∣a⃗∣∣b⃗∣cos⁡⟨a⃗,b⃗⟩\\vec{a} \\cdot \\vec{b}=|\\vec{a}| |\\vec{b}|\\cos \\left\\langle \\vec{a},\\vec{b} \\right\\rangle a⋅b=∣a∣∣b∣cos⟨a,b⟩ 又可以表示为： a⃗⋅b⃗=x1x2+y1y2+z1z2\\vec{a} \\cdot \\vec{b} = x_1x_2+y_1y_2+z_1z_2 a⋅b=x1​x2​+y1​y2​+z1​z2​ 是一个常数。 叉积 空间直角坐标系中向量a⃗\\vec{a}a和向量b⃗\\vec{b}b的叉积为： a⃗×b⃗=(y1z2−y2z1,x2z1−x1z2,x1y2−x2y1)\\vec{a} \\times \\vec{b} = (y_1z_2-y_2z_1,x_2z_1-x_1z_2,x_1y_2-x_2y_1) a×b=(y1​z2​−y2​z1​,x2​z1​−x1​z2​,x1​y2​−x2​y1​) 结果是一个向量，另外可以用行列式表示， 设 c⃗=a⃗×b⃗,c⃗=(x3,y3,z3)\\vec{c} = \\vec{a} \\times \\vec{b},\\vec{c} = (x_3,y_3,z_3)c=a×b,c=(x3​,y3​,z3​),叉积结果为： ∣x3y3z3x1y1z1x2y2z2∣\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} ∣∣∣∣∣∣​x3​x1​x2​​y3​y1​y2​​z3​z1​z2​​∣∣∣∣∣∣​ 将其展开即为 ： x3(y1z2−y2z1)+y3(x2z1−x1z2)+z3(x1y2−x2y1)x_3(y_1z_2-y_2z_1)+y_3(x_2z_1-x_1z_2)+z_3(x_1y_2-x_2y_1) x3​(y1​z2​−y2​z1​)+y3​(x2​z1​−x1​z2​)+z3​(x1​y2​−x2​y1​) 叉积结果即为(y1z2−y2z1,x2z1−x1z2,x1y2−x2y1)(y_1z_2-y_2z_1,x_2z_1-x_1z_2,x_1y_2-x_2y_1)(y1​z2​−y2​z1​,x2​z1​−x1​z2​,x1​y2​−x2​y1​)， 另外根据叉积的定义，在空间直角坐标系中叉积所代表的向量为两个进行叉积向量所在平面的法向量。 tips:三阶行列式的展开 比如上面的 ∣x3y3z3x1y1z1x2y2z2∣\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} ∣∣∣∣∣∣​x3​x1​x2​​y3​y1​y2​​z3​z1​z2​​∣∣∣∣∣∣​ 将其第一，二列 copy 到第三列右边： ∣x3y3z3x1y1z1x2y2z2∣∣x3y3x1y1x2y2∣\\begin{vmatrix} x_3&amp;y_3&amp;z_3 \\\\ x_1&amp;y_1&amp;z_1 \\\\ x_2&amp;y_2&amp;z_2 \\end{vmatrix} \\begin{vmatrix} x_3&amp;y_3 \\\\ x_1&amp;y_1 \\\\ x_2&amp;y_2 \\end{vmatrix} ∣∣∣∣∣∣​x3​x1​x2​​y3​y1​y2​​z3​z1​z2​​∣∣∣∣∣∣​∣∣∣∣∣∣​x3​x1​x2​​y3​y1​y2​​∣∣∣∣∣∣​ 用第 1,2,3 列的对角线的乘积和减去第 3,4,5 列的乘积和： (x3y1z2+y3z1x2+z3x1y2)−(y3x1z2+x3z1y2+z3y1x2)(x_3y_1z_2+y_3z_1x_2+z_3x_1y_2)-(y_3x_1z_2+x_3z_1y_2+z_3y_1x_2) (x3​y1​z2​+y3​z1​x2​+z3​x1​y2​)−(y3​x1​z2​+x3​z1​y2​+z3​y1​x2​) 化简即上述结果，（算错可就寄了） 平面的表示 我们可以用平面上的一点P(x,y,z)P(x,y,z)P(x,y,z)和该平面的法向量n⃗(a,b,c)\\vec{n}(a,b,c)n(a,b,c)来表示一个平面，满足P⋅n⃗=0P \\cdot \\vec{n}=0P⋅n=0的点集即为该平面，可以推出， Ax+By+Cz+D=0Ax+By+Cz+D=0 Ax+By+Cz+D=0 为平面的一般式。 三维计算几何其实也没啥，就是升维打击。 凸包 二维凸包 凸多边形 凸多边形是指所有内角在[0,π]\\left[ 0,\\pi \\right][0,π]范围内的简单多边形。 凸包 对于在平面上的一个点集，凸包是能包含所有点的最小凸多边形。 其定义为：对于给定集合DDD，所有包含DDD的凸集的交集SSS被称为DDD的凸包。 如： 凸包求法 对于平面上的一个点集，其凸包可以用分治，Graham−ScanGraham-ScanGraham−Scan，和 AndrewAndrewAndrew。 分治 对于分治算法解决凸包问题，递归求解，找到子问题的凸包，讲左右两个子集的凸包进进行合并即可，时间复杂度(nlog⁡n)(n \\log n)(nlogn)。 AndrewAndrewAndrew 对于AndrewAndrewAndrew算法，主要流程： 首先将所有点以横坐标为第一关键字，纵坐标为第二关键字进行排序； 显然排序后最小的元素和最大的元素一定在凸包上，然后用单调栈维护上下凸壳； 因为上下凸壳所旋转的方向不同，我们首先升序枚举下凸壳，然后降序枚举上凸壳。 时间复杂度(nlog⁡n)(n \\log n)(nlogn)。 Graham−ScanGraham-ScanGraham−Scan 主要介绍这种算法，更好写一些，首先我们先找出在最右下角的点，此时这个点一定在凸包上，然后我们从这个点开始逆时针旋转，同时用单调栈维护凸包上的点，每加入一个新点是判断改点是否会出现，该边在上一条边的“右边”，如果出现则删除上一个点。 【模板】二维凸包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int n,top;double ans;struct geometric{ double x,y,dss; friend geometric operator + (const geometric a,const geometric b){return (geometric){a.x+b.x,a.y+b.y};} friend geometric operator - (const geometric a,const geometric b){return (geometric){a.x-b.x,a.y-b.y};} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);}};geometric origin,data[maxn],st[maxn];bool vis[maxn];bool cmp(geometric a,geometric b){ geometric opt; double tamp=opt.cross(data[1],a,data[1],b); if(tamp&gt;0)return true; if(tamp==0&amp;&amp;opt.dis(data[1],a)&lt;=opt.dis(data[1],b))return true; return false;}geometric opt;int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lf%lf&quot;,&amp;data[i].x,&amp;data[i].y); if(i!=1&amp;&amp;data[i].y&lt;data[1].y) { double tmp; swap(data[1].y,data[i].y); swap(data[1].x,data[i].x); } if(i!=1&amp;&amp;data[i].y==data[1].y&amp;&amp;data[i].x&gt;data[1].x) swap(data[1].x,data[i].x); } sort(data+2,data+n+1,cmp); st[++top]=data[1]; for(int i=2;i&lt;=n;i++) { while(top&gt;1&amp;&amp;opt.cross(st[top-1],st[top],st[top],data[i])&lt;=0)top--; st[++top]=data[i]; } st[++top]=data[1]; for(int i=1;i&lt;top;i++)ans+=opt.dis(st[i],st[i+1]); printf(&quot;%.2lf&quot;,ans); return 0;} 动态凸包 首先我们考虑这样一个问题： 两种操作： 向点集中添加一个点(x,y)(x,y)(x,y); 询问点是否在凸包中。 首先我们对于一个动态的凸包，很明显在每次加入新点时不能再进行一次Graham−ScanGraham-ScanGraham−Scan，否则时间复杂度不优。 那么我们就可以用一下方法： 首先建一棵平衡树，按极角排序； 询问是找到该点的前驱后继，用叉积判断即可，否则执行插入操作； 插入时，先将点插入平衡树内然后找该点的前驱后继，同时不断去旋转将在凸包内的点删去。 对于平衡树我们可以直接用STLSTLSTL里的setsetset 去实现，需要用到迭代器。 Professor’s task 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define it set&lt;geometric&gt;::iterator#define eps 1e-8using namespace std;const int maxn=1e5+10;int Sure(double x){return fabs(x)&lt;eps?0:(x&lt;0?-1:1);}struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);} geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));}}opt,d[maxn],origin;bool operator &lt; (geometric a,geometric b){ a=a-origin;b=b-origin; double ang1=atan2(a.y,a.x),ang2=atan2(b.y,b.x); double l1=sqrt(a.x*a.x+a.y*a.y),l2=sqrt(b.x*b.x+b.y*b.y); if(Sure(ang1-ang2)!=0)return Sure(ang1-ang2)&lt;0; else return Sure(l1-l2)&lt;0;}int q,cnt;set&lt;geometric&gt; S;it Pre(it pos){if(pos==S.begin())pos=S.end();return --pos;}it Nxt(it pos){++pos; return pos==S.end() ? S.begin():pos;}bool Query(geometric key){ it pos=S.lower_bound(key); if(pos==S.end())pos=S.begin(); return Sure(opt.cross(*(Pre(pos)),key,*(Pre(pos)),*(pos)))&lt;=0;}void Insert(geometric key){ if(Query(key))return; S.insert(key); it pos=Nxt(S.find(key)); while(S.size()&gt;3&amp;&amp;Sure(opt.cross(*(Nxt(pos)),*(pos),*(Nxt(pos)),key))&gt;=0) { S.erase(pos);pos=Nxt(S.find(key)); } pos=Pre(S.find(key)); while(S.size()&gt;3&amp;&amp;Sure(opt.cross(*(Pre(pos)),*(pos),*(Pre(pos)),key))&lt;=0) { S.erase(pos);pos=Pre(S.find(key)); }}int main(){ scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=3;i++) { int opt;double x,y;scanf(&quot;%d%lf%lf&quot;,&amp;opt,&amp;x,&amp;y); d[++cnt]=geometric(x,y);origin.x+=x;origin.y+=y; } origin=origin/3.0; for(int i=1;i&lt;=3;i++)S.insert(d[i]); for(int i=4;i&lt;=q;i++) { int opt;double x,y; scanf(&quot;%d%lf%lf&quot;,&amp;opt,&amp;x,&amp;y); d[++cnt]=geometric(x,y); if(opt==1)Insert(d[cnt]); else { if(Query(d[cnt]))printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } return 0;} 注意使用迭代器时不要越界，要和用指针一样小心！ 三维凸包 对于 a⃗(x1,y1)\\vec{a}(x_1,y_1)a(x1​,y1​) 和 b⃗(x2,y2)\\vec{b}(x_2,y_2)b(x2​,y2​) 三维凸包的话，主要是空间几何坐标系中点积为： a⃗⋅b⃗=x1x2+y1y2+z1z2 \\vec{a} · \\vec{b} = x_1x_2+y_1y_2+z_1z_2 a⋅b=x1​x2​+y1​y2​+z1​z2​ 叉积为向量（法向量）： a⃗×b⃗=(y1z2−y2z1,x2z1−z2x1,x1y2−x2y1) \\vec{a} \\times \\vec{b} =(y_1z_2 - y_2z_1, x_2z_1-z_2x_1, x_1y_2 -x_2y_1) a×b=(y1​z2​−y2​z1​,x2​z1​−z2​x1​,x1​y2​−x2​y1​) 对于三维凸包的解法有很多种，介绍几种比较常用的吧。 增量法 主要是考虑加入一个点时如何维护凸包,每加入一个点，从这个点“能看见的面”都不会是最终凸包的面，将这些不会成为答案的面删去就好了。 另外如果新加入的点在已经加入的面上，不用删除这个面。 首先先选取四个顶点，构成一个四面体，作为初始凸包，每加入一个点去在已经加入面中去找，从这个点能看到的面，将其删除， 关于存面的时候，同一条边会被使用两次，被顺时针使用一次，逆时针使用一次，可以对每条边打上标记，删掉不需要的面后对于只使用过一次的边按照其使用方向与新点建面， 存面的时候只需用到三个点就可以了，对于多个点共面的情况，因为我们用的是三个点来存面，最后的凸多边形，有可能会出现多个点共面的情况，导致将这个面分成多个小三角形，为了免去去重的一些操作，更好写一些，可以对点进行扰动，加一个不算大的误差。 时间复杂度O(n2)O(n^2)O(n2)而且支持在线。 【模板】三维凸包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define eps 1e-10#define double long doubleusing namespace std;const int maxn=2010;double randeps(){return (rand()/(double)RAND_MAX-0.5)*eps;}struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} void shake(){x+=randeps(),y+=randeps(),z+=randeps();} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// 向量的四则运算 double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // 向量模长 double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// 点积 geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a=a2-a1,b=b2-b1;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // 叉积}opt,origin,p[maxn];struct plane{ int v[3]; plane(){v[0]=v[1]=v[2]=0;} plane(int A,int B,int C){v[0]=A,v[1]=B,v[2]=C;} geometric normal(){return opt.cross(p[v[0]],p[v[1]],p[v[0]],p[v[2]]);} double area(){return fabs(opt.dis(normal(),origin))/2.0;}}con[maxn&lt;&lt;1],h[maxn&lt;&lt;1];// 存储面从外面看逆时针存int check(plane alpha,geometric vec){return opt.dot(origin,alpha.normal(),p[alpha.v[0]],vec)&gt;0;}int n,cnt,indx,l,vis[maxn][maxn];double S;int main(){ srand(time(0)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { double x,y,z; scanf(&quot;%Lf%Lf%Lf&quot;,&amp;x,&amp;y,&amp;z); p[++cnt]=geometric(x,y,z); p[i].shake(); } con[++indx]=plane(1,2,3); con[++indx]=plane(3,2,1); for(int i=4;i&lt;=cnt;i++) { for(int j=1,res;j&lt;=indx;j++) { res=check(con[j],p[i]); if(!res)h[++l]=con[j];//保存不需要删除的面 for(int k=0;k&lt;3;k++) { vis[con[j].v[k]][con[j].v[(k+1)%3]]=res;// 标记边 // 删除的标记为true不删除的标记为false } } for(int j=1;j&lt;=indx;j++) { for(int k=0;k&lt;3;k++) { int x=con[j].v[k],y=con[j].v[(k+1)%3]; if(vis[x][y]&amp;&amp;!vis[y][x])h[++l]=plane(x,y,i); // 边缘 // 使用过的被删了，建面用使用过的顺序 } } for(int j=1;j&lt;=l;j++)con[j]=h[j]; indx=l,l=0; } for(int i=1;i&lt;=indx;i++)S+=con[i].area(); printf(&quot;%0.3Lf&quot;,S); return 0;} 卷包裹法 其实就像是用一张纸去旋转包住凸包，碰到的第一个点作为凸包顶点，额不太会写。 时间复杂度O(nh)O(nh)O(nh)，hhh为凸包点数，随机数据下能跑成O(n)O(\\sqrt n)O(n​)？ QuickHull 不会，挖坑。（也许不会补，比竟难写，又不用） 时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn)好像是最快的。 一些例题： [SHOI2012]信用卡凸包 [HAOI2011]防线修建 [HNOI2008]水平可见直线 [SDOI2013]保护出题人 旋转卡壳 读法 （其实我也不知道该怎么读，有 16 种读法） 凸多边形的切线 如果一条直线与凸多边形有交点，并且整个凸多边形都在这条直线的一侧，那么这条直线就是该凸多边形的一条切线。 对踵点 如果过凸多边形上两点作一对平行线，使得整个多边形都在这两条线之间，那么这两个点被称为一对对踵点。 凸多边形的直径 即凸多边形上任意两个点之间距离的最大值。直径一定会在对踵点中产生，如果两个点不是对踵点，那么两个点中一定可以让一个点向另一个点的对踵点方向移动使得距离更大。并且点与点之间的距离可以体现为线与线之间的距离，在非对踵点之间构造平行线，一定没有在对踵点构造平行线优，这一点可以通过平移看出。 旋转卡壳 先上一张比较标致的图，来对旋转卡壳有一个初步的了解： 对于实现旋转卡壳，我们首先可以先去求出凸包，然后去枚举每一条边，去找对踵点，即可找出凸包直径。时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn) 在旋转的时候用叉积对应的面积，来找对踵点就好了，因为在凸包上有一个单调性，在找对踵点的时候，实际上是O(n)O(n)O(n)的，建议好好思考一下。 注意，在旋转时为一个环，需要注意边界问题，要不要会收获血与泪的教训 （别问我怎么知道的） 【模板】旋转卡壳 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;struct geometric{ double x,y,dss; friend geometric operator + (const geometric a,const geometric b){return (geometric){a.x+b.x,a.y+b.y};} friend geometric operator - (const geometric a,const geometric b){return (geometric){a.x-b.x,a.y-b.y};} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));}};int n,top;double ans;geometric d[maxn],opt,st[maxn];bool cmp(geometric a,geometric b){ double tamp=opt.cross(d[1],a,d[1],b); if(tamp&gt;0)return true; if(tamp==0&amp;&amp;opt.dis(d[1],a)&lt;opt.dis(d[1],b))return true; return false;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%lf%lf&quot;,&amp;d[i].x,&amp;d[i].y); if(i!=1&amp;&amp;d[i].y&lt;d[1].y) { swap(d[1].y,d[i].y); swap(d[1].x,d[i].x); } if(i!=1&amp;&amp;d[i].y==d[1].y&amp;&amp;d[i].x&gt;d[1].x) swap(d[1].x,d[i].x); } sort(d+2,d+n+1,cmp); st[++top]=d[1]; for(int i=2;i&lt;=n;i++) { while(top&gt;1&amp;&amp;opt.cross(st[top-1],st[top],st[top],d[i])&lt;=0)top--; st[++top]=d[i]; } st[++top]=d[1]; for(int i=2,j=3;i&lt;=top;i++) { while(opt.cross(st[i-1],st[i],st[i-1],st[j])&lt;opt.cross(st[i-1],st[i],st[i-1],st[j+1]))j==top-1?j=1:j++;// ！！！！ ans=max(ans,max(opt.dis(st[i],st[j]),opt.dis(st[i-1],st[j]))); } printf(&quot;%d&quot;,int(ans*ans)); return 0;} 一些例题 [HNOI2007]最小矩形覆盖 [SCOI2007]最大土地面积 [HNOI2008]水平可见直线 [ZJOI2008]瞭望塔 部分资料参考自洛谷日报 半平面交 半平面 平面内的一条直线把这个平面分成两部分，每一部分对这个平面来说，都叫做半平面。包括这条直线的半平面叫做闭半平面，否则叫做开半平面。 解析式为 Ax+By+C&gt;=0Ax + By +C &gt;=0Ax+By+C&gt;=0或Ax+By+C&lt;=0Ax + By +C &lt;=0Ax+By+C&lt;=0。 在计算几何中用向量表示，整个题统一以向量的左侧或右侧为半平面。 半平面交 半平面交就是多个半平面的交集。半平面交是一个点集。 它可以理解为向量集中每一个向量的右侧的交，或者是下面方程组的解。 {A1x+B1y+C1≥0A2x+B2y+C2≥0 \\left\\{ \\begin{aligned} A_1x+B_1y+C_1 \\ge 0\\\\ A_2x+B_2y+C_2 \\ge 0 \\end{aligned} \\right. {A1​x+B1​y+C1​≥0A2​x+B2​y+C2​≥0​ 多边形的核 如果一个点集中的点与多边形上任意一点的连线与多边形没有其他交点，那么这个点集被称为多边形的核。 把多边形的每条边看成是首尾相连的向量，那么这些向量在多边形内部方向的半平面交就是多边形的核。 求法 D&amp;C 算法 该算法是基于分治思想的： 将nnn个半平面分成两个n/2n/2n/2的集合; 对两个子集和递归求解半平面交; 将前一步算出来的两个交利用平面扫描法求解。 时间复杂度(nlog⁡n)(n \\log n)(nlogn)这个算法并不常用，主要介绍的是下面这个。 S&amp;I 算法 该算法是在 2006 年有中国队队员朱泽园提出来的“排序增量法”。 假设给出nnn条直线，求这nnn条直线的左方半平面的交集： 首先对这nnn条直线按极角排序； 用一个队列去维护半平面的交集，和相邻两条直线的交点； 每次加入新的直线时判断是否有交点在该直线的右面，如果是则弹出直线，先判队尾再判队首，注意判断平行情况； 最后队列中的交集即为半平面交。 注意事项！！！ 在弹出不需要的交点时一定要先处理队尾再处理队首，因为在插入向量时，有可能是会把队首向量弹出的，此时如果先弹队首没回出现误删， （AB⃗\\vec{AB}AB先入队） 此时我们插入EF⃗\\vec{EF}EF，GGG点肯定是要删去，但是如果我们先弹队首就会把可能会成为答案的AB⃗\\vec{AB}AB删去，因为按逆时针排序，所以后插入的CD⃗\\vec{CD}CD影响会更大一些，应先处理队尾。 【模板】半平面交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;const int maxn=1010;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);}}opt;int n,m,tot,head=1,tail=1;double ans;geometric data[maxn],origin,T[maxn];struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }}q[maxn],p[maxn],take;int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;m); for(int j=1;j&lt;=m;j++) scanf(&quot;%lf%lf&quot;,&amp;data[j].x,&amp;data[j].y); for(int j=1;j&lt;=m;j++) { if(j==m)p[++tot]=line(data[j],data[1]-data[j]); else p[++tot]=line(data[j],data[j+1]-data[j]); } } sort(p+1,p+tot+1); q[head]=p[head]; for(int i=2;i&lt;=tot;i++) { while(head&lt;tail&amp;&amp;opt.cross(origin,p[i].B,p[i].A,T[tail-1])&lt;=eps)tail--; while(head&lt;tail&amp;&amp;opt.cross(origin,p[i].B,p[i].A,T[head])&lt;=eps)head++; q[++tail]=p[i]; if(fabs(opt.cross(origin,q[tail].B,origin,q[tail-1].B))&lt;=eps) { tail--; if(opt.cross(origin,q[tail].B,q[tail].A,p[i].A)&gt;eps)q[tail]=p[i]; } if(head&lt;tail)T[tail-1]=take.sdot(q[tail-1],q[tail]); } while(head&lt;tail&amp;&amp;opt.cross(origin,q[head].B,q[head].A,T[tail-1])&lt;=eps)tail--; if(tail-head&gt;1) T[tail]=take.sdot(q[head],q[tail]); for(int i=head;i&lt;=tail;i++) { if(i==tail)ans+=opt.cross(origin,T[i],origin,T[head]); else ans+=opt.cross(origin,T[i],origin,T[i+1]); } printf(&quot;%.3lf&quot;,ans/2); return 0;} 一些例题 [ZJOI2008]瞭望塔 [HNOI2008]水平可见直线 [JLOI2013]赛车 [HNOI2012]射箭 随机增量 随机增量法 随机增量法可以用来解决最小圆覆盖。 首先，我们先思考一下这个问题： 给定平面上nnn个点，求一个半径最小的圆去覆盖这nnn个点。 我们可以先设点集AAA的最小圆覆盖为c(A)c(A)c(A)，对于一个最小覆盖圆，它肯定满足以下性质： c(A)c(A)c(A) 是唯一的; 圆上有三个（或以上）AAA中的点; 圆上有两个点为一条直径的两端. 其中第二条和第三条必须满足其中之一。 我们先假设目前已经求出了i−1i-1i−1个点的最小覆盖圆，在加入第iii个点后，最小覆盖圆一定是: 前i−1i-1i−1个点中的两个点与第iii个点三点确定的圆; 前i−1i-1i−1个点中的一个点与第iii个点为直径作的圆. 额。。易证！ 主要的代码部分： 12345678910111213141516171819202122for(int i=2;i&lt;=n;i++) { if(check(center,r,d[i]))continue; geometric now;double nr=0; for(int j=1;j&lt;i;j++) { if(check(now,nr,d[j]))continue; now=(d[i]+d[j])/2.0; nr=opt.dis(d[i],d[j])/2.0; // 先以一条直径作圆 for(int k=1;k&lt;j;k++) { if(check(now,nr,d[k]))continue; now=Center(d[i],d[j],d[k]); nr=opt.dis(now,d[i]); // 找第三个点作圆 } } center=now;r=nr; } 然后我们发现，我们似乎写了一个O(n3)O(n^3)O(n3)的暴力。。其实不然。 时间复杂度的证明 由于nnn个点最多由三个点确定的最小覆盖圆，因此每个点参与确定最下覆盖圆的概率不大于3n\\frac{3}{n}n3​。 所以每一层在第iii个点处调用下一层的概率不大于3i\\frac{3}{i}i3​。 设三个循环的时间复杂度为T1,T2,T3T_1,T_2,T_3T1​,T2​,T3​: T1(n)=O(n)+∑i=1n3iT2(i)T2(n)=O(n)+∑i=1n3iT3(i)T3(n)=O(n)\\begin{aligned}T_1(n) &amp; = O(n) + \\sum_{i=1}^{n}{\\frac{3}{i}T_2(i)}\\\\ T_2(n) &amp; = O(n) + \\sum_{i=1}^{n}{\\frac{3}{i}T_3(i)}\\\\ T_3(n) &amp; = O(n)\\end{aligned} T1​(n)T2​(n)T3​(n)​=O(n)+i=1∑n​i3​T2​(i)=O(n)+i=1∑n​i3​T3​(i)=O(n)​ 可以解得T1=T2=T3=O(n)T_1=T_2=T_3=O(n)T1​=T2​=T3​=O(n)。 证毕。 但是这只是在数据随机的情况下，但是出题人往往不这么做，所以我们需要用random_shuffle函数进行扰动就很好了。 最后n3n^3n3过百万！！（迫真） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;const int maxn=1e5+10;struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);} double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} double angle(geometric a){return atan2(a.y,a.x);} geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));}}opt,origin,d[maxn],st[maxn];int n,top;double S=0,rx,ry;int Sure(double x){return fabs(x)&lt;eps?0:(x&lt;0?-1:1);}bool check(geometric a,double r,geometric b){return Sure(r-opt.dis(a,b))&gt;=0;}geometric Center(geometric a,geometric b,geometric c){ geometric mid1,mid2,cen; double k1=0,k2=0,b1=0,b2=0; if(a.y!=b.y)k1=-(a.x-b.x)/(a.y-b.y); if(b.y!=c.y)k2=-(b.x-c.x)/(b.y-c.y); mid1=(a+b)/2.0;mid2=(b+c)/2.0; b1=mid1.y-mid1.x*k1;b2=mid2.y-mid2.x*k2; if(k1==k2) cen=(a+c)/2.0; else { cen.x=(b2-b1)/(k1-k2); cen.y=k1*cen.x+b1; } return cen;}int main(){ srand(time(0)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;d[i].x,&amp;d[i].y); random_shuffle(d+1,d+n+1); geometric center=d[1];double r=0; for(int i=2;i&lt;=n;i++) { if(check(center,r,d[i]))continue; geometric now;double nr=0; for(int j=1;j&lt;i;j++) { if(check(now,nr,d[j]))continue; now=(d[i]+d[j])/2.0; nr=opt.dis(d[i],d[j])/2.0; for(int k=1;k&lt;j;k++) { if(check(now,nr,d[k]))continue; now=Center(d[i],d[j],d[k]); nr=opt.dis(now,d[i]); } } center=now;r=nr; } printf(&quot;%0.10lf\\n%0.10lf %0.10lf&quot;,r,center.x,center.y); return 0;} 一些例题 最小圆覆盖 [AHOI2012]信号塔 闵可夫斯基和 闵可夫斯基和 闵可夫斯基和，又称作闵可夫斯基加法，是两个欧几里得空间的点集的和，以德国数学家闵可夫斯基命名。（小知识：闵可夫斯基曾经做过爱因斯坦的老师。） 闵可夫斯基和是两个欧几里得空间的点集的和，也称为这两个空间的膨胀集，被定义为 A+B={a+b∣a∈A,b∈B} A + B=\\{a+b|a \\in A, b \\in B \\} A+B={a+b∣a∈A,b∈B} 根据闵可夫斯基和的定义，若集合元素所处代数系统满足阿贝尔群（加法可交换），则闵可夫斯基和本身也满足交换律： A+B=B+A A+B=B+A A+B=B+A （以上参考自 Baidu) 其实对于闵可夫斯基和，可以通俗的理解为，对于一个凸包AAA绕着凸包BBB转一圈： 算法实现 对于求两个点集的闵可夫斯基和，通过肉眼观察，和理性分析，我们可以得出这么一个结论：两个凸包AAA和BBB上的边一定在闵可夫斯基和中出现。 然后我们就可以先求出两个点集的凸包，然后按极角排序后求闵可夫斯基和。 求凸包： 123456789101112131415161718192021222324int Convexhull(geometric *p,ll l){ for(int i=2;i&lt;=l;i++) { if(p[i].y&lt;p[1].y)swap(p[1],p[i]); if(p[i].y==p[1].y&amp;&amp;p[i].x&lt;p[1].x) swap(p[i],p[1]); } geometric k=p[1]; for(int i=1;i&lt;=l;i++)p[i]=p[i]-k; sort(p+2,p+l+1,cmp); int top=0; geometric st[maxn]; st[++top]=p[1]; for(int i=2;i&lt;=l;i++) { while(top&gt;1&amp;&amp;cross(st[top-1],st[top],st[top],p[i])&lt;0) top--; st[++top]=p[i]; } for(int i=1;i&lt;=top;i++)p[i]=st[i]+k; p[top+1]=p[1]; return top;} 求闵可夫斯基和： 123456789101112131415161718192021222324void Minkowski(){ for(int i=1;i&lt;=n;i++)s1[i]=p1[i+1]-p1[i]; for(int i=1;i&lt;=m;i++)s2[i]=p2[i+1]-p2[i]; S[++cnt]=p1[1]+p2[1]; int i=1,j=1; while(i&lt;=n&amp;&amp;j&lt;=m) { cnt++; if(cross(origin,s1[i],origin,s2[j])&gt;=0) S[cnt]=S[cnt-1]+s1[i++]; else S[cnt]=S[cnt-1]+s2[j++]; } while(i&lt;=n) { cnt++; S[cnt]=S[cnt-1]+s1[i++]; } while(j&lt;=m) { cnt++; S[cnt]=S[cnt-1]+s2[j++]; }} 一些例题 [JSOI2018]战争 Pick 定理 给定顶点均为整点的多边形，其面积SSS和内部格点数目iii，边上格点数目bbb的关系为： S=i+b2−1S=i+\\frac{b}{2}-1 S=i+2b​−1 其与欧拉公式， V−E+F=2V-E+F=2 V−E+F=2 是等价的（FFF为面数，VVV为顶点数，EEE为边数） （好像可以证明为什么只有五种正多面体🤔） 扫描线 扫描线是用来解决二维平面内的矩形面积并的， 主要还是用到了线段树和坐标离散化。 用线段树维护当前位置上是否有矩形即可， 题目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ll long long#define lson(p) (p&lt;&lt;1)#define rson(p) (p&lt;&lt;1|1)using namespace std;const int maxn=1e5+10;ll n,num[4*maxn],tot,cnt,ans;struct segment{ ll Lx,Ly,Rx,Ry,v; segment(int x1=0,int y1=0,int x2=0,int y2=0,int V=0):Lx(x1),Ly(y1),Rx(x2),Ry(y2),v(V) {} friend bool operator &lt; (const segment x,const segment y){ if(x.Ly==y.Ly)return x.Lx&lt;y.Lx; return x.Ly&lt;y.Ly; } ll len(segment x,segment y){return Rx-Lx;}}line[maxn*2];struct Segmentree{ ll val,ls,rs,cnt;}t[maxn&lt;&lt;4];int len(int p){return num[t[p].rs]-num[t[p].ls-1];}ll read(){ ll x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}void LSH(){ sort(num+1,num+tot+1); tot=unique(num+1,num+tot+1)-num-1; sort(line+1,line+cnt+1);}void push_up(int p){ if(t[p].cnt)t[p].val=len(p); else t[p].val=t[lson(p)].val+t[rson(p)].val;}void build(int l,int r,int p){ t[p].ls=l;t[p].rs=r; if(l==r)return; int mid=(l+r)&gt;&gt;1; build(l,mid,lson(p)); build(mid+1,r,rson(p));}void change(int l,int r,int p,int x,int y,int k){ if(x&lt;=l&amp;&amp;r&lt;=y) { t[p].cnt+=k; push_up(p); return ; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(l,mid,lson(p),x,y,k); if(mid&lt;y)change(mid+1,r,rson(p),x,y,k); push_up(p);}int main(){ n=read(); for(int i=1;i&lt;=n;i++) { ll x1,x2,y1,y2; x1=read();y1=read();x2=read();y2=read(); line[++cnt]=segment(x1,y1,x2,y1,1); line[++cnt]=segment(x1,y2,x2,y2,-1); num[++tot]=x1;num[++tot]=x2; } LSH(); build(1,tot,1); for(int i=1;i&lt;=cnt;i++) { int x=lower_bound(num+1,num+tot+1,line[i].Lx)-num; int y=lower_bound(num+1,num+tot+1,line[i].Rx)-num; if(line[i].Ly!=line[i-1].Ly&amp;&amp;i!=1) ans+=(line[i].Ly-line[i-1].Ly)*t[1].val; change(1,tot,1,x+1,y,line[i].v); } printf(&quot;%lld&quot;,ans); return 0;} 窗口的星星 首先我们可以先固定住矩形的右上角使其在一定的范围内可以覆盖到星星，这时这个范围就是第一个以该星星为最下角的一个矩阵，权值即为这个星星的亮度，转化为区间最值问题。 偏序问题 二维偏序 给定nnn个二元组(x,y)(x,y)(x,y)，求满足条件的二元组对数。 比如逆序对，这里给出权值线段树的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define lson(p) (p&lt;&lt;1)#define rson(p) (p&lt;&lt;1|1)using namespace std;const int maxn=5e5+10;int n,a[maxn],h[maxn],size;int k[maxn],indx[maxn];long long ans;struct Segment{ int ls,rs,val;}t[maxn&lt;&lt;2];void push_up(int p){ t[p].val=t[lson(p)].val+t[rson(p)].val;}void update(int l,int r,int p,int x){ if(l==r) { t[p].val++; return; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) { ans+=t[rson(p)].val; update(l,mid,lson(p),x); } else update(mid+1,r,rson(p),x); push_up(p);}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),h[i]=a[i]; sort(h+1,h+n+1); size=unique(h+1,h+n+1)-h-1; for(int i=1;i&lt;=n;i++) { indx[i]=lower_bound(h+1,h+size+1,a[i])-h; update(1,size,1,indx[i]); } printf(&quot;%lld\\n&quot;,ans); return 0;} 三维偏序 给定nnn个三元组(x,y,z)(x,y,z)(x,y,z)，求满足条件的对数。 先对xxx排序，将其转化为二维偏序，然后用 CDQ 分治，将yyy排序，用树状数组维护zzz 陌上花开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;const int maxn=1e5+10;using namespace std;int n,cnt=1,Max,Ans[maxn];struct node{ int a,b,c,t,val;}d[maxn];struct Segmentree{ int ls,rs,val;}t[maxn&lt;&lt;3];void push_up(int p){ t[p].val=t[t[p].ls].val+t[t[p].rs].val;}bool cmp1(node x,node y){ if(x.a==y.a) { if(x.b==y.b) return x.c&lt;y.c; else return x.b&lt;y.b; } else return x.a&lt;y.a;}bool cmp2(node x,node y){ if(x.b==y.b) return x.c&lt;y.c; else return x.b&lt;y.b;}int Insert(int l,int r,int p,int x,int k,int&amp; sum){ if(p==0)p=++cnt; if(l==r) { sum+=t[p].val; t[p].val+=k; return p; } int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) t[p].ls=Insert(l,mid,t[p].ls,x,k,sum); else { sum+=t[t[p].ls].val; t[p].rs=Insert(mid+1,r,t[p].rs,x,k,sum); } push_up(p); return p;}void cdq(int l,int r){ if(l==r)return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); cdq(mid+1,r); sort(d+l,d+mid+1,cmp2); sort(d+mid+1,d+r+1,cmp2); cnt=1; int sum,j=l; for(int i=mid+1;i&lt;=r;i++) { while(d[i].b&gt;=d[j].b&amp;&amp;j&lt;=mid) { Insert(1,Max,1,d[j].c,d[j].t,sum); j++; } sum=0; Insert(1,Max,1,d[i].c,0,sum); d[i].val+=sum; } for(int i=1;i&lt;=cnt;i++) t[i].ls=t[i].rs=t[i].val=0;}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;Max); int N=n; for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;d[i].a,&amp;d[i].b,&amp;d[i].c); sort(d+1,d+n+1,cmp1); int tot=0; for(int i=1,len=1;i&lt;=n;i++) { if(d[i].a!=d[i+1].a||d[i].b!=d[i+1].b||d[i].c!=d[i+1].c) { tot++; d[tot]=d[i]; d[tot].t=len; len=1; } else len++; } n=tot; cdq(1,n); for(int i=1;i&lt;=n;i++) Ans[d[i].val+d[i].t-1]+=d[i].t; for(int i=0;i&lt;N;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0;} n 维偏序 四维的话可以考虑 CDQ 套 CDQ，更高的话直接 KD-tree。 数值积分 不会，挖坑，考虑一下在补，可以很高效的处理精度问题和一些奇奇怪怪的问题。 upd(2022/8/16):在另一处补好力！。 计算几何杂项 本来想写到前面的，结果写到这里了 判断精度 精度问题是计算几何非常恶心的一个地方，有时候一个非常合适的精度可以决定你是否能 A 掉这个题 12345const double eps=1e-10;int sure(double x){ return fabs(x)&lt;eps?0:x&lt;0?-1:1;} 点 123struct Point{ double x,y;}; 向量 记录起点和终点 123struct Vector{ Point a,b;}; 四则运算 1234friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// 向量的四则运算 距离 1double dis(Point a,Point b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} 点积 1double dot(Point a1,Point a2,Point b1,Point b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);} 叉积 1double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} 向量夹角 1double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a1,b1,b2)/(dis(a1,a2)*dis(b1,b2));} 两向量围成的四边形面积 1double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));} 极角 1double angle(geometric a){return atan2(a.y,a.x);} 逆时针旋转 1geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} 顺时针旋转 1geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} 直线 点加方向向量 1234567891011struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }};// 按极角排序已经求两直线的交点 三维计算几何 1234567891011struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// 向量的四则运算 double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // 向量模长 double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// 点积 geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a,b;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // 叉积}; 平面 123456truct plane{ geometric a,b,c; plane(geometric A=origin,geometric B=origin,geometric C=origin):a(A),b(B),c(C) {} geometric normal(){return opt.cross(p[v[0]],p[v[1]],p[v[0]],p[v[2]]);} double area(){return fabs(opt.dis(origin,opt.cross(a,b,a,c)))/2.0;}};// 面积，逆时针存点,法向量 最后推荐两个画图工具desmos和Geogebra! 目前我整理的还只有这些，过段时间还会再作补充，感谢观看！！！","link":"/2022/06/11/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95All-in-All/"},{"title":"计算几何小车头","text":"一些计算几何常用的东西吧。 (upd:2022/8/17 写了一个新版的板子，在后面) 一些计算几何常用的东西吧。 (upd:2022/8/17 写了一个新版的板子，在后面) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132struct geometric{ double x,y; geometric(double X=0,double Y=0):x(X),y(Y) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p);}// 向量的四则运算 double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));} // 向量模长 double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y);}// 点积 double cross(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.y-b1.y)-(a2.y-a1.y)*(b2.x-b1.x);} // 叉积 double corner(geometric a1,geometric a2,geometric b1,geometric b2){return dot(a1,a2,b1,b2)/(dis(a1,a2)*dis(b1,b2));}// 向量夹角 double area(geometric a1,geometric a2,geometric b1,geometric b2){return fabs(cross(a1,a2,b1,b2));}// 两向量围成的四边形面积 double angle(geometric a){return atan2(a.y,a.x);}// 极角 geometric rotate_counterclockwise(geometric a,double theta){return geometric(a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta));} // 向量逆时针旋转 geometric rotate_clockwise(geometric a,double theta){return geometric(a.x*cos(theta)+a.y*sin(theta),-a.x*sin(theta)+a.y*cos(theta));} // 向量顺时针旋转}opt;struct line{ geometric A,B;double An; line(geometric a,geometric b):A(a),B(b) {An=opt.angle(B);} line(){} bool operator &lt; (const line &amp;a)const{return An&lt;a.An;} geometric sdot(line a,line b){ geometric c=a.A-b.A; double k=opt.cross(origin,b.B,origin,c)/opt.cross(origin,a.B,origin,b.B); return a.A+a.B*k; }};// 二维计算几何struct geometric{ double x,y,z; geometric(double X=0,double Y=0,double Z=0):x(X),y(Y),z(Z) {} friend geometric operator + (const geometric a,const geometric b){return geometric(a.x+b.x,a.y+b.y,a.z+b.z);} friend geometric operator - (const geometric a,const geometric b){return geometric(a.x-b.x,a.y-b.y,a.z-b.z);} friend geometric operator * (const geometric a,double p){return geometric(a.x*p,a.y*p,a.z*p);} friend geometric operator / (const geometric a,double p){return geometric(a.x/p,a.y/p,a.z/p);}// 向量的四则运算 double dis(geometric a,geometric b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));} // 向量模长 double dot(geometric a1,geometric a2,geometric b1,geometric b2){return (a2.x-a1.x)*(b2.x-b1.x)+(a2.y-a1.y)*(b2.y-b1.y)+(a2.z-a1.z)*(b2.z-b1.z);}// 点积 geometric cross(geometric a1,geometric a2,geometric b1,geometric b2){geometric a,b;return geometric(a.y*b.z-b.y*a.z,b.x*a.z-a.x*b.z,a.x*b.y-b.x*a.y);} // 叉积}opt;struct plane{ geometric a,b,c; plane(geometric A=origin,geometric B=origin,geometric C=origin):a(A),b(B),c(C) {} double area(){return fabs(opt.dis(origin,opt.cross(a,b,a,c)))/2.0;}};// 平面// 三维计算几何/*新的板子！！！*/struct Point{ double x, y; Point(double _x = 0, double _y = 0):x(_x), y(_y) {} friend Point operator + (Point a, Point b){return Point(a.x+b.x, a.y+b.y);} friend Point operator - (Point a, Point b){return Point(a.x-b.x, a.y-b.y);} friend Point operator * (Point a, double b){return Point(a.x*b, a.y*b);} friend Point operator / (Point a, double b){return Point(a.x/b, a.y/b);}}origin;struct Vector{ Point a, b; Vector(Point _a = 0, Point _b = 0):a(_a), b(_b) {} double calx(){return b.x - a.x;} double caly(){return b.y - a.y;}};double dis(Point a, Point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}double len(Vector v){ return dis(v.a, v.b);}double dot(Vector v1, Vector v2){ return v1.calx()*v2.calx() + v1.caly()*v2.caly();}double cross(Vector v1, Vector v2){ return v1.calx()*v2.caly() - v2.calx()*v1.caly();}double corner(Vector v1, Vector v2){ return dot(v1, v2)/(len(v1)*len(v2));}double area(Vector v1, Vector v2){ return cross(v1, v2)/2.0;}double angle(Vector v){ return atan2(v.caly(), v.calx());}Vector rotate_counterclockwise(Vector v, double theta){ double x = v.calx(); double y = v.caly(); return Vector(x*cos(theta) - y*sin(theta), x*sin(theta) + y*cos(theta));}Vector rotate_clockwise(Vector v, double theta){ double x = v.calx(); double y = v.caly(); return Vector(x*cos(theta) + y*sin(theta), y*cos(theta) - x*sin(theta));}struct line{ Point A, B; double An; line(Point a = 0, Point b = 0):A(a), B(b) {An = atan2(B.y, B.x);} bool operator &lt; (const line &amp;a)const{return An &lt; a.An;}};Point sdot(line a, line b){ Point c = a.A - b.A; double k = cross(Vector(origin, b.B), Vector(origin, c)) / cross(Vector(origin, a.B), Vector(origin, b.B)); return a.A + a.B*k;}","link":"/2022/06/14/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%B0%8F%E8%BD%A6%E5%A4%B4/"},{"title":"计算几何选做","text":"计算几何大水题！！！ 计算几何选做 [SCOI2016]妖怪 还挺简单的一道题，不难看出答案是具有单调性的而且，求最大攻击力最小，很容易就会想到二分。 假设我们当前二分的值为midmidmid，现在需要去解决的是如何去checkcheckcheck当前的答案合不合法，其实就是解一个形如： atki+dnfi+atkiba+dnfiab≤midatk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b} \\le mid atki​+dnfi​+atki​ab​+dnfi​ba​≤mid 的一个不等式，上述式子中说明了每个妖精的战斗力很显然是atki+dnfi+atkiba+dnfiabatk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b}atki​+dnfi​+atki​ab​+dnfi​ba​，现在我们可以对式子进行变形： atki+dnfi+atkiba+dnfiab−mid≤0atk_i+dnf_i+atk_i\\frac{b}{a}+dnf_i\\frac{a}{b}- mid \\le 0 atki​+dnfi​+atki​ab​+dnfi​ba​−mid≤0 设A=atki,B=atki+dnfi−mid,C=dnfiA = atk_i,B = atk_i + dnf_i-mid,C = dnf_iA=atki​,B=atki​+dnfi​−mid,C=dnfi​再将ba\\frac{b}{a}ab​设为xxx，式子变为： Ax+B+C1x≤0Ax+B+C\\frac{1}{x} \\le 0 Ax+B+Cx1​≤0 两边同时乘以xxx得： Ax2+Bx+C≤0Ax^2+Bx+C \\le 0 Ax2+Bx+C≤0 checkcheckcheck时判断范围二次函数解集是否有交即可，还有注意解是要大于0的。 时间复杂度O(nlog⁡n)O(n \\log n)O(nlogn) 窗口的星星 先只考虑给定窗口的左上角哪些位置可以圈到一颗星星，不难发现下图： 右下角为我们需要圈到的星星，整个虚线区域就是可以使我们所用的窗口的左上角满足条件的解集（不包括边界），将这个矩形的权值设为这颗星星的亮度，对于每一颗星星都有对应的一个这样的矩形，转化为重合的区域最大权值为多少，这样就可以用扫描线转化为区间最值问题。 处理边界的话可以将所有星星的坐标偏移0.5，就可以很好的处理边界问题。 [HNOI2007]最小矩形覆盖 题意很简单，求对平面上点的最小矩形覆盖。 不难想到，旋转卡壳可以轻松的解决这个问题，对于最小矩形覆盖，其最小矩形的一条边必定在这nn个点的凸包上，这样我们就先求出凸包再使用旋转卡壳，找到在以当前边为矩形的一条边时，在最左边，最右边，最上边的点，然后用向量加减的方法求出矩形的高和宽，再进一步求面积就好了。 （注意是否有无解的情况） 然后还有一道类似的题目，就是数据不太一样。 UVA11178 Morley’s Theorem 无非就是向量的旋转和直线的求交点而已。 [USACO15FEB]Fencing the Herd G 题意大概就是有mmm种操作： 插入一个点 询问Ax+By=CAx+By=CAx+By=C这条直线是否和当前插入的点组成的凸包有交 既然不强制在线，就可以离线下来利用CDQ分治的思想，去处理每个询问之前的修改操作对询问的影响，接下来就是考虑如何计算影响。 给出的限制条件其实就是判断当前已经插入的所有点，带入式子后是否同号，其实就是判断是否都在同一个半平面，进一步转化问题为，凸包的上下两个点的值的判断，可以看一个图（我搬的） 判断时，只需要计算Ax+ByAx + ByAx+By来作为值去判断，假设计算出来的最大值为CmaxC_{max}Cmax​最小值为CminC_{min}Cmin​，当Cmin&lt;C&lt;CmaxC_{min} &lt; C &lt;C_{max}Cmin​&lt;C&lt;Cmax​时很明显就是与凸包有交。 维护时需要维护一个上凸包和一个下凸包，利用凸包单调性，去旋转判断，记录每条直线的CminC_{min}Cmin​和CmaxC_{max}Cmax​最后统一判断即可。 时间复杂度O(nlog⁡n)O(n\\log n)O(nlogn) [IOI1998] [USACO5.5] 矩形周长Picture 题意就是求平面内矩形的周长并，可以看一下图 图很形象吧，很明显扫描线可以轻易的解决这道题，（但是数据范围太小，连n2n^2n2都能暴碾过去，而且似乎跑的比扫描线还快）。 首先和求面积并一样的方法去维护，同时数据规模也不需要我们去离散化，现在考虑如何去统计答案， 每次加入一条线段时，对整棵线段树，中维护的区间覆盖的个数的改变其实就是我们需要累加的答案，很容易想到不是吗？ 但是一次扫描还不够，要扫两次，先扫一遍xxx轴再扫一遍yyy轴即可，不过也可以在扫xxx个轴的时候同时计算yyy轴的答案，扫一遍也能解决问题，就是需要注意一些小细节。 首先需要注意，权值线段树的值域为[−1e5,1e5][-1e5, 1e5][−1e5,1e5]，然后非常重要的一点就是，在线段树上一段区间的长度为r−l+1r-l+1r−l+1，但在计算边长的时候对于坐标系中的一条线段，其长为r−lr-lr−l，也就是说我们在修改线段时需要对右端点-1，接下来还有一个比较重要的点，那就是，在排序时如果两个线段在同一直线上需要让执行加入线段操作的在前，比如： 123456input:20 0 4 40 4 4 8output:24 这组数据，对应过来就是 如过我们在计算xxx轴时先删去了BCBCBC再执行插入就会算了两遍贡献，yyy轴上也同理，排序的时候需要注意一下。 [JSOI2010]冷冻波 很清晰的题意对吧，首先我们先考虑没有树木阻挡的情况，求最小时间，一种做法就是二分加网络流，二分枚举最小时间，然后建图的话就是对于每个巫妖向它能以攻击到的精灵连一条权值为1的边，然后从源点向每个巫妖连一条权值为在限制的时间内能以攻击的最多次数的边，每个精灵向汇点连一条权值为1的边，最后跑最大流即可。 现在加入树木，树木能以影响两个点的话就是判断，圆与线段是否有交点，如下： 线段的两个端点都在圆内，无交点。 线段的两个端点一个在园内一个在圆外，有交点。 线段的两个端点均在圆外，判断方法就是从圆心向线段所在的直线作垂线，长度记为ddd如果d&gt;rd &gt; rd&gt;r则无交点，如果d≤rd \\le rd≤r需要去判断圆心与端点的连线与线段所成的角是否为锐角。 （说实话，这题数据挺水的)，首先n3n^3n3枚举处理出每个巫妖所能打到的精灵，然后二分跑网络流即可。 给一个比较清晰的图吧。 [JLOI2016]圆的异或并 题意就是求圆的异或并，看到n≤2×105n \\le 2\\times 10^5n≤2×105，肯定是不能乱搞过去的，但是注意到题目中的已知这些圆两两没有交点，即两圆的关系只存在相离和包含，就会不难得出一个性质：如果将每个圆按xxx坐标排序后，假设有一条垂直于xxx轴的扫描线，从左往右扫，一个圆肯定是比它包含的圆先出现，后消失的。 显然扫描线可以解决这个问题，现在需要知道如何去判断奇偶性，每次扫描线向右移动的时候，我们肯定不能插入一个圆，来计算与扫描线的交点，但是我们用set维护，分别插入一个圆的上圆弧和下圆弧，按与扫描线的交点排序来判断以下情况： 插入的圆弧是set中的唯一一段圆弧，为奇面积。 插入圆弧的前驱为上圆弧，该圆的奇偶性与其相同（因为扫描线从左到右移动时，由于圆两两之间没有交点，前驱为上圆弧时肯定不包含该圆） 插入圆弧的前驱为下圆弧时，该圆的奇偶性与其相反（该圆被前驱的圆包含） 最后ans加上奇面积减去偶面积就可以了 需要注意的几个点： set重载小于号时要重载成严格小于，set具有不可重性，只需要计算与扫描线交点时加上一个epsepseps就行了 统计答案时开long long UVA1298 Triathlon 根据题意列出式子，设三段距离分别为x,y,zx, y, zx,y,z对于第iii个人和第jjj个人，iii可以得到冠军，当且仅当： xvi,1+yvi,2+zvi,3&lt;xvj,1+yvj,2+zvj,3\\frac{x}{v_{i,1}} + \\frac{y}{v_{i,2}} + \\frac{z}{v_{i,3}} &lt; \\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{z}{v_{j,3}} vi,1​x​+vi,2​y​+vi,3​z​&lt;vj,1​x​+vj,2​y​+vj,3​z​ 发现有三个未知数，但因为总路程是一样的可以假设总路程为“1”，这样就有： xvi,1+yvi,2+1−x−yvi,3&lt;xvj,1+yvj,2+1−x−yvj,3\\frac{x}{v_{i,1}} + \\frac{y}{v_{i,2}} + \\frac{1-x-y}{v_{i,3}} &lt; \\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{1-x-y}{v_{j,3}} vi,1​x​+vi,2​y​+vi,3​1−x−y​&lt;vj,1​x​+vj,2​y​+vj,3​1−x−y​ 考虑化成Ax+By+C&gt;0Ax + By +C &gt; 0Ax+By+C&gt;0的形式： xvj,1+yvj,2+1−x−yvj,3−xvi,1−yvi,2−1−x−yvi,3&gt;0\\frac{x}{v_{j,1}} + \\frac{y}{v_{j,2}} + \\frac{1-x-y}{v_{j,3}} - \\frac{x}{v_{i,1}} - \\frac{y}{v_{i,2}} - \\frac{1-x-y}{v_{i,3}} &gt; 0 vj,1​x​+vj,2​y​+vj,3​1−x−y​−vi,1​x​−vi,2​y​−vi,3​1−x−y​&gt;0 进一步整理得： (1vj,1−1vi,1+1vi,3−1vj,3)x+(1vj,2−1vi,2+1vi,3−1vj,3)y+1vj,3−1vi,3&gt;0(\\frac{1}{v_{j,1}} - \\frac{1}{v_{i,1}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}})x + (\\frac{1}{v_{j,2}} - \\frac{1}{v_{i,2}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}})y + \\frac{1}{v_{j,3}} - \\frac{1}{v_{i,3}} &gt; 0 (vj,1​1​−vi,1​1​+vi,3​1​−vj,3​1​)x+(vj,2​1​−vi,2​1​+vi,3​1​−vj,3​1​)y+vj,3​1​−vi,3​1​&gt;0 其中A=1vj,1−1vi,1+1vi,3−1vj,3A = \\frac{1}{v_{j,1}} - \\frac{1}{v_{i,1}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}}A=vj,1​1​−vi,1​1​+vi,3​1​−vj,3​1​，B=1vj,2−1vi,2+1vi,3−1vj,3B = \\frac{1}{v_{j,2}} - \\frac{1}{v_{i,2}} + \\frac{1}{v_{i,3}} - \\frac{1}{v_{j,3}}B=vj,2​1​−vi,2​1​+vi,3​1​−vj,3​1​，C=1vj,3−1vi,3C = \\frac{1}{v_{j,3}} - \\frac{1}{v_{i,3}}C=vj,3​1​−vi,3​1​，半平面交求解即可，时间复杂度O(n2)O(n^2)O(n2)。 需要注意计算系数时，分式的分子为1很明显会产生较大的误差， 可以在式子两边同时乘以一个较大的数，来解决这个问题，更需要说明的是根据我们设的x,yx,yx,y很明显x+y≤1x+y \\le 1x+y≤1，需要对其进行限制。 关于半平面交 解决这类问题很明显是半平面交的很大用处，来判断多元一次不等式组是否有解，在推理完式子后，往往需要插入直线，选择直线上的一个点和方向向量，一般建议化简式子为Ax+By+C≥0Ax + By +C \\ge 0Ax+By+C≥0的形式（或不带等），取直线的“左侧”，这里的左侧是依照选取的方向向量来说的，对于选取方向向量，我们需要让其满足式子中的条件，又需要让其满足求左侧的交，是不能随便选直线上的两个点来确定的，其实多画图就不难发现方向向量取(B,−A)(B,-A)(B,−A)是可以满足要求的，起点的话，一般选x=0x= 0x=0处的取值，但是有时需要考虑值域。在求交的时候，需要额外注意题目中的值域条件，在求交的集合中加入对应的直线。 [SCOI2015]小凸想跑步 首先假设PPP点为(x,y)(x,y)(x,y)，那么根据题意就有： (x0−x,y0−y)×(x1−x,y1−y)&lt;(xi−1−x,yi−1−y)×(xi−x,yi−y)(x_0-x, y_0-y) \\times (x_1-x, y_1-y) &lt; (x_{i-1}-x, y_{i-1}-y)\\times(x_i-x, y_i-y) (x0​−x,y0​−y)×(x1​−x,y1​−y)&lt;(xi−1​−x,yi−1​−y)×(xi​−x,yi​−y) 进一步化简得： (x0−x)(y1−y)−(x1−x)(y0−y)&lt;(xi−1−x)(yi−y)−(xi−x)(yi−1−y)(x_0-x)(y_1-y)-(x_1-x)(y_0-y) &lt; (x_{i-1}-x)(y_i-y)-(x_i-x)(y_{i-1}- y) (x0​−x)(y1​−y)−(x1​−x)(y0​−y)&lt;(xi−1​−x)(yi​−y)−(xi​−x)(yi−1​−y) 拆开式子， x0y1−x0y−xy1+xy−x1y0+x1y+xy0−xy&lt;xi−1yi−xi−1y−xyi+xy−xiyi−1+xiy+xyi−1−xyx_0y_1-x_0y-xy_1+xy-x_1y_0+x_1y+xy_0-xy &lt; x_{i-1}y_i-x_{i-1}y-xy_i+xy-x_iy_{i-1}+x_iy+xy_{i-1}-xy x0​y1​−x0​y−xy1​+xy−x1​y0​+x1​y+xy0​−xy&lt;xi−1​yi​−xi−1​y−xyi​+xy−xi​yi−1​+xi​y+xyi−1​−xy 转化为Ax+By+C&gt;0Ax+By +C &gt; 0Ax+By+C&gt;0的形式， (−yi+yi−1+y1−y0)x+(−xi−1+xi+x0−x1)y+xi−1yi−xiyi−1−x0y1+x1y0&gt;0(-y_i + y_{i-1} + y_1-y_0)x + (-x_{i-1}+x_i+x_0-x_1)y+x_{i-1}y_i-x_iy_{i-1}-x_0y_1+x_1y_0 &gt; 0 (−yi​+yi−1​+y1​−y0​)x+(−xi−1​+xi​+x0​−x1​)y+xi−1​yi​−xi​yi−1​−x0​y1​+x1​y0​&gt;0 其中A=−yi+yi−1+y1−y0,B=−xi−1+xi+x0−x1,C=xi−1yi−xiyi−1−x0y1+x1y0A =-y_i + y_{i-1} + y_1-y_0 ,B = -x_{i-1}+x_i+x_0-x_1,C = x_{i-1}y_i-x_iy_{i-1}-x_0y_1+x_1y_0A=−yi​+yi−1​+y1​−y0​,B=−xi−1​+xi​+x0​−x1​,C=xi−1​yi​−xi​yi−1​−x0​y1​+x1​y0​，半平面交求解即可，别忘了把解限制在凸多边形内。 [USACO22JAN] Multiple Choice Test P 其实看到题目就可以发现，最终向量之和最大其实是闵可夫斯基和上离原点最远的点，对于多个凸包的闵可夫斯基和，可以用启发式合并，每次合并小的， 复杂度O(nlog⁡n)O(n\\log n)O(nlogn)。","link":"/2022/08/17/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E9%80%89%E5%81%9A/"},{"title":"高斯消元","text":"高斯消元 高斯消元 定义 数学上，高斯消元法（或译：高斯消去法），是线性代数规划中的一个算法，可用来为线性方程组求解。但其算法十分复杂，不常用于加减消元法，求出矩阵的秩，以及求出可逆方阵的逆矩阵。不过，如果有过百万条等式时，这个算法会十分省时。一些极大的方程组通常会用迭代法以及花式消元来解决。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。高斯消元法可以用在电脑中来解决数千条等式及未知数。亦有一些方法特地用来解决一些有特别排列的系数的方程组。 ——Baidu 高斯消元法（Gauss−JordaneliminationGauss-Jordan eliminationGauss−Jordanelimination）是求解线性方程组的经典算法。并且高斯消元还可以计算行列式，求矩阵的逆。 消元法 消元法主要为加减消元，同时加减消元也是一个比较常用的方法，如： {4x+y=10−−−−−−(1)x−y=5−−−−−−(2)\\left\\{ \\begin{aligned} 4x+y=10 ------(1)\\\\ x-y=5 ------ (2) \\end{aligned} \\right. {4x+y=10−−−−−−(1)x−y=5−−−−−−(2)​ (1)+(2)式可得： 5x=155x=15 5x=15 解得： x=3x=3 x=3 将x=3x=3x=3带回(1)和(2)任一式子可得： y=−2y=-2 y=−2 这就是消元法，通过使两个方程中同一未知数的系数相加减来消去未知数，完成求解的目的。 高斯消元法 对于一个线性方程组我们可以将其化为一个矩阵，比如一个mmm个nnn元一次方程组，我们可以将其化为一个m×(n+1)m \\times (n+1)m×(n+1)的一个矩阵，矩阵的每行的前nnn个元素表示为每个未知数的系数，第n+1n+1n+1个元素表示为该方程所等于的常数，这个矩阵就是增广矩阵。 如: 对于一个三元一次方程组： x1+x2+x3=62x1−x2+x3=1x1+2x2−3x3=1x_1+x_2+x_3=6 \\\\ 2x_1-x_2+x_3=1 \\\\ x_1+2x_2-3x_3=1 x1​+x2​+x3​=62x1​−x2​+x3​=1x1​+2x2​−3x3​=1 其增广矩阵为： (111∣62−11∣112−3∣1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\2&amp;-1&amp;1&amp;|&amp;1\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ⎝⎛​121​1−12​11−3​∣∣∣​611​⎠⎞​ 接下来会经过以下变化： (111∣62−11∣112−3∣1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\2&amp;-1&amp;1&amp;|&amp;1\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ⎝⎛​121​1−12​11−3​∣∣∣​611​⎠⎞​ (111∣60−3−1∣−1112−3∣1)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\1&amp;2&amp;-3&amp;|&amp;1\\end{pmatrix} ⎝⎛​101​1−32​1−1−3​∣∣∣​6−111​⎠⎞​ (111∣60−3−1∣−1101−4∣−5)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\0&amp;1&amp;-4&amp;|&amp;-5\\end{pmatrix} ⎝⎛​100​1−31​1−1−4​∣∣∣​6−11−5​⎠⎞​ (111∣60−3−1∣−1100−13∣−26)\\begin{pmatrix}1&amp;1&amp;1&amp;|&amp;6\\\\0&amp;-3&amp;-1&amp;|&amp;-11\\\\0&amp;0&amp;-13&amp;|&amp;-26\\end{pmatrix} ⎝⎛​100​1−30​1−1−13​∣∣∣​6−11−26​⎠⎞​ 根据最后一个式子即可得： x3=2x_3=2 x3​=2 接着回带： (100∣1010∣3001∣2)\\begin{pmatrix}1&amp;0&amp;0&amp;|&amp;1\\\\0&amp;1&amp;0&amp;|&amp;3\\\\0&amp;0&amp;1&amp;|&amp;2\\end{pmatrix} ⎝⎛​100​010​001​∣∣∣​132​⎠⎞​ 以上的几种变换叫做初等行变换，后化简后的叫做阶梯型矩阵，最后化简后的矩阵为简化阶梯型矩阵。 同时如果化简后出现这种情况： x1=6−x2x3=1x_1=6-x_2\\\\ x_3=1 x1​=6−x2​x3​=1 这时x2x_2x2​取任何一个值都有一个x1x_1x1​与之对应，在上述的方程中，像x1,x3x_1,x_3x1​,x3​称为主元，x2x_2x2​称为自由元。 引论 根据以上分析，高斯消元后会有三种情况： 若存在系数全为零，然而常数不为零时，方程无解； 若系数不全为零的行数和未知数的个数相等，则方程有唯一解； 若系数不全为零的行数小于未知数的个数，则方程有无数个解。 代码实现 首先我们整理一下高斯消元的步骤： 增广矩阵初等行变换为最简阶梯矩阵； 还原线性方程组； 求解第一个变量； 补充自由未知量； 列表示方程组通解。 CODE： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define eps 1e-8using namespace std;int n;double c[110][110];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) scanf(&quot;%lf&quot;,&amp;c[i][j]); for(int i=1;i&lt;=n;i++) { for(int j=i;j&lt;=n;j++) { if(fabs(c[j][i])&gt;eps)swap(c[i],c[j]); // 找到x[i]系数不为零的方程 } for(int j=1;j&lt;=n;j++) { if(i==j)continue; double rate=c[j][i]/c[i][i]; for(int k=i;k&lt;=n;k++) { c[j][k]-=c[i][k]*rate; if(fabs(c[j][k])&lt;eps)c[j][k]=0;// 浮点型不可避免的精度误差 }// 消元 c[j][n+1]-=c[i][n+1]*rate; if(fabs(c[j][n+1])&lt;eps)c[j][n+1]=0;// 改变常数 } } for(int i=1;i&lt;=n;i++) { int x=0; for(int j=1;j&lt;=n;j++) { if(c[i][j]==0)x++; } if(x==n) { printf(&quot;No Solution&quot;); return 0; }// 判断是否无解 } for(int i=1;i&lt;=n;i++)printf(&quot;%0.2lf\\n&quot;,c[i][n+1]/c[i][i]); return 0;} 附上模板题P3389 【模板】高斯消元法。 练习题：P4035 [JSOI2008]球形空间产生器。 完结撒花（&gt;_&lt;)","link":"/2022/06/13/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"title":"高级作战记录","text":"高级作战记录 算法竞赛进阶指南 算法竞赛进阶指南练习 CSP初赛整理 知识点 LaTeX公式大全 时间复杂度-势能分析浅谈 博弈论 计算几何 洛谷日报-计算几何 desmos 群论 gay算几何 Geogebra! 冷门函数 Emoji CSP初赛知识点 DLX 多项式总结 支配树详解 PollardRho 浅谈虚树","link":"/2022/06/15/%E9%AB%98%E7%BA%A7%E4%BD%9C%E6%88%98%E8%AE%B0%E5%BD%95/"},{"title":"博弈论","text":"整理了一些博弈论模型，但大部分还是咕咕咕了(●ˇ∀ˇ●) 博弈论 组合游戏 前言 组合游戏是指一种两个玩家的游戏，每个玩家都是聪明绝顶不存在随机操作，比如打牌不是，游戏的结果只有赢和输。 通常玩家会交替移动，直到游戏结束，即达到终止状态，不存在任何一种可行的移动方式的状态。 这种游戏的结果在一开始就已经被决定了，由游戏的集合，游戏的初始状态和玩家的先后手完全确定。 组合游戏的形式有两种分别是Impartial Combinatorial Games和Partizan Combinatorial Games，前者是指在游戏中两位玩家进行的移动是完全相同的，后者则不相同比如国际象棋（NGNL），主要还是讨论ICG。 定义 形式化的定义一个组合游戏： 两个玩家组成的游戏 游戏存在一个有限的状态集合 两个玩家的操作方式是相同的，没有区别 玩家交替进行 当玩家移动到终止状态时，游戏结束 一般的话都是最后一个移动的玩家获胜，讨论起来还相对简单，不过也存在最后一个移动的玩家失败的游戏，更为复杂一些。 不过重要的是，无论游戏怎样进行，都会在有限步数内结束。 另外，两个玩家都是足够聪明的玩家，每一步都会走最优策略。 状态 由于游戏的结果在一开始就可以确定，所以存在先手必胜和后手必胜。 定义P-position为先手必胜，N-position 为后手必胜。 NIM 游戏 前置知识 位运算 正文 NIM游戏，属于组合游戏的一种，起源可以追溯到很久以前，其游戏内容为： 有nnn堆石子Alice和Bob轮流从中取至少一个至多不超过一堆石子，谁取走最后一堆石子，谁就胜利。 是否存在一种先手必胜的策略？ 这种问题的解决方法，是设aia_iai​为每堆石子的数量，x=a1⊕a2⊕a3⊕⋯⊕anx=a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_nx=a1​⊕a2​⊕a3​⊕⋯⊕an​，若x≠0x\\ne 0x​=0则先手必胜，否则后手必胜。 证明： 没有后继状态的状态为必败状态（Terminal Position） 例如将石子取完后x=0⊕0⊕⋯⊕0=0x=0 \\oplus 0 \\oplus \\cdots \\oplus 0 = 0x=0⊕0⊕⋯⊕0=0，此时为N-position（此时先手已经没有可以取的石子了）。 对于x≠0x\\ne 0x​=0 的局面一定存在某种移动使得 x=0x=0x=0，即P-position一定可以转移到N-position 假设a1⊕a2⊕a3⊕⋯⊕an≠0a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_n \\ne 0a1​⊕a2​⊕a3​⊕⋯⊕an​​=0设xxx为1的最高位为第kkk位，那么一定存在一个aia_iai​的第kkk位为1，此时x⊕ai=a1⊕a2⊕⋯⊕anx \\oplus a_i=a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_nx⊕ai​=a1​⊕a2​⊕⋯⊕an​，x⊕aix\\oplus a_ix⊕ai​一定小于aia_iai​（因为xxx的第kkk位不为0，异或aia_iai​后为0肯定小于aia_iai​），我们移走ai−ai⊕xa_i-a_i \\oplus xai​−ai​⊕x个石子，此时第iii堆还剩ai−(ai−ai⊕x)=ai⊕xa_i-(a_i-a_i\\oplus x)=a_i \\oplus xai​−(ai​−ai​⊕x)=ai​⊕x个石子，此时a1⊕a2⊕⋯⊕ai⊕x⊕⋯⊕an=x⊕x=0a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_i \\oplus x \\oplus \\cdots\\oplus a_n=x\\oplus x=0a1​⊕a2​⊕⋯⊕ai​⊕x⊕⋯⊕an​=x⊕x=0，得证。 对于x=0x =0x=0的局面一定不存在某种移动使得x=0x=0x=0，即N-position一定不可转移到N-position 设取走第iii堆的石子后aia_iai​变为了ai′a_i'ai′​，此时a1⊕a2⊕⋯⊕ai′⊕⋯⊕an=0=a1⊕a2⊕⋯⊕ai⊕⋯⊕ana_1 \\oplus a_2 \\oplus \\cdots\\oplus a_i' \\oplus\\cdots \\oplus a_n = 0 =a_1 \\oplus a_2 \\oplus \\cdots \\oplus a_i \\oplus \\cdots \\oplus a_na1​⊕a2​⊕⋯⊕ai′​⊕⋯⊕an​=0=a1​⊕a2​⊕⋯⊕ai​⊕⋯⊕an​得ai=ai′a_i = a_i'ai​=ai′​不成立。 至于异或为什么能表示状态之间的转移主要还是因为： 终止状态时显然有0⊕0⊕⋯⊕0=00 \\oplus 0 \\oplus \\cdots \\oplus 0 = 00⊕0⊕⋯⊕0=0 取出第iii堆的石子的操作其实等价于将这堆石子的数目异或上一个数变为ai′=ai⊕ka_i'= a_i \\oplus kai′​=ai​⊕k 每个状态之间的异或其实就体现在上述证明中的第2，3条引理，对某个状态的异或就是对整体结果的异或 现在我们将取石子的游戏转化成了异或的游戏，同时也满足对应的规则，异或和在x=0x=0x=0与x≠0x \\ne 0x​=0的两个状态间不停的转换，就体现了P-position和N-position之间的转换。 Anti NIM 前置知识 NIM 正文 Anti NIM游戏，就是修改NIM游戏的胜利判定为拿走最后一堆石子的失败，会变得更复杂一点（但也不难） 引理： 先手必胜当且仅当： 每堆的物品数都为1且NIM和为0 有些堆的物品数大于1且NIM和不为0 证明： 当所有堆的石子均为1时 石子NIM和x=0x=0x=0，此时有偶数堆，先手必胜 x≠0x \\ne 0x​=0时，此时有奇数堆，先手必败 当有一堆石子数&gt;1&gt;1&gt;1时，此时xxx显然≠0\\ne 0​=0 若有奇数堆石子，此时把&gt;1&gt;1&gt;1的那堆石子取至1个石子，转化为1中的2，先手必胜 若有偶数堆石子，此时把&gt;1&gt;1&gt;1的那堆石子取完，同样转化为1中的2，先手必胜 当有两堆及以上石子数&gt;1&gt;1&gt;1时 若x=0x=0x=0，又可以分为两种情况 转化为至少两堆石子&gt;1&gt;1&gt;1且x!=0x!=0x!=0,转化到3中的2 转化为一堆石子&gt;1&gt;1&gt;1，由2可知，此时先手必胜 若x≠0x\\ne 0x​=0，根据NIM游戏的证明，必定有一种方法转化为3中的1，此时先手总是能让后手取进行3中的1，后手只能给先手3中2直至必胜状态，故此时先手必胜 Staircase NIM 前言 Staircase NIM是NIM游戏的又一种变形，不过还是非常简单 正文 这次Alice和Bob又换了种玩法， 有nnn堆石子，每次移动可以将第iii层上的至少一个石子移动到i−1i-1i−1层上，谁取完最后一堆石子谁就胜利。 求是否存在一种先手必胜的策略。 首先考虑只有偶数层存在石子也就是说，假设对方为先手，那么对方只能将若干个石子移动的奇数层，此时我们再讲其移动到偶数层，直到最后偶数层上都没有石子（都到第0层上了），此时后手必胜 然后考虑奇数层的石子，将奇数层移动到偶数层，其实可以直接当做把奇数层的石子直接拿走，并不会影响之前偶数层策略的影响，那么就将问题转化为了奇数层之间的NIM博弈，如果可以做到留给对方的只有偶数层石子，则对方必败 其他博弈论游戏 占个坑 😱 博弈问题 1. A Funny Game 首先Alice作为先手， 拿一个，环断为长度为奇数的链，此时Bob再拿一个把链的长度变为偶数，接下来Alice拿几个Bob拿相同数目的硬币，Bob必胜 拿两个，环断为长度为偶数的链，此时Bob再拿两个链的长度仍然为偶数，接下来采取和1相同的策略即可，Bob必胜 综上，当n≤2n \\le 2n≤2时Alice必胜，反正Bob必胜。（好像叫做对称博弈） 2.谁能赢呢？ 很简单，就像多米诺骨牌去覆盖棋盘，nnn为奇数时需要挖掉左上和右下才能完全覆盖，此时后手必胜，nnn为偶数时直接覆盖此时先手必胜。 3.取石子 首先如果不能合并，那么只要石子总数是偶数，Alice就必胜，所以也就是说，合并操作是用来转换状态的。 考虑石子个数$&gt;1，此时设1，此时设1，此时设m为石子总数加上石子堆数−1，若为石子总数加上石子堆数-1，若为石子总数加上石子堆数−1，若m$为奇数则先手必胜，否则后手必胜 ​ 证明： ​ mmm为奇数时，不管后手做哪一个操作均可将mmm变回奇数，最后合并为一堆时先手必胜。 ​ mmm为偶数时， 先手选择合并，mmm变为奇数，变成后手的必胜局面 先手选择取&gt;2&gt; 2&gt;2石子，mmm变为奇数，变成后手的必胜局面 先手选择取=2=2=2石子，mmm变为奇数，此时后手将=1=1=1的石子堆合并（如果选择取石子，则堆数-1，石子数-1，mmm为奇数，先手必胜） 考虑石子个数=1=1=1，使用记忆化搜索，f[i][j]f[i][j]f[i][j]为有iii堆石子为1，jjj堆数量不为1的状态。 4.A New Stone Game 考虑两堆石子数量相同，这时肯定是后手必胜，只要后手和先手一直做相同的操作就可以必胜。 如果有的石子数量不相同的话，此时必定存在一种方案使得操作后石子数量相同 若当前有奇数堆石子的数量不能两两配对，则将其中的一堆石子全部取走，分到其他堆石子，使其两两配对，有偶数堆 若当前有偶数堆石子的数量不能两两配对，则将其中的一堆石子不全部取走，分到其他石子，仍为偶数堆 所以此时后手面对的是必败状态，先手必胜。 5.小约翰的游戏 Anti NIM游戏，时间复杂度O(n)O(n)O(n) 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--) { int n,sum=0,res=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res^=x; sum+=(x==1); } if(sum==n&amp;&amp;res==0) printf(&quot;John\\n&quot;); else if(sum!=n&amp;&amp;res!=0) printf(&quot;John\\n&quot;); else printf(&quot;Brother\\n&quot;); } return 0;} 6.NIM游戏 判断异或和即可，时间复杂度O(n)O(n)O(n) 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int T;int main(){ scanf(&quot;%d&quot;,&amp;T); while(T--) { int n,ans=0;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x;scanf(&quot;%d&quot;,&amp;x);ans^=x; } ans?printf(&quot;Yes\\n&quot;):printf(&quot;No\\n&quot;); } return 0;} 坑。。。","link":"/2022/07/23/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"title":"😅","text":"😅","link":"/2022/11/08/%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%BE%97%E4%BA%86/"},{"title":"test","text":"eiπ=cos⁡π+isin⁡πe^{i \\pi} = \\cos \\pi + i \\sin \\pi eiπ=cosπ+isinπ","link":"/2022/09/22/test/"}],"tags":[{"name":"闲话","slug":"闲话","link":"/tags/%E9%97%B2%E8%AF%9D/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"启发式搜索","slug":"启发式搜索","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AtCoder Regular Contest","slug":"AtCoder-Regular-Contest","link":"/tags/AtCoder-Regular-Contest/"},{"name":"Record","slug":"Record","link":"/tags/Record/"},{"name":"杂项","slug":"杂项","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"BSGS","slug":"BSGS","link":"/tags/BSGS/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"数学期望","slug":"数学期望","link":"/tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"},{"name":"Link Cut Tree","slug":"Link-Cut-Tree","link":"/tags/Link-Cut-Tree/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"动态树","slug":"动态树","link":"/tags/%E5%8A%A8%E6%80%81%E6%A0%91/"},{"name":"原根","slug":"原根","link":"/tags/%E5%8E%9F%E6%A0%B9/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"NaCly_Fish&#39;s Math Contest","slug":"NaCly-Fish-s-Math-Contest","link":"/tags/NaCly-Fish-s-Math-Contest/"},{"name":"勾股数组","slug":"勾股数组","link":"/tags/%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84/"},{"name":"高斯整数","slug":"高斯整数","link":"/tags/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0/"},{"name":"高斯素数","slug":"高斯素数","link":"/tags/%E9%AB%98%E6%96%AF%E7%B4%A0%E6%95%B0/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","link":"/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"欧拉反演","slug":"欧拉反演","link":"/tags/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"},{"name":"多项式","slug":"多项式","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"快速傅里叶变换(FFT)","slug":"快速傅里叶变换-FFT","link":"/tags/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","link":"/tags/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"生成函数","slug":"生成函数","link":"/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"旋转卡壳","slug":"旋转卡壳","link":"/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"},{"name":"三角剖分","slug":"三角剖分","link":"/tags/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Actions","slug":"Github-Actions","link":"/tags/Github-Actions/"},{"name":"动态DP(DDP)","slug":"动态DP-DDP","link":"/tags/%E5%8A%A8%E6%80%81DP-DDP/"},{"name":"快速数论变换(NTT)","slug":"快速数论变换-NTT","link":"/tags/%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2-NTT/"},{"name":"快速沃尔什变换(FWT)","slug":"快速沃尔什变换-FWT","link":"/tags/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2-FWT/"},{"name":"任意模数NTT","slug":"任意模数NTT","link":"/tags/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0NTT/"},{"name":"多项式乘法逆","slug":"多项式乘法逆","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86/"},{"name":"多项式对数函数(多项式求ln)","slug":"多项式对数函数-多项式求ln","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82ln/"},{"name":"多项式指数函数(多项式exp)","slug":"多项式指数函数-多项式exp","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0-%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp/"},{"name":"多项式开根","slug":"多项式开根","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BC%80%E6%A0%B9/"},{"name":"多项式幂函数","slug":"多项式幂函数","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B9%82%E5%87%BD%E6%95%B0/"},{"name":"分治FFT&#x2F;NTT","slug":"分治FFT-NTT","link":"/tags/%E5%88%86%E6%B2%BBFFT-NTT/"},{"name":"下降幂多项式乘法","slug":"下降幂多项式乘法","link":"/tags/%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/"},{"name":"多项式除法","slug":"多项式除法","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95/"},{"name":"多项式多点求值","slug":"多项式多点求值","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/"},{"name":"多项式复合函数","slug":"多项式复合函数","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0/"},{"name":"多项式复合逆","slug":"多项式复合逆","link":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E9%80%86/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"反演变换","slug":"反演变换","link":"/tags/%E5%8F%8D%E6%BC%94%E5%8F%98%E6%8D%A2/"},{"name":"常系数齐次线性递推","slug":"常系数齐次线性递推","link":"/tags/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数值积分","slug":"数值积分","link":"/tags/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"},{"name":"欧拉路","slug":"欧拉路","link":"/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"狄利克雷卷积","slug":"狄利克雷卷积","link":"/tags/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/"},{"name":"普通生成函数(OGF)","slug":"普通生成函数-OGF","link":"/tags/%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-OGF/"},{"name":"指数型生成函数(EGF)","slug":"指数型生成函数-EGF","link":"/tags/%E6%8C%87%E6%95%B0%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0-EGF/"},{"name":"矩阵树定理","slug":"矩阵树定理","link":"/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"笛卡尔树","slug":"笛卡尔树","link":"/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"类欧几里德","slug":"类欧几里德","link":"/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"凸包","slug":"凸包","link":"/tags/%E5%87%B8%E5%8C%85/"},{"name":"半平面交","slug":"半平面交","link":"/tags/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/"},{"name":"随机增量","slug":"随机增量","link":"/tags/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F/"},{"name":"闵可夫斯基和","slug":"闵可夫斯基和","link":"/tags/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"},{"name":"扫描线","slug":"扫描线","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"偏序问题","slug":"偏序问题","link":"/tags/%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"name":"Pick定理","slug":"Pick定理","link":"/tags/Pick%E5%AE%9A%E7%90%86/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"categories":[{"name":"闲话","slug":"闲话","link":"/categories/%E9%97%B2%E8%AF%9D/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"做题记录","slug":"做题记录","link":"/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"板子","slug":"板子","link":"/categories/%E6%9D%BF%E5%AD%90/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"}],"pages":[{"title":"Jekyll_Y","text":"About Hi there is Jekyll👋, a OIer’s blog. This is my blog, Welcome! Some of my Github Stats","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"留言","text":"留下你想说的话吧","link":"/comments/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"My Friends","text":"","link":"/friends/index.html"},{"title":"Archives","text":"","link":"/archives/index.html"}]}